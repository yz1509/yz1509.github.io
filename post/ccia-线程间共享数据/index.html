<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>CCIA-线程间共享数据 - HTT - ふわふわ時間</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="765PRO.P" />
  <meta name="description" content="《C&#43;&#43; Concurrentcy in Action 2nd》 第三章阅读笔记。
" />

  <meta name="keywords" content="K-ON, KyoAni" />






<meta name="generator" content="Hugo 0.85.0" />


<link rel="canonical" href="https://k-on.me/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" />







<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">








<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="CCIA-线程间共享数据" />
<meta property="og:description" content="《C&#43;&#43; Concurrentcy in Action 2nd》 第三章阅读笔记。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://k-on.me/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-11-15T17:15:13+00:00" />
<meta property="article:modified_time" content="2019-11-15T17:15:13+00:00" />

<meta itemprop="name" content="CCIA-线程间共享数据">
<meta itemprop="description" content="《C&#43;&#43; Concurrentcy in Action 2nd》 第三章阅读笔记。"><meta itemprop="datePublished" content="2019-11-15T17:15:13+00:00" />
<meta itemprop="dateModified" content="2019-11-15T17:15:13+00:00" />
<meta itemprop="wordCount" content="4118">
<meta itemprop="keywords" content="C&#43;&#43;,多线程,并发," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CCIA-线程间共享数据"/>
<meta name="twitter:description" content="《C&#43;&#43; Concurrentcy in Action 2nd》 第三章阅读笔记。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">HTT</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/about/">About</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/categories/">Categories</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      HTT
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/about/">About</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/categories/">Categories</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">CCIA-线程间共享数据</h1>
      
      <div class="post-meta">
        <time datetime="2019-11-15" class="post-time">
          2019-11-15
        </time>
        <div class="post-category">
            <a href="https://k-on.me/categories/c/c&#43;&#43;/"> c/c&#43;&#43; </a>
            
          </div>
        <span class="more-meta"> 4118 words </span>
          <span class="more-meta"> 9 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-使用互斥锁保护共享数据">1. 使用互斥锁保护共享数据</a>
      <ul>
        <li><a href="#11-在-c-中使用互斥锁">1.1. 在 C++ 中使用互斥锁</a></li>
        <li><a href="#12-利用-oop-的思想保护共享数据">1.2. 利用 OOP 的思想保护共享数据</a></li>
        <li><a href="#13-发现接口固有的竞争情况">1.3. 发现接口固有的竞争情况</a></li>
        <li><a href="#14-死锁">1.4. 死锁</a></li>
        <li><a href="#15-避免死锁的几点建议">1.5. 避免死锁的几点建议</a></li>
        <li><a href="#16-stdunique_lock">1.6. <code>std::unique_lock</code></a></li>
        <li><a href="#17-合理设置互斥锁的粒度">1.7. 合理设置互斥锁的粒度</a></li>
      </ul>
    </li>
    <li><a href="#2-保护共享数据的其他场景方法">2. 保护共享数据的其他场景/方法</a>
      <ul>
        <li><a href="#21-仅在初始化阶段需要保护的共享数据">2.1. 仅在初始化阶段需要保护的共享数据</a></li>
        <li><a href="#22-保护极少更新的共享数据">2.2. 保护极少更新的共享数据</a></li>
        <li><a href="#23-递归锁">2.3. 递归锁</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>《C++ Concurrentcy in Action 2nd》 第三章阅读笔记。</p>
<hr>
<h2 id="1-使用互斥锁保护共享数据">1. 使用互斥锁保护共享数据</h2>
<h3 id="11-在-c-中使用互斥锁">1.1. 在 C++ 中使用互斥锁</h3>
<p>构造一个 <code>std::mutex</code> 的实例即可创建一个互斥锁，使用成员函数 <code>lock()</code> 和 <code>unlock()</code> 可分别执行加锁和释放锁的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.1. Protecting a list with a mutex
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_list</span><span class="p">;</span>   <span class="c1">// global variable
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">some_mutex</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">// RAII idiom for a mutex
</span><span class="c1"></span>  <span class="n">some_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">list_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value_to_find</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">some_list</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">value_to_find</span><span class="p">)</span> <span class="o">!=</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 C++17 中，由于添加了类模板中的模板参数自动推导，故可将 <code>std::lock_guard&lt;std::mutex&gt; guard(some_mutex)</code> 简化为 <code>std::lock_guard guard(some_mutex)</code>。</p>
<h3 id="12-利用-oop-的思想保护共享数据">1.2. 利用 OOP 的思想保护共享数据</h3>
<p>在使用互斥锁保护共享数据时，特别要注意关于临界资源的指针和引用，其可能会在临界区外修改临界资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.2 Accidentally passing out a reference to protected data
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">some_data</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">data_wrapper</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">some_data</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function</span><span class="o">&gt;</span> 
  <span class="kt">void</span> <span class="n">process_data</span><span class="p">(</span><span class="n">Function</span> <span class="n">func</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// Pass &#34;protected&#34; data to user-supplied function
</span><span class="c1"></span>  <span class="p">}</span>  
<span class="p">};</span>

<span class="n">some_data</span><span class="o">*</span> <span class="n">unprotected</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">malicious_function</span><span class="p">(</span><span class="n">some_data</span><span class="o">&amp;</span> <span class="n">protected_data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">unprotected</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">protected_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">data_wrapper</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="n">process_data</span><span class="p">(</span><span class="n">malicious_function</span><span class="p">);</span> <span class="c1">// Pass in a malicious function
</span><span class="c1"></span>  <span class="n">unprotected</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span> <span class="c1">// Unprotected access to protected data
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于共享数据，无论是作为函数的返回值，还是函数的实参，都不要传递其指针或引用至临界区外。</p>
<h3 id="13-发现接口固有的竞争情况">1.3. 发现接口固有的竞争情况</h3>
<p>例如在双向链表中，如果想删除某个节点，仅仅对该节点上锁是不可行的。假设一个 stack 容器定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.3 The interface to the std::stack container adapter
</span><span class="c1"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Container</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">stack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">explicit</span> <span class="nf">stack</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="o">=</span> <span class="n">Container</span><span class="p">());</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="k">explicit</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="n">stack</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">();</span>
  <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">stack</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>在多线程环境下，上述定义中 <code>empty()</code> 和 <code>size()</code> 接口得到的值不保证可用性。例如在下述代码中，在 phase 1 和 phase 2 之间可能有另外一个线程清空该 stack 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="c1">// phase 1
</span><span class="c1"></span><span class="p">{</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// phase 2
</span><span class="c1"></span>  <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>  <span class="c1">// phase 3
</span><span class="c1"></span>  <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除此之外，还有一种很常见的情况发生：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Thread A</th>
<th style="text-align:left">Thread B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>if(!s.empty())</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left"><code>if(!s.empty())</code></td>
</tr>
<tr>
<td style="text-align:left"><code>int const value = s.top()</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left"><code>int const value = s.top()</code></td>
</tr>
<tr>
<td style="text-align:left"><code>s.pop()</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>do_something(value)</code></td>
<td style="text-align:left"><code>s.pop()</code></td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left"><code>do_something(value)</code></td>
</tr>
</tbody>
</table>
<p>在上述表格的执行顺序下，我们会 pop 出两个元素，但 <code>do_something()</code> 只处理了其中一个元素，而且我们还很难发现这个 bug 。但是如果将 <code>top()</code> 和 <code>pop()</code> 两个接口合并的话，也会有新的问题：拷贝操作可能抛出异常(比如内存分配失败等)，从而导致 stack 发生了修改，但我们没得到栈顶的元素。我们可以从几个方面试着解决这个问题：</p>
<ol>
<li>
<p>Pass in a reference</p>
<p>我们可以选择给 <code>pop()</code> 函数传递一个变量的引用以避免内存分配时可能抛出的异常。该方法有两个前提条件：</p>
<ul>
<li>需要提前构造栈元素的实例</li>
<li>需要栈元素支持赋值操作</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Container</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">stack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">some_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Require a no-throw copy constructor or move constructor</p>
<p>有些类型的拷贝构造函数或者移动构造函数并不会抛出异常，所以对它们而言并不存在该异常安全问题。</p>
</li>
<li>
<p>Return a pointer to the popped value</p>
<p>返回指针虽然可以避免拷贝操作，但是需要注意内存泄露问题，可使用智能指针进行内存管理。</p>
</li>
<li>
<p>Provide both option 1 and either option 2 or 3</p>
<p>下面是线程安全的 <code>threadsafe_stack</code> 类型定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.4 An outline class definition for a thread-safe satck
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt; // For std::shared_ptr&lt;T&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">empty_stack</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe_stack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">threadsafe_stack</span><span class="p">();</span>
  <span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">();</span> <span class="c1">// option 3
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// option 1
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  
<span class="p">};</span>


<span class="c1">// Listing 3.5 A fleshed-out class definition for a thread-safe satck
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">struct</span> <span class="nc">empty_stack</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe_stack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
  <span class="cm">/* Mutable is used to specify that the member does not affect the externally 
</span><span class="cm">    visible state of the class. */</span>
  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span> 

<span class="k">public</span><span class="o">:</span>
  <span class="n">threadsafe_stack</span><span class="p">(){}</span>
  <span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span> <span class="c1">// Copy performed in constructor body
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="c1">// Check for empty before trying to pop value
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>
    <span class="c1">// Allocate return value before modifying stack
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shard_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">()));</span>
    <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// require m mutable here
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="p">}</span>  
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><em>Tips:</em> <a href="https://stackoverflow.com/questions/12833241/difference-between-c03-throw-specifier-c11-noexcept">Difference between C++03 throw() specifier C++11 noexcept.</a></p>
</li>
</ol>
<h3 id="14-死锁">1.4. 死锁</h3>
<p>当一个操作中含有两个或多个互斥锁时，死锁就有可能会发生。如果可以同时加锁的话，此时可避免死锁的情况，针对于此，STL 的 <code>std::lock</code> 函数可同时对多个互斥锁进行加锁操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.6 Using std::lock() and std::lock_guard in a swap operation
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">some_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span> <span class="o">:</span> <span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">){}</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>  <span class="c1">// phase 1
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// phase 2
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// phase 3
</span><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>phase 2 和 phase 3 中的 <code>std::adopt_lock</code> 表示 <code>lock_guard</code> 构造函数仅会取得互斥锁 $m$ 的所有权，不会对其进行加锁操作。C++ 17 提供了 和 <code>lock_guard</code> 功能类似但是支持可变模板参数的 <code>scoped_lock</code>，C++ 17 中可将 <code>swap</code> 函数改写成如下形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="c1">// std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(lhs.m, rhs.m);
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">guard</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于可以同时加锁的情况，避免死锁比较容易做到，但是在其他情况下，如果有效避免死锁的发生是相当困难的。</p>
<h3 id="15-避免死锁的几点建议">1.5. 避免死锁的几点建议</h3>
<p>死锁不仅仅是伴随着互斥锁而出现，例如，在两个线程互相等待对方结束的情况下，也会发生死锁。</p>
<ol>
<li>
<p>Don&rsquo;t acquire a lock if you already hold one. 使用场景受限，而且不能避免循环等待。</p>
</li>
<li>
<p>Avoid calling user-supplied code while holding a lock.</p>
</li>
<li>
<p>如果必须要获得多个锁时，建议按固定顺序进行加锁操作，例如在双向链表中，加锁时只能以从头至尾的顺序。</p>
</li>
<li>
<p>Use a lock hierarchy</p>
<p>给互斥锁附加一个 <code>hierarchy_value</code> 字段，当线程持有互斥锁时，只能对 <code>hierarchy_value</code> 比当前锁更小的 mutex 加锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.7 Using a lock hierarchy to prevent deadlock
</span><span class="c1"></span><span class="n">hierarchical_mutex</span> <span class="nf">high_level_mutex</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="n">hierarchical_mutex</span> <span class="nf">low_level_mutex</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
<span class="n">hierarchical_mutex</span> <span class="nf">other_mutex</span><span class="p">(</span><span class="mi">6000</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">do_low_level_stuff</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">low_level_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">low_level_mutex</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">do_low_level_stuff</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">high_level_stuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">high_level_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierachical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">high_level_mutex</span><span class="p">);</span>
  <span class="n">high_level_stuff</span><span class="p">(</span><span class="n">low_level_func</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_a</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">high_level_func</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_other_stuff</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">other_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">high_level_func</span><span class="p">();</span>
  <span class="n">do_other_stuff</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_b</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierachical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">other_mutex</span><span class="p">)</span>
  <span class="n">other_stuff</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述示例中，thread_a() 遵守规则，运行良好；而 thread_b() 违反规则，故运行失败。下面是 <code>hierarchical_mutex</code> 的一个简单实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.8 A simple hierachical mutex
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">hierarchical_mutex</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">internal_mutex</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hierarchy_value</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">previous_hierarchy_value</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">thread_local</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_thread_hierarchy_value</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">check_for_hierarchy_violation</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this_thread_hierarchy_value</span> <span class="o">&lt;=</span> <span class="n">hierarchy_value</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&#34;mutex hierarchy violated.&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">update_hierarchy_value</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">pervious_hierarchy_value</span> <span class="o">=</span> <span class="n">this_thread_hierarchy_value</span><span class="p">;</span>
    <span class="n">this_thread_hierarchy_value</span> <span class="o">=</span> <span class="n">hierarchy_value</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">hierarchical_mutex</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
    <span class="n">hierarchy_value</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
    <span class="n">previous_hierarchy_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">check_for_hierarchy_violation</span><span class="p">();</span>
    <span class="n">internal_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">update_hierarchy_value</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this_thread_hierarchy_value</span> <span class="o">!=</span> <span class="n">hierarchy_value</span><span class="p">)</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&#34;mutex hierarchy violated.&#34;</span><span class="p">);</span>
    <span class="n">this_thread_hierarchy_value</span> <span class="o">=</span> <span class="n">previous_hierarchy_value</span><span class="p">;</span>
    <span class="n">internal_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">try_lock</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">check_for_hierarchy_violation</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">internal_mutex</span><span class="p">.</span><span class="n">try_lock</span><span class="p">())</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">update_hierarchy_value</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">thread_local</span> <span class="kt">unsigned</span> <span class="kt">long</span> 
  <span class="n">hierarchical_mutex</span><span class="o">::</span><span class="n">this_thread_hierarchy_value</span><span class="p">(</span><span class="n">ULONG_MAX</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><em>Tips:</em> <a href="https://en.cppreference.com/w/cpp/language/storage_duration">thread_local</a></p>
</li>
</ol>
<h3 id="16-stdunique_lock">1.6. <code>std::unique_lock</code></h3>
<p>使用 <code>std::unique_lock</code> 可以将 Listing 3.6 改写为如下形式。其中 <code>std::defer_lock</code> 表示在构造 <code>std::unqiue_lock</code> 实例时，会让传入的 <code>std::mutex</code> 保持 unlocked。</p>
<p><code>std::unique_lock</code> 的优缺点：</p>
<ul>
<li>优点：<code>std::unique_lock</code> 并不会总是持有 <code>std::mutex</code> 的所有权，使用更加灵活</li>
<li>缺点：为了实现上面的优点，需要花费额外的空间和时间以存储更新相关状态数据，所以 <code>std::unqiue_lock</code> 比 <code>std::lock_guard</code> 慢且更占存储空间。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.9 Using std::lock() and std::unique_lock() in a swap operation
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">some_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span><span class="o">:</span><span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="c1">// std::defer_lock leaves mutexes unlocked.
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span>
    <span class="c1">// Mutexes are locked here
</span><span class="c1"></span>    <span class="c1">// std::unique_lock objects could be passed to std::lock()
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lock_a</span><span class="p">,</span> <span class="n">lock_b</span><span class="p">);</span>  
    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>在上例中，我们发现 <code>std::unique_lock</code> 对象可以传入 <code>std::lock()</code> 函数，这是因为 <code>std::unique_lock</code> 实现了 <code>lock()</code>、<code>try_lock()</code> 和 <code>unlock()</code> 成员函数。除此之外，还可以通过调用 <code>owns_lock()</code> 函数查看 <code>std::unique_lock</code> 当前是否拥有 <code>std::mutex</code>。</p>
<p><code>std::unique_lock</code> 类型不支持 copy，但支持 move，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">get_lock</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">some_mutex</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
  <span class="n">prepare_data</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">lk</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process_data</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">get_lock</span><span class="p">());</span>
  <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="17-合理设置互斥锁的粒度">1.7. 合理设置互斥锁的粒度</h3>
<p>通常说到粒度，大家都会想到数据大小相关的粒度的概念；除此之外，占有锁的时间的粒度大小也需要多加注意。比如，有时不必全程持有互斥锁，只在对共享数据进行操作时才上锁，操作完毕后及时释放。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">get_add_process_data</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">my_lock</span><span class="p">(</span><span class="n">the_mutex</span><span class="p">);</span>
  <span class="n">some_class</span> <span class="n">data_to_process</span> <span class="o">=</span> <span class="n">get_next_data_chunk</span><span class="p">();</span>
  <span class="c1">// Don&#39;t need mutex locked across call to process()
</span><span class="c1"></span>  <span class="n">my_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">result_type</span> <span class="n">result</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">data_to_process</span><span class="p">);</span>
  <span class="c1">// Relock mutex to write result
</span><span class="c1"></span>  <span class="n">my_lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">write_result</span><span class="p">(</span><span class="n">data_to_process</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其次，我们需要尽可能地减少占有锁的时间。比如，如果对数据的副本进行操作也可以得到想要的结果，而且拷贝操作耗时很小时，我们可以选择操作副本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.10 Locking one mutex at a time in a comparison operator
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">Y</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">some_detail</span><span class="p">;</span>
  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">get_detail</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">some_detail</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Y</span><span class="p">(</span><span class="kt">int</span> <span class="n">sd</span><span class="p">)</span><span class="o">:</span><span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="n">Y</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Y</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">lhs_value</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">get_detail</span><span class="p">();</span> <span class="c1">// phase 1
</span><span class="c1"></span>    <span class="kt">int</span> <span class="k">const</span> <span class="n">rhs_value</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">get_detail</span><span class="p">();</span> <span class="c1">// phase 2
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">lhs_value</span> <span class="o">==</span> <span class="n">rhs_value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>上例中需要注意的是，在 phase 1 和 phase 2 之间，可能 <code>lhs</code> 的值发生了改变，所以返回的结果的有效性有一定损失。</p>
<h2 id="2-保护共享数据的其他场景方法">2. 保护共享数据的其他场景/方法</h2>
<p>互斥锁的确很通用，但在特定的场合下选择更适合的保护机制也是很有必要的。</p>
<h3 id="21-仅在初始化阶段需要保护的共享数据">2.1. 仅在初始化阶段需要保护的共享数据</h3>
<p>假设你需要对某个对象使用 <strong>Lazy initialization</strong> 机制，在单线程下很容易实现，仅需要在使用之前检查是否已初始化即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span> 
  <span class="p">}</span>
  <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在多线程的场景下，初始化的操作需要进行保护，一个简单的实现如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.11 Thread-safe lazy initialization using a mutex
</span><span class="c1"></span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">resource_mutex</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// All threads are serialized here
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span> 
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Only the initialization needs protection
</span><span class="c1"></span>    <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在上述实现中，增加了不必要的加锁、释放锁的操作，而我们所需要保护的仅仅是初始化操作而已。为了解决这个问题，可能有人会想到 double-checked locking 模式，写出如下所示的代码，但是这不仅不会解决我们得问题，还会额外引发其他问题：线程在 phase 1 可随意访问共享对象，其与 phase 3 并不处于同步状态，很有可能在 phase 1 阶段发现指针非空便直接到了 phase 4 阶段，而此时对象 <code>some_resource</code> 可能还未构造完毕，从而造成未定义的行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// infamous double-checked locking pattern
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">undefined_behaviour_with_double_checked_locking</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>  <span class="c1">// phase 1
</span><span class="c1"></span>  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>  <span class="c1">// phase 2
</span><span class="c1"></span>    <span class="p">{</span>
      <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>  <span class="c1">// phase 3
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span> <span class="c1">// phase 4
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 C++ 提供的 <code>std::once_flag</code> 和 <code>std::call_once</code> 便可写出满足要求的代码，每个 <code>std::once_flag</code> 实例对应于不同的初始化过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">resourceZ_flag</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">init_resource</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Initalization is called exactly once.
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">resource_flag</span><span class="p">,</span> <span class="n">init_resource</span><span class="p">);</span>
  <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在类的成员函数使用 <code>std::call_once()</code> 时需要传入 <code>this</code> 指针，就像 <code>std::thread</code> 的构造函数或 <code>std::bind()</code> 一样，如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.12 Thread-safe lazy initialization of a class member using std::call_once
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">connection_info</span> <span class="n">connection_details</span><span class="p">;</span>
  <span class="n">connection_handle</span> <span class="n">connection</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">once_flag</span>  <span class="n">connection_init_flag</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">open_connection</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">connection_manager</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">connection_details</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">X</span><span class="p">(</span><span class="n">connection_info</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">connection_details_</span><span class="p">)</span> <span class="o">:</span> 
        <span class="n">connection_details</span><span class="p">(</span><span class="n">connection_details_</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="nf">send_data</span><span class="p">(</span><span class="n">data_packet</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">connection_init_flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">open_connection</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>  
    <span class="n">connection</span><span class="p">.</span><span class="n">send_data</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">data_packet</span> <span class="nf">receive_data</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">connection_init_flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">open_connection</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">connection</span><span class="p">.</span><span class="n">receive_data</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>在 C++11 之前，静态变量也有潜在的竞态情况，但在 C++11 之中这一点被修复了，静态局部变量的初始化仅会在一个线程中执行，所以在 C++11 之中，声明变量为 <code>static</code> 也可以起到和 <code>std::call_once()</code> 类似的效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_class</span><span class="p">;</span>
<span class="n">my_class</span><span class="o">&amp;</span> <span class="n">get_my_class_instance</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Initialization guaranteed to be thread-safe.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">my_class</span> <span class="n">instance</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="22-保护极少更新的共享数据">2.2. 保护极少更新的共享数据</h3>
<p>对于这种情况，我们可以立马想到使用读写锁，C++17 提供两种读写锁：<code>std::shared_mutex</code> 和 <code>std::shared_timed_mutex</code>；C++14 仅提供 <code>std::shared_time_mutex</code>；而对于 C++11，如果想使用读写锁，就需要依赖 Boost library 提供的实现。</p>
<p>对于 <code>std::shared_mutex</code>(<code>std::mutex_time_mutex</code>同样)，在使用 RAII 机制时：</p>
<ul>
<li>写锁：<code>std::lock_guard&lt;std::shared_mutex&gt;</code> 或 <code>std::unique_lock&lt;std::shared_mutex&gt;</code></li>
<li>读锁：<code>std::shared_lock&lt;std::shared_mutex&gt;</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Listing 3.13 Protecting a data structure with std::shared_mutex
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;shared_mutex&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">dns_entry</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">dns_cache</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">dns_entry</span><span class="o">&gt;</span> <span class="n">entries</span><span class="p">;</span>
  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">entry_mutex</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">dns_entry</span> <span class="n">find_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">dns_entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="n">it</span> <span class="o">=</span> <span class="n">entries</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">entries</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">?</span> <span class="n">dns_entry</span><span class="p">()</span> <span class="o">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">update_or_add_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">,</span> <span class="n">dns_entry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dns_details</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
    <span class="n">entries</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">dns_details</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="23-递归锁">2.3. 递归锁</h3>
<p>虽然一般不推荐使用递归锁，但是想使用的话，C++ 提供了递归锁的实现：<code>std::recursive_mutex</code>。</p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">765PRO.P</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2019-11-15
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://k-on.me/tags/c&#43;&#43;/">C&#43;&#43;</a>
          <a href="https://k-on.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          <a href="https://k-on.me/tags/%E5%B9%B6%E5%8F%91/">并发</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/go%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">GO 进程资源占用分析</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/ccia-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">
            <span class="next-text nav-default">CCIA-线程管理</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="pro-765@qq.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/yz1509" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://k-on.me/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        765PRO.P
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>



  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>









  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
