<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>图 - HTT - ふわふわ時間</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="765PRO.P" />
  <meta name="description" content="简单介绍图及其相关算法。
" />

  <meta name="keywords" content="K-ON, KyoAni" />






<meta name="generator" content="Hugo 0.76.0-DEV" />


<link rel="canonical" href="https://yz1509.github.io/post/%E5%9B%BE/" />







<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">








<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="图" />
<meta property="og:description" content="简单介绍图及其相关算法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yz1509.github.io/post/%E5%9B%BE/" />
<meta property="article:published_time" content="2018-07-26T13:17:37+00:00" />
<meta property="article:modified_time" content="2018-07-26T13:17:37+00:00" />
<meta itemprop="name" content="图">
<meta itemprop="description" content="简单介绍图及其相关算法。">
<meta itemprop="datePublished" content="2018-07-26T13:17:37+00:00" />
<meta itemprop="dateModified" content="2018-07-26T13:17:37+00:00" />
<meta itemprop="wordCount" content="2432">



<meta itemprop="keywords" content="图,BFS,DFS,拓扑排序,强连通分量,最小生成树,Kruskal 算法,Prim 算法,单源最短路径,Bellman-Ford 算法,Dijkstra 算法," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="图"/>
<meta name="twitter:description" content="简单介绍图及其相关算法。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">HTT</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/about/">About</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/categories/">Categories</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      HTT
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/about/">About</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://yz1509.github.io/categories/">Categories</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">图</h1>
      
      <div class="post-meta">
        <time datetime="2018-07-26" class="post-time">
          2018-07-26
        </time>
        <div class="post-category">
            <a href="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"> 数据结构与算法 </a>
            
          </div>
        <span class="more-meta"> 2432 words </span>
          <span class="more-meta"> 5 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#什么是图">什么是图</a>
      <ul>
        <li><a href="#图的表示">图的表示</a></li>
      </ul>
    </li>
    <li><a href="#广度优先搜索">广度优先搜索</a>
      <ul>
        <li><a href="#bfs-的性质">BFS 的性质</a></li>
      </ul>
    </li>
    <li><a href="#深度优先搜索">深度优先搜索</a>
      <ul>
        <li><a href="#dfs-的性质">DFS 的性质</a></li>
        <li><a href="#拓扑排序">拓扑排序</a></li>
        <li><a href="#强连通分量">强连通分量</a></li>
      </ul>
    </li>
    <li><a href="#最小生成树">最小生成树</a>
      <ul>
        <li><a href="#kruskal-算法">Kruskal 算法</a></li>
        <li><a href="#prim-算法">Prim 算法</a></li>
      </ul>
    </li>
    <li><a href="#单源最短路径">单源最短路径</a>
      <ul>
        <li><a href="#bellman-ford-算法">Bellman-Ford 算法</a></li>
        <li><a href="#有向无环图中的单源最短路径问题">有向无环图中的单源最短路径问题</a></li>
      </ul>
    </li>
    <li><a href="#dijkstra-算法">Dijkstra 算法</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>简单介绍图及其相关算法。</p>
<hr>
<h2 id="什么是图">什么是图</h2>
<p><strong>定义</strong> 一个图 $G = (V, E)$ 由顶点（或结点）的非空集 $V$ 和边的集合 $E$ 构成，每条边有一个或两个顶点与它相连，这样的顶点称为边的端点。边连接它的端点。</p>
<h3 id="图的表示">图的表示</h3>
<ul>
<li>邻接链表：稀疏图</li>
<li>邻接矩阵：稠密图，或者需要快速判断任意两个结点之间是否有边的情况</li>
</ul>
<p><img src="/graph-001.png" alt="图的表示"></p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/** u.color 存放结点 u 的颜色属性
</span><span class="cm">  *         白色表示未被发现
</span><span class="cm">  *         灰色表示邻接结点中还有白色结点
</span><span class="cm">  *         黑色表示邻接结点均被发现
</span><span class="cm">  * u.π 存放前驱结点
</span><span class="cm">  * u.d 存放从源结点 s 到结点 u 之间的距离
</span><span class="cm">  **/</span>
<span class="n">BFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span> <span class="o">-</span> <span class="p">{</span><span class="n">s</span><span class="p">}</span>
                <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">WHITE</span>
                <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="err">∞</span>
                <span class="n">u</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
        <span class="n">s</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
        <span class="n">s</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="err">∅</span>
        <span class="n">ENQUEUE</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">Q</span> <span class="err">≠</span> <span class="err">∅</span>  <span class="c1">// 灰色结点的集合
</span><span class="c1"></span>                <span class="n">u</span> <span class="o">=</span> <span class="n">DEQUEUE</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
                                <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
                                <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
                                <span class="n">ENQUEUE</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>BFS 的总运行时间为 O(V + E)</p>
</blockquote>
<p><img src="/graph-002.png" alt="BFS"></p>
<h3 id="bfs-的性质">BFS 的性质</h3>
<ol>
<li>BFS 可以计算出从源结点 s 到 结点 v 的最短路径。</li>
<li>BFS 在对图进行搜索的过程中将创建一棵广度优先树</li>
</ol>
<h2 id="深度优先搜索">深度优先搜索</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/** u.color 存放结点 u 的颜色属性
</span><span class="cm">  *         白色表示未被发现
</span><span class="cm">  *         灰色表示邻接结点中还有白色结点
</span><span class="cm">  *         黑色表示邻接结点均被发现
</span><span class="cm">  * u.π 存放前驱结点
</span><span class="cm">  * u.d 记录结点 u 第一次被发现的时间
</span><span class="cm">  * u.f 记录搜索完成对 u 的邻接链表扫描的事件
</span><span class="cm">  **/</span>
<span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
                <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">WHITE</span>
                <span class="n">u</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
                <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
                        <span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

<span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// white vertex u has just been discovered
</span><span class="c1"></span>        <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="c1">// explore edge (u, v)
</span><span class="c1"></span>                <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
                        <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
                        <span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>  <span class="c1">// blacken u, it is finished
</span><span class="c1"></span>        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">time</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>DFS 的总运行时间为 O(V + E)</p>
</blockquote>
<p><img src="/graph-003.png" alt="DFS"></p>
<h3 id="dfs-的性质">DFS 的性质</h3>
<ol>
<li>
<p>括号化定理：在对有向或无向图进行的任意 DFS 中，对于任意两个结点 u 和 v 来说，下面三种情况只有一种成立：</p>
<ul>
<li>区间 $[u.d, u.f]$ 和 区间 $[v.d, v.f$ 完全分离，在深度优先森林中，结点 u 不是结点 v 的后代，结点 v 也不是结点 u 的后代</li>
<li>区间 $[u.d, u.f]$ 完全包含在 区间 $[v.d, v.f$ 内，在深度优先树中，结点 u 是结点 v 的后代</li>
<li>区间 $[v.d, v.f]$ 完全包含在 区间 $[u.d, u.f$ 内，在深度优先树中，结点 v 是结点 u 的后代</li>
</ul>
</li>
<li>
<p>边的分类</p>
<ul>
<li>树边：是深度优先森林 $G_π$ 中的边。如果结点  v 是因算法对边 (u, v) 的探索而首先被发现，则 (u, v) 是一条树边</li>
<li>后向边：是将结点 u 连接到其在深度优先树中祖先结点 v 的边。由于有向图中可以有自循环，自循环也被认为是后向边</li>
<li>前向边：是将结点 u 连接到其在深度优先树中后代结点 v 的边</li>
<li>横向边：其他所有的边</li>
</ul>
</li>
</ol>
<blockquote>
<p>在对无向图 G 进行深度优先搜索时，每条边要么是树边，要么是后向边。</p>
</blockquote>
<h3 id="拓扑排序">拓扑排序</h3>
<p>对于一个有向无环图 G(V, E) 来说，其拓扑排序是 G 中所有结点的一种线性次序，该次序满足如下条件：如果图 G 包含边 (u, v)，则结点 u 在拓扑排序中处于结点 v 的前面。</p>
<p><img src="/graph-004.png" alt="拓扑排序"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">TOPOLOGICAL</span><span class="o">-</span><span class="n">SORT</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">call</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">finishing</span> <span class="n">time</span> <span class="n">v</span><span class="p">.</span><span class="n">f</span> <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span>
    <span class="n">as</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">is</span> <span class="n">finished</span><span class="p">,</span> <span class="n">insert</span> <span class="n">it</span> <span class="n">onto</span> <span class="n">the</span> <span class="n">front</span> <span class="n">of</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span>
    <span class="k">return</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">of</span> <span class="n">list</span> <span class="n">of</span> <span class="n">vertices</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="强连通分量">强连通分量</h3>
<p><strong>定义：</strong> 如果一个有向图中任意两个顶点互相可达，则该有向图是强连通的。
图 G 的转置 $G^T = (V, E^T)$，其中 $E^T = {(u, v): (u, v) \in E}$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">STRONGLY</span><span class="o">-</span><span class="n">CONNECTED</span><span class="o">-</span><span class="n">COMPONENTS</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">call</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">finishing</span> <span class="n">time</span> <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span>
    <span class="n">compute</span> <span class="n">G</span><span class="o">^</span><span class="n">T</span>
    <span class="n">call</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="o">^</span><span class="n">T</span><span class="p">),</span> <span class="n">but</span> <span class="n">in</span> <span class="n">the</span> <span class="n">main</span> <span class="n">loop</span> <span class="n">of</span> <span class="n">DFS</span><span class="p">,</span> <span class="n">consider</span> <span class="n">the</span> <span class="n">vertices</span>
            <span class="n">in</span> <span class="n">order</span> <span class="n">of</span> <span class="n">decreasing</span> <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="p">(</span><span class="n">as</span> <span class="n">computed</span> <span class="n">in</span> <span class="n">line</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">output</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="n">each</span> <span class="n">tree</span> <span class="n">in</span> <span class="n">the</span> <span class="n">depth</span><span class="o">-</span><span class="n">first</span> <span class="n">forest</span> <span class="n">formed</span>
            <span class="n">in</span> <span class="n">line</span> <span class="mi">3</span> <span class="n">as</span> <span class="n">a</span> <span class="n">separate</span> <span class="n">strongly</span> <span class="n">connected</span> <span class="n">component</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/graph-005.png" alt="强连通分量"></p>
<h2 id="最小生成树">最小生成树</h2>
<p><strong>定义：</strong> 连通加权图里的最小生成树是具有边的权值之和最小的生成树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 在每遍循环之前，A 是某棵最小生成树的一个子集
</span><span class="c1">// 加入集合 A 而不会破坏 A 的循环不变式的边称为集合 A 的安全边
</span><span class="c1"></span><span class="n">GENERIC</span><span class="o">-</span><span class="n">MST</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="err">∅</span>
    <span class="k">while</span> <span class="n">A</span> <span class="n">does</span> <span class="n">not</span> <span class="n">form</span> <span class="n">a</span> <span class="n">spanning</span> <span class="n">tree</span>
            <span class="n">find</span> <span class="n">an</span> <span class="n">edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">that</span> <span class="n">is</span> <span class="n">safe</span> <span class="k">for</span> <span class="n">A</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="err">∪</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>定理：</strong> 设 G = (V, E) 是一个在边 E 上定义了实数值权重函数 w 的连通无向图。设集合 A 为 E 的一个子集，且 A 包括在图 G 的某棵最小生成树中，设 (S, V - S) 是图 G 中尊重集合 A 的任意一个切割（集合 A 中不存在横跨该切割的边），又设 (u, v) 是横跨切割 (S, V - S) 的一条轻边。那么边 (u, v) 对于集合 A 是安全的。</p>
<h3 id="kruskal-算法">Kruskal 算法</h3>
<p>在 Kurskal 算法中，集合 A 是一个森林，其结点就是给定图的结点。每次加入集合 A 中的安全边永远是权重最小的连接两个不同分量的边。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">MST</span><span class="o">-</span><span class="n">KRUSKAL</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="err">∅</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
            <span class="n">MAKE</span><span class="o">-</span><span class="n">SET</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">sort</span> <span class="n">the</span> <span class="n">edge</span> <span class="n">of</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span> <span class="n">into</span> <span class="n">nondecreasing</span> <span class="n">order</span> <span class="n">by</span> <span class="n">weight</span> <span class="n">w</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span><span class="p">,</span> <span class="n">taken</span> <span class="n">in</span> <span class="n">nondecreasing</span> <span class="n">order</span> <span class="n">by</span> <span class="n">weight</span>
        <span class="k">if</span> <span class="n">FIND</span><span class="o">-</span><span class="n">SET</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="err">≠</span> <span class="n">FIND</span><span class="o">-</span><span class="n">SET</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="err">∪</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
            <span class="n">UNION</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Kruskal 算法的时间复杂度为 $O(ElgV)$。</p>
</blockquote>
<p><img src="/graph-006.png" alt="Kruskal 算法"></p>
<h3 id="prim-算法">Prim 算法</h3>
<p>在 Prim 算法里，集合 A 则是一棵树。这棵树从一个任意的根结点 r 开始，一直长大到覆盖 V 中的所有结点时为止。每次加入到 A 中的安全边永远是连接 A 和 A 之外某个结点的边中权重最小的边。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">MST</span><span class="o">-</span><span class="n">PRIM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="n">u</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="err">∞</span>
        <span class="n">u</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
    <span class="n">r</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
    <span class="k">while</span> <span class="n">Q</span> <span class="err">≠</span> <span class="err">∅</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">EXTRACT</span><span class="o">-</span><span class="n">MIN</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="n">in</span> <span class="n">Q</span> <span class="n">and</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">key</span>
                <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">v</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 $O(ElgV)$；
如果使用斐波那契堆来实现最小优先队列 Q，则 Prim 算法的运行时间将改进到 $O(E + VlgV)$</p>
</blockquote>
<p><img src="/graph-007.png" alt="Prim算法"></p>
<h2 id="单源最短路径">单源最短路径</h2>
<ol>
<li>最短路径的子路径也是最短路径</li>
<li>如果从结点 s 到结点 v 的某条路径上存在权重为负值的环路，我们定义 $\delta(s, v) = -\infty$</li>
<li>一般地，我们假定在找到的最短路径中没有环路，即它们都是简单路径。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/** 初始化
</span><span class="cm">  * v.d：s 到 v 的最短路径估计
</span><span class="cm">  * v.π：前驱结点 */</span>
<span class="n">INITIALIZE</span><span class="o">-</span><span class="n">SINGLE</span><span class="o">-</span><span class="n">SOURCE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="err">∞</span>
        <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
    <span class="n">s</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// 松弛操作
</span><span class="c1"></span><span class="n">RELAX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Dijkstra 算法和用于有向无环图的最短路径算法对每条边仅松弛一次。 Bellman-Ford 算法则对每条边松弛 |V| - 1 次。</p>
</blockquote>
<h3 id="bellman-ford-算法">Bellman-Ford 算法</h3>
<p>Bellman-Ford 算法解决的是一般情况下的最短路径问题。该算法返回 TRUE 值当且仅当输入图不包含可以从源结点到达的权重为负值的环路。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BELLMAN</span><span class="o">-</span><span class="n">FORD</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">INITIALIZE</span><span class="o">-</span><span class="n">SINGLE</span><span class="o">-</span><span class="n">SOURCE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="o">|</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="o">|-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span>
            <span class="n">RELAX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">FALSE</span>
    <span class="k">return</span> <span class="n">TRUE</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Bellman-Ford 算法的总运行时间为 O(VE)</p>
</blockquote>
<p><img src="/graph-008.png" alt="Bellman-Ford 算法"></p>
<h3 id="有向无环图中的单源最短路径问题">有向无环图中的单源最短路径问题</h3>
<p>根据结点的拓扑排序次序来对带权重的有向无环图 G = (V, E) 进行边的松弛操作，我们便可以在 $O(V + E)$ 时间内计算出从单个源结点到所有结点之间的最短路径。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">DAG</span><span class="o">-</span><span class="n">SHOPTEST</span><span class="o">-</span><span class="n">PATHS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">topologically</span> <span class="n">sort</span> <span class="n">the</span> <span class="n">vertice</span> <span class="n">of</span> <span class="n">G</span>
    <span class="n">INITIALIZE</span><span class="o">-</span><span class="n">SINGLE</span><span class="o">-</span><span class="n">SOURCE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span><span class="p">,</span> <span class="n">taken</span> <span class="n">in</span> <span class="n">topologically</span> <span class="n">sorted</span> <span class="n">order</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">RELAX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/graph-009.png" alt="DAG"></p>
<h2 id="dijkstra-算法">Dijkstra 算法</h2>
<p>Dijkstra 算法解决的是带权重的有向图上的单源最短路径问题，该算法要求所有边的权重都为非负值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">DIJKSTRA</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">INITIALIZE</span><span class="o">-</span><span class="n">SINGLE</span><span class="o">-</span><span class="n">SOURCE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="err">∅</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
    <span class="k">while</span> <span class="n">Q</span> <span class="err">≠</span> <span class="err">∅</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">EXTRACT</span><span class="o">-</span><span class="n">MIN</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="err">∪</span> <span class="p">{</span><span class="n">u</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">RELAX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 $O(ElgV)$；
如果使用斐波那契堆来实现最小优先队列 Q，则 Dijkstra 算法的运行时间将改进到 $O(E + VlgV)$</p>
</blockquote>
<p><img src="/graph-010.png" alt="Dijsktra算法"></p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">765PRO.P</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2018-07-26
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://yz1509.github.io/tags/%E5%9B%BE/">图</a>
          <a href="https://yz1509.github.io/tags/bfs/">BFS</a>
          <a href="https://yz1509.github.io/tags/dfs/">DFS</a>
          <a href="https://yz1509.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a>
          <a href="https://yz1509.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/">强连通分量</a>
          <a href="https://yz1509.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a>
          <a href="https://yz1509.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">单源最短路径</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/c-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">C&#43;&#43;面试知识点</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/%E5%90%90%E8%A1%80bug%E5%90%88%E9%9B%86/">
            <span class="next-text nav-default">吐血bug合集（持续更新）</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="pro-765@qq.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/yz1509" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://yz1509.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        765PRO.P
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>



  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>









  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
