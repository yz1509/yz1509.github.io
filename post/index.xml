<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HTT - ふわふわ時間</title>
    <link>https://yz1509.github.io/post/</link>
    <description>Recent content in Posts on HTT - ふわふわ時間</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 07 Sep 2020 12:02:54 +0000</lastBuildDate><atom:link href="https://yz1509.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Efficient State-based CRDTs by Delta-Mutation</title>
      <link>https://yz1509.github.io/post/efficient-state-based-crdts-by-delta-mutation/</link>
      <pubDate>Mon, 07 Sep 2020 12:02:54 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/efficient-state-based-crdts-by-delta-mutation/</guid>
      <description>Efficient State-based CRDTs by Delta-Mutation 阅读笔记。 论文地址 代码地址 CmRDT 和 CvRDT 的不足 本文作者认为 CmRDT 的不足之处有三： 为确保幂等性：要求消息传输提供 exactly once 的保证 (本身幂等的操作无需此</description>
    </item>
    
    <item>
      <title>Redis Modules APIs</title>
      <link>https://yz1509.github.io/post/redis-modules-apis/</link>
      <pubDate>Thu, 27 Aug 2020 10:45:48 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/redis-modules-apis/</guid>
      <description>Redis Modules APIs 介绍。 源码地址 内存管理 虽然在模块中可以调用 malloc() 和 free() 函数，但是通过 malloc() 分配的内存并不会被计算到 used_memory 信息中去，也不会受到 maxmemory 限制，所以应首先考虑使</description>
    </item>
    
    <item>
      <title>NVM-notes</title>
      <link>https://yz1509.github.io/post/nvm-notes/</link>
      <pubDate>Wed, 26 Aug 2020 20:38:59 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/nvm-notes/</guid>
      <description>NVM 相关笔记。 Intel Optane DC Persistent Memory Overview 原文地址 Intel Optane DC Persistent Memory has two main properties: It is persistent. Data is maintained even when the system power is off. This memory is byte-addressable. Like in regular DRAM, programs can access data structures in place at cache line granularity, avoiding the need to access data in large blocks as it currently happens</description>
    </item>
    
    <item>
      <title>Introduction to Redis modules</title>
      <link>https://yz1509.github.io/post/introduction-to-redis-modules/</link>
      <pubDate>Wed, 19 Aug 2020 16:52:01 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/introduction-to-redis-modules/</guid>
      <description>Redis Modules 入门。 Introduction to Redis modules 原文地址 加载、卸载和查看 Modules 加载 Modules 有两种加载方式： 在 redis.conf 中设置：loadmodule /path/to/mymodule.so 通过 redis command 实时加载：MODULE LOAD /path/to/mymodule.so 也可在</description>
    </item>
    
    <item>
      <title>分布式系统相关笔记</title>
      <link>https://yz1509.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 17 Aug 2020 20:08:58 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</guid>
      <description>分布式系统相关资源汇总及简要笔记。 基础概念 一致性相关 Strong consistency models 中文版 英文版 正确性 (Correctness) 我们说一个系统是由状态和一些导致状态转移的操作组成的 系统的正确</description>
    </item>
    
    <item>
      <title>CRDTs in Redis</title>
      <link>https://yz1509.github.io/post/crdts-in-redis/</link>
      <pubDate>Wed, 17 Jun 2020 11:15:10 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/crdts-in-redis/</guid>
      <description>Redis 全球多活调研笔记。 CRDT 简单介绍 在 Conflict-free Replicated Data Types 一文中，作者依据传递消息内容的区别，提出了两种 CRDT： CvRDT(State-based Convergent Replicated Data Type): 基于状态的聚合复制数据类型 条件： 状</description>
    </item>
    
    <item>
      <title>Conflict free replicated data types</title>
      <link>https://yz1509.github.io/post/conflict-free-replicated-data-types/</link>
      <pubDate>Wed, 22 Apr 2020 18:09:55 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/conflict-free-replicated-data-types/</guid>
      <description>Conflict free replicated data types 阅读笔记。 论文地址 最终一致性 Eventual Consistency 一个分布式系统是最终一致的，需满足以下条件： Eventual delivery: 在健康节点上执行的更新操作最终会被传递至所有健康节</description>
    </item>
    
    <item>
      <title>CRDT-notes</title>
      <link>https://yz1509.github.io/post/crdt-notes/</link>
      <pubDate>Tue, 21 Apr 2020 11:02:30 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/crdt-notes/</guid>
      <description>CRDT 学习笔记。 CRDT 相关资源 CRDT wiki CRDT Website CRDT Research Awesome CRDT 背景知识 A CRDT Primer Part I: Defanging Order Theory Order Definition An Order set is a binary relation $\le$ on a set $\mathcal{S}$, written $(\mathcal{S},\le)$. Core concepts If we can say that $a \le b$ or $b \le a$, then we know that $a$ is comparable to $b$.</description>
    </item>
    
    <item>
      <title>初试性能调优</title>
      <link>https://yz1509.github.io/post/%E5%88%9D%E8%AF%95%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Wed, 22 Jan 2020 10:36:38 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/%E5%88%9D%E8%AF%95%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>利用 perf + FlameGraph 进行性能调优。 简单使用示例： 1 2 3 4 5 6 7 // perf # perf record -F 99 -p pid --call-graph dwarf sleep 60 # perf script &amp;gt; out.perf // FlameGraph # ./stackcollapse-perf.pl out.perf &amp;gt; out.folded # ./flamegraph.pl out.folded &amp;gt; flameGraph.svg Perf 命令示例</description>
    </item>
    
    <item>
      <title>钓鱼实战技巧</title>
      <link>https://yz1509.github.io/post/%E9%92%93%E9%B1%BC%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 23 Dec 2019 19:59:24 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/%E9%92%93%E9%B1%BC%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/</guid>
      <description>我再也不想当空军了.jpg 黑坑(鲫鱼)实战技巧 线组 黑坑鲫鱼口小，所以需采用较为精细的线组。例如 2.0 的主线搭配 0.6 的子线，浮漂选择细长浮力小的。 实</description>
    </item>
    
    <item>
      <title>CCIA-线程间同步</title>
      <link>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 11 Dec 2019 19:45:55 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5/</guid>
      <description>《C++ Concurrentcy in Action 2nd》 第四章阅读笔记。 在多线程编程中，不仅需要知道处理数据的一致性问题，还需要熟悉线程之间的同步机制。 等待某个事件/条件 当一</description>
    </item>
    
    <item>
      <title>GO 进程资源占用分析</title>
      <link>https://yz1509.github.io/post/go%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 22 Nov 2019 18:47:27 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/go%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/</guid>
      <description>使用 pprof 和 graphviz 分析进程内存分配，CPU 耗时等信息。 当我们想分析自己写的代码中内存分配主要发生在哪或者哪些语句比较耗时时，可以使用 pprof 帮我们记录这些</description>
    </item>
    
    <item>
      <title>CCIA-线程间共享数据</title>
      <link>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Fri, 15 Nov 2019 17:15:13 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</guid>
      <description>《C++ Concurrentcy in Action 2nd》 第三章阅读笔记。 使用互斥锁保护共享数据 在 C++ 中使用互斥锁 构造一个 std::mutex 的实例即可创建一个互斥锁，使用成员函数 lock() 和 unlock() 可分别执行</description>
    </item>
    
    <item>
      <title>CCIA-线程管理</title>
      <link>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 14 Nov 2019 14:20:01 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/ccia-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>《C++ Concurrentcy in Action 2nd》 第二章阅读笔记。 基础线程管理 启动线程 使用 C++ 线程库启动线程，可以归结为构造 std::thread 对象，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description>
    </item>
    
    <item>
      <title>Redis Streams</title>
      <link>https://yz1509.github.io/post/redisstreams/</link>
      <pubDate>Wed, 16 Oct 2019 17:50:09 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/redisstreams/</guid>
      <description>主要介绍 Redis Streams 数据结构及部分操作，并不涉及源码部分。 整理自 Streams: a new general purpose data structure in Redis、An update on Redis Streams development、Redis streams as a pure data</description>
    </item>
    
    <item>
      <title>Consistent Hashing</title>
      <link>https://yz1509.github.io/post/consistenthashing/</link>
      <pubDate>Sat, 12 Oct 2019 21:26:09 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/consistenthashing/</guid>
      <description>一致性哈希的 first paper (maybe) 阅读笔记。 论文地址 Whydunit 当大量的客户端同时对单个服务器发起请求时，可能会使该服务器(Hot spots) &amp;ldquo;swamped&amp;rdquo; （无法使用）。除此之外，还可能会</description>
    </item>
    
    <item>
      <title>Redis 源码之 sds</title>
      <link>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Bsds/</link>
      <pubDate>Sat, 12 Oct 2019 20:10:31 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Bsds/</guid>
      <description>Redis 简单字符串的源码读后感 (超500字)。 源码文件 /src/sds.h &amp;amp; sdsalloc.h &amp;amp; /src/sds.c sds 数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 typedef char *sds;</description>
    </item>
    
    <item>
      <title>Redis 源码之 adlist</title>
      <link>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Badlist/</link>
      <pubDate>Sat, 12 Oct 2019 20:08:45 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Badlist/</guid>
      <description>Redis 底层链表结构相关源码阅读笔记。 源码文件 /src/adlist.h &amp;amp; /src/adlist.c adlist 数据结构 adlist 其实是一个双向链表，我们首先介绍其链表节点、链表迭代器和链表的数据结构。 链表节点 1</description>
    </item>
    
    <item>
      <title>Redis 源码之 zmalloc</title>
      <link>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Bzmalloc/</link>
      <pubDate>Sat, 12 Oct 2019 20:07:44 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/redis%E6%BA%90%E7%A0%81%E4%B9%8Bzmalloc/</guid>
      <description>Redis 内存分配及释放相关源码阅读笔记，版本: 47ff13637 Redis 6.0.1 源码文件 /src/zmalloc.h &amp;amp; /src/zmalloc.c 分配内存 zmalloc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void *zmalloc(size_t size) { // 调用 malloc 分配内存 void *ptr = malloc(size+PREFIX_SIZE);</description>
    </item>
    
    <item>
      <title>Linux相关小问题</title>
      <link>https://yz1509.github.io/post/linux%E7%9B%B8%E5%85%B3%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 12 Oct 2019 20:00:38 +0000</pubDate>
      
      <guid>https://yz1509.github.io/post/linux%E7%9B%B8%E5%85%B3%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>这个人明明遇到过很多问题，却总是忘了记录。 手动卸载旧版本软件，安装完新版本之后，提示 No such file or directory 怎么办？ 使用 echo $PATH 命令检查环境变量，如新版本软件</description>
    </item>
    
  </channel>
</rss>
