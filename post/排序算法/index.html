<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>排序算法 - HTT - ふわふわ時間</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="765PRO.P" />
  <meta name="description" content="掌握了排序算法就不会失业.jpg
" />

  <meta name="keywords" content="K-ON, KyoAni" />






<meta name="generator" content="Hugo 0.76.0-DEV" />


<link rel="canonical" href="https://k-on.me/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />







<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">








<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="排序算法" />
<meta property="og:description" content="掌握了排序算法就不会失业.jpg" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://k-on.me/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<meta property="article:published_time" content="2018-07-19T10:07:14+00:00" />
<meta property="article:modified_time" content="2018-07-19T10:07:14+00:00" />
<meta itemprop="name" content="排序算法">
<meta itemprop="description" content="掌握了排序算法就不会失业.jpg">
<meta itemprop="datePublished" content="2018-07-19T10:07:14+00:00" />
<meta itemprop="dateModified" content="2018-07-19T10:07:14+00:00" />
<meta itemprop="wordCount" content="4570">



<meta itemprop="keywords" content="排序,直接插入排序,希尔排序,简单选择排序,堆排序,冒泡排序,快排,归并排序,基数排序," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="掌握了排序算法就不会失业.jpg"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">HTT</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/about/">About</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/categories/">Categories</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      HTT
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/about/">About</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://k-on.me/categories/">Categories</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">排序算法</h1>
      
      <div class="post-meta">
        <time datetime="2018-07-19" class="post-time">
          2018-07-19
        </time>
        <div class="post-category">
            <a href="https://k-on.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"> 数据结构与算法 </a>
            
          </div>
        <span class="more-meta"> 4570 words </span>
          <span class="more-meta"> 10 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#直接插入排序">直接插入排序</a>
      <ul>
        <li><a href="#算法思想">算法思想</a></li>
        <li><a href="#算法步骤">算法步骤</a></li>
        <li><a href="#代码实现">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#希尔排序">希尔排序</a>
      <ul>
        <li><a href="#算法思想-1">算法思想</a></li>
        <li><a href="#算法步骤-1">算法步骤</a></li>
        <li><a href="#代码实现-1">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#简单选择排序">简单选择排序</a>
      <ul>
        <li><a href="#算法思想-2">算法思想</a></li>
        <li><a href="#算法步骤-2">算法步骤</a></li>
        <li><a href="#代码实现-2">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#堆排序">堆排序</a>
      <ul>
        <li><a href="#堆的概念">堆的概念</a></li>
        <li><a href="#基本思想">基本思想</a></li>
        <li><a href="#代码实现-3">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#冒泡排序">冒泡排序</a>
      <ul>
        <li><a href="#基本思想-1">基本思想</a></li>
        <li><a href="#算法步骤-3">算法步骤</a></li>
        <li><a href="#代码实现-4">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#快速排序">快速排序</a>
      <ul>
        <li><a href="#算法思想-3">算法思想</a></li>
        <li><a href="#代码实现-5">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#归并排序">归并排序</a>
      <ul>
        <li><a href="#算法思想-4">算法思想</a></li>
        <li><a href="#代码实现-6">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#基数排序">基数排序</a>
      <ul>
        <li><a href="#算法思想-5">算法思想</a></li>
        <li><a href="#代码实现-7">代码实现</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>掌握了排序算法就不会失业.jpg</p>
<hr>
<h2 id="前言">前言</h2>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p>常见的八大排序算法，他们之间关系如下：</p>
<p><img src="/sort001.png" alt="avatar"></p>
<p>它们的性能比较：</p>
<p><img src="/sort002.png" alt="avatar"></p>
<p>下面，利用 Python 分别将他们进行实现。</p>
<h2 id="直接插入排序">直接插入排序</h2>
<h3 id="算法思想">算法思想</h3>
<p><img src="/sort006.gif" alt="插入排序示意图"></p>
<p>直接插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -------------- 直接插入排序 ------------------</span>
<span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 遍历数组中的所有元素，其中 0 号元素默认已排序，因此从 1 开始</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
        <span class="c1"># 将该元素与已排序好的前序数组依次比较，如果该元素小，则交换</span>
        <span class="c1"># range(x-1, -1, -1): 从 x-1 倒序循环到 0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 判断：如果符合条件则交换</span>
            <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="希尔排序">希尔排序</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于直接插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>直接插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率</li>
<li>但直接插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h3 id="算法步骤-1">算法步骤</h3>
<ol>
<li>选择一个增量序列 $t_1, t_2, \dots , t_k$, 其中 $t_i &gt; t_{i+1}, t_k = 1$；</li>
<li>按增量序列个数 $k$，对序列进行 $k$ 趟排序；</li>
<li>每趟排序，根据对应的增量 $t_i$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><img src="/sort003.png" alt="avatar"></p>
<h3 id="代码实现-1">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -------------- 希尔排序 ---------------</span>
<span class="k">def</span> <span class="nf">insert_shell</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 初始化gap值，此处利用序列长度的一半为其赋值</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># 第一层循环：依次改变gap值对列表进行分组</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># 下面，利用直接插入排序的思想对分组数据进行排序</span>
        <span class="c1"># range(gap, len(L)): 从gap开始</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
            <span class="c1"># range(x-gap, -1, -gap)：从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">gap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">gap</span><span class="p">):</span>
                <span class="c1"># 如果该组当中两个元素满足交换条件，则进行交换</span>
                <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">gap</span><span class="p">]:</span>
                    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">gap</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># gap折半</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">gap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="简单选择排序">简单选择排序</h2>
<h3 id="算法思想-2">算法思想</h3>
<p>简单选择排序的基本思想：比较 + 交换。</p>
<h3 id="算法步骤-2">算法步骤</h3>
<ol>
<li>从待排序序列中，找到关键字最小的元素，存放在待排序序列的起始位置；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 $N - 1$ 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。</li>
</ol>
<h3 id="代码实现-2">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -------------- 简单选择排序 ----------------</span>
<span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 依次遍历序列中的每一个元素</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
        <span class="c1"># 将当前位置的元素定义为比伦循环当中的最小值</span>
        <span class="n">minmum</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="c1"># 将该元素与剩下的元素依次比较寻找最小元素</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minmum</span><span class="p">:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">minmum</span> <span class="o">=</span> <span class="n">minmum</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">minmum</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="堆排序">堆排序</h2>
<h3 id="堆的概念">堆的概念</h3>
<p>堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于 (或大于) 它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。
利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。</p>
<h3 id="基本思想">基本思想</h3>
<p>堆排序可以按照以下步骤来完成：</p>
<ol>
<li>
<p>首先将序列构建称为大顶堆；这样，位于根节点的元素一定是当前序列的最大值
<img src="/sort004.png" alt="avatar"></p>
</li>
<li>
<p>取出当前大顶堆的根节点，将其与序列末尾元素进行交换；此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质</p>
</li>
<li>
<p>对交换后的前 $n-1$ 个序列元素进行调整，使其满足大顶堆的性质；
<img src="/sort005.png" alt="avatar"></p>
</li>
<li>
<p>重复 2、3 步骤，直至堆中只有 1 个元素为止</p>
</li>
</ol>
<h3 id="代码实现-3">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#--------------------- 堆排序 ----------------------</span>
<span class="c1">#************* 获取左右叶子结点 ***************</span>
<span class="k">def</span> <span class="nf">LEFT</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">RIGHT</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">#************ 调整大顶堆 ***************</span>
<span class="c1"># L：待调整序列</span>
<span class="c1"># length：序列长度</span>
<span class="c1"># i: 需要调整的结点</span>
<span class="k">def</span> <span class="nf">adjust_max_heap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="c1"># 定义一个int值保存当前序列最大值的下标</span>
    <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
    <span class="c1"># 执行循环: 1.寻找最大值的下标；</span>
    <span class="c1">#           2.最大值与父节点交换</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># 获得序列左右叶子结点的下标</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">RIGHT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># 当左叶子节点的下标小于序列长度并且左叶子节点的值大于父节点时，将左叶子节点的下标赋值给largest</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;左叶子节点&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># 当右叶子节点的下标小于序列长度并且右叶子节点的值大于父节点时，将右叶子节点的下标赋值给largest</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">largest</span><span class="p">]):</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;右边子节点&#39;</span><span class="p">)</span>
        <span class="c1"># 如果 largest 不等于 i，说明当前的父节点不是最大值，需要交换值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">largest</span>
            <span class="k">print</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
<span class="c1">#************* 建立大顶堆 *************</span>
<span class="k">def</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">int</span><span class="p">)((</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">adjust_max_heap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">#************* 堆排序 *************</span>
<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 先建立大顶堆，保证最大值位于根节点，并且父节点的值大于叶子节点</span>
    <span class="n">build_max_heap</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="c1"># i：当前堆中序列的长度，初始化为序列的长度</span>
    <span class="k">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="c1"># 执行循环：1.每次取出堆顶元素置于序列的最后(len-1, len-2, len-3...)</span>
    <span class="c1">#           2.调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 堆中序列长度减 1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># Python没有自加自减运算符！</span>
        <span class="c1"># 调整大顶堆</span>
        <span class="n">adjust_max_heap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="冒泡排序">冒泡排序</h2>
<h3 id="基本思想-1">基本思想</h3>
<p>冒泡排序 (Bubble Sort) 也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢浮到数列的顶端。</p>
<h3 id="算法步骤-3">算法步骤</h3>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="代码实现-4">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#---------------- 冒泡排序 -------------------</span>
<span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="c1"># 序列长度为 length 时，需要执行 length-1 轮交换</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="c1"># 对于每一轮交换，都将序列当中的左右元素进行比较</span>
    <span class="c1"># 每轮交换中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="快速排序">快速排序</h2>
<h3 id="算法思想-3">算法思想</h3>
<p>快速排序的基本思想：</p>
<ol>
<li>从序列当中选择一个基准数 (pivot)，在这里我们选择序列当中第一个数最为基准数</li>
<li>将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序，重复步骤 1、2，直到所有子集当中只有一个元素为止。</li>
</ol>
<h3 id="代码实现-5">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#--------------- 快速排序 -------------------</span>
<span class="c1"># L: 待排序的序列</span>
<span class="c1"># start：序列起始 index</span>
<span class="c1"># end：序列末尾 index</span>
<span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">):</span>
            <span class="c1"># 从右向左找第一个小于pivot的值</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># 将小于pivot的值移到左边</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># 从左到右找第一个大于pivot的值</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># 将大于pivot的值移到右边</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># 循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot</span>
        <span class="c1"># pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可</span>
        <span class="c1"># 递归调用函数：依次对左侧序列：从 start 到 i-1</span>
        <span class="c1">#                     右侧序列：从 i+1 到 end</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="c1"># 左侧序列继续排序</span>
        <span class="n">quick_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 右侧序列继续排序</span>
        <span class="n">quick_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="归并排序">归并排序</h2>
<h3 id="算法思想-4">算法思想</h3>
<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个典型的应用。它的基本操作是：将已有的有序子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p>归并排序其实要做两件事：</p>
<ul>
<li>分解&mdash;-将序列每次折半拆分</li>
<li>合并&mdash;-将划分后的序列段两两排序合并</li>
</ul>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<p><strong>如何分解？</strong></p>
<p>在这里，我们采用递归的方法，首先将待排序列分成 A、B 两组；然后重复对 A、B 序列分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<p><strong>如何合并？</strong></p>
<p>$L[first \dots mid]$ 为第一段，$L[mid+1 \dots last]$ 为第二段，并且两端已经有序，现在我们要将两端合成达到 $[first \dots last]$ 并且也有序。</p>
<ol>
<li>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给 $temp[]$</li>
<li>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给 $temp[]$</li>
<li>此时将 $temp[]$ 中的元素复制给 $L[]$，则得到的 $L[first \dots last]$ 有序</li>
</ol>
<h3 id="代码实现-6">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#---------------- 归并排序 -------------------</span>
<span class="c1">#*********** 合并函数 **************</span>
<span class="k">def</span> <span class="nf">mergearray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="c1"># 当左右两边都有数时进行比较，取较小的数</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># 如果左边序列还有数</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">):</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># 如果右边序列还有数</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">):</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># 将temp当中该段有序元素赋值给 L 待排序序列使之部分有序</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">L</span><span class="p">[</span><span class="n">first</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="c1">#************ 分组函数 *************</span>
<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">first</span> <span class="o">+</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># 使左边序列有序</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
        <span class="c1"># 使右边序列有序</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
        <span class="c1"># 将两个有序序列合并</span>
        <span class="n">mergearray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

<span class="c1">#************ 归并排序 **************</span>
<span class="k">def</span> <span class="nf">merge_sort_array</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 声明一个长度为len(L)的空列表</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="n">merge_sort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="基数排序">基数排序</h2>
<h3 id="算法思想-5">算法思想</h3>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串 (比如名字或日期) 和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>通过序列中各个元素的值，对排序的 $N$ 个元素进行若干趟的<code>分配</code>与<code>收集</code>来实现排序。</p>
<ul>
<li>分配：我们将 $L[i]$ 中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li>
<li>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列 $L[]$</li>
<li>对新形成的序列 $L[]$ 重复执行分配和收集元素中的十位、百位&hellip;直到分配完该序列中的最高位，则排序结束</li>
</ul>
<h3 id="代码实现-7">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#------------------- 基数排序 --------------------</span>
<span class="c1"># 确定排序的趟数</span>
<span class="c1"># 排序的顺序跟序列中最大数的位数相关</span>
<span class="k">def</span> <span class="nf">radix_sort_nums</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">maxNum</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># 寻找序列中的最大数</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">maxNum</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">maxNum</span> <span class="o">=</span> <span class="n">x</span>
    <span class="c1"># 确定序列中最大元素的位数</span>
    <span class="n">times</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="n">maxNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">maxNum</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">maxNum</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">times</span>

<span class="c1"># 找到num从低到高第 pos 位的数据</span>
<span class="k">def</span> <span class="nf">get_num_pos</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="nb">int</span><span class="p">)(</span><span class="n">num</span><span class="o">/</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span><span class="o">%</span><span class="mi">10</span>

<span class="c1"># 基数排序</span>
<span class="k">def</span> <span class="nf">radix_sort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># 存放各个桶的数据统计值</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="c1"># 暂时存放排序结果</span>
    <span class="n">bucket</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="c1"># 从低位到高位依次循环</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">radix_sort_nums</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># 置空各个桶的数据统计值</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 统计当前位数（个位，十位，百位...）的元素数目</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
            <span class="c1"># 统计各个桶将要装进去的元素个数</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">get_num_pos</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># count[i] 表示第 i 个桶的右边界索引</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 将数据依次装入桶中</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 求出元素第 k 位的数字</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">get_num_pos</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">pos</span><span class="p">)</span>
            <span class="c1"># 放入对应的桶中，count[j]-1 是第 j 个桶的右边界索引</span>
            <span class="n">bucket</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="c1"># 对应桶的装入数据索引 -1</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">765PRO.P</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2018-07-19
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://k-on.me/tags/%E6%8E%92%E5%BA%8F/">排序</a>
          <a href="https://k-on.me/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">直接插入排序</a>
          <a href="https://k-on.me/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">希尔排序</a>
          <a href="https://k-on.me/tags/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">简单选择排序</a>
          <a href="https://k-on.me/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a>
          <a href="https://k-on.me/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
          <a href="https://k-on.me/tags/%E5%BF%AB%E6%8E%92/">快排</a>
          <a href="https://k-on.me/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>
          <a href="https://k-on.me/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">基数排序</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/leetcode-204/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">LeetCode 204. Count Primes</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">
            <span class="next-text nav-default">分治算法</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="pro-765@qq.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/yz1509" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://k-on.me/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        765PRO.P
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>



  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>









  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
