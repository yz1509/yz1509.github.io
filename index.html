<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="兔子和阿铁">
<meta property="og:url" content="https://yz1509.github.io/index.html">
<meta property="og:site_name" content="兔子和阿铁">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兔子和阿铁">

<link rel="canonical" href="https://yz1509.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>兔子和阿铁</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">兔子和阿铁</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">旅の途中</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/76da14fe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/76da14fe/" class="post-title-link" itemprop="url">Redis Streams</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-16 17:50:09 / 修改时间：17:51:38" itemprop="dateCreated datePublished" datetime="2019-10-16T17:50:09+08:00">2019-10-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整理自 <a href="http://antirez.com/news/114" target="_blank" rel="noopener">Streams: a new general purpose data structure in Redis</a>、<a href="http://antirez.com/news/116" target="_blank" rel="noopener">An update on Redis Streams development</a>、<a href="http://antirez.com/news/128" target="_blank" rel="noopener">Redis streams as a pure data structure</a> 和 <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">Introduction to Redis Streams</a> 。</p>
<h1 id="什么是-redis-streams">什么是 Redis Streams</h1>
<p>本质上是一个抽象日志：</p>
<ul>
<li>日志中的每条记录是结构化、可扩展的 <code>&lt;field, value&gt;</code> 对</li>
<li>支持范围查询和指定读取</li>
<li>每条记录在日志中有唯一标识，标识中包含了单调递增的时间戳信息</li>
<li>日志可以根据需要自动清理历史记录</li>
<li>日志保存在内存中，但是也支持持久化</li>
</ul>
<p>和其他可模拟消息队列的数据类型 (List, Pub/Sub, Zset) 对比：</p>
<table>
<colgroup>
<col style="width: 60%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>List, Pub/Sub, Zset</th>
<th>Redis Streams</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>List 不能从中间获取成员，<span class="math inline">\(O(N)\)</span></td>
<td>可以从中间获取成员，<span class="math inline">\(O(logN)\)</span></td>
</tr>
<tr class="even">
<td>no fan-out is possible, blocking operations on list serve a single element to a single client</td>
<td>可以多个 clients 使用 XREAD blocking for new message</td>
</tr>
<tr class="odd">
<td>List 中没有标识符的概念</td>
<td>每条 msg 都有一个唯一的 id</td>
</tr>
<tr class="even">
<td>Pub/Sub 无法保留历史消息，只能获取连接之后的消息，不支持范围查询</td>
<td>可以保存在 AOF 和 RDB 中</td>
</tr>
<tr class="odd">
<td>Pub/Sub 没有 consumer group 的概念</td>
<td>有 consumer group，更贴近真实的业务场景</td>
</tr>
<tr class="even">
<td>Pub/Sub 的性能和订阅某个频道的 client 数量正相关</td>
<td>不存在</td>
</tr>
<tr class="odd">
<td>Zset 不允许添加重复成员，不支持成员淘汰和 block 新消息操作，内存开销大</td>
<td>允许，支持按时间线来淘汰历史数据，支持 block 操作，基于 redix tree 和 listpack，内存开销低</td>
</tr>
<tr class="even">
<td>Zset 支持删除任意元素</td>
<td>不支持从中间删除元素 (log属性)，more compact and memory efficient</td>
</tr>
</tbody>
</table>
<h1 id="redis-streams-结构">Redis Streams 结构</h1>
<figure class="highlight plain"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">| key | Entry1 |--| Entry2 |--| ...... |--| EntryN |</span><br><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">      :        :       </span><br><span class="line">+-----+        +-------------------------------------------+</span><br><span class="line">|                                                          |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| ID | field1 | value1 | field2 | value3 | ...... | ...... |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">:    : </span><br><span class="line">|    +-------------------------------+ </span><br><span class="line">|                                    |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| millisecond time | sequence number |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>在每个 streams 中含有多个 entry(message)</li>
<li>每个 entry 有一唯一的 ID，并且可包含多个 <code>&lt;filed, value&gt;</code> 对
<ul>
<li>添加连续的 entry，如果使用相同的 field name 可以节省内存</li>
</ul></li>
<li>ID 由 millisecond time(64bit) 和 sequence number(64bit) 两部分组成
<ul>
<li>其中，millisecond time 取当前时间戳和上一条插入 streams 的 entry 的时间戳之间的较大值，保证单调性</li>
</ul></li>
</ul>
<h1 id="redis-streams-api">Redis Streams API</h1>
<h2 id="xadd">XADD</h2>
<p><code>XADD key [MAXLEN [~] number] ID field string [field string ...]</code></p>
<p>Appends a new entry into the specified streams.</p>
<ul>
<li>ID 为 <code>*</code> 表示让 Redis 自动生成 ID</li>
<li>如果指定消息 ID，为了维持单调递增性，后面指令的 ID 必须大于之前指令的 ID</li>
<li>可以指定 streams 的 <code>MAXLEN</code>，此时 streams 类似于一个固定大小的队列</li>
<li>添加 <code>~</code> 表示并不严格要求 <code>MAXLEN=number</code></li>
</ul>
<h2 id="xrange-xrevrange">XRANGE / XREVRANGE</h2>
<p><code>XRANGE key start end [COUNT count]</code></p>
<ul>
<li>返回结果包含 start ID 和 end ID，即闭区间</li>
<li><code>-</code> 和 <code>+</code> 分别表示最小和最大 ID</li>
<li>start ID 和 end ID 可以省略 sequenceNumber 部分，此时 start ID 默认 sequenceNumber = 0，而 end ID 默认 sequenceNumber 为最大值</li>
<li>可以添加 <code>COUNT</code> 参数，实现类似 <code>scan</code> 操作</li>
</ul>
<p><code>XREVRANGE key end start [COUNT count]</code></p>
<ul>
<li>逆序返回结果，使用方法类似 <code>XRANGE</code></li>
</ul>
<h2 id="xread-blocking-for-new-data">XREAD: blocking for new data</h2>
<p><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></p>
<ul>
<li>ID为 <code>$</code> 表示指定 ID 为流中目前已存的最大 ID</li>
<li>BLOCK 超时时间单位为 ms，超时时间为 0 时表示不会超时</li>
<li>当有多个 client BLOCK 等待新 msg 时，排队方式为 FIFO</li>
</ul>
<h2 id="xlen">XLEN</h2>
<p><code>XLEN key</code></p>
<p>查看指定流中的 entry 个数，one ID one entry.</p>
<h1 id="consumer-groups">Consumer groups</h1>
<p>一个 consumer group 就像一个 pseudo consumer 一样从 streams 中获取数据，它有如下特点：</p>
<ul>
<li>同一消息不可能传递给多个 consumer</li>
<li>在 consumer group 中由 consumer(client) 自身提供 name 来进行区分</li>
<li>每个 consumer group 保存了目前尚未分发的第一条消息的 ID (即，偏移量)，据此，当 consumer 请求消费时， consumer group 保证不会将先前已分发的消息发送给该 consumer</li>
<li>消费消息需要显式地 ACK 机制，只有当该消息确认被处理，才会从 consumer group 的消息队列中删除</li>
<li>Consumer group 记录当前所有的未决消息的信息，因此保证了 consumer 在中断重连后只能重新获取之前自身未 ACK 的消息</li>
</ul>
<p>一个 consumer group 状态的示例如下:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| consumer_group_name: mygroup             |</span><br><span class="line">| consumer_group_stream: somekey           |</span><br><span class="line">| last_delivered_id: <span class="number">1292309234234</span><span class="number">-92</span>      |     </span><br><span class="line">|                                          |                                   </span><br><span class="line">| consumers:                               |</span><br><span class="line">|     <span class="string">"consumer-1"</span> <span class="keyword">with</span> pending messages   |</span><br><span class="line">|        <span class="number">1292309234234</span><span class="number">-4</span>                   |</span><br><span class="line">|        <span class="number">1292309234232</span><span class="number">-8</span>                   | </span><br><span class="line">|     <span class="string">"consumer-42"</span> <span class="keyword">with</span> pending messages  |</span><br><span class="line">|       ... (<span class="keyword">and</span> so forth)                 |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="xgroup">XGROUP</h2>
<p>创建、销毁和管理 consumer group</p>
<ul>
<li><code>XGROUP CREATE key groupname id-or-$</code>
<ul>
<li>目前尚不支持从一个未存在的 streams 上创建 consumer group</li>
</ul></li>
<li><code>XGROUP SETID key groupname id-or-$</code></li>
<li><code>XGROUP DESTROY key groupname</code></li>
<li><code>XGROUP DELCONSUMER key groupname consumername</code></li>
</ul>
<h2 id="xreadgroup">XREADGROUP</h2>
<p>通过 consumer group 的方式从 streams 中读取数据</p>
<p><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code> * 首次出现的 consumer 将自动加入 consumer group，无需显式声明 * ID 为 <code>&gt;</code> 表示请求尚未分发给其他 consumer 的新消息 * ID 为其他有效的数字 ID 表示请求自身尚未 ACK 的 pending messages</p>
<h2 id="xack">XACK</h2>
<p>将一个未决消息标记为已处理</p>
<p><code>XACK key group ID [ID ...]</code></p>
<h2 id="xpending">XPENDING</h2>
<p>返回 consumer group 中的 pending messages 相关信息</p>
<p><code>XPENDING key group [start end count] [consumer]</code></p>
<h2 id="xclaim">XCLAIM</h2>
<p>将满足条件的 pending messages 重分配</p>
<p><code>XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]</code></p>
<p>全部 consumer group 命令可查看<a href="https://redis.io/commands/xack" target="_blank" rel="noopener">相关页面</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/33be3840/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/33be3840/" class="post-title-link" itemprop="url">Chord</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-15 14:45:23 / 修改时间：20:53:30" itemprop="dateCreated datePublished" datetime="2019-10-15T14:45:23+08:00">2019-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/现在英语怎么样-过托福没-可以看论文吗/" itemprop="url" rel="index">
                    <span itemprop="name">现在英语怎么样 过托福没 可以看论文吗</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://www.falleneth.com/cmuj/papers/chord.pdf" target="_blank" rel="noopener">论文地址</a></p>
<h1 id="whydunit">Whydunit</h1>
<h1 id="whodunit">Whodunit</h1>
<h1 id="howdunit">Howdunit</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/affa099c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/affa099c/" class="post-title-link" itemprop="url">Consistent Hashing</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 21:26:09" itemprop="dateCreated datePublished" datetime="2019-10-12T21:26:09+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-15 20:43:43" itemprop="dateModified" datetime="2019-10-15T20:43:43+08:00">2019-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/现在英语怎么样-过托福没-可以看论文吗/" itemprop="url" rel="index">
                    <span itemprop="name">现在英语怎么样 过托福没 可以看论文吗</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://david.choffnes.com/classes/cs4700sp14/papers/akamai.pdf" target="_blank" rel="noopener">论文地址</a></p>
<h1 id="whydunit">Whydunit</h1>
<p>当大量的客户端同时对单个服务器发起请求时，可能会使该服务器(Hot spots) "swamped" （无法使用）。除此之外，还可能会阻塞该服务附近的网络通信。所以我们需要一个负载均衡算法来有效地避免 Hot spots 的出现。</p>
<h1 id="whodunit">Whodunit</h1>
<h2 id="proxy-cache">Proxy cache</h2>
<p>使用 proxy 缓存经常被请求的数据，多个客户端共享一个 proxy cache。</p>
<ol type="1">
<li>所有用户的请求都发往 proxy</li>
<li>未命中时，proxy 会把该请求转发至 home server。</li>
</ol>
<p><strong>缺点</strong>：proxy 本身可能会 swamped</p>
<h2 id="a-group-of-caches-functions-as-one">A group of caches functions as one</h2>
<ol type="1">
<li>用户的请求发往任意一个 cache</li>
<li>未命中时，使用 IP Multicast 将该请求转发至所有其他的 cache</li>
<li>未命中时，将该请求转发至 heme server</li>
</ol>
<p><strong>缺点</strong>：cache 之间的通信消息数量不可控</p>
<h2 id="harvest-cache">Harvest Cache</h2>
<p>使用树型结构的 cache，root 为 home server</p>
<ol type="1">
<li>用户的请求发往邻近的叶节点</li>
<li>未命中时，将该请求转发至兄弟节点(siblings)</li>
<li>未命中时，将该请求转发至父节点(parent)</li>
</ol>
<p><strong>优点</strong>：保证了请求只会来自于子节点或兄弟节点</p>
<p><strong>缺点</strong>：当所有不同请求同时到来时，至少会有一个请求会到达 root，因此这只是一个缩放的结构，root 无法避免 swamped 的命运</p>
<h2 id="using-randomization-and-hashing">Using randomization and hashing</h2>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.877&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Plaxton and Rajaraman</a></p>
<p>新增一组 virtual cache 集合层，通过 random hash function 在现有的 Caches 和 virtual cache 集合之间建立映射，用户的请求发往任一 virtual cache 集合。如果 virtual cache 集合的负载超过阈值，则创建一个更大的 virtual cache 集合。</p>
<p><strong>优点</strong>：请求响应快，因为每个 cache 的负载都在可控范围；负载均衡。</p>
<p><strong>缺点</strong>：由于用户的请求发往任一 virtual cache 集合，故小规模的 virtual cache 集合可能会 swamped。</p>
<h2 id="random-cache-trees">Random cache trees</h2>
<p>下次一定看！</p>
<h2 id="consistent-hashing">Consistent hashing</h2>
<p>传统 hashing 的局限： * 假定节点数是固定的 * 每个节点需要知道全局信息，使用消息进行同步时，由于延时的存在，节点所保存的全局信息正确性无法保证</p>
<p>Consistent hashing 如何解决这两个问题，将于下文详述。</p>
<h1 id="howdunit">Howdunit</h1>
<h2 id="符号说明">符号说明</h2>
<ul>
<li><span class="math inline">\(\mathcal{I}\)</span>: set of items，数据</li>
<li><span class="math inline">\(i\)</span>: is an item</li>
<li><span class="math inline">\(\mathcal{B}\)</span>: set of buckets，类似于 proxy chche</li>
<li><span class="math inline">\(b\)</span>: is a bucket</li>
<li><em>view</em>: any subset of the buckets <span class="math inline">\(\mathcal{B}\)</span>，模拟节点的增加与删除</li>
<li><em>ranged hash function</em> <span class="math inline">\(f\)</span>: <span class="math inline">\(2^{\mathcal{B}} \times \mathcal{I} \rightarrowtail \mathcal{B}\)</span>
<ul>
<li><span class="math inline">\(f(\mathcal{V}, i)\)</span> or <span class="math inline">\(f_{\mathcal{V}}(i)\)</span> is the bucket to which item <span class="math inline">\(i\)</span> is assigned in view <span class="math inline">\(\mathcal{V}\)</span></li>
<li>Require: <span class="math inline">\(f_{\mathcal{V}}(\mathcal{I}) \subseteq \mathcal{V}\)</span> for every view <span class="math inline">\(\mathcal{V}\)</span></li>
</ul></li>
<li><em>ranged hash family</em> <span class="math inline">\(\mathcal{F}\)</span>: is a family of ranged hash functions</li>
<li><em>random ranged hash function</em>: is a function drawn at random from a particular ranged hash family</li>
</ul>
<h2 id="一致性哈希函数应满足的性质介绍">一致性哈希函数应满足的性质介绍</h2>
<ol type="1">
<li><p>Balance</p>
<p>A ranged hash family is <em>balanced</em> if, given a particular view <span class="math inline">\(\mathcal{V}\)</span>, a set of items,and a randomly chosen function selected from the hash family, with high probability the fraction of items mapped to each bucket is <span class="math inline">\(O(1/|V|)\)</span>.</p></li>
<li><p>Monotonicity</p>
<ul>
<li>A ranged hash function <span class="math inline">\(f\)</span> is <em>monotone</em> if for all views <span class="math inline">\(\mathcal{V}_1 \subseteq \mathcal{V}_2 \subseteq \mathcal{B}, f_{\mathcal{V}_2}(i) \in \mathcal{V}_1\)</span> implies <span class="math inline">\(f_{\mathcal{V}_1}(i) = f_{\mathcal{V}_2}(i)\)</span>.</li>
<li>A ranged hash family is <em>monotone</em> if every ranged hash function in it is.</li>
</ul>
<p>单调性保证了：如果新增了一个节点，只会有将之前的数据迁移到新节点的操作，而不会有旧节点之间互相迁移的操作。</p></li>
<li><p>Spread</p>
<p>Let <span class="math inline">\(\mathcal{V}_1 \dots \mathcal{V}_{|V|}\)</span> be a set of views, altogether containing <span class="math inline">\(C\)</span> distinct buckets and each individually containing at least <span class="math inline">\(C/t\)</span> buckets.</p>
<ul>
<li>For a ranged hash function and a particular item <span class="math inline">\(i\)</span>, the <em>spread</em> <span class="math inline">\(\sigma(i)\)</span> = <span class="math inline">\(|\{f_{\mathcal{V}_j}(i)\}^{|V|}_{j=1}|\)</span>.</li>
<li>The <em>spread</em> of a hash function <span class="math inline">\(\sigma(f)\)</span> is the maximum spread of an item.</li>
<li>The <em>spread</em> of a hash family is <span class="math inline">\(\sigma\)</span> if with high probability, the spread of a random hash function from the family is <span class="math inline">\(\sigma\)</span>.</li>
</ul>
<p>Spread 大致意思是指，一个 item 在不同的 view 下会被分配到的 bucket 所组成集合的大小，其越小说明在节点数量发生变化时，需要做的数据迁移操作越少。</p></li>
<li><p>Load</p>
<p>Define a set of <span class="math inline">\(|V|\)</span> views as before.</p>
<ul>
<li>For a ranged hash function <span class="math inline">\(f\)</span> and bucket <span class="math inline">\(b\)</span>, the <em>load</em> <span class="math inline">\(\lambda(b) = |\cup_{\mathcal{V}}f^{-1}_{\mathcal{V}}(b)|\)</span>. (Note that <span class="math inline">\(f^{-1}_{\mathcal{V}}(b)\)</span>) is the set of items assigned to bucket <span class="math inline">\(b\)</span> in view <span class="math inline">\(\mathcal{V}\)</span>)</li>
<li>The <em>load</em> of a hash function <span class="math inline">\(\lambda(f)\)</span> is the maximum load of a bucket.</li>
<li>The <em>load</em> of a hash family is <span class="math inline">\(\lambda\)</span> if with high probability, a randomly chosen hash function has load <span class="math inline">\(\lambda\)</span>.</li>
</ul>
<p>Load 大致意思是指， 一个 bucket 在不同的 view 下所包含的 items 集合的并集的大小，其具有上界保证了在不同的节点总数情况下，不会出现单个节点需要储存过多的数据的现象。</p></li>
</ol>
<h2 id="构造一致性哈希函数">构造一致性哈希函数</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/18e84d53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/18e84d53/" class="post-title-link" itemprop="url">Redis 源码之 sds</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-12 20:10:31 / 修改时间：20:25:08" itemprop="dateCreated datePublished" datetime="2019-10-12T20:10:31+08:00">2019-10-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>源码文件 <code>/src/sds.h</code> &amp; <code>sdsalloc.h</code> &amp; <code>/src/sds.c</code></p>
<h1 id="sds-数据结构">sds 数据结构</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------- sds 的头部结构 -------------------------------</span></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出来，sds 本质还是 C 风格字符串，但是由于不需用 <code>\0</code> 作为结尾标志，所以 sds 是二进制安全的，但是为了兼容 C 风格字符串， sds 也以终止字符 <code>\0</code> 结尾，所以 sds 可以直接重用一部分 C 字符串函数库里面的函数。关于 sds 的头部结构，作者定义了四种不同类型的 sdshdr 供程序使用，区别只是存储 <code>len</code> 和 <code>alloc</code> 使用的整型长度不同，目的应该是为了节省内存。</p>
<p>四种不同类型的 sdshdr 结构一致，主要包括以下几个部分：</p>
<ul>
<li><code>len</code>：存储 <code>buf</code> 数组的长度，不包括终止字符 <code>\0</code></li>
<li><code>alloc</code>：<code>buf</code> 数组的容量大小</li>
<li><code>flags</code>：sdshdr 的类型</li>
</ul>
<p><em>Tips:</em> <code>__attribute__ ((__packed__))</code> 的作用就是告诉编译器取消结构体在编译过程中的优化对齐，以紧凑模式来分配内存。按照实际占用字节数进行对齐，是 GCC 特有的语法。这个功能是跟操作系统没关系，跟编译器有关。</p>
<p><em>Tips:</em> 在上述结构体定义中，字符数组 <code>buf</code> 的长度为 0，不占用额外的内存空间，<code>buf</code> 实际指向的是结构体之后的内存空间，如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个 <code>buf</code> 的内容，也可用此类特性实现 C 语言变长数组。</p>
<h1 id="辅助函数">辅助函数</h1>
<p>重申：长度 ≠ 容量</p>
<h2 id="获取字符数组-buf-的长度-len">获取字符数组 <code>buf</code> 的长度 <code>len</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同 sdshdr 的类型码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="comment">// 用于 sdshdr 的位运算常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="comment">// 得到 sdshdr 的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 flags 的值</span></span><br><span class="line">    <span class="comment">// 由于结构体定义使用紧凑模式，所以 s 所指的地址紧接在存储 flags 的地址之后</span></span><br><span class="line">    <span class="comment">// 从而 s[-1] 的内容即为 flags，注意不要和 Python 中的 -1 混淆</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Tips:</em> 宏定义中的 <code>##</code> 为符号连接操作符。</p>
<h2 id="获取-buf-数组中的剩余可用空间大小">获取 <code>buf</code> 数组中的剩余可用空间大小</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处使用 <code>SDS_HDR_VAR</code> 而不使用 <code>return SDS_HDR(T,s)-&gt;alloc - SDS_HDR(T,s)-&gt;len;</code> 的原因可能如下：</p>
<ul>
<li>为了代码好看</li>
<li>可以少计算一次</li>
</ul>
<p>而 <code>SDS_HDR_VAR</code> 的宏定义最后的分号其实可以去掉，<a href="https://wiki.sei.cmu.edu/confluence/display/c/PRE11-C.+Do+not+conclude+macro+definitions+with+a+semicolon" target="_blank" rel="noopener">详情请见</a></p>
<h2 id="设置-buf-数组的长度-len">设置 <code>buf</code> 数组的长度 <code>len</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取存储 flags 的地址</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 低 3 位存 type，高 5 位存长度</span></span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加-buf-数组的长度-len">增加 <code>buf</code> 数组的长度 <code>len</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newlen = len + inc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, <span class="keyword">size_t</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> newlen = SDS_TYPE_5_LEN(flags)+inc;</span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有获取/设置 <code>buf</code> 数组的容量 <code>alloc</code> 的函数，函数逻辑一致便不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="comment">// 设置 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>Tips</em> 关于 <code>static inline</code></p>
<ul>
<li><code>inline</code> 的作用仅仅是建议编译器做内联开展处理，而不是强制。内联函数（inline）可以减少 CPU 的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数。通常，程序执行时，处理器从内存中读取代码执行。当程序中调用一个函数时，程序跳到存储器中保存函数的位置，开始读取代码执行，执行完后再返回。为了提高速度，C 语言定义了 <code>inline</code> 函数，告诉编译器把函数代码在编译时直接拷贝到程序中，这样就不用执行时另外读取函数代码。</li>
<li><code>static</code> 告诉编译器其他文件看不到这个函数，因此该函数只能在当前文件中被调用。</li>
</ul>
<h1 id="sds-基本操作">sds 基本操作</h1>
<h2 id="构造函数">构造函数</h2>
<ol type="1">
<li><p><code>sdsnewlen</code></p>
<p>根据指针 <code>init</code> 和长度 <code>initlen</code> 构造一个 sds。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;   <span class="comment">// 头部指针</span></span><br><span class="line">    sds s;      <span class="comment">// 存储返回值</span></span><br><span class="line">    <span class="comment">/* static inline char sdsReqType(size_t string_size)</span></span><br><span class="line"><span class="comment">    * 根据字符串长度选择合适的 sdshdr 类型 */</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">    * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">/* static inline int sdsHdrSize(char type)</span></span><br><span class="line"><span class="comment">    * 根据 type 返回 sdshdr 的存储空间大小 */</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* #define s_malloc zmalloc</span></span><br><span class="line"><span class="comment">    * + 1 是为了存储 \0 */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* const char *SDS_NOINIT = "SDS_NOINIT";</span></span><br><span class="line"><span class="comment">    * If SDS_NOINIT is used, the buffer is left uninitialized; */</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 填充 sdshdr 中的 len、alloc、flags</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);   <span class="comment">// 填充 buf 字符数组的内容</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;  <span class="comment">// 填充终止字符 \0</span></span><br><span class="line">    <span class="keyword">return</span> s;   <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现生成的 sds 中有：<span class="math inline">\(len = alloc = initlen\)</span></p></li>
<li><p><code>sdsempty</code></p>
<p>构造一个空的 sds，可以看出 <code>buf</code> 数组长度即使为 0，该 sds 也包含 <code>\0</code>。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsnew</code></p>
<p>根据一个 C 风格字符串构造一个 sds 。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsdup</code></p>
<p>复制一个 sds 。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsfromlonglong</code></p>
<p>将一个 <code>long long</code> 类型转换为 sds，该操作比直接调用 <code>sdscatprintf(sdsempty(),"%lld\n", value);</code> 高效得多。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// #define SDS_LLSTR_SIZE 21</span></span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">    <span class="comment">/* int sdsll2str(char *s, long long value)</span></span><br><span class="line"><span class="comment">    * The function returns the length of the null-terminated string </span></span><br><span class="line"><span class="comment">            representation stored at 's'.</span></span><br><span class="line"><span class="comment">    * 's' must point to a string with room for at least </span></span><br><span class="line"><span class="comment">            SDS_LLSTR_SIZE bytes. */</span></span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="析构函数请不要沉迷-c">析构函数（请不要沉迷 C++</h2>
<ol type="1">
<li><p><code>sdsclear</code> —— 虚假的析构函数</p>
<p>将 <code>buf</code> 数组长度设置为 0，但是可以发现并未调用 <code>free</code>，而是将其设置为空闲空间。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsfree</code> —— 真实的析构函数</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* #define s_free zfree</span></span><br><span class="line"><span class="comment">    * (char*)s-sdsHdrSize(s[-1]) —— sds 头部的起始地址 */</span></span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>])); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="动态调整函数">动态调整函数</h2>
<ol type="1">
<li><p><code>sdsMakeRoomFor</code> —— 扩容</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;   <span class="comment">// 旧、新的头指针</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 剩余可用空间大小</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen; </span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen; <span class="comment">// 存储新的头部长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);    <span class="comment">// buf 数组目前长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">// 旧的头指针</span></span><br><span class="line">    newlen = (len+addlen);  <span class="comment">// buf 数组将来长度</span></span><br><span class="line">    <span class="comment">/* #define SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class="line"><span class="comment">    * 扩容策略：如果 buf 数组将来长度小于 1 M，按两倍给你扩容，大气</span></span><br><span class="line"><span class="comment">    *          如果 buf 数组将来长度不小于 1 M，比要求多给你扩 1 M，精打细算 */</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newtype (NT 新人类，大雾)</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">    * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">    * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);  <span class="comment">// 新的头部长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;    <span class="comment">// 不需要更改头部的 len 和 flags，直接扩充 buf 数组的容量</span></span><br><span class="line">        <span class="comment">// #define s_realloc zrealloc</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">        * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 申请新的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// len + 1，\0 也被复制</span></span><br><span class="line">        s_free(sh); <span class="comment">// 释放旧空间</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;    <span class="comment">// 更新 buf 数组首地址</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;   <span class="comment">// 更新 flags</span></span><br><span class="line">        sdssetlen(s, len);  <span class="comment">// 设置 len，大小没变</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen); <span class="comment">// 更新 alloc</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现该函数仅在当前剩余可用空间不足时进行扩容，采取的扩容策略类似 <code>vector</code>，可以在尽可能不浪费内存空间的基础上减少扩容操作的次数。当然扩容并不会改变 <code>buf</code> 数组的长度 <code>len</code>。</p></li>
<li><p><code>sdsRemoveFreeSpace</code> —— 回收空闲空间</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">    * fit this string. */</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">    * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">    * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">    * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的基本流程和扩容操作类似，可以看出仅仅在旧的头部结构不为 <code>sdshdr8</code> 且新的头部结构为 <code>sdshdr8</code> 时，才会重新申请新的内存空间，不然只是在旧的 sds 基础上调用 <code>zrealloc</code> 调整 <code>buf</code> 数组的容量，使得 <span class="math inline">\(alloc = len\)</span> 成立。</p>
<p>注意调用 <code>sdsRemoveFreeSpace</code> 成功返回后，原指针可能会失效，请使用返回的新指针。</p></li>
<li><p><code>sdsIncrLen</code> —— 调整长度</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span> </span>&#123;  <span class="comment">// typedef long long ssize_t</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">// fp 指向存储 flags 的地址</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> oldlen = SDS_TYPE_5_LEN(flags);</span><br><span class="line">            <span class="comment">/* 增长时需确保剩余可用空间大小充足</span></span><br><span class="line"><span class="comment">            * 缩短时需确保减少量不得超过现有长度 */</span></span><br><span class="line">            assert((incr &gt; <span class="number">0</span> &amp;&amp; oldlen+incr &lt; <span class="number">32</span>) || (incr &lt; <span class="number">0</span> &amp;&amp; oldlen &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            *fp = SDS_TYPE_5 | ((oldlen+incr) &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            len = oldlen+incr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: len = <span class="number">0</span>; <span class="comment">/* Just to avoid compilation warnings. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;  <span class="comment">// 设置终止字符 '\0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，变量 <code>incr</code> 可正可负，所以在满足条件的基础上长度可增可减。</p></li>
</ol>
<h2 id="append-操作">Append 操作</h2>
<ol type="1">
<li><p><code>sdsgrowzero</code></p>
<p>将 <code>buf</code> 的数组长度增长到给定的 <code>len</code>，如果 <span class="math inline">\(len &lt; currentLen\)</span>，则什么都不做。新增的字节部分，每一位都置为 0。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscatlen</code></p>
<p>将二进制安全的字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<ul>
<li><code>t</code>：附加字符串首位地址</li>
<li><code>len</code>：附加字符串长度</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscat</code></p>
<p>将 C 风格字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscatsds</code></p>
<p>拼接两个 sds，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscatvprintf</code></p>
<p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>], *buf = staticbuf, *t;</span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try to start using a static buffer for speed.</span></span><br><span class="line"><span class="comment">    * If not possible we revert to heap allocation. */</span></span><br><span class="line">    <span class="keyword">if</span> (buflen &gt; <span class="keyword">sizeof</span>(staticbuf)) &#123;</span><br><span class="line">        buf = s_malloc(buflen);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try with buffers two times bigger every time we fail to</span></span><br><span class="line"><span class="comment">    * fit the string in the current buffer size. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置哨兵，测试格式化字符串是否已全部写入 buf 中</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">/* void va_copy(va_list dest, va_list src);</span></span><br><span class="line"><span class="comment">        * The va_copy macro copies src to dest. */</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">/* int vsnprintf( char *restrict buffer, size_t bufsz, </span></span><br><span class="line"><span class="comment">                const char *restrict format, va_list vlist );</span></span><br><span class="line"><span class="comment">        * writes the results to a character string buffer. At most buflen - 1 </span></span><br><span class="line"><span class="comment">                characters are written </span></span><br><span class="line"><span class="comment">        * The resulting character string will be terminated with a </span></span><br><span class="line"><span class="comment">                null character, unless buflen is zero. */</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">/* void va_end(va_list ap);</span></span><br><span class="line"><span class="comment">        * The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy */</span></span><br><span class="line">        va_end(cpy);</span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;    <span class="comment">// 当前 buf 不够长！</span></span><br><span class="line">            <span class="keyword">if</span> (buf != staticbuf) s_free(buf);  </span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            buf = s_malloc(buflen);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 格式化字符串已全部写入 buf</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally concat the obtained string to the SDS string and return it. */</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    <span class="keyword">if</span> (buf != staticbuf) s_free(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于不知晓格式化字符串的长度，所以我们需要使用一个 <code>while</code> 循环来测试当前分配的 <code>buf</code> 字符数组的容量是否可以容纳该格式化字符串，每次失败时，我们将 <code>buf</code> 的容量翻倍。</p></li>
<li><p><code>sdscatprintf</code></p>
<p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    <span class="comment">/* void va_start(va_list ap, parmN);</span></span><br><span class="line"><span class="comment">    * The va_start macro enables access to the variable arguments following </span></span><br><span class="line"><span class="comment">            the named argument parmN. */</span></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscatfmt</code></p>
<p>将格式化字符串拼接到 sds 之后，但是比 <code>sdscatprintf</code> 更快，但是其支持以下几种格式化字符串：</p>
<ul>
<li><code>%s</code> - C String</li>
<li><code>%S</code> - SDS string</li>
<li><code>%i</code> - signed int</li>
<li><code>%I</code> - 64 bit signed integer (long long, int64_t)</li>
<li><code>%u</code> - unsigned int</li>
<li><code>%U</code> - 64 bit unsigned integer (unsigned long long, uint64_t)</li>
<li><code>%%</code> - Verbatim "%" character.</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscatrepr</code></p>
<p>将无法打印显式字符的字符数组的转义形式 (eg, "..." or "&lt;hex-number&gt;") 拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="拷贝操作">拷贝操作</h2>
<ol type="1">
<li><p><code>sdscpylen</code></p>
<p>丢弃 sds 字符数组中的原内容，将长为 <code>len</code> 的字符串拷贝至 sds 的 <code>buf</code> 中。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdsalloc(s) &lt; len) &#123;    <span class="comment">// 容量不足，扩容</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sdslen(s));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscpy</code></p>
<p>丢弃 sds 字符数组中的原内容，将 C 风格字符串拷贝至 sds 的 <code>buf</code> 中。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="修剪操作">修剪操作</h2>
<ol type="1">
<li><p><code>sdstrim</code></p>
<p>从 sds 两端开始遍历，出现在 C 风格字符串 cset 中的字符将会被删除。注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;     <span class="comment">// 指向第一个字符</span></span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;   <span class="comment">// 指向终止字符 `\0` 前一字符</span></span><br><span class="line">    <span class="comment">/* char *strchr(const char *str, int ch);</span></span><br><span class="line"><span class="comment">    * Finds the first occurrence of ch (after conversion to char as if </span></span><br><span class="line"><span class="comment">        by (char)ch) in the null-terminated byte string pointed to by str </span></span><br><span class="line"><span class="comment">        (each character interpreted as unsigned char). </span></span><br><span class="line"><span class="comment">    * 从前往后遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 +1 */</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="comment">/* 前一步遍历的终止条件不是越界时有 ep &gt; sp</span></span><br><span class="line"><span class="comment">    * 从后往前遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 -1 */</span></span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    <span class="comment">// 计算修剪后的字符串长度</span></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* void* memmove( void* dest, const void* src, size_t count );</span></span><br><span class="line"><span class="comment">    * Copies count characters from the object pointed to by src to the object </span></span><br><span class="line"><span class="comment">        pointed to by dest*/</span></span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p>
<p>虽然作者提示原指针可能会失效，但是在函数中可以发现返回的就是原指针值，表示疑惑。</p></li>
<li><p><code>sdsrange</code></p>
<p>依据起始和结束索引下标修剪 sds 字符串，注意：</p>
<ul>
<li><code>start</code> 和 <code>end</code> 可以为负数，类似数组的下标索引</li>
<li>结果子串的范围为闭区间 <span class="math inline">\([start, end]\)</span></li>
<li>该操作是就地进行的</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引下标</span></span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;   <span class="comment">// 绝对值大于字符串长度的负数索引值置为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算子串长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">ssize_t</span>)len) &#123;    <span class="comment">// 起始索引值大于等于字符串长度，子串为空</span></span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">ssize_t</span>)len) &#123; <span class="comment">// 结束索引值大于等于字符串长度，置为 len-1</span></span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 因 end 更改，故更新子串长度</span></span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(s, s+start, newlen);</span><br><span class="line">    s[newlen] = <span class="number">0</span>;  <span class="comment">// 等价于 s[newlen] = '\0';</span></span><br><span class="line">    sdssetlen(s,newlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同上，可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p></li>
</ol>
<h2 id="split-操作">split 操作</h2>
<ol type="1">
<li><p><code>sdssplitlen</code></p>
<p>使用长为 <code>seplen</code> 的二进制安全字符串 <code>sep</code> 作为分隔符，将长为 <code>len</code> 的二进制安全字符串 <code>s</code> 分割成 <code>count</code> 个 sds 字符串。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* elements 存放当前 sds 字符串的个数</span></span><br><span class="line"><span class="comment">    * slots 存放当前已分配内存的 sds 指针数组 tokens 的大小 */</span></span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">0</span>, j;</span><br><span class="line">    sds *tokens;    <span class="comment">// sds 指针数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tokens = s_malloc(<span class="keyword">sizeof</span>(sds)*slots);   <span class="comment">// 先搞五个试试</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符串匹配过程</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;     <span class="comment">// 扩容采取倍增策略</span></span><br><span class="line">            newtokens = s_realloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator </span></span><br><span class="line"><span class="comment">        * int memcmp( const void* lhs, const void* rhs, size_t count );</span></span><br><span class="line"><span class="comment">        * Compares the first count characters of the objects pointed to by lhs and rhs*/</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        s_free(tokens);</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsfreesplitres</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    s_free(tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsplitargs</code></p>
<ul>
<li>Split a line into arguments, where every argument can be in the following programming-language REPL-alike form: <code>foo bar "newline are supported\n" and "\xff\x00otherstuff"</code></li>
<li>The number of arguments is stored into *argc, and an array of sds is returned.</li>
<li>The caller should free the resulting array of sds strings with sdsfreesplitres().</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span></span><br></pre></td></tr></table></figure></p>
<p>偷个懒，用到时再看hhhhh</p></li>
</ol>
<h2 id="其他函数">其他函数</h2>
<ol type="1">
<li><p><code>sdsupdatelen</code></p>
<p>更新 sds 的长度 <code>len</code>，由于是调用 <code>strlen</code>，故只统计到终止字符 <code>\0</code>（不包括 <code>\0</code>）</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsAllocSize</code></p>
<p>返回分配内存空间的大小，包括：</p>
<ul>
<li>头部结构体的大小 <code>sdsHdrSize</code></li>
<li><code>buf</code> 数组容量 <code>alloc</code></li>
<li>终止字符 <code>\0</code> 的长度 1</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> alloc = sdsalloc(s);</span><br><span class="line">    <span class="keyword">return</span> sdsHdrSize(s[<span class="number">-1</span>])+alloc+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsAllocPtr</code></p>
<p>返回 sds 头部起始地址。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) (s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdstolower</code></p>
<p>转换为小写</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdstoupper</code></p>
<p>转换为大写</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdscmp</code></p>
<p>使用 <code>memcmp</code> 实现两个 sds 的比较操作</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1&gt;l2? <span class="number">1</span>: (l1&lt;l2? <span class="number">-1</span>: <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsmapchars</code></p>
<p>遍历 sds 字符串，将在字符串 <code>from</code> 中出现的字符替换成 <code>to</code> 中对应位置的字符，<code>setlen</code> 为字符串 <code>from</code> 和 <code>to</code> 的长度。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> j, i, l = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setlen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == from[i]) &#123;</span><br><span class="line">                s[j] = to[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsjoin</code></p>
<p>使用 C 风格字符串 <code>sep</code> 作为分隔符，将 C 风格字符串数组拼接为一个 sds。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sdsjoinsds</code></p>
<p>类似于 <code>sdsjoin</code>，将 sds 字符串数组拼接为一个 sds。值得注意的是，使用的字符串分隔符是二进制安全的，而不是 C 风格字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscatsds(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscatlen(join,sep,seplen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/28a59907/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/28a59907/" class="post-title-link" itemprop="url">Redis 源码之 adlist</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-12 20:08:45 / 修改时间：20:17:27" itemprop="dateCreated datePublished" datetime="2019-10-12T20:08:45+08:00">2019-10-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>源码文件 <code>/src/adlist.h</code> &amp; <code>/src/adlist.c</code></p>
<h1 id="adlist-数据结构">adlist 数据结构</h1>
<p>adlist 其实是一个双向链表，我们首先介绍其链表节点、链表迭代器和链表的数据结构。</p>
<h2 id="链表节点">链表节点</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向前一节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向后一节点</span></span><br><span class="line">    <span class="keyword">void</span> *value;            <span class="comment">// 指向当前节点的值</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<h2 id="链表迭代器">链表迭代器</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;     <span class="comment">// 迭代器当前所指节点，为什么不叫 now ？       </span></span><br><span class="line">    <span class="keyword">int</span> direction;      <span class="comment">// 迭代访问的方向    </span></span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0     <span class="comment">// 从首到尾</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1     <span class="comment">// 从尾到首</span></span></span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;     <span class="comment">// 首节点</span></span><br><span class="line">    listNode *tail;     <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 用户可自定义的节点值匹配函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;  <span class="comment">// 记录链表长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<h1 id="辅助函数">辅助函数</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure>
<h1 id="adlist-基本操作">adlist 基本操作</h1>
<h2 id="构造函数">构造函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span>  <span class="comment">// 指向一个链表的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 首尾节点默认为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值： * 分配内存执行失败时，返回 <code>NULL</code> * 执行成功时返回指向已构造的空链表的指针。</p>
<h2 id="析构函数">析构函数</h2>
<ol type="1">
<li><p><code>lsitEpmty</code> —— 不健全的析构函数</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;   <span class="comment">// 保存下一节点的指针</span></span><br><span class="line">        <span class="comment">// 如果 list 中的 free 函数已设置，调用其，释放节点值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        <span class="comment">// 释放当前节点的指针</span></span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 将首尾节点置为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，<code>listEmpty</code> 函数释放了链表中的每个节点，但是并未释放指向该链表的指针本身。</p></li>
<li><p><code>listRelease</code> —— 析构函数完全体</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);    <span class="comment">// 释放指向该链表的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="添加">添加</h2>
<ol type="1">
<li><p><code>listAddNodeHead</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;  <span class="comment">// 首节点的 prev 指针指向 NULL</span></span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，该函数的作用是，根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的首部，其返回值为：</p>
<ul>
<li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li>
<li>申请内存成功时，返回修改好的链表指针 <code>list</code></li>
</ul></li>
<li><p><code>listAddNodeTail</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 尾节点的 next 指针指向 NULL</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的尾部，其返回值为：</p>
<ul>
<li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li>
<li>申请内存成功时，返回修改好的链表指针 <code>list</code></li>
</ul></li>
<li><p><code>listInsertNode</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;    <span class="comment">// atfer 非 0，新节点插入在指定节点之后</span></span><br><span class="line">        node-&gt;prev = old_node;  </span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123; <span class="comment">// 指定节点为尾节点     </span></span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;        <span class="comment">// 更新链表的尾节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// after 为 0，新节点插入在指定节点之前</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;  <span class="comment">// 指定节点为首节点</span></span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;         <span class="comment">// 更新链表的首节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;    <span class="comment">// 更新插入节点的前一节点的 next 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;    <span class="comment">// 更新插入节点的后一节点的 prev 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，随后将该节点插入到链表的指定位置：</p>
<ul>
<li><span class="math inline">\(after \ne 0\)</span>，插入到 <code>old_node</code> 之后</li>
<li><span class="math inline">\(after = 0\)</span>，插入到 <code>old_node</code> 之前</li>
</ul>
<p>函数的返回值为：</p>
<ul>
<li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li>
<li>申请内存成功时，返回修改好的链表指针 <code>list</code></li>
</ul>
<p><em>Tips:</em> 插入节点时，可以先更新插入节点的指针，然后再更新插入节点相邻节点的指针。</p></li>
</ol>
<h2 id="删除">删除</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;  </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;    <span class="comment">// 删除节点为首节点，更新链表首节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;    <span class="comment">// 删除节点为尾节点，更新链表尾节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);    <span class="comment">// 释放该节点所占内存空间</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的作用是：删除给定节点，并释放其所占内存空间。</p>
<h2 id="迭代器相关">迭代器相关</h2>
<ol type="1">
<li><p><code>listGetIterator</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD) </span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;    <span class="comment">// 从首到尾      </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;    <span class="comment">// 从尾到首</span></span><br><span class="line">    iter-&gt;direction = direction;    <span class="comment">// 存储遍历方向</span></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的返回值：</p>
<ul>
<li>申请内存失败时，返回 <code>NULL</code></li>
<li>申请内存成功时，根据方向参数初始化迭代器，并返回其指针 <code>iter</code></li>
<li><code>direction == AL_START_HEAD</code> 时，返回正序迭代器</li>
<li><code>direction == AL_START_TAIL</code> 时，返回逆序迭代器</li>
</ul></li>
<li><p><code>listReleaseIterator</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：释放迭代器所占内存。</p></li>
<li><p><code>listRewind</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：将给定迭代器重置为正序迭代器。</p></li>
<li><p><code>listRewindTail</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：将给定迭代器重置为逆序迭代器。</p></li>
<li><p><code>listNext</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next; <span class="comment">// 迭代器当前所指节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：如果迭代器当前所指节点非空，则根据方向参数更新迭代器的 <code>next</code> 指针，最后返回迭代器当前所指节点。</p></li>
</ol>
<h2 id="复制">复制</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)  <span class="comment">// 构造一个空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;      <span class="comment">// 复制自定义值复制函数</span></span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;    <span class="comment">// 复制自定义值释放函数</span></span><br><span class="line">    copy-&gt;match = orig-&gt;match;  <span class="comment">// 复制自定义值匹配函数</span></span><br><span class="line">    listRewind(orig, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;   <span class="comment">// 遍历原链表</span></span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;    <span class="comment">// 值复制函数已给定</span></span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;    <span class="comment">// 值复制失败</span></span><br><span class="line">                listRelease(copy);  <span class="comment">// 释放复制链表</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>      <span class="comment">// 未给定值复制函数</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123; <span class="comment">// 添加新节点到尾部</span></span><br><span class="line">            listRelease(copy);  <span class="comment">// 添加节点失败，释放链表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的作用为：完全复制给定的链表 <code>orig</code>，函数的返回值为： * 执行失败时，返回 <code>NULL</code> * 执行成功时，返回复制链表指针 <code>copy</code></p>
<p><strong>注意</strong>：不论该函数是否执行成功，原链表都不会被修改。</p>
<h2 id="查找">查找</h2>
<ol type="1">
<li><p><code>listSearchKey</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;  <span class="comment">// 值匹配函数已指定</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定值匹配函数</span></span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 未找到，返回 NUll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：根据给定的值指针，寻找值相等的链表节点，该函数的返回值为：</p>
<ul>
<li>成功找到时，返回第一个值相等的链表节点指针（正序）</li>
<li>未找到时，返回 <code>NULL</code></li>
</ul></li>
<li><p><code>listIndex</code></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用是：根据给定的索引值，返回相应的链表节点</p>
<ul>
<li>从 0 开始计算索引</li>
<li>支持负数索引</li>
<li>当索引值 <code>index</code> <span class="math inline">\(\notin[-len, len - 1]\)</span> 时，返回 <code>NULL</code></li>
</ul></li>
</ol>
<h2 id="旋转">旋转</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev; </span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的作用是：删除链表原尾节点，将原尾节点插入到首部，作为新的首节点。</p>
<h2 id="拼接">拼接</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head)    <span class="comment">// 链表 o 不为空</span></span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail)    <span class="comment">// 链表 l 不为空</span></span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail;</span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. */</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的作用是：将链表 <code>o</code> 拼接到链表 <code>l</code> 之后，随后将链表 <code>o</code> 置为空链表，并未释放链表指针。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/ab216dfd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/ab216dfd/" class="post-title-link" itemprop="url">Redis 源码之 zmalloc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-12 20:07:44 / 修改时间：20:18:08" itemprop="dateCreated datePublished" datetime="2019-10-12T20:07:44+08:00">2019-10-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>源码文件 <code>/src/zmalloc.h</code> &amp; <code>/src/zmalloc.c</code></p>
<h1 id="分配内存">分配内存</h1>
<h2 id="zmalloc">zmalloc</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 malloc 分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="comment">// HAVE_MALLOC_SIZE 为 1 时，PREFIX_SIZE 为 0，直接返回 ptr</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 保存数据所需分配内存的实际大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// PREFIX_SIZE 中存储了 malloc size</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>zmalloc_size</p>
<p>使用 <code>tcmalloc 1.6+</code> 或 <code>jemalloc 2.1+</code> 或 <code>malloc</code>，则 <code>HAVE_MALLOC_SIZE</code> 为 1 。至于不同内存分配函数的区别，可以参考<a href="https://cyningsun.github.io/07-07-2018/memory-allocator-contrasts.html" target="_blank" rel="noopener">这篇博客</a>。</p>
<p>自身定义的 <code>zmalloc_size</code> 函数如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Provide zmalloc_size() for systems where this function is not provided by</span></span><br><span class="line"><span class="comment">* malloc itself, given that in that case we store a header with this</span></span><br><span class="line"><span class="comment">* information as the first bytes of every allocation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></span><br><span class="line"><span class="comment">    * the underlying allocator. */</span></span><br><span class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_usable(<span class="keyword">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_size(ptr)-PREFIX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>update_zmalloc_stat_alloc</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \    </span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="comment">// atomicIncr(var,count) </span></span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>根据 <a href="https://github.com/antirez/redis/pull/4770" target="_blank" rel="noopener">redis #4770</a>，第 2、3 两行可以删除，由于并未计算内存补齐的原因，全局变量 <code>used_memory</code> 一般小于实际分配内存大小。</p>
<p><em>Tips:</em> <a href="http://www.spongeliu.com/415.html" target="_blank" rel="noopener"><code>do {} while(0)</code> 的作用</a>：</p>
<ul>
<li>辅助定义复杂的宏，避免引用的时候出错</li>
<li>避免使用 <code>goto</code> 对程序流进行统一的控制，例如：使用 <code>break</code> 来代替 <code>goto</code>，后续的处理工作在 <code>while</code> 之后，就能够达到同样的效果</li>
<li>避免空宏引起的 <code>warning</code></li>
<li>定义一个单独的函数块来实现复杂的操作</li>
</ul>
<p><em>Tips:</em> 将 <span class="math inline">\(a\)</span> 调整为 <span class="math inline">\(b = 2^n\)</span> 的整数倍</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &amp; (b<span class="number">-1</span>))</span><br><span class="line">    a += b - (a &amp; (b<span class="number">-1</span>));</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="zcalloc">zcalloc</h2>
<p>源码逻辑和 <code>zmalloc</code> 一样，此处主要介绍 <code>malloc</code> 和 <code>calloc</code> 的区别：</p>
<table>
<thead>
<tr class="header">
<th>区别</th>
<th><code>malloc</code></th>
<th><code>calloc</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td><code>void* malloc(size_t size);</code></td>
<td><code>void* calloc(size_t num, size_t size);</code></td>
</tr>
<tr class="even">
<td>作用</td>
<td>分配 <code>size</code> 字节未初始化的内存空间</td>
<td>为 <code>num</code> 个大小为 <code>size</code> 的对象分配内存空间，并且初始化每一 <code>bit</code> 为 0</td>
</tr>
</tbody>
</table>
<p>两个函数都是线程安全的，并且都自带满足内存对齐，当分配成功时，返回指向初始位置的指针，该指针需要调用 <code>free()</code> 或 <code>realloc()</code> 释放，当分配失败时，返回空指针。</p>
<h2 id="zrealloc">zrealloc</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配的内存的大小为 0</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原内存指针为空，无需释放</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size); </span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="comment">// HAVE_MALLOC_SIZE 为 1 时，PREFIX_SIZE 为 0，直接返回 newptr</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">// 对应 *((size_t*)ptr) = size;</span></span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// PREFIX_SIZE 中存储了 malloc size</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>update_zmalloc_stat_free</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="comment">// atomicDecr(var,count)</span></span><br><span class="line">    atomicDecr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>同上，根据 <a href="https://github.com/antirez/redis/pull/4770" target="_blank" rel="noopener">redis #4770</a>，第 2、3 两行可以删除，由于并未计算内存补齐的原因，全局变量 <code>used_memory</code> 一般小于实际分配内存大小。</p></li>
<li><p>疑问：变量定义语句置于判断返回语句前是否浪费了为变量分配存储空间的时间？变量定义是否应该离使用变量语句近一些更好？</p></li>
</ol>
<h1 id="释放内存">释放内存</h1>
<h2 id="zfree">zfree</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 指针为空时无需调用 free</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="辅助函数">辅助函数</h1>
<h2 id="复制字符串">复制字符串</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>; <span class="comment">// '\0' 结尾</span></span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用字符串复制函数 void* memcpy(void *dest, const void *src, size_t count);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取-used_memory">获取 <code>used_memory</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line">    <span class="comment">// atomicGet(var,dstvar)</span></span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置异常处理函数">设置异常处理函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认异常处理函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置异常处理函数</span></span><br><span class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/e4b38dc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/e4b38dc/" class="post-title-link" itemprop="url">Linux相关小问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-10-12 20:00:38 / 修改时间：20:11:03" itemprop="dateCreated datePublished" datetime="2019-10-12T20:00:38+08:00">2019-10-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="手动卸载旧版本软件安装完新版本之后提示-no-such-file-or-directory-怎么办">手动卸载旧版本软件，安装完新版本之后，提示 No such file or directory 怎么办？</h1>
<ol type="1">
<li>使用 <code>echo $PATH</code> 命令检查环境变量，如新版本软件安装路径不在环境变量中，添加。如新版本软件安装路径已在环境变量中，转 2.
<ul>
<li>添加环境变量：编辑 <code>/etc/profile</code> or <code>/ect/environment</code> or <code>~/.bashrc</code></li>
</ul></li>
<li>因为 bash 路径是有缓存的，只要运行过的命令，bash 就会保存到一张 hash 表中，下次直接从 hash 表中找地址，故需要我们手动删除缓存
<ul>
<li>运行 <code>hash</code> 命令，查看缓存的 hash 表</li>
<li>运行 <code>hash -d &lt;softname&gt;</code> 删除掉 <code>&lt;softname&gt;</code> 的缓存</li>
</ul></li>
</ol>
<h1 id="gccg-版本切换">gcc/g++ 版本切换</h1>
<ol type="1">
<li>查看所安装的各个版本</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin/gcc*</span><br><span class="line">ls /usr/bin/g++*</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>设置候选优先级</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 gcc-5 和 gcc-7 为例，最后的数字是优先级，数字越大，优先级越高</span></span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 100</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 g++-5 和 g++-7 为例，最后的数字是优先级，数字越大，优先级越高</span></span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 100</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 80</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>切换版本</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config gcc</span><br><span class="line"></span><br><span class="line">update-alternatives --config g++</span><br></pre></td></tr></table></figure>
<p>注意保持 gcc 和 g++ 的版本一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/787e5648/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/787e5648/" class="post-title-link" itemprop="url">Thrift-Protocol 概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-30 22:57:40" itemprop="dateCreated datePublished" datetime="2019-07-30T22:57:40+08:00">2019-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-12 19:57:19" itemprop="dateModified" datetime="2019-10-12T19:57:19+08:00">2019-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="协议层类关系图">协议层类关系图</h1>
<p>协议层相关的类主要实现与数据传输格式封装的协议相关的内容。可以发现，所有的协议类都直接或间接继承 TProtocol 类，协议层类关系图主要分为三部分来看：</p>
<ul>
<li>抽象基类 Tprotocol，它是所有协议类的基类，有很大一部分类直接从它继承实现它定义的接口函数（纯虚函数）</li>
<li>TProtocol 的默认实现 TProtocolDefaults 类和虚拟协议类 TVirtualProtocol 及其子类</li>
<li>各种协议类的对象生成工厂类，负责某一种具体协议类对象的生产</li>
</ul>
<h1 id="tprotocol">Tprotocol</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TProtocol.h</code></p>
<p>抽象类 TProtocol 对于每一种数据类型都提供了读写的开始和结束的方法，这里的读写方法应该是针对网络 I/O 读写，不过真正实现网络读写的是 TTransport 相关类，此处的读写方法主要针对数据的处理（如数据格式调整）。除了有针对具体的数据类型的读写方法，消息也可以通过网络传递。所以也定义了消息的读写方法。此外，还定义了一些公用的功能，例如跳过某一个结构不读，大小端数据格式调整、主机字节序和网络字节序的相互转换等。</p>
<h2 id="支持的数据结构">支持的数据结构</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thrift 协议支持的数据类型</span></span><br><span class="line"><span class="keyword">enum</span> TType &#123;</span><br><span class="line">  T_STOP       = <span class="number">0</span>,</span><br><span class="line">  T_VOID       = <span class="number">1</span>,</span><br><span class="line">  T_BOOL       = <span class="number">2</span>,</span><br><span class="line">  T_BYTE       = <span class="number">3</span>,</span><br><span class="line">  T_I08        = <span class="number">3</span>,</span><br><span class="line">  T_I16        = <span class="number">6</span>,</span><br><span class="line">  T_I32        = <span class="number">8</span>,</span><br><span class="line">  T_U64        = <span class="number">9</span>,</span><br><span class="line">  T_I64        = <span class="number">10</span>,</span><br><span class="line">  T_DOUBLE     = <span class="number">4</span>,</span><br><span class="line">  T_STRING     = <span class="number">11</span>,</span><br><span class="line">  T_UTF7       = <span class="number">11</span>,</span><br><span class="line">  T_STRUCT     = <span class="number">12</span>,</span><br><span class="line">  T_MAP        = <span class="number">13</span>,</span><br><span class="line">  T_SET        = <span class="number">14</span>,</span><br><span class="line">  T_LIST       = <span class="number">15</span>,</span><br><span class="line">  T_UTF8       = <span class="number">16</span>,</span><br><span class="line">  T_UTF16      = <span class="number">17</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thrift 支持的消息类型</span></span><br><span class="line"><span class="keyword">enum</span> TMessageType &#123;</span><br><span class="line">  T_CALL       = <span class="number">1</span>,</span><br><span class="line">  T_REPLY      = <span class="number">2</span>,</span><br><span class="line">  T_EXCEPTION  = <span class="number">3</span>,</span><br><span class="line">  T_ONEWAY     = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="写函数">写函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(*)</span><span class="title">Begin_virt</span><span class="params">(<span class="keyword">const</span> parameters)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(*)</span><span class="title">End_virt</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">writeFiledStop_virt</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 只有 Filed 有 stop</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(TtypeName)</span>_<span class="title">virt</span><span class="params">(<span class="keyword">const</span> parameter)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用相应纯虚函数的函数</span></span><br><span class="line"><span class="keyword">unit32_t</span> functionName(&lt;<span class="keyword">const</span> parameters&gt;)&#123;</span><br><span class="line">    T_VIRTUAL_CALL();       <span class="comment">// 调用打印日志函数</span></span><br><span class="line">    <span class="keyword">return</span> functionName_virt(&lt;<span class="keyword">const</span> parameters);  <span class="comment">// 调用纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读函数">读函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(*)</span><span class="title">Begin_virt</span><span class="params">(parameters)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(*)</span><span class="title">End_virt</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(TtypeName)</span>_<span class="title">virt</span><span class="params">(parameter)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个 readBool() 函数，</span></span><br><span class="line"><span class="comment">// std::vector is specialized for bool, and its elements are individual bits</span></span><br><span class="line"><span class="comment">// rather than bools.   We need to define a different version of readBool()</span></span><br><span class="line"><span class="comment">// to work with std::vector&lt;bool&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">readBool_virt</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::reference value)</span> </span>= <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用相应纯虚函数的函数</span></span><br><span class="line"><span class="keyword">unit32_t</span> functionName(&lt;parameters&gt;)&#123;</span><br><span class="line">    T_VIRTUAL_CALL();       <span class="comment">// 调用打印日志函数</span></span><br><span class="line">    <span class="keyword">return</span> functionName_virt(&lt;parameters);  <span class="comment">// 调用纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数">构造函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  TProtocol(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TTransport&gt; ptrans)</span><br><span class="line">    : ptrans_(ptrans), input_recursion_depth_(<span class="number">0</span>), output_recursion_depth_(<span class="number">0</span>), recursion_limit_(DEFAULT_RECURSION_LIMIT)</span><br><span class="line">  &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他函数">其他函数</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过任意数据类型的函数</span></span><br><span class="line"><span class="keyword">uint32_t</span> skip(TType type) &#123;</span><br><span class="line">    T_VIRTUAL_CALL();</span><br><span class="line">    <span class="keyword">return</span> skip_virt(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">skip_virt</span><span class="params">(TType type)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用此命名空间下全局函数实现</span></span><br><span class="line">    <span class="comment">// 在该头文件的最后定义模板函数 skip 以适用于不同的 Protocol 类</span></span><br><span class="line">    <span class="keyword">return</span> ::apache::thrift::protocol::skip(*<span class="keyword">this</span>, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TTransport&gt; getTransport() &#123; <span class="keyword">return</span> ptrans_; &#125;</span><br></pre></td></tr></table></figure>
<p>此外还有一些与输入，输出递归深度有关的函数在上面并未列出。</p>
<h1 id="tprotocoldefaults">TProtocolDefaults</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TVirtualProtocol.h</code></p>
<h2 id="继承关系">继承关系</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TProtocolDefaults</span> :</span> <span class="keyword">public</span> TProtocol &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="主要操作">主要操作</h2>
<ol type="1">
<li>重写了父类非虚拟的读写函数，这些函数都会抛出一个 <code>TProtocolException::NOT_IMPLEMENTED</code> 异常</li>
<li>重写了父类的 <code>skip</code> 函数，直接调用父类中的 <code>skip</code> 模板函数</li>
<li>构造函数直接调用父类的构造函数</li>
</ol>
<h1 id="tvirtualprotocol">TVirtualProtocol</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TVirtualProtocol.h</code></p>
<h2 id="继承关系-1">继承关系</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Protocol_</span>, <span class="title">class</span> <span class="title">Super_</span> = <span class="title">TProtocolDefaults</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TVirtualProtocol</span> :</span> <span class="keyword">public</span> Super_ &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="读写函数">读写函数</h2>
<p>TVirtualProtocol 类中的读写函数会重写父类中的读写纯虚函数，其都是通过 <code>this</code> 指针调用模板参数 <code>class Protocol_</code> 中相应的实现方法来实现自己的读写函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> writeMessageBegin_virt(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">                                <span class="keyword">const</span> TMessageType messageType,</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">int32_t</span> seqid) override &#123; <span class="comment">// override 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Protocol_*&gt;(<span class="keyword">this</span>)-&gt;writeMessageBegin(name, messageType, seqid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作">其他操作</h2>
<ol type="1">
<li>提供了 <code>skip</code> 函数和针对 <code>std::vector&lt;boo&gt;</code> 的 <code>readBool</code> 函数的默认实现</li>
<li>构造函数直接调用父类的构造函数</li>
</ol>
<h1 id="为何要有-tprotocoldefaults-和-tvirtualprotocol">为何要有 TProtocolDefaults 和 TVirtualProtocol ？</h1>
<p>下面来分析如果不从定义的默认实现类继承，直接从抽象类继承怎样会产生无限递归调用。现在我们假设直接从抽象类继承，那么如果一个指向子类对象的父类（TProtocol）调用 <code>writeMessageBegin</code> 方法，因为这个方法不是虚拟函数（不会动态绑定）所以就会调用父类的 <code>writeMessageBegin</code> 方法，然后父类会直接调用它的纯虚函数 <code>writeMessageBegin_virt</code>，这个函数就会动态绑定，就会执行子类的实现，在这里就是通过虚协议类 TVirtualProtocol 实现的，而这个函数又会调用之类的 <code>writeMessageBegin</code> 方法，如果子类没有实现这个方法，那么就又回到父类的这个方法了,从而产生无限递归调用。那么如果默认是从默认实现类 TProtocolDefaults 继承，那么就会执行它的 <code>writeMessageBegin</code> 方法，从而抛出一个异常，就不会产生无限递归调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/f531f65/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/f531f65/" class="post-title-link" itemprop="url">Thrift-Transport 概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-30 22:57:26" itemprop="dateCreated datePublished" datetime="2019-07-30T22:57:26+08:00">2019-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-12 19:57:51" itemprop="dateModified" datetime="2019-10-12T19:57:51+08:00">2019-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="传输层类关系图">传输层类关系图</h1>
<p>传输层类关系图主要分为三部分来看： * 抽象基类 TTransport，它是所有传输类的基类，有很大一部分类直接从它继承实现它定义的接口函数（纯虚函数） * TTransport 的默认实现 TTransportDefaults 类和虚拟传输类 TvirtualTransport 及其子类 * 各种传输类的对象生成工厂类，负责某一种具体传输类对象的生产</p>
<h1 id="ttransport">TTransport</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h</code></p>
<h2 id="模板函数-readall">模板函数 <code>readAll</code></h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Transport_</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">uint32_t</span> <span class="title">readAll</span>(<span class="title">Transport_</span>&amp; <span class="title">trans</span>, <span class="title">uint8_t</span>* <span class="title">buf</span>, <span class="title">uint32_t</span> <span class="title">len</span>) &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> have = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> get = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (have &lt; len) &#123;</span><br><span class="line">    get = trans.read(buf + have, len - have);   <span class="comment">// 通过具体的传输类对象读取剩余的需要读取的数据</span></span><br><span class="line">    <span class="keyword">if</span> (get &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> TTransportException(TTransportException::END_OF_FILE, <span class="string">"No more data to read."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    have += get;    <span class="comment">// 已读取的字节数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> have;  <span class="comment">// 返回读取得字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ttransport-的接口定义">TTransport 的接口定义</h2>
<ol type="1">
<li><code>isOpen()</code>：transport 是否 open</li>
<li><code>peek()</code>：测试是否仍然有数据可读或远程 transport 是否 open</li>
<li><code>open()</code>：打开 transport</li>
<li><code>close()</code>：关闭 transport</li>
<li><code>read()</code> &amp; <code>read_virt()</code>：尝试读取指定的字节数到字符串
<ul>
<li><code>uint8_t* buf</code>：Reference to the location to write the data</li>
<li><code>uint32_t len</code>: How many bytes to read</li>
</ul></li>
<li><code>readAll()</code> &amp; <code>readAll_virt()</code>：必须读取指定长度的数据
<ul>
<li><code>uint8_t* buf</code>：Reference to location for read data</li>
<li><code>uint32_t len</code>: How many bytes to read</li>
</ul></li>
<li><code>readEnd()</code>：读取完成时调用</li>
<li><code>write()</code> &amp; <code>write_virt()</code>：将字符串写入缓存
<ul>
<li><code>uint8_t* buf</code>：The data to write out</li>
<li><code>uint32_t len</code>: How many bytes to write</li>
<li>必须调用 <code>flush()</code> 才能确保成功写入，析构一个 TTransport 对象并不会自动 flush pendng data.</li>
</ul></li>
<li><code>writeEnd()</code>：写入完成时调用</li>
<li><code>flush()</code>：Flushes any pending data to be written.</li>
<li><code>borrow()</code> &amp; <code>borrow_virt()</code>：尝试返回一个指向长为 len 的字符串缓存而不真正地读取消耗它</li>
</ol>
<ul>
<li><code>uint8_t* buf</code>：A buffer where the data can be stored if needed.</li>
<li><code>uint32_t* len</code>: len should initially contain the number of bytes to borrow.</li>
</ul>
<ol start="12" type="1">
<li><code>consume()</code> &amp; <code>consume_virt()</code>：从传输层消耗 len 字节的数据</li>
</ol>
<ul>
<li><code>uint32_t len</code>: How many bytes to consume</li>
</ul>
<p>通常一个传输层的对象要么作为输出要么作为输入，但是通常不能同时作为输入和输出。上述已把所有支持的接口操作都简单的介绍了，后面介绍的具体某一个传输层类的实现都会实现这些接口，只是根据各个子类不同的作用和实现方式有不同而已。特别需要注意的是最后两组函数，这两组函数主要是用于支持可变长度编码的，所以如果传输层对象需要支持可变长度编码必须实现这两组函数。</p>
<h1 id="ttransportdefaults">TTransportDefaults</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h/TVirtualTransport.h</code></p>
<p>默认传输类 TTransportDefaults 是 TTransport 的子类，提供了抽象类 TTransport 的默认实现，实现了非虚拟的方法 <code>*_virt()</code> 方法。</p>
<h1 id="tvirtualtransport">TVirtualTransport</h1>
<p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h/TVirtualTransport.h</code></p>
<p>虚拟传输类 TVirtualTransport 采用了模板的方式来实现多继承（同时从两个类继承），也就是说可以从一个默认的类继承，而另一个类采用模板参数传递。而默认传输类的作用就是防止那些没有实现默认传输类实现的方法的子类造成递归调用（死循环了）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/56b70/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yz1509">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子和阿铁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/56b70/" class="post-title-link" itemprop="url">Thrift 概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-26 23:48:45" itemprop="dateCreated datePublished" datetime="2019-07-26T23:48:45+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-12 19:58:01" itemprop="dateModified" datetime="2019-10-12T19:58:01+08:00">2019-10-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括 C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。</p>
<h1 id="软件栈">软件栈</h1>
<p>Thrift 对软件栈的定义非常的清晰, 使得各个组件能够松散的耦合, 针对不同的应用场景, 选择不同的方式去搭建服务。</p>
<div data-align="center">
<img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=8b52d3e0808ba61ecbe3c07d205dfc6f/29381f30e924b8999366ac126c061d950a7bf646.jpg" alt="技术栈" width="400">
</div>
<p><br></p>
<ul>
<li>传输层(Transport Layer)：传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议；比如说 TCP/IP 传输、MemoryBuffer 等</li>
<li>协议层(Protocol Layer)：协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化；比如说 JSON、XML、二进制数据等</li>
<li>处理层(Processor Layer)：处理层作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口，是由具体的IDL（接口描述语言）生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的 Handler 进行处理</li>
<li>服务层(Server Layer)：整合上述组件，根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架，提供具体的网络线程/IO 服务模型，形成最终的服务</li>
<li>业务逻辑层(Your code)</li>
</ul>
<p>接下来我们按照自底向上的顺序介绍 thrift 的各个模块。</p>
<h2 id="传输层transport-layer">传输层(Transport Layer)</h2>
<p>Transport 与网络数据通信相关，thrift 通信协议有基于 TCP/IP 协议的实现。在现在的网络通信服务器中， TCP/IP 协议栈由 socket 来实现。Thrift 也不例外，在 thrift 源码中，是通过将 socket 包装成各种功能不同的 <code>TTransport</code> 来使用：</p>
<ul>
<li><code>TSocket</code>：使用阻塞式 I/O 进行传输，是常见的模式</li>
<li><code>TNonblockingTransport</code>：使用非阻塞方式，用于构建异步客户端</li>
<li><code>TFrameTransport</code>：使用非阻塞方式，按块的大小进行传输</li>
</ul>
<h2 id="协议层protocol-layer">协议层(Protocol Layer)</h2>
<p>Protocol 是 transport 的上一层，transport 负责数据传输，protocol 负责对数据进行解析，将数据解析成对应的数据结构代码，供程序直接调用。Thrift 支持各种语言，通过一个 <code>x.thrift</code> 的接口描述文件来通信。Thrift 的接口描述文件是各种语言通用的，其通过 thrift compiler 来生成对应的源代码，例如 C++ 对应的命令为 <code>thrift --gen cpp x.thrift</code>。</p>
<p>Thrift 可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本(text)和二进制(binary)传输协议。为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p>
<ul>
<li><code>TBinaryProtocol</code>：二进制编码格式进行数据传输</li>
<li><code>TCompactProtocol</code>：高效率的、密集的二进制编码格式进行数据传输</li>
<li><code>TJSONProtocol</code>：使用 JSON 文本的数据编码协议进行数据传输</li>
<li><code>TSimpleJSONProtocol</code>：只提供 JSON 只写的协议，适用于通过脚本语言解析</li>
</ul>
<h2 id="处理层processor-layer">处理层(Processor Layer)</h2>
<p>服务调用组件。 Processor 封装了从输入流读取数据和向输出流写入数据的能力。输入和输出流由 Protocol objectss 表示。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface TProcessor &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(TProtocol in, TProtocol out)</span> throws TException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务层server-layer">服务层(Server Layer)</h2>
<p>Server 主要做以下工作:</p>
<ul>
<li>Create a transport</li>
<li>Create input/output protocols for the transport</li>
<li>Create a processor based on the input/output protocols</li>
<li>Wait for incoming connections and hand them off to the processor</li>
</ul>
<p>根据单线程/多线程，同步/异步分为以下几种：</p>
<ul>
<li><code>TSimpleServer</code>：单线程服务器端，使用标准的阻塞式 I/O</li>
<li><code>TThreadPoolServer</code>：多线程服务器端，使用标准的阻塞式 I/O</li>
<li><code>TNonblockingServer</code>：单线程服务器端，使用非阻塞式 I/O</li>
<li><code>THsHaServer</code>：半同步半异步服务器端，基于非阻塞式 I/O 读写和多线程工作任务处理</li>
<li><code>TThreadedSelectorServer</code>：多线程选择器服务器端，对 <code>THsHaServer</code> 在异步 I/O 模型上进行增强</li>
</ul>
<h1 id="特点">特点</h1>
<ol type="1">
<li><p>开发速度快</p>
<p>通过编写 RPC 接口 Thrift IDL 文件，利用编译生成器自动生成服务端骨架(Skeletons)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p>
<ul>
<li>服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(Handler)即实现类即可。</li>
<li>客户端：只需要拷贝 IDL 定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。</li>
</ul></li>
<li><p>接口维护简单</p>
<p>通过维护 Thrift 格式的 IDL（接口描述语言）文件（注意写好注释），即可作为给 Client 使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且 Thrift 协议可灵活支持接口的可扩展性。</p></li>
</ol>
<h1 id="数据类型">数据类型</h1>
<p>Thrifty 的数据类型包括预定义的基本类型，容器类型，用户自定义的结构体和异常，以及服务。</p>
<ol type="1">
<li><p>基本类型(Base Type)</p>
<ul>
<li><code>bool</code>：布尔值，一个字节</li>
<li><code>i8(byte)</code>：8 位有符号整数</li>
<li><code>i16</code>：16 位有符号整数</li>
<li><code>i32</code>：32 位有符号整数</li>
<li><code>i64</code>：64 位有符号整数</li>
<li><code>double</code>：64 位浮点数</li>
<li><code>binary</code>：一个字节数组</li>
<li><code>string</code>：编码不可知的文本或二进制字符串</li>
</ul></li>
<li><p>容器类型(Container)</p>
<ul>
<li><code>list&lt;t&gt;</code>：元素类型为 t 的有序列表，容许元素重复</li>
<li><code>set&lt;t&gt;</code>：元素类型为 t 的无序表，不容许元素重复</li>
<li><code>map&lt;k,v&gt;</code>：key/value 映射，key 不允许重复</li>
<li>其中容器中的元素类型可以是除了 <code>service</code> 外的任何合法 Thrift 类型（包括结构体和异常）</li>
</ul></li>
<li><p>结构体类型 <code>struct</code></p>
<p>Thrift 中的 <code>struct</code> 类似于 C 语言，其在面向对象的语言中转换为 <code>class</code>。一个 <code>struct</code> 其由多个 <code>field</code> 组成，每个 <code>field</code> 包括唯一的整数标识符、<code>type</code>、<code>name</code> 和可选的默认值组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;    <span class="comment">// 没有逗号</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;</span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;</span><br><span class="line">    <span class="number">5</span>: optional TweetType tweetType = TweetType.TWEET;    <span class="comment">// 详见 enum</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"Endlish"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>field</code> 可用关键字 <code>optional</code> 或 <code>required</code> 进行标识</li>
<li><code>struct</code> 不能继承，但是可以嵌套，但不能嵌套自己</li>
<li>同一文件可以定义多个 <code>struct</code>，也可以定义在不同的文件中，利用 <code>include</code> 导入</li>
</ul></li>
<li><p>异常类型 <code>exception</code></p>
<p>异常在语法和功能上相当于结构体，差别是异常使用关键字 <code>exception</code> 而不是 <code>struct</code> 声明。它在语义上不同于结构体：当定义一个 RPC 服务时，开发者可能需要声明一个远程方法抛出一个异常。</p></li>
<li><p>服务类型 <code>service</code></p>
<p>服务的定义方法在语义上等同于面向对象语言中的接口，Thrift compiler 将用你所选择的语言据此生成 service interface code (for the server) and stubs (for the client)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service Twitter&#123;</span><br><span class="line">    <span class="comment">// A method definition looks like C code. It has a return type, arguments</span></span><br><span class="line">    <span class="comment">// and optionally a list of exceptions that it may throw. Note that argument</span></span><br><span class="line">    <span class="comment">// lists and exception list are specified using the exact same syntax as</span></span><br><span class="line">    <span class="comment">// field lists in structs.</span></span><br><span class="line">    void ping(),</span><br><span class="line">    bool postTweet(1:Tweet tweet) throws (1:TwitterUnavailable unavailable),</span><br><span class="line">    <span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 'oneway' modifier indicates that the client only makes a request and</span></span><br><span class="line">    <span class="comment">// does not wait for any response at all. Oneway methods MUST be void.</span></span><br><span class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义可以用分号或者逗号结尾</li>
<li>参数和返回值类型可以是基本类型或者结构体</li>
<li><code>void</code> 是函数的有效返回类型</li>
<li>服务支持继承，一个 <code>service</code> 可使用 <code>extends</code> 关键字继承另一个 <code>service</code></li>
<li>服务不支持重载</li>
</ul></li>
</ol>
<h1 id="其他特性">其他特性</h1>
<h2 id="typedef">Typedef</h2>
<p>Thrift 支持 C/C++ 风格的 typedef</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> i32 MyInteger   <span class="comment">// 结尾无分号</span></span><br><span class="line"><span class="keyword">typedef</span> Tweet ReTweet   <span class="comment">// struct 也可 typedef</span></span><br></pre></td></tr></table></figure>
<h2 id="enum">enum</h2>
<p>Thrift 支持 C 风格的 enum ，编译器从 0 开始分配默认值。Thrift 还不支持嵌套枚举，枚举常量大小不超过 32 位正整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType&#123;</span><br><span class="line">    TWEET,</span><br><span class="line">    RETWEET = <span class="number">2</span>,    <span class="comment">// 可以设置特定的整数值</span></span><br><span class="line">    DM = <span class="number">0xa</span>,       <span class="comment">// 支持 16 进制</span></span><br><span class="line">    REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="constant">constant</h2>
<p>Thrift 允许定义跨语言使用的常量，复杂类型和结构体使用 JSON 格式赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i32 INT_CONST = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; MAP_CONST = &#123;<span class="string">"hello"</span>: <span class="string">"world"</span>, <span class="string">"goodnight"</span>: <span class="string">"Kyoani"</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="generated-filesc">Generated Files(C++)</h1>
<ul>
<li>All constants go into a single <code>.cpp/.h</code> pair</li>
<li>All type definitions (enums and structs) go into another <code>.cpp/.h</code> pair</li>
<li>Each service gets its own <code>.cpp/.h</code> pair</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree gen-cpp</span><br><span class="line">|-- example_constants.cpp</span><br><span class="line">|-- example_constants.h</span><br><span class="line">|-- example_types.cpp</span><br><span class="line">|-- example_types.h</span><br><span class="line">|-- Twitter.cpp</span><br><span class="line">|-- Twitter.h</span><br><span class="line">`-- Twitter_server.skeleton.cpp</span><br></pre></td></tr></table></figure>
<p>Thrift 数据类型和 C++ 数据类型对应表</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Thrift</th>
<th style="text-align: left;">C++</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">bool</td>
</tr>
<tr class="even">
<td style="text-align: left;">byte</td>
<td style="text-align: left;">int8_t</td>
</tr>
<tr class="odd">
<td style="text-align: left;">i16</td>
<td style="text-align: left;">int16_t</td>
</tr>
<tr class="even">
<td style="text-align: left;">i32</td>
<td style="text-align: left;">int32_t</td>
</tr>
<tr class="odd">
<td style="text-align: left;">i64</td>
<td style="text-align: left;">int64_t</td>
</tr>
<tr class="even">
<td style="text-align: left;">double</td>
<td style="text-align: left;">double</td>
</tr>
<tr class="odd">
<td style="text-align: left;">binary</td>
<td style="text-align: left;">std::string</td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">std::string</td>
</tr>
<tr class="odd">
<td style="text-align: left;">list<t1></t1></td>
<td style="text-align: left;">std::vector<t1></t1></td>
</tr>
<tr class="even">
<td style="text-align: left;">set<t1></t1></td>
<td style="text-align: left;">std::set<t1></t1></td>
</tr>
<tr class="odd">
<td style="text-align: left;">map&lt;t1, t2&gt;</td>
<td style="text-align: left;">std::map&lt;t1, t2&gt;</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="yz1509"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yz1509</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yz1509</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
