<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="STL 简单介绍，并不涉及源码剖析。">
<meta name="keywords" content="C++,STL">
<meta property="og:type" content="article">
<meta property="og:title" content="认识STL">
<meta property="og:url" content="https://yz1509.github.io/posts/64d148d3/index.html">
<meta property="og:site_name" content="HTT">
<meta property="og:description" content="STL 简单介绍，并不涉及源码剖析。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yz1509.github.io/posts/64d148d3/001.png">
<meta property="og:image" content="https://yz1509.github.io/posts/64d148d3/002.png">
<meta property="og:image" content="https://yz1509.github.io/posts/64d148d3/003.png">
<meta property="og:image" content="https://yz1509.github.io/posts/64d148d3/004.png">
<meta property="og:updated_time" content="2019-10-31T02:11:53.066Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="认识STL">
<meta name="twitter:description" content="STL 简单介绍，并不涉及源码剖析。">
<meta name="twitter:image" content="https://yz1509.github.io/posts/64d148d3/001.png">

<link rel="canonical" href="https://yz1509.github.io/posts/64d148d3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>认识STL | HTT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HTT</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">ふわふわ時間</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/64d148d3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/k-on.jpg">
      <meta itemprop="name" content="KyoAni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HTT">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          认识STL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-31 10:48:06" itemprop="dateCreated datePublished" datetime="2018-07-31T10:48:06+08:00">2018-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-31 10:11:53" itemprop="dateModified" datetime="2019-10-31T10:11:53+08:00">2019-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/秋招/" itemprop="url" rel="index">
                    <span itemprop="name">秋招</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>STL 简单介绍，并不涉及源码剖析。</p>
<a id="more"></a>
<hr>
<p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。</p>
<h1 id="标准库类型-string">标准库类型 string</h1>
<p>标准库类型 string 表示可变长的字符序列。</p>
<h2 id="定义和初始化-string-对象">定义和初始化 string 对象</h2>
<ul>
<li><p>初始化 string 对象的方式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;              <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;          <span class="comment">// s2 是 s1 的一个副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;         <span class="comment">// 等价于 s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;     <span class="comment">// s3 是字面值 "value" 的副本，不包含字面值最后的空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;    <span class="comment">// 等价于 s3("value")</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;      <span class="comment">// 把 s4 初始化为连续 n 个字符 c 组成的串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 string 的其他方法</span></span><br><span class="line"><span class="comment">// n, len2 和 pos2 都是无符号值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp, n)</span></span>;		<span class="comment">// 	s 是指向 cp 指向的数组中的前 n 个字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 此数组至少应该包含 n 个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2)</span></span>;		<span class="comment">// s 是 string s2 从下标 pos2 开始的字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2, len2)</span></span>;	<span class="comment">// s 是 string s2 从下标 pos2 开始 len2 个字符的							  // 拷贝，若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line">                        <span class="comment">// 不管 len2 的值为多少，至多拷贝 s2.size()-pos2个字符</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>直接初始化和拷贝初始化</p>
<ul>
<li>如果使用等号 = 初始化一个变量，实际执行的是拷贝初始化</li>
<li>如果不使用等号，则执行的是直接初始化（direct initialization）</li>
</ul></li>
</ul>
<h2 id="string-对象上的操作">string 对象上的操作</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s;            <span class="comment">// 将 s 写到输出流 os 中，返回 os</span></span><br><span class="line">is &gt;&gt; s;            <span class="comment">// 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is</span></span><br><span class="line">                	<span class="comment">// string 对象会自动忽略开头的空白并从第一个非空白字符开始</span></span><br><span class="line">                	<span class="comment">// 直至遇见下一处空白为止。</span></span><br><span class="line">getline(is, s);     <span class="comment">// 从 is 中读取一行赋给 s，返回 is</span></span><br><span class="line">                    <span class="comment">// getline 函数从给定的流中读入内容，直到遇到</span></span><br><span class="line">                    <span class="comment">// 换行符为止（换行符也被读进来），</span></span><br><span class="line">                    <span class="comment">// 然后把所读内容存入到 string 对象中（注意不存换行符）</span></span><br><span class="line">s.empty();          <span class="comment">// s 为空返回 true</span></span><br><span class="line">s.size();           <span class="comment">// 返回 s 中字符的个数</span></span><br><span class="line">s[n];               <span class="comment">// 返回 s 中第 n 个字符的引用，位置 n 从 0 开始</span></span><br><span class="line">s1 + s2;            <span class="comment">// 返回 s1 和 s2 连接后的结果</span></span><br><span class="line">s1 = s2;            <span class="comment">// 用 s2 的副本代替 s1 中原来的字符</span></span><br><span class="line">s1 == s2;</span><br><span class="line">s1 != s2;           <span class="comment">// 大小写敏感</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=        <span class="comment">// 字典序比较，且大小写敏感</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子字符串操作</span></span><br><span class="line">s.substr(pos, n);	<span class="comment">// 返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。</span></span><br><span class="line">                    <span class="comment">// pos 的默认值为 0，n 的默认值为 s.size() - pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 string 的操作</span></span><br><span class="line">s.insert(pos, args)	<span class="comment">// 在 pos 之前插入 args 指定的字符</span></span><br><span class="line">                    <span class="comment">// pos 为下标的版本返回一个指向 s 的引用</span></span><br><span class="line">                    <span class="comment">// pos 为迭代器的版本返回指向第一个插入字符的迭代器</span></span><br><span class="line">s.erase(pos, len)	<span class="comment">// 删除从位置 pos 开始的 len 个字符。如果 len 被省略，</span></span><br><span class="line">                    <span class="comment">// 则删除从 pos 开始直至 s 末尾的所有字符</span></span><br><span class="line">                    <span class="comment">// 返回一个指向 s 的引用</span></span><br><span class="line">s.assign(args)	<span class="comment">// 将 s 中的字符替换为 args 指定的字符，返回一个指向 s 的引用</span></span><br><span class="line">s.append(args)	<span class="comment">// 将 args 追加到 s, 返回一个指向 s 的引用</span></span><br><span class="line">s.replace(range, args)	<span class="comment">// 删除 s 中范围 range 内的字符，替换为 args 指定的字符</span></span><br><span class="line">                        <span class="comment">// range 为一个下标+长度，或为一对指向 s 的迭代器</span></span><br><span class="line">                        <span class="comment">// 返回一个指向 s 的引用</span></span><br></pre></td></tr></table></figure>
<p>args 可以是下列形式之一，str 不能与 s 相同，迭代器 b 和 e 不能指向 s</p>
<table>
<thead>
<tr class="header">
<th>args</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>str</td>
<td>字符串 str</td>
</tr>
<tr class="even">
<td>str, pos, len</td>
<td>str 中从 pos 开始最多 len 个字符</td>
</tr>
<tr class="odd">
<td>cp, len</td>
<td>从 cp 指向的字符数组的前(最多)len 个字符</td>
</tr>
<tr class="even">
<td>cp</td>
<td>cp 指向的以空字符结尾的字符数组</td>
</tr>
<tr class="odd">
<td>n, c</td>
<td>n 个字符 c</td>
</tr>
<tr class="even">
<td>b, e</td>
<td>迭代器 b 和 e 指定的范围内的字符</td>
</tr>
<tr class="odd">
<td>初始化列表</td>
<td>花括号包围的，以逗号分隔的字符列表</td>
</tr>
</tbody>
</table>
<p>append 和 assign 可以使用所有形式的 args</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>args</th>
<th>replace(pos,len,args)</th>
<th>replace(b,e,args)</th>
<th>insert(pos,args)</th>
<th>insert(iter,args)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>str</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>str, pos, len</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="odd">
<td>cp, len</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr class="even">
<td>cp</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr class="odd">
<td>n, c</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>b, e</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr class="odd">
<td>初始化列表</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>size 函数返回的是一个 string::size_type 类型的值，它是一个无符号类型。这种配套类型体现了标准库类型与机器无关的特性。</li>
</ul>
<blockquote>
<p>Tip：如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。</p>
</blockquote>
<ul>
<li>当把 string 对象和字符（或字符串）字面值混在一条语句中使用时，必须确保每个加法运算符 (+) 的两侧的运算对象至少有一个是 string。（字符串字面值与 string 是不同的的类型）</li>
</ul>
<h1 id="标准库类型-vector">标准库类型 vector</h1>
<p>标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。因为引用不是对象，所以不存在引用的 vector。</p>
<h2 id="定义和初始化-vector-对象">定义和初始化 vector 对象</h2>
<ul>
<li><p>初始化 vector 对象的方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1;                   <span class="comment">// v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2(v1);               <span class="comment">// v2 中包含有 v1 所有元素的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2 = v1;              <span class="comment">// 等价于 v2(v1)</span></span><br><span class="line">                                <span class="comment">// 注意两个 vector 对象的类型必须相同</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val);           <span class="comment">// v3 包含了 n 个重复的元素，每个元素的值都为 val</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v4(n);                <span class="comment">// v4 包含了 n 个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5&#123;a, b, c, ... &#125;;    <span class="comment">// v5 包含了初始值个数的元素，每个元素被赋予相应的初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5 = &#123;a, b, c, ... &#125;; <span class="comment">// 等价于 v5&#123;a, b, c, ... &#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在大多数情况下这些初始化的方式可以相互等价地使用，不过也有例外：</p>
<ul>
<li>使用拷贝初始化（即使用 =）时，只能提供一个初始值</li>
<li>如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化</li>
<li>如果提供的是初始元素值的列表，则只能把初始值放在花括号内执行列表初始化，而不能放圆括号内</li>
</ul></li>
<li><p>值初始化的两个特殊限制：</p>
<ul>
<li>有些类要求必须明确提供初始值时，只提供元素的数量而不设定初始值无法完成初始化工作</li>
<li>如果只提供了元素而没有设定初始值，只能使用直接初始化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = <span class="number">10</span>;    <span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(<span class="number">10</span>);     <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125;;        <span class="comment">// 列表初始化，v5 有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>);        <span class="comment">// 错误：不能用字符串字面值构造 vector 对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;          <span class="comment">// v7 有 10 个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;    <span class="comment">// v8 有 10 个值为 “hi” 的元素</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="vector-支持的操作">vector 支持的操作</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v.empty();              <span class="comment">// 如果 v 不含有任何元素，返回真；否则返回假</span></span><br><span class="line">v.size();               <span class="comment">// 返回 v 中元素的个数</span></span><br><span class="line">                        <span class="comment">// 返回值的类型是由 vector 定义的 size_type 类型</span></span><br><span class="line">v.push_back(t);         <span class="comment">// 向 v 的尾端添加一个值为 t 的元素</span></span><br><span class="line">v[n];                   <span class="comment">// 返回 v 中第 n 个位置上元素的引用</span></span><br><span class="line">v1 = v2;                <span class="comment">// 用 v2 中元素的拷贝替换 v1 中的元素</span></span><br><span class="line">v1 = &#123;a, b, c, ... &#125;;   <span class="comment">// 用列表中元素的拷贝替换 v1 中元素</span></span><br><span class="line">v1 == v2;               <span class="comment">// v1 和 v2 相等当且它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2;</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=            <span class="comment">// 字典序进行比较（前提是 vector 对象中元素的值可比较）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要使用 size_type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type      <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type           <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h1 id="迭代器">迭代器</h1>
<h2 id="使用迭代器">使用迭代器</h2>
<p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 begin 和 end 的成员： * begin 成员负责返回指向第一个元素（或第一个字符）的迭代器 * end 成员则负责返回指向容器（或 string 对象）“尾元素的下一个位置（one past the end）”的迭代器，称为尾后迭代器（off-the-end iterator） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end();    <span class="comment">// b 和 e 的类型相同</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。</p>
</blockquote>
<h2 id="标准容器迭代器的运算符">标准容器迭代器的运算符</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*iter               <span class="comment">// 返回迭代器 iter 所指元素的引用</span></span><br><span class="line">iter-&gt;mem           <span class="comment">// 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem</span></span><br><span class="line">                    <span class="comment">// 箭头运算符 -&gt; 将解引用和成员访问两个操作结合在一起</span></span><br><span class="line">++iter              <span class="comment">// 令 iter 指示容器中的下一个元素</span></span><br><span class="line">--iter              <span class="comment">// 令 iter 指示容器中的上一个元素</span></span><br><span class="line">iter1 == iter2      <span class="comment">// 如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等</span></span><br><span class="line">iter1 != iter2      <span class="comment">// 反之，不相等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p>
</blockquote>
<h2 id="迭代器类型">迭代器类型</h2>
<p>实际上，那些拥有迭代器的标准库类型使用 iteration 和 const_iterator 来表示迭代器的类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;           <span class="comment">// it 能读写 vector&lt;int&gt; 的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;               <span class="comment">// it2 能读写 string 对象中的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;    <span class="comment">// it3 只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;         <span class="comment">// it4 只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果标准库类型对象是常量，只能使用 const_iterator</li>
<li>如果标准库类型对象不是常量，那么既能使用 iterator，也能使用 const_iterator</li>
<li>begin 和 end 返回的具体类型由对象是否是常量决定
<ul>
<li>对象是常量，返回 const_iterator</li>
<li>对象不是常量，返回 iterator</li>
<li>专门返回 const_iterator 类型的函数：cbegin 和 cend</li>
</ul></li>
</ul>
<blockquote>
<p>WARNING：谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，这会使迭代器失效。</p>
</blockquote>
<h2 id="vector-和-string-迭代器支持的运算">vector 和 string 迭代器支持的运算</h2>
<p>string 和 vector 的迭代器比标准库容器迭代器提供了更多额外的运算符 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter + n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter - n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter += n       <span class="comment">// 迭代器加法的复合赋值语句</span></span><br><span class="line">iter -= n       <span class="comment">// 迭代器减法的复合赋值语句</span></span><br><span class="line">iter1 - iter2   <span class="comment">// 两个迭代器相减的结果是它们之间的距离。参与运算的两个迭代器必须指向的是同一个容器中的</span></span><br><span class="line">                <span class="comment">// 元素或者尾元素的下一个位置</span></span><br><span class="line">&gt;, &gt;=, &lt;, &lt;=    <span class="comment">// 参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置</span></span><br></pre></td></tr></table></figure></p>
<h1 id="顺序容器">顺序容器</h1>
<p>顺序容器是将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。标准库常用顺序容器如下： * vector，可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。 * deque，双端队列。支持快速随机访问，在头尾部插入速度很快。 * list，双向链表。支持双向顺序访问，在 list 中任何位置插入删除都很快。 * forward_list，单向链表。只支持单向顺序访问，在链表任何位置插入删除都很快。 容器只定义了少量操作，大多数额外操作则由算法库提供。容器类型的操作集合具有以下层次结构特点：一些操作适用于所有容器类型；另外一些操作则只适用于顺序或关联容器类型；还有一些操作只适用于顺序或关联容器类型的一个子集。</p>
<h2 id="顺序容器的定义和初始化">顺序容器的定义和初始化</h2>
<p>所有的容器都是类模版，要定义某种特殊的容器，必须在容器后的尖括号内提供存放元素的数据类型。容器元素类型必须满足以下两个约束： * 元素类型必须支持赋值运算； * 元素类型的对象必须可以复制。</p>
<p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。除了默认构造函数，容器类型还提供其他的构造函数，使程序员可以指定元素初值。在 C++11 中，我们可以对容器进行列表初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;  <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(svec);  <span class="comment">//将一个容器复制给另一个容器时，类型必须匹配</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());   <span class="comment">//初始化为一段元素的副本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::size_type list_size = <span class="number">64</span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(list_size, <span class="string">"eh"</span>);  <span class="comment">//分配和初始化指定数目的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Qin"</span>,<span class="string">"Li"</span>&#125;;  <span class="comment">//C++11列表初始化</span></span><br></pre></td></tr></table></figure></p>
<h2 id="顺序容器的常用操作">顺序容器的常用操作</h2>
<h3 id="添加元素">添加元素</h3>
<p><img src="/posts/64d148d3/001.png" alt="顺序容器添加元素"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; container;</span><br><span class="line"><span class="built_in">string</span> text_word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; text_word) </span><br><span class="line">     container.push_back(text_word); </span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">4</span>; ++ix) </span><br><span class="line">     ilist.push_front(ix);</span><br></pre></td></tr></table></figure></p>
<p>任何 insert 或 push 操作都可能导致迭代器失效。当编写循环将元素插入到 vector 或 deque 容器中时，程序必须确保迭代器在每次循环后都得到更新。为了避免存储 end 迭代器，可以在每次做完插入运算后重新计算 end 迭代器值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first = v.begin(); <span class="comment">//不要令last = v.end();</span></span><br><span class="line"><span class="keyword">while</span> (first != v.end()) </span><br><span class="line">&#123; </span><br><span class="line">     first = v.insert(first, <span class="number">42</span>); <span class="comment">// insert new value </span></span><br><span class="line">     ++first; <span class="comment">// advance first just past the element we added </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="改变容器的大小">改变容器的大小</h3>
<p>为避免每次添加元素都会执行内存分配和释放的操作，vector 和 string 每次获取新的内存空间时，都会分配比需求更大的空间作为备用，以此减少内存分配的次数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> a = c.size();  <span class="comment">//返回容器c中的元素个数</span></span><br><span class="line"><span class="keyword">bool</span> b = c.empty();  <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">c.resize(<span class="number">15</span>);		<span class="comment">// 将 5 个值为 0 的元素添加到 c 的末尾</span></span><br><span class="line">c.resize(<span class="number">20</span>, <span class="number">-1</span>);	<span class="comment">// 将 5 个值为 -1 的元素添加到 c 的末尾</span></span><br><span class="line">c.reserve(<span class="number">30</span>);  <span class="comment">// 分配至少能容纳 30 个元素的内存空间</span></span><br><span class="line">c.capacity();  <span class="comment">// 返回容器可以容纳的元素个数 30，此时 c.size()=20</span></span><br></pre></td></tr></table></figure></p>
<p>resize() 和 reserve() 区别： * size 指容器当前拥有的元素个数，调用 resize(n) 后，容器的 size 即为 n。 * capacity 则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。调用 reserve(n) 后，若容器的 <span class="math inline">\(capacity &lt; n\)</span>，则重新分配内存空间，从而使得 capacity 等于 n。如果 <span class="math inline">\(capacity \ge n\)</span>，capacity 无变化。 * 容器调用 resize() 函数后，所有的空间都已经初始化了，所以可以直接访问。而 reserve() 函数预分配出的空间没有被初始化，所以不可访问。</p>
<h3 id="删除元素">删除元素</h3>
<p><img src="/posts/64d148d3/002.png" alt="顺序容器删除元素"> pop_front 和 pop_back 函数的返回值并不是删除的元素值，而是 void。要获取删除的元素值，则必须在删除元素之前调用 front 或 back 函数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ilist.empty()) &#123; </span><br><span class="line">         process(ilist.front()); <span class="comment">// do something with the current top of ilist </span></span><br><span class="line">         ilist.pop_front();      <span class="comment">// done; remove first element </span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>erase 操作不会检查它的参数，因此必须确保用作参数的迭代器或迭代器范围是有效的。通常，程序员必须在容器中找出要删除的元素后，才使用 erase 操作。寻找一个指定元素的最简单方法是使用标准库的 find 算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">searchValue</span><span class="params">(<span class="string">"Quasimodo"</span>)</span></span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = find(slist.begin(), slist.end(), searchValue); </span><br><span class="line"><span class="keyword">if</span> (iter != slist.end())    </span><br><span class="line">    slist.erase(iter);</span><br></pre></td></tr></table></figure></p>
<h2 id="容器适配器">容器适配器</h2>
<p>除了顺序容器外，标准库来提供了三种容器适配器：stack、queue 和 priority_queue。适配器（adaptor）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，使得某种事物的行为看起来像另外一件事物一样。</p>
<p>实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括 stack、queue 和 priority_queue 类型。</p>
<p>栈的常用操作： * s.empty()，判断栈是否为空，为空则返回true。 * s.size()，返回栈中元素个数。 * s.pop()，删除栈顶元素，但不返回其值。 * s.top()，返回栈顶元素的值，不降元素弹出栈。 * s.push()，在栈顶压入新元素。</p>
<p>队列的常用操作： * q.empty() , q.size() 同栈 * q.pop()，删除队首元素，但不返回其值。 * q.push()，在队尾压入一个新元素。 * q.front()，返回队首元素，但不删除此元素 * q.back()，返回队尾元素。（只适用于 queue） * q.top()，返回最高优先级元素，但不删除此元素（只适用于 priority_queue）</p>
<h1 id="关联容器">关联容器</h1>
<p>关联容器支持通过键来高效地查找和读取元素，两个基本的关联容器类型是 map 和 set。 * map 的元素以键-值（key-value）对的形式组织：键用于元素在 map 中的索引，而值则表示所存储和读取的数据。 * set 仅包含一个键，并有效地支持关于某个键是否存在的查询。map 可理解为字典，set 可理解为一类元素的集合。</p>
<p>关联容器和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。</p>
<p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。 ## pair 类型 pair 包含两个数据值。在创建 pair 对象时，必须提供两个类型名：pair 对象所包含的两个数据成员各自对应的类型名字。如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;   <span class="comment">//利用 typedef 简化其声明</span></span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是公有的，分别命名为 first 和 second。只需使用普通的点操作符（成员访问标志）即可访问其成员： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook; </span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author.second == <span class="string">"Joyce"</span>) </span><br><span class="line">    firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure></p>
<p>除了构造函数，标准库还定义了一个 make_pair 函数，由传递给它的两个实参生成一个新的 pair 对象。可如下使用该函数创建新的 pair 对象，并赋给已存在的 pair 对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth; </span><br><span class="line"><span class="built_in">string</span> first, last; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123; </span><br><span class="line">    next_auth = make_pair(first, last); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="map-类型">map 类型</h2>
<p>map 对象的元素是键－值对，也即每个元素包含两个部分：键以及由键关联的值。map 的 value_type 就反映了这个事实。该类型比前面介绍的容器所使用的元素类型要复杂得多：value_type 是存储元素的键以及值的 pair 类型，而且键为 const。如下，word_count 数组的 value_type 为 pair&lt;const string, int&gt; 类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count.insert(make_pair(<span class="string">"James"</span>, <span class="string">"Joyce"</span>));</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin(); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br></pre></td></tr></table></figure></p>
<h3 id="给-map-添加元素">给 map 添加元素</h3>
<p>map 容器中添加键－值元素对，可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。在这两种情况下，一个给定的键只能对应于一个元素这一事实影响了这些操作的行为。</p>
<p>用下标操作符来获取该键所关联的值。 * 如果该键已在容器中，则返回该键所关联的值。 * 只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。此时，所关联的值采用值初始化：类类型的元素用默认构造函数初始化，而内置类型的元素初始化为 0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; <span class="comment">// empty map from string to int </span></span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) </span><br><span class="line">    ++word_count[word];</span><br></pre></td></tr></table></figure></p>
<p>使用下标给 map 容器添加新元素时，元素的值部分将采用值初始化。通常，我们会立即为其赋值，其实就是对同一个对象进行初始化并赋值。而插入元素的另一个方法是：直接使用 insert 成员，其语法更紧凑： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>)); </span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<p>map 对象中一个给定键只对应一个元素。如果试图插入的元素所对应的键已在容器中，则 insert 将不做任何操作。但是，带有一个键－值 pair 形参的 insert 版本将返回一个值：包含一个迭代器和一个 bool 值的 pair 对象，其中迭代器指向 map 中具有相应键的元素，而 bool 值则表示是否插入了该元素。如果该键已在容器中，则其关联的值保持不变，返回的 bool 值为 true。在这两种情况下，迭代器都将指向具有给定键的元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; </span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) &#123; </span><br><span class="line">    <span class="comment">// inserts element with key equal to word and value 1; </span></span><br><span class="line">    <span class="comment">// if word already in word_count, insert does nothing </span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = 			 											word_count.insert(make_pair(word, <span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!ret.second)          <span class="comment">// word already in word_count </span></span><br><span class="line">        ++ret.first-&gt;second;  <span class="comment">// increment counter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查找并读取-map-中的元素">查找并读取 map 中的元素</h3>
<p>不能使用下标来查找 map 中的某一元素是否存在，因为如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。</p>
<p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"foobar"</span>);</span><br><span class="line"><span class="keyword">if</span>(it != wor_count.end())</span><br><span class="line">    occurs = it-&gt;second;</span><br></pre></td></tr></table></figure></p>
<h3 id="从-map-对象中删除元素">从 map 对象中删除元素</h3>
<p><img src="/posts/64d148d3/003.png" alt="map删除元素"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word_count.erase(removal_word)) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ok: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" removed\n"</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"oops: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" not found!\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="map-对象的迭代遍历">map 对象的迭代遍历</h3>
<p>与其他容器一样，map 同样提供 begin 和 end 运算，以生成用于遍历整个容器的迭代器。例如，可如下将 map 容器 word_count 的内容输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = word_count.begin();</span><br><span class="line"><span class="keyword">while</span>(it != word_count.end())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs "</span></span><br><span class="line">            &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" times "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set-类型">set 类型</h2>
<p>map 容器是键－值对的集合，好比以人名为键的地址和电话号码。相反地，set 容器只是单纯的键的集合。例如，某公司可能定义了一个名为 bad_checks 的 set 容器，用于记录曾经给本公司发空头支票的客户。当只想知道一个值是否存在时，使用 set 容器是最适合的。例如，在接收一张支票前，该公司可能想查询 bad_checks 对象，看看该客户的名字是否存在。</p>
<p>set 容器支持大部分的 map 操作，包括上面描述的构造函数、 insert 操作、 count 和 find 操作、 erase 操作等。但是， 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。这一差别也体现了 set 存储的元素仅仅是键，而没有所关联的值。与 map 一样，set 容器存储的键也必须唯一，而且不能修改。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 20 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 10 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; set1;</span><br><span class="line">set1.insert(<span class="string">"the"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset2;</span><br><span class="line">iset2. insert( ivec.begin(), ivec.end() );     <span class="comment">// iset2 has 10 elements</span></span><br><span class="line"></span><br><span class="line">iset.find(<span class="number">1</span>);     <span class="comment">// returns iterator that refers to the element with key == 1</span></span><br><span class="line">iset.find(<span class="number">11</span>);   <span class="comment">// returns iterator == iset.end() </span></span><br><span class="line">iset.count(<span class="number">1</span>);    <span class="comment">// returns 1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = isec.find(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>正如不能修改 map 中元素的键部分一样，set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p>
<h2 id="multimap-和-multiset-类型">multimap 和 multiset 类型</h2>
<p>map 和 set 容器中，一个键只能对应一个实例。而 multiset 和 multimap 类型则允许一个键对应多个实例。例如，在电话簿中，每个人可能有单独的电话号码列表。在作者的文章集中，每位作者可能有单独的文章标题列表。<strong>multimap 和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和 set 头文件。</strong></p>
<p>multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。为了顺应一个键可以对应多个值这一性质，map 和 multimap，或 set 和 multiset 中相同的操作都以不同的方式做出了一定的修改。在使用 multimap 或 multiset 时，对于某个键，必须做好处理多个值的准备，而非只有单一的值。</p>
<p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p>
<p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p>
<p>关联容器 map 和 set 的元素是按顺序存储的， multimap 和 multset 也一样。因此，在 multimap 和 multiset 容器中，如果某个键对应多个实例，则这些实例在容器中将相邻存放。 在 multimap 和 multiset 中查找元素有三种策略，而且三种策略都基于一个事实——在 multimap 中，同一个键所关联的元素必然相邻存放。 * 使用 find 和 count 操作 * lower_bound 和 upper_bound * enual_range 函数</p>
<figure>
<img src="/posts/64d148d3/004.png" alt=""><figcaption>multimap/set查找</figcaption>
</figure>
<p>equal_range 函数返回存储一对迭代器的 pair 对象。如果该值存在，则 pair 对象中的第一个迭代器指向该键关联的第一个实例，第二个迭代器指向该键关联的最后一个实例的下一位置。如果找不到匹配的元素，则 pair 对象中的两个迭代器都将指向此键应该插入的位置。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;authors_it, authors_it&gt; pos = authors.equal_range(search_item); </span><br><span class="line"><span class="keyword">while</span> (pos.first != pos.second) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    ++pos.first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="常用泛型算法">常用泛型算法</h1>
<p>标准库为容器类型定义的操作很少，并没有为每个容器实现更多的操作。因为这部分操作可以抽象出来为所有的容器工作，那就是泛型算法。所谓“泛型”是指这些算法可以应用于多种容器类型上，而容器内的元素类型也可以多样化。标准库提供了 100 多个泛型算法，主要定义于头文件&lt;algorithm&gt; 中，还有一组泛化的算术算法定义于头文件 &lt;numeric&gt; 中。</p>
<p>大多数泛型算法是工作于容器的一对迭代器所标识的范围，并完全通过迭代器来实现其功能。这段由迭代器指定的范围称为“输入范围”。带有输入范围参数的算法总是使用前两个参数标记该范围，分别指向要处理的第一个元素和最后一个元素的下一个位置。</p>
<h2 id="查找">查找</h2>
<p>find 和 count 算法在输入范围中查找指定值。find 算法返回引用第一个匹配元素的迭代器，count 算法返回元素在输入序列中出现次数的计数。它们都在输入范围中查找等于 val 的元素，使用基础类型的相等（==）操作符。find 返回第一个匹配元素的迭代器，如果不存在在匹配元素就返回 end。count 返回 val 出现次数的计数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val); </span><br><span class="line">count(beg, end, val);</span><br></pre></td></tr></table></figure></p>
<p>find 函数的源码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*first == val)	<span class="keyword">return</span> first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个例子，查找数组中的某个值。由于指针就像内置数组上的迭代器一样，因此可以用find在数组中查找值。使用begin和end函数可以获取指向数组首尾元素的指针。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myints[]=&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    p = find(begin(myints), end(myints), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != myints+<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="排序">排序</h2>
<p>C++ 中最经常使用的算法应该就是排序算法，也就是 sort 函数。当然还有 partial_sort 以及stable_sort。sort 函数排序默认是从小到大，如果想给自定义类型排序，可以重载运算符或者自定义比较函数。 * 升序：sort(begin, end, less&lt;data-type&gt;()); * 降序：sort(begin, end, greater&lt;data-type&gt;()); <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">43</span>,<span class="number">24</span>,<span class="number">65</span>&#125;,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a,a+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，也可以自己写比较函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">100</span>];   </span><br><span class="line">&#125;str[<span class="number">100</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data &amp;elem1, <span class="keyword">const</span> Data &amp;elem2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(elem1.data, elem2.data) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, i;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str[i].data;  </span><br><span class="line">          </span><br><span class="line">        sort(str, str+n, cmp);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i].data &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="去重">去重</h2>
<p>unique 的作用是从输入序列中删除”所有相邻的重复元素。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器（容器的长度没变，只是元素顺序改变了），表示无重复的值范围的结束。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end());   <span class="comment">//排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator end_unique = </span><br><span class="line">            unique(words.begin(), words.end());  <span class="comment">//去重</span></span><br><span class="line">words.erase(end_unique, words.end());  <span class="comment">//删除结尾元素</span></span><br></pre></td></tr></table></figure></p>
<p>在 STL 中 unique 函数是一个去重函数， unique 的功能是去除相邻的重复元素(只保留一个)，其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中， 返回去重后最后一个元素的地址，因为 unique 去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p>
<p>源代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">unique</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (first==last) <span class="keyword">return</span> last;</span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (++first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*result == *first))    *(++result)=*first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="赋值">赋值</h2>
<p>fill 函数可以可以向容器当中的一定范围能赋值，一共接受 3 个参数，类似于 memset 函数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(beg, end, val)</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/STL/" rel="tag"># STL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/db684f2c/" rel="next" title="C++面试知识点">
                  <i class="fa fa-chevron-left"></i> C++面试知识点
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/7543f9ab/" rel="prev" title="运维开发工程师面经">
                  运维开发工程师面经 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库类型-string"><span class="nav-number">1.</span> <span class="nav-text">标准库类型 string</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义和初始化-string-对象"><span class="nav-number">1.1.</span> <span class="nav-text">定义和初始化 string 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-对象上的操作"><span class="nav-number">1.2.</span> <span class="nav-text">string 对象上的操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库类型-vector"><span class="nav-number">2.</span> <span class="nav-text">标准库类型 vector</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义和初始化-vector-对象"><span class="nav-number">2.1.</span> <span class="nav-text">定义和初始化 vector 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-支持的操作"><span class="nav-number">2.2.</span> <span class="nav-text">vector 支持的操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器"><span class="nav-number">3.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用迭代器"><span class="nav-number">3.1.</span> <span class="nav-text">使用迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准容器迭代器的运算符"><span class="nav-number">3.2.</span> <span class="nav-text">标准容器迭代器的运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器类型"><span class="nav-number">3.3.</span> <span class="nav-text">迭代器类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-和-string-迭代器支持的运算"><span class="nav-number">3.4.</span> <span class="nav-text">vector 和 string 迭代器支持的运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#顺序容器"><span class="nav-number">4.</span> <span class="nav-text">顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器的定义和初始化"><span class="nav-number">4.1.</span> <span class="nav-text">顺序容器的定义和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器的常用操作"><span class="nav-number">4.2.</span> <span class="nav-text">顺序容器的常用操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加元素"><span class="nav-number">4.2.1.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变容器的大小"><span class="nav-number">4.2.2.</span> <span class="nav-text">改变容器的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">4.2.3.</span> <span class="nav-text">删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器适配器"><span class="nav-number">4.3.</span> <span class="nav-text">容器适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关联容器"><span class="nav-number">5.</span> <span class="nav-text">关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map-类型"><span class="nav-number">5.1.</span> <span class="nav-text">map 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#给-map-添加元素"><span class="nav-number">5.1.1.</span> <span class="nav-text">给 map 添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找并读取-map-中的元素"><span class="nav-number">5.1.2.</span> <span class="nav-text">查找并读取 map 中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-map-对象中删除元素"><span class="nav-number">5.1.3.</span> <span class="nav-text">从 map 对象中删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-对象的迭代遍历"><span class="nav-number">5.1.4.</span> <span class="nav-text">map 对象的迭代遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-类型"><span class="nav-number">5.2.</span> <span class="nav-text">set 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multimap-和-multiset-类型"><span class="nav-number">5.3.</span> <span class="nav-text">multimap 和 multiset 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用泛型算法"><span class="nav-number">6.</span> <span class="nav-text">常用泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">6.1.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">6.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#去重"><span class="nav-number">6.3.</span> <span class="nav-text">去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值"><span class="nav-number">6.4.</span> <span class="nav-text">赋值</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="KyoAni"
    src="/images/k-on.jpg">
  <p class="site-author-name" itemprop="name">KyoAni</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yz1509" title="GitHub &rarr; https://github.com/yz1509" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pro-765@qq.com" title="E-Mail &rarr; mailto:pro-765@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KyoAni</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
