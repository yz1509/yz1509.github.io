<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Redis Modules APIs 介绍。">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis Modules APIs">
<meta property="og:url" content="https://yz1509.github.io/posts/3720c85c/index.html">
<meta property="og:site_name" content="HTT">
<meta property="og:description" content="Redis Modules APIs 介绍。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-09-01T10:29:14.267Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis Modules APIs">
<meta name="twitter:description" content="Redis Modules APIs 介绍。">

<link rel="canonical" href="https://yz1509.github.io/posts/3720c85c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Redis Modules APIs | HTT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HTT</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">ふわふわ時間</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/3720c85c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/k-on.jpg">
      <meta itemprop="name" content="KyoAni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HTT">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis Modules APIs
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 10:45:48" itemprop="dateCreated datePublished" datetime="2020-08-27T10:45:48+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-01 18:29:14" itemprop="dateModified" datetime="2020-09-01T18:29:14+08:00">2020-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis Modules APIs 介绍。</p>
<a id="more"></a>
<hr>
<p><a href="https://github.com/redis/redis/blob/unstable/src/module.c" target="_blank" rel="noopener">源码地址</a></p>
<h2 id="内存管理">内存管理</h2>
<p>虽然在模块中可以调用 <code>malloc()</code> 和 <code>free()</code> 函数，但是通过 <code>malloc()</code> 分配的内存并不会被计算到 <code>used_memory</code> 信息中去，也不会受到 <code>maxmemory</code> 限制，所以应首先考虑使用 Redis Modules 提供的 APIs。而且，使用 APIs 分配内存实现的自定义数据结构也可以被 RDB 加载函数正确地反序列化。</p>
<p>在函数返回时就需释放的短期对象可使用内存池模式进行分配。内存对齐原则为：</p>
<ul>
<li>若申请的内存大于 <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)" target="_blank" rel="noopener">word size</a>，则按 <code>word size</code> 对齐</li>
<li>若申请的内存小于 <code>word size</code>，则按 2 的幂字节对齐</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Use like malloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Alloc</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like calloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like realloc() for memory obtained with RedisModule_Alloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like free() for memory obtained by RedisModule_Alloc()</span></span><br><span class="line"><span class="comment"> * and RedisModule_Realloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like strdup() but returns memory allocated with RedisModule_Alloc(). */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_Strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return heap allocated memory that will be freed automatically when the</span></span><br><span class="line"><span class="comment"> * module callback function returns */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_PoolAlloc</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable automatic memory management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function must be called as the first function of a command implementation</span></span><br><span class="line"><span class="comment"> * that wants to use automatic memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_AutoMemory</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For a given pointer allocated via RedisModule_Alloc() or</span></span><br><span class="line"><span class="comment"> * RedisModule_Realloc(), return the amount of memory allocated for it.</span></span><br><span class="line"><span class="comment"> * Note that this may be different (larger) than the memory we allocated</span></span><br><span class="line"><span class="comment"> * with the allocation calls, since sometimes the underlying allocator</span></span><br><span class="line"><span class="comment"> * will allocate more memory. */</span></span><br><span class="line"><span class="keyword">size_t</span> RedisModule_MallocSize(<span class="keyword">void</span>* ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the a number between 0 to 1 indicating the amount of memory</span></span><br><span class="line"><span class="comment"> * currently used, relative to the Redis "maxmemory" configuration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 - No memory limit configured.</span></span><br><span class="line"><span class="comment"> * Between 0 and 1 - The percentage of the memory used normalized in 0-1 range.</span></span><br><span class="line"><span class="comment"> * Exactly 1 - Memory limit reached.</span></span><br><span class="line"><span class="comment"> * Greater 1 - More memory used than the configured limit. */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RedisModule_GetUsedMemoryRatio</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="service-api-exported-to-modules">Service API exported to modules</h2>
<h3 id="注册命令">注册命令</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a new command in the Redis server. The function returns REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if the specified command name is already busy or a set of invalid flags were</span></span><br><span class="line"><span class="comment"> * passed, otherwise REDISMODULE_OK is returned and the new command is registered. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CreateCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name, RedisModuleCmdFunc cmdfunc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *strflags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> firstkey, <span class="keyword">int</span> lastkey, <span class="keyword">int</span> keystep)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数必须在 <code>RedisModule_OnLoad()</code> 中调用，命令的执行由传入的 <code>cmdfunc</code> 完成，其 <code>prototype</code> 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The command function type is the following,</span></span><br><span class="line"><span class="comment"> * and is supposed to always return REDIMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCmd_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>strflags</code> 确定了该命令的行为模式，其值的列表如下，如要传递多个 flags，则以空格隔开.</p>
<ul>
<li><code>write</code>: The command may modify the data set(it may also read from it)</li>
<li><code>readonly</code>: The command returns data from keys but never writes</li>
<li><code>admin</code>: The command is an administrative command (may change replication or perform similar tasks).</li>
<li><code>deny-oom</code>: The command may use additional memory and should be denied during out of memory conditions.</li>
<li><code>deny-script</code>: Don't allow this command in Lua scripts.</li>
<li><code>allow-loading</code>: Allow this command while the server is loading data. Only commands not interacting with the data set should be allowed to run in this mode. If not sure don't use this flag.</li>
<li><code>pubsub</code>: The command publishes things on Pub/Sub channels.</li>
<li><code>random</code>: The command may have different outputs even starting from the same input arguments and key values.</li>
<li><code>allow-stale</code>: The command is allowed to run on slaves that don't serve stale data. Don't use if you don't know what this means.</li>
<li><code>no-monitor</code>: Don't propagate the command on monitor. Use this if the command has sensible data among the arguments.</li>
<li><code>no-slowlog</code>: Don't log this command in the slowlog. Use this if the command has sensible data among the arguments.</li>
<li><code>fast</code>: The command time complexity is not greater than O(log(N)) where N is the size of the collection or anything else representing the normal scalability issue with the command.</li>
<li><code>getkeys-api</code>: The command implements the interface to return the arguments that are keys. Used when start/stop/step is not enough because of the command syntax.</li>
<li><code>no-cluster</code>: The command should not register in Redis Cluster since is not designed to work with it because, for example, is unable to report the position of the keys, programmatically creates key names, or any other reason.</li>
<li><code>no-auth</code>: This command can be run by an un-authenticated client. Normally this is used by a command that is used to authenticate a client.</li>
</ul>
<p><code>firstkey</code> 表明在执行该注册的命令之时，需要读取的首个 key，其值为 0 则视为无需读取 key，<code>lastkey</code> 亦是如此。</p>
<h3 id="其他">其他</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lookup the requested module API and store the function pointer</span></span><br><span class="line"><span class="comment"> * into the target pointer. The function returns REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if there is no such named API, otherwise REDISMODULE_OK.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is not meant to be used by modules developer, it is only</span></span><br><span class="line"><span class="comment"> * used implicitly by including redismodule.h. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetApi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *funcname, <span class="keyword">void</span> **targetPtrPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command, that was declared with the</span></span><br><span class="line"><span class="comment"> * flag "getkeys-api", is called in a special way to get the keys</span></span><br><span class="line"><span class="comment"> * position and not to get executed. Otherwise zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsKeysPositionRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uses this function to report keys.</span></span><br><span class="line"><span class="comment"> * example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     if (RedisModule_IsKeysPositionRequest(ctx)) &#123;</span></span><br><span class="line"><span class="comment"> *         RedisModule_KeyAtPos(ctx,1);</span></span><br><span class="line"><span class="comment"> *         RedisModule_KeyAtPos(ctx,2);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_KeyAtPos</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called by RM_Init() to setup the ctx-&gt;module structure */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetModuleAttribs</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> ver, <span class="keyword">int</span> apiver)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if the module name is busy. Otherwise zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsModuleNameBusy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current UNIX time in milliseconds. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_Milliseconds</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set flags defining capabilities or behavior bit flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i.e. REDISMODULE_OPTIONS_HANDLE_IO_ERRORS:</span></span><br><span class="line"><span class="comment"> * Generally, modules don't need to bother with this, as the process will just</span></span><br><span class="line"><span class="comment"> * terminate if a read error happens, however, setting this flag would allow</span></span><br><span class="line"><span class="comment"> * repl-diskless-load to work if enabled.</span></span><br><span class="line"><span class="comment"> * The module should use RedisModule_IsIOError after reads, before using the</span></span><br><span class="line"><span class="comment"> * data that was read, and in case of error, propagate it upwards, and also be</span></span><br><span class="line"><span class="comment"> * able to release the partially populated value and all it's allocations. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetModuleOptions</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Signals that the key is modified from user's perspective</span></span><br><span class="line"><span class="comment"> * i.e. invalidate WATCH and client side caching. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SignalModifiedKey</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="redismodulestring-objects-apis">RedisModuleString objects APIs</h2>
<h3 id="create">Create</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new module string object by copying the len bytes starting ar ptr.</span></span><br><span class="line"><span class="comment"> * No reference is retained to the passed buffer. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string object from a printf format and arguments.</span></span><br><span class="line"><span class="comment"> * The string is created using the sds formatter function sdscatvprintf(). */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringPrintf</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a long long integer */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromLongLong</span><span class="params">(RedisModuleCtx *ctx</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a double */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromDouble</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a long double */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromLongDouble</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> <span class="keyword">double</span> ld, <span class="keyword">int</span> humanfriendly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from another RedisModuleString */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在未启用自动内存管理功能时，上述接口所返回的对象必须调用 <code>RedisModule_FreeString()</code> 进行释放</li>
<li>当你想在上下文范围之外创建一个 <code>RedisModuleString</code> 对象时，<code>ctx</code> 可设置为 <code>NULL</code>，此时，自动内存管理功能不可用，你必须手动进行释放操作</li>
</ul>
<h3 id="free">Free</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a module string object obtained with one of the</span></span><br><span class="line"><span class="comment"> * Redis Module API calls that return new string objects. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在启用自动内存管理的情况下，我们仍然可以调用该函数，会立即释放传入的 <code>RedisModuleString</code>，并从字符串待释放列表中移除该对象</li>
<li>如果在创建 <code>RedisModuleString</code> 时上下文为 <code>NULL</code>，则在释放时上下文也可为 <code>NULL</code>，不过此时上下文不为 <code>NULL</code> 也没啥问题。但如果创建时上下文不为空，则在释放时也不可为空。</li>
</ul>
<h3 id="retain">Retain</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_RetainString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通常而言，只有在以下条件都满足时，才会调用这个函数：</p>
<ul>
<li>You have automatic memory management enabled</li>
<li>You want to create string objects</li>
<li>Those string objects you create need to live after the callback function creating them returns</li>
</ul></li>
<li><p>每次调用该函数，必须额外调用一次 <code>RedisModule_FreeString()</code> 以真正释放内存。</p></li>
<li><p>在该函数中，上下文也可以为空。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_HoldString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>RedisModule_RetainString()</code> 中只有在无法从字符串待释放列表中移除该字符串时，才会增加引用次数；而调用 <code>RedisModule_HoldString()</code> 总是会成功达到目的。</li>
<li>调用该函数时，在传入字符串的引用次数达到上限 <code>INT_MAX - 1</code> 时，调用 <code>RedisModule_CreateStringFromString()</code> 复制，返回副本的指针；否则，增加引用次数，返回传入字符串指针。所以该函数比 <code>RedisModule_CreateStringFromString()</code> 效率更高。</li>
<li>在未开启自动内存管理时，需要手动调用 <code>RedisModule_FreeString()</code>。</li>
<li>在该函数中，上下文也可以为空。</li>
</ul>
<h3 id="convert">Convert</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the string pointer and length of the given module string.</span></span><br><span class="line"><span class="comment"> * Return value should only be used for read only access and never modified. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_StringPtrLen</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a long long integer, storing it at *ll.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success. if the string can't be parsed as a valid,</span></span><br><span class="line"><span class="comment"> * strict long long(no sapces before/after), REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToLongLong</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">long</span> <span class="keyword">long</span> *ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a double, storing it at *d.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success or REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if the string is not a valid string representation of a double value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToDouble</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">double</span> *d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a long double, storing it at *ld.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success or REDISMODULE_ERR if the</span></span><br><span class="line"><span class="comment"> * string is not a valid string representation of a long double value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToLongDouble</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">long</span> <span class="keyword">double</span> *ld)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="operators">Operators</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare two string objects, returning -1, 0 or 1 respectively if a &lt; b,</span></span><br><span class="line"><span class="comment"> * a == b or a &gt; b. String are compared byte by byte as two binary blobs</span></span><br><span class="line"><span class="comment"> * without any encoding care/collation attempt. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringCompare</span><span class="params">(RedisModuleString *a, RedisModuleString *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Append the specified buffer to the string str. The string must be</span></span><br><span class="line"><span class="comment"> * a string created by the user that is referenced only a single time,</span></span><br><span class="line"><span class="comment"> * otherwise REDISMOUDLE_ERR is returned and the operation is not performed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringAppendBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *str,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="reply-apis">Reply APIs</h2>
<h3 id="reply-with-numeral">Reply with numeral</h3>
<p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send an integer reply to the client, with the specified long long value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithLongLong</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a string reply obtained converting the double 'd' into a bulk string.</span></span><br><span class="line"><span class="comment"> * This function is basically equivalent to converting a double into a string</span></span><br><span class="line"><span class="comment"> * into a C buffer, and then calling the function</span></span><br><span class="line"><span class="comment"> * RedisModule_ReplyWithStringBuffer() with the buffer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithDouble</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a string reply obtained converting the long double 'ld' into a bulk</span></span><br><span class="line"><span class="comment"> * string. This function is basically equivalent to converting a long double</span></span><br><span class="line"><span class="comment"> * into a string into a C buffer, and then calling the function</span></span><br><span class="line"><span class="comment"> * RedisModule_ReplyWithStringBuffer() with the buffer and length.</span></span><br><span class="line"><span class="comment"> * The double string uses human readable formatting</span></span><br><span class="line"><span class="comment"> * (see addReplyHumanLongDouble in networking.c). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithLongDouble</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> <span class="keyword">double</span> ld)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="reply-with-string">Reply with string</h3>
<p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reply with a simple string(+...\r\n in RESP protocol). This replies are</span></span><br><span class="line"><span class="comment"> * suitable only when sending a small non-binary string with small overhead,</span></span><br><span class="line"><span class="comment"> * like "OK" or similar replies. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithSimpleString</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a C buffer pointer</span></span><br><span class="line"><span class="comment"> * that is assumed to be null-terminated. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithCString</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a C buffer pointer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithStringBuffer</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a RedisModuleString object. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with an empty string */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithEmptyString</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a binary safe string, which should not be escaped or filtered</span></span><br><span class="line"><span class="comment"> * taking in input a C buffer pointer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithVerbatimString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="reply-with-array">Reply with array</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reply with an array type of 'len' elements.</span></span><br><span class="line"><span class="comment"> * However 'len' other calls to ReplyWith* style functions must follow in order to</span></span><br><span class="line"><span class="comment"> * emit the elements of the array. The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithArray</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When RedisModule_ReplyWithArray() is used with the argument</span></span><br><span class="line"><span class="comment"> * REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number</span></span><br><span class="line"><span class="comment"> * of items we are going to output as elements of the array, this function will</span></span><br><span class="line"><span class="comment"> * take care to set the array length.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since it is possible to have multiple array replies pending with unknown</span></span><br><span class="line"><span class="comment"> * length, this function guarantees to always set the latest array length</span></span><br><span class="line"><span class="comment"> * that was created in a postponed way. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ReplySetArrayLength</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to the client with a null array, simple null in RESP3</span></span><br><span class="line"><span class="comment"> * null array in RESP2. The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithNullArray</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to client with an empty array.</span></span><br><span class="line"><span class="comment"> * The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithEmptyArray</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="others">Others</h3>
<p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send an error about the number of arguments given to the command,</span></span><br><span class="line"><span class="comment"> * citing the command name in the error message. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_WrongArity</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to client with a NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithNull</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with the error 'err'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'err' must contain all the error, including</span></span><br><span class="line"><span class="comment"> * the initial error code. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithError</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply exactly what a Redis command returned us with RedisModule_Call().</span></span><br><span class="line"><span class="comment"> * This function is useful when we use RedisModule_Call() in order to execute</span></span><br><span class="line"><span class="comment"> * some command, as we want to reply to the client exactly the same reply</span></span><br><span class="line"><span class="comment"> * we obtained by the command. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithCallReply</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RedisModuleCallReply *reply)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="commands-replication-apis">Commands replication APIs</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replicate the specified command and arguments to slaves and AOF, as effect</span></span><br><span class="line"><span class="comment"> * of execution of the calling command implementation. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Replicate</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制的命令在 <code>MULTI/EXEC</code> 块中，其包含在该 module command 执行期间调用的所有命令，在 <code>MULTI/EXEC</code> 块中，通过 <code>RedisModule_Call()</code> 复制的命令在前，<code>RedisModule_Replicate</code> 复制的命令在后。Modules 应该只使用两个接口其中一个。</li>
<li>该函数的接口和 <code>RedisModule_Call()</code> 相同，可查看 <code>RedisModule_Call()</code> 了解详情</li>
<li>格式说明符非法或不存在该 <code>cmdname</code> 时，函数返回 <code>REDISMODULE_ERR</code></li>
</ul>
<blockquote>
<p>Note about calling this function from a thread safe context: Normally when you call this function from the callback implementing a module command, or any other callback provided by the Redis Module API, Redis will accumulate all the calls to this function in the context of the callback, and will propagate all the commands wrapped in a MULTI/EXEC transaction. However when calling this function from a threaded safe context that can live an undefined amount of time, and can be locked/unlocked in at will, the behavior is different: MULTI/EXEC wrapper is not emitted and the command specified is inserted in the AOF and replication stream immediately.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replicate the command exactly as it was invoked by the client. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplicateVerbatim</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制的命令不会包含在 <code>MULTI/EXEC</code> 块中，所以不要和其他命令复制的接口混用</li>
<li>常用于想将客户端请求的命令直接复制转发至 <code>slave</code> 或 <code>AOF</code> 的场景</li>
<li>返回值固定为 <code>REDISMODULE_OK</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if some client sent the CLIENT PAUSE command to the server or</span></span><br><span class="line"><span class="comment"> * if Redis Cluster is doing a manual failover, and paused tue clients.</span></span><br><span class="line"><span class="comment"> * This is needed when we have a master with replicas, and want to write,</span></span><br><span class="line"><span class="comment"> * without adding further data to the replication channel, that the replicas</span></span><br><span class="line"><span class="comment"> * replication offset, match the one of the master. When this happens, it is</span></span><br><span class="line"><span class="comment"> * safe to failover the master without data loss.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However modules may generate traffic by calling RedisModule_Call() with</span></span><br><span class="line"><span class="comment"> * the "!" flag, or by calling RedisModule_Replicate(), in a context outside</span></span><br><span class="line"><span class="comment"> * commands execution, for instance in timeout callbacks, threads safe</span></span><br><span class="line"><span class="comment"> * contexts, and so forth. When modules will generate too much traffic, it</span></span><br><span class="line"><span class="comment"> * will be hard for the master and replicas offset to match, because there</span></span><br><span class="line"><span class="comment"> * is more data to send in the replication channel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So modules may want to try to avoid very heavy background work that has</span></span><br><span class="line"><span class="comment"> * the effect of creating data to the replication channel, when this function</span></span><br><span class="line"><span class="comment"> * returns true. This is mostly useful for modules that have background</span></span><br><span class="line"><span class="comment"> * garbage collection tasks, or that do writes and replicate such writes</span></span><br><span class="line"><span class="comment"> * periodically in timer callbacks or other periodic callbacks. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AvoidReplicaTraffic</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="db-and-key-apis----generic-apis">DB and Key APIs -- Generic APIs</h2>
<p><strong>GetClientId</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return th ID of the current client calling the currently active module cmd. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_GetClientId</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个客户端 ID 是唯一的，单调递增的，取值范围为 <span class="math inline">\([1, 2^{64} - 1]\)</span></li>
<li>返回 0 则意味着在当前上下文中无法获取客户端 ID</li>
<li>获取客户端 ID 后，可通过调用 <code>RedisModule_IsAOFClient(id)</code> 等判断当前客户端是否为指定类型</li>
</ul>
<p><strong>GetClientInfoById</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return information about the client with the specified ID. If the client</span></span><br><span class="line"><span class="comment"> * exists, REDISMODULE_OK is returned, otherwise REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetClientInfoById</span><span class="params">(<span class="keyword">void</span> *ci, <span class="keyword">uint64_t</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当对应的客户端存在且传入的 <code>ci</code> 指向一个 <code>RedisModuleClientInfo</code> 结构体时，会使用客户端信息填充该结构体，其包含以下成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> flags;     <span class="comment">// REDISMODULE_CLIENTINFO_FLAG_*</span></span><br><span class="line"><span class="keyword">uint64_t</span> id;        <span class="comment">// Client ID</span></span><br><span class="line"><span class="keyword">char</span> addr[<span class="number">46</span>];      <span class="comment">// IPv4 or IPv6 address</span></span><br><span class="line"><span class="keyword">uint16_t</span> port;      <span class="comment">// TCP port</span></span><br><span class="line"><span class="keyword">uint16_t</span> db;        <span class="comment">// Selected DB</span></span><br></pre></td></tr></table></figure>
<p>该结构体可被 <code>REDISMODULE_CLIENTINFO_INITIALIZER</code> 初始化，其中 <code>flags</code> 的种类如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">flag</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_SSL</td>
<td style="text-align: left;">Client using SSL connection.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_PUBSUB</td>
<td style="text-align: left;">Client in Pub/Sub mode.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_BLOCKED</td>
<td style="text-align: left;">Client blocked in command.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_TRACKING</td>
<td style="text-align: left;">Client with keys tracking on.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET</td>
<td style="text-align: left;">Client using unix domain socket.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_MULTI</td>
<td style="text-align: left;">Client in MULTI state.</td>
</tr>
</tbody>
</table>
<p>当传入的 <code>ci</code> 为 <code>NULL</code> 时，会直接返回 <code>REDISMODULE_OK</code> 或 <code>REDISMODULE_ERR</code> 表明对应的客户端存在/不存在。</p>
<p><strong>PublishMessage</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Publish a message to subscribers (see PUBLISH command). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_PublishMessage</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *channel, RedisModuleString *message)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>GetSelectedDb</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the currently selected DB. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetSelectedDb</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>SelectDb</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Change the currently selected DB. Returns an error if the id is out of range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SelectDb</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> newid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若调用该函数，直接返回响应后，客户端会一直保留该函数执行后所选择的 <code>DB</code>。因此，如想切换回之前的 <code>DB</code>，可调用 <code>RedisModule_GetSelectedDb()</code> 保存之前的 <code>DB</code>，并在返回响应前，切换回原先的 <code>DB</code>。</p>
<p><strong>DbSize</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the number of keys in the current db. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_DbSize</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>ResetDataset</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ResetDataset</span><span class="params">(<span class="keyword">int</span> restart_aof, <span class="keyword">int</span> async)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行与 <code>FLUSHALL</code> 类似的操作</li>
<li>在启用 <code>AOF</code> 的情况下，如果 <code>restart_aof</code> 为 <code>true</code>，则会启动一个新的 <code>AOF</code> 文件，必须确保该命令不会传播到新的 <code>AOF</code> 文件</li>
<li>如果 <code>async</code> 设置为 <code>true</code>，则释放数据占用内存的操作会在后台线程中执行</li>
</ul>
<p><strong>GetContextFlags</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the current context's flags. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetContextFlags</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>上下文标志会包含当前请求信息和实例信息</li>
<li>也可以对 <code>NULL</code> 上下文调用该函数</li>
</ul>
<p>其中 <code>flags</code> 的种类如下：</p>
<table>
<colgroup>
<col style="width: 55%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">flag</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_LUA</td>
<td style="text-align: left;">The command is running in a Lua script</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_MULTI</td>
<td style="text-align: left;">The command is running inside a transaction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_REPLICATED</td>
<td style="text-align: left;">The command was sent over the replication link by the MASTER</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_MASTER</td>
<td style="text-align: left;">The Redis instance is a master</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_SLAVE</td>
<td style="text-align: left;">The Redis instance is a slave</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_READONLY</td>
<td style="text-align: left;">The Redis instance is read-only</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_CLUSTER</td>
<td style="text-align: left;">The Redis instance is in cluster mode</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_AOF</td>
<td style="text-align: left;">The Redis instance has AOF enabled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_RDB</td>
<td style="text-align: left;">The instance has RDB enabled</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_MAXMEMORY</td>
<td style="text-align: left;">The instance has Maxmemory set</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_EVICT</td>
<td style="text-align: left;">Maxmemory is set and has an eviction policy that may delete keys</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_OOM</td>
<td style="text-align: left;">Redis is out of memory according to the maxmemory setting.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_OOM_WARNING</td>
<td style="text-align: left;">Less than 25% of memory remains before reaching the maxmemory level.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_LOADING</td>
<td style="text-align: left;">Server is loading RDB/AOF</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_STALE</td>
<td style="text-align: left;">No active link with the master.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_CONNECTING</td>
<td style="text-align: left;">The replica is trying to connect with the master.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_TRANSFERRING</td>
<td style="text-align: left;">Master -&gt; Replica RDB transfer is in progress.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_ONLINE</td>
<td style="text-align: left;">The replica has an active link with its master. This is the contrary of STALE state.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULECTXFLAGS_ACTIVE_CHILD</td>
<td style="text-align: left;">There is currently some background process active (RDB, AUX or module).</td>
</tr>
</tbody>
</table>
<h2 id="low-level-key-apis">Low level Key APIs</h2>
<h3 id="base">Base</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return an handle representing a Redis key, so that it is possible to call</span></span><br><span class="line"><span class="comment"> * other APIs with the key handle as argument to perform operations on the key. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_OpenKey</span><span class="params">(RedisModuleCtx *ctx, robj *keyname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过 <code>RedisModule_OpenKey()</code> 返回的 <code>RedisModuleKey</code>，在对其访问结束之前，必须调用 <code>RedisModule_CloseKey()</code> 以释放句柄。</p>
<p>调用 <code>RedisModule_OpenKey()</code> 传入的 key 不存在时：</p>
<ul>
<li>如果是 <code>REDISMODULE_WRITE</code> 模式，仍会返回句柄</li>
<li>如果仅是 <code>REDISMODULE_READ</code> 模式，则会返回 <code>NULL</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Close a key handle. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_CloseKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the type of the key. If the key pointer is NULL then</span></span><br><span class="line"><span class="comment"> * REDISMODULE_KEYTYPE_EMPTY is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_KeyType</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用 <code>RedisModule_CloseKey()</code> 或 <code>RedisModule_KeyType()</code> 时，传入的实参可以为 <code>NULL</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the length of the value associated with the key.</span></span><br><span class="line"><span class="comment"> * For strings this is the length of the string. For all the other types</span></span><br><span class="line"><span class="comment"> * is the number of elements (just counting keys for hashes).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key pointer is NULL or the key is empty, zero is returned. */</span></span><br><span class="line"><span class="keyword">size_t</span> RedisModule_ValueLength(RedisModuleKey *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the key is open for writing, remove it, and setup the key to</span></span><br><span class="line"><span class="comment"> * accept new writes as an empty key (that will be created on demand).</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DeleteKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the key is open for writing, unlink it (that is delete it in a</span></span><br><span class="line"><span class="comment"> * non-blocking way, not reclaiming memory immediately) and setup the key to</span></span><br><span class="line"><span class="comment"> * accept new writes as an empty key (that will be created on demand).</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnlinkKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the key expire value, as milliseconds of remaining TTL.</span></span><br><span class="line"><span class="comment"> * If no TTL is associated with the key or if the key is empty,</span></span><br><span class="line"><span class="comment"> * REDISMODULE_NO_EXPIRE is returned. */</span></span><br><span class="line"><span class="keyword">mstime_t</span> RedisModule_GetExpire(RedisModuleKey *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a new expire for the key. If the special expire</span></span><br><span class="line"><span class="comment"> * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was</span></span><br><span class="line"><span class="comment"> * one (the same as the PERSIST command).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the expire must be provided as a positive integer representing</span></span><br><span class="line"><span class="comment"> * the number of milliseconds of TTL the key should have.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if</span></span><br><span class="line"><span class="comment"> * the key was not open for writing or is an empty key. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetExpire</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> expire)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a name of a random key, or NULL if current db is empty. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_RandomKey</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="string-type">String type</h3>
<p><strong>Set</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the key is open for writing, set the specified string 'str' as the</span></span><br><span class="line"><span class="comment"> * value of the key, deleting the old value if any.</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing or there is an active iterator, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringSet</span><span class="params">(RedisModuleKey *key, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>DMA access</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare the key associated string value for DMA access, and returns</span></span><br><span class="line"><span class="comment"> * a pointer and size (by reference), that the user can use to read or</span></span><br><span class="line"><span class="comment"> * modify the string in-place accessing it directly via pointer. */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_StringDMA</span><span class="params">(RedisModuleKey *key, <span class="keyword">size_t</span> *len, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>key</code> 所关联的对象不是 <code>String</code> 类型，则会返回 <code>NULL</code></li>
<li>如果 <code>mode</code> 仅为可读，则不可修改返回值</li>
<li>DMA access rules:
<ul>
<li>因为是就地访问，所以应避免并发问题。对于同一个 key，只存在一写或多读的情况。</li>
<li>每次调用 <code>RedisModule_StringTruncate()</code> 之后, 需重新调用 <code>RedisModule_StringDMA()</code> 以获取新的字符串指针和长度</li>
<li>若获取的指针不为 <code>NULL</code>，但长度为 0 时 (key 为空或字符串为空)，可使用 <code>RedisModule_StringTruncate()</code> 调整字符串大小后再次调用 <code>RedisModule_StringDMA()</code>。</li>
</ul></li>
</ul>
<p><strong>Truncate</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the string is open for writing and is of string type, resize it, padding</span></span><br><span class="line"><span class="comment"> * with zero bytes if the new length is greater than the old one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After this call, RedisModule_StringDMA() must be called again to continue</span></span><br><span class="line"><span class="comment"> * DMA access with the new pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on</span></span><br><span class="line"><span class="comment"> * error, that is, the key is not open for writing, is not a string</span></span><br><span class="line"><span class="comment"> * or resizing for more than 512 MB is requested.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is empty, a string key is created with the new string value</span></span><br><span class="line"><span class="comment"> * unless the new length value requested is zero. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringTruncate</span><span class="params">(RedisModuleKey *key, <span class="keyword">size_t</span> newlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="list-type">List type</h3>
<p><strong>Push</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Push an element into a list, on head or tail depending on 'where' argument. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ListPush</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> where, RedisModuleString *ele)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果传入的 <code>key</code> 为空，模式为写模式的话，则会创建新 <code>key</code></li>
<li>只读模式或类型错误时，返回 <code>REDISMODULE_ERR</code>，否则返回 <code>REDISMODULE_OK</code></li>
</ul>
<p><strong>Pop</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pop an element from list, from head or tail depending on 'where' argument. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ListPop</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> where)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在未启用自动内存管理的情况下，返回值必须调用 <code>RedisModule_FreeString()</code> 进行释放</li>
<li>返回值为 <code>NULL</code> 时，可能由以下原因造成：
<ul>
<li>列表为空</li>
<li>只读模式</li>
<li>类型错误</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tail and head */</span></span><br><span class="line">REDISMODULE_LIST_HEAD</span><br><span class="line">REDISMODULE_LIST_TAIL</span><br></pre></td></tr></table></figure>
<h3 id="sorted-set-type">Sorted Set type</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conversion from/to public flags of the Modules API and our private flags,</span></span><br><span class="line"><span class="comment"> * so that we have everything decoupled. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAddFlagsToCoreFlags</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAddFlagsFromCoreFlags</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>ZADD</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new element into a sorted set, with the specified 'score'.</span></span><br><span class="line"><span class="comment"> * If the element already exists, the score is updated. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> score,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *ele,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *flagsptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在写模式下，如果 <code>key</code> 为空，则会新建一个 <code>ZSET</code>。</p>
<p>可以注意到，此处 flags 按指针传递，其用途有二：</p>
<ul>
<li>作为 <code>input flags</code>， 决定 <code>RedisModule_ZsetAdd()</code> 的行为模式</li>
<li>作为 <code>output flags</code>，返回 <code>RedisModule_ZsetAdd()</code> 的执行结果</li>
</ul>
<p>其中，<code>input flags</code> 可以为</p>
<ul>
<li><code>REDISMODULE_ZADD_XX</code>: Element must already exist. Do nothing otherwise.</li>
<li><code>REDISMODULE_ZADD_NX</code>: Element must not exist. Do nothing otherwise.</li>
</ul>
<p><code>output flags</code> 可以为：</p>
<ul>
<li><code>REDISMODULE_ZADD_ADDED</code>: The new element was added to the sorted set.</li>
<li><code>REDISMODULE_ZADD_UPDATED</code>: The score of the element was updated.</li>
<li><code>REDISMODULE_ZADD_NOP</code>: No operation was performed because XX or NX flags.</li>
</ul>
<p>当然，<code>flagsptr</code> 也可为 <code>NULL</code>。</p>
<p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p>
<ul>
<li>只读模式</li>
<li>类型错误</li>
<li>传入的 <code>score</code> 不是数值类型</li>
</ul>
<p><strong>ZINCRBY</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Increase the score of the existing element, of if the element does not</span></span><br><span class="line"><span class="comment"> * already exist, it is added assuming the old score was zero. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetIncrby</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> score,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *ele,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *flagsptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> *newscore)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>inpout/output flags</code> 和返回值和 <code>RedisModule_ZsetAdd()</code> 一样，唯一的区别是，当 <code>score</code> 不是数值类型时，该函数除了返回 <code>REDISMODULE_ERR</code> 之外，还会使得现有 <code>element</code> 的 <code>socre</code> 变成非数值类型。</p>
<p>传入的 <code>newscore</code> 实参不为 <code>NULL</code> 时，会在函数执行完毕之后使用 <code>element</code> 新的 <code>score</code> 进行填充，在无错误的情况下，会被返回。</p>
<p><strong>ZREM</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified element from the sorted set. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRem</span><span class="params">(RedisModuleKey *key, RedisModuleString *ele, <span class="keyword">int</span> *deleted)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p>
<ul>
<li>只读模式</li>
<li>类型错误</li>
</ul>
<p>通过返回值不能确定该 <code>element</code> 是否真的被移除，如果想知道 <code>element</code> 是否被移除的话，则需要传入非空的 <code>deleted</code> 指针，其在返回时会根据函数执行情况填充 0 或 1</p>
<p><strong>ZSCORE</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve the double score associated at the sorted set element 'ele'. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetScore</span><span class="params">(RedisModuleKey *key, RedisModuleString *ele, <span class="keyword">double</span> *score)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p>
<ul>
<li>该 <code>ZSET</code> 中不存在该 <code>element</code></li>
<li><code>key</code> 为空</li>
<li>类型错误</li>
</ul>
<p><strong>Sorted Set iterator</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Stop a sorted set iteration. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ZsetRangeStop</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the "End of range" flag value to signal the end of the iteration. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangeEndReached</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current sorted set element of an active sorted set iterator or</span></span><br><span class="line"><span class="comment"> * NULL if the range specified in the iterator does not include any element. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ZsetRangeCurrentElement</span><span class="params">(RedisModuleKey *key, <span class="keyword">double</span> *score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Go to the next element of the sorted set iterator.</span></span><br><span class="line"><span class="comment"> * Returns 1 if there was a next element, 0 if we are already</span></span><br><span class="line"><span class="comment"> * at the latest element or the range does not include any item at all. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangeNext</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Go to the previous element of the sorted set iterator.</span></span><br><span class="line"><span class="comment"> * Returns 1 if there was a previous element, 0 if we are already</span></span><br><span class="line"><span class="comment"> * at the first element or the range does not include any item at all. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangePrev</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup a sorted set iterator seeking the first element in the specified range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetFirstInScoreRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> min, <span class="keyword">double</span> max,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> minex, <span class="keyword">int</span> maxex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of</span></span><br><span class="line"><span class="comment"> * the range is selected for the start of the iteration instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetLastInScoreRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> min, <span class="keyword">double</span> max,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> minex, <span class="keyword">int</span> maxex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述两函数在迭代器被正确初始化时，返回 <code>REDISMODULE_OK</code>；在 <code>key</code> 为空或对应的数据类型不是 <code>ZSET</code> 时，返回 <code>REDISMODULE_ERR</code>。</p>
<p>迭代区间由 <code>min</code> 和 <code>max</code> 控制，当 <code>minex</code>(<code>maxex</code>) 设置为 <code>true</code> 时，区间不包含 <code>min</code>(<code>max</code>)。可以使用以下宏赋值给 <code>min</code> 或 <code>max</code>:</p>
<ul>
<li><code>REDISMODULE_POSITIVE_INFINITE</code>: positive infinite value</li>
<li><code>REDISMODULE_NEGATIVE_INFINITE</code>: negative infinite value</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup a sorted set iterator seeking the first element in the</span></span><br><span class="line"><span class="comment"> * specified lexicographical range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetFirstInLexRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *min, RedisModuleString *max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element</span></span><br><span class="line"><span class="comment"> * of the range is selected for the start of the iteration instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetLastInLexRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *min, RedisModuleString *max)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述两函数在迭代器被正确初始化时，返回 <code>REDISMODULE_OK</code>，在以下情况下返回 <code>REDISMODULE_ERR</code>:</p>
<ul>
<li><code>key</code> 对应的数据类型不为 <code>ZSET</code></li>
<li><code>key</code> 为空</li>
<li>确定字典范围的 <code>min</code> 和 <code>max</code> 格式错误</li>
</ul>
<p>传入的 <code>min</code> 和 <code>max</code> 格式和 <code>ZRANGEBYLEX</code> 命令参数的格式相同。<code>min</code> 和 <code>max</code> 对象可在迭代器被正确赋值之后立即释放。</p>
<h3 id="hash-type">Hash type</h3>
<p><strong>HashSet</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the field of the specified hash field to the specified value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_HashSet</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> flags, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果 <code>key</code> 为空且处于写模式，则会新建一个 <code>Hash</code>。</p>
<p>控制函数行为模式的 <code>flags</code> 列表如下：</p>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 67%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">flags</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_HASH_NONE</td>
<td style="text-align: left;">No special behavior is needed.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_HASH_NX</td>
<td style="text-align: left;">The operation is performed only if the field was not already existing in the hash.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_HASH_XX</td>
<td style="text-align: left;">The operation is performed only if the field was already existing, so that a new value could be associated to an existing filed, but no new fields are created.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_HASH_CFIELDS</td>
<td style="text-align: left;">The field names passed are null terminated C strings instead of RedisModuleString objects.</td>
</tr>
</tbody>
</table>
<p>可变参数列表由 <code>flied/value-ptr pairs</code> 和 <code>NULL</code> 组成：</p>
<ul>
<li><code>flied/value-ptr pairs</code> 中传入的数据类型为 <code>RedisModuleString*</code> (flags 不为 CFIELDS)</li>
<li><code>NULL</code> 为最后一个实参的标识</li>
<li>当 <code>value == REDISMODULE_HASH_DELETE</code> 时，意为删除对应的 <code>field</code></li>
</ul>
<p>该函数的返回值为更新的 <code>field</code> 个数，故 <code>key</code> 为只读模式或对应的数据类型不为 <code>Hash</code> 时，返回值一直为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Example to set the hash argv[1] to the value argv[2]: */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of delete fileds */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],REDISMODULE_HASH_DELETE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_CFIELDS */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,<span class="string">"foo"</span>,REDISMODULE_HASH_DELETE,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>HashGet</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get fields value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_HashGet</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> flags, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>控制函数行为模式的 <code>flags</code> 列表如下：</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">flags</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_HASH_NONE</td>
<td style="text-align: left;">No special behavior is needed.</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_HASH_CFIELD</td>
<td style="text-align: left;">field names as null terminated C strings.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_HASH_EXISTS</td>
<td style="text-align: left;">instead of setting the value of the field expecting a RedisModuleString pointer to pointer, the function just reports if the field exists or not and expects an integer pointer as the second element of each pair.</td>
</tr>
</tbody>
</table>
<p>可变参数列表由 <code>flied/value-ptr pairs</code> 和 <code>NULL</code> 组成：</p>
<ul>
<li><code>flied/value-ptr pairs</code> 中传入的数据类型为 <code>RedisModuleString*</code> (flags 不为 CFIELDS)</li>
<li><code>NULL</code> 为最后一个实参的标识</li>
<li>返回时，<code>value</code> 指针为空表示对应的 <code>field</code> 不存在</li>
<li>不要忘记释放 <code>RedisModuleString</code> 对象</li>
</ul>
<p>在函数执行成功时返回 <code>REDISMODULE_OK</code>，如 <code>key</code> 对应的数据类型不为 <code>Hash</code>，则返回 <code>REDISMODULE_ERR</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An example usage. */</span></span><br><span class="line">RedisModuleString *first, *second;</span><br><span class="line">RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],&amp;first,argv[<span class="number">2</span>],&amp;second,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_CFIELD */</span></span><br><span class="line">RedisModuleString *username, *hashedpass;</span><br><span class="line">RedisModule_HashGet(mykey,<span class="string">"username"</span>,&amp;username,<span class="string">"hp"</span>,&amp;hashedpass, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_EXISTS */</span></span><br><span class="line"><span class="keyword">int</span> exists;</span><br><span class="line">RedisModule_HashGet(mykey,argv[<span class="number">1</span>],&amp;exists,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2 id="high-level-key-apis----call">High level Key APIs -- Call</h2>
<p><strong>Call</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exported API to call any Redis command from modules. */</span></span><br><span class="line"><span class="function">RedisModuleCallReply *<span class="title">RedisModule_Call</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>格式说明符列表如下：</p>
<ul>
<li><code>c</code> -- Null terminated C string pointer</li>
<li><code>b</code> -- C buffer, two arguments needed: C string pointer and <code>size_t</code> length</li>
<li><code>s</code> -- RedisModuleString as received in <code>argv</code> or by other Redis module APIs returning a RedisModuleString object</li>
<li><code>l</code> -- Long long integer</li>
<li><code>v</code> -- Array of RedisModuleString objects</li>
<li><code>!</code> -- This modifier just tells the function to replicate the command to replicas and AOF. it is ignored from the point of view of arguments parsing</li>
<li><code>A</code> -- This modifier, when <code>!</code> is given, tells to suppress AOF propagation: the command will propagated only to replicas</li>
<li><code>R</code> -- This modifier, when <code>!</code> is given, tells to suppress replicas propagation: the command will be propagated only to the AOF if enabled</li>
</ul>
<p>函数执行成功时返回 <code>RedisModuleCallReply</code> 对象，失败时返回 <code>NULL</code> 并将 <code>errno</code> 设置为以下值：</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">errno</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">EBADF</td>
<td style="text-align: left;">wrong format specifier.</td>
</tr>
<tr class="even">
<td style="text-align: left;">EINVAL</td>
<td style="text-align: left;">wrong command arity.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ENOENT</td>
<td style="text-align: left;">command does not exist.</td>
</tr>
<tr class="even">
<td style="text-align: left;">EPERM</td>
<td style="text-align: left;">operation in Cluster instance with key in non local slot.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">EROFS</td>
<td style="text-align: left;">operation in Cluster instance when a write command is sent in a readonly state. ENETDOWN</td>
</tr>
</tbody>
</table>
<p><strong>Access CallReply</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the reply type. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CallReplyType</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the reply type length, where applicable. */</span></span><br><span class="line"><span class="keyword">size_t</span> RedisModule_CallReplyLength(RedisModuleCallReply *reply);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the 'idx'-th nested call reply element of an array reply,</span></span><br><span class="line"><span class="comment"> * or NULL if the reply type is wrong or the index is out of range. */</span></span><br><span class="line"><span class="function">RedisModuleCallReply *<span class="title">RedisModule_CallReplyArrayElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCallReply *reply, <span class="keyword">size_t</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the long long of an integer reply. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_CallReplyInteger</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer and length of a string or error reply. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_CallReplyStringPtr</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a new string object from a call reply of type string,</span></span><br><span class="line"><span class="comment"> * error or integer. Otherwise (wrong reply type) return NULL. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromCallReply</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer, and a length, to the protocol</span></span><br><span class="line"><span class="comment"> * returned by the command that returned the reply object. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_CallReplyProto</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">size_t</span> *len)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Free CallReply</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a Call reply and all the nested replies it contains if it's an array. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeCallReply_Rec</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">int</span> freenested)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper for the recursive free reply function.</span></span><br><span class="line"><span class="comment"> * This is needed in order to have the first level function to return</span></span><br><span class="line"><span class="comment"> * on nested replies, but only if called by the module API. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeCallReply</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="自定义数据类型">自定义数据类型</h2>
<h3 id="create-data-type">Create Data Type</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Register a new data type exported by the module. */</span></span><br><span class="line"><span class="function">moduleType *<span class="title">RedisModule_CreateDataType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> encver,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *typemethods_ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>name</code> 已存在，<code>name</code> 或 <code>encver</code> 非法的情况下，该函数返回 <code>NULL</code>。</p>
<p>各个参数说明如下：</p>
<ul>
<li><p><code>name</code>: 类型名，由 9 个字符组成，可用字符集合为 <code>{A-Z, a-z, 0-9, -, _}</code> &gt;"AAAAAAAAA" is reserved and produces an error</p></li>
<li><p><code>encver</code>: 序列化数据的 Encoding version，用于向前兼容，取值范围为 <span class="math inline">\([0, 1023]\)</span></p></li>
<li><p><code>typemethods_ptr</code>: 指向 <code>RedisModuleTypeMethods</code> 结构体的指针，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleTypeMethods tm =</span><br><span class="line">&#123;</span><br><span class="line">    .version = REDISMODULE_TYPE_METHOD_VERSION,</span><br><span class="line">    .rdb_load = myType_RDBLoadCallBack,</span><br><span class="line">    .rdb_save = myType_RDBSaveCallBack,</span><br><span class="line">    .aof_rewrite = myType_AOFRewriteCallBack,</span><br><span class="line">    .<span class="built_in">free</span> = myType_FreeCallBack,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional fields */</span></span><br><span class="line">    .digest = myType_DigestCallBack,</span><br><span class="line">    .mem_usage = myType_MemUsageCallBack,</span><br><span class="line">    .aux_save = myType_AuxRDBSaveCallBack,</span><br><span class="line">    .aux_load = myType_AuxRDBLoadCallBack,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体成员说明如下：</p>
<ul>
<li><code>rdb_load</code>: A callback function pointer that loads data from RDB files.</li>
<li><code>rdb_save</code>: A callback function pointer that saves data to RDB files.</li>
<li><code>aof_rewrite</code>: A callback function pointer that rewrites data as commands.</li>
<li><code>free</code>: A callback function pointer that can free a type value.</li>
<li><code>digest</code>: A callback function pointer that is used for <code>DEBUG DIGEST</code>.</li>
<li><code>mem_usage</code>: A callback function pointer that is used for <code>MEMORY</code></li>
<li><code>aux_save</code>: A callback function pointer that saves out of keyspace data to RDB files. <code>when</code> argument is either <code>REDISMODULE_AUX_BEFORE_RDB</code> or <code>REDISMODULE_AUX_AFTER_RDB</code>.</li>
<li><code>aux_load</code>: A callback function pointer that loads out of keyspace data from RDB files. Similar to <code>aux_save</code>, returns <code>REDISMODULE_OK</code> on success, and <code>REDISMODULE_ERR</code> otherwise.</li>
</ul>
<blockquote>
<p>The <code>digest</code> and <code>mem_usage</code> methods should currently be omitted since they are not yet implemented inside the Redis modules core.</p>
</blockquote></li>
</ul>
<h3 id="access-to-moduletype">Access to moduleType</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the key is open for writing, set the specified module type object</span></span><br><span class="line"><span class="comment"> * as the value of the key, deleting the old value if any.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for writing</span></span><br><span class="line"><span class="comment"> * or there is an active iterator, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ModuleTypeSetValue</span><span class="params">(RedisModuleKey *key, moduleType *mt, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Replace the value assigned to a module type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The key must be open for writing, have an existing value, and have a moduleType</span></span><br><span class="line"><span class="comment"> * that matches the one specified by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlike RM_ModuleTypeSetValue() which will free the old value, this function</span></span><br><span class="line"><span class="comment"> * simply swaps the old value with the new value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success, REDISMODULE_ERR on errors</span></span><br><span class="line"><span class="comment"> * such as:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Key is not opened for writing.</span></span><br><span class="line"><span class="comment"> * 2. Key is not a module data type key.</span></span><br><span class="line"><span class="comment"> * 3. Key is a module datatype other than 'mt'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If old_value is non-NULL, the old value is returned by reference. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ModuleTypeReplaceValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key, moduleType *mt, <span class="keyword">void</span> *new_value, <span class="keyword">void</span> **old_value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on</span></span><br><span class="line"><span class="comment"> * the key, returns the module type pointer of the value stored at key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is NULL, is not associated with a module type, or is empty,</span></span><br><span class="line"><span class="comment"> * then NULL is returned instead. */</span></span><br><span class="line"><span class="function">moduleType *<span class="title">RedisModule_ModuleTypeGetType</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on</span></span><br><span class="line"><span class="comment"> * the key, returns the module type low-level value stored at key, as</span></span><br><span class="line"><span class="comment"> * it was set by the user via RedisModule_ModuleTypeSetValue().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is NULL, is not associated with a module type, or is empty,</span></span><br><span class="line"><span class="comment"> * then NULL is returned instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_ModuleTypeGetValue</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="rdb-loading-and-saving-functions">RDB loading and saving functions</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if any previous IO API failed.</span></span><br><span class="line"><span class="comment"> * for Load* APIs the REDISMODULE_OPTIONS_HANDLE_IO_ERRORS flag must be set with</span></span><br><span class="line"><span class="comment"> * RediModule_SetModuleOptions first. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsIOError</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save an unsigned 64 bit value into the RDB file. This function should only</span></span><br><span class="line"><span class="comment"> * be called in the context of the rdb_save method of modules implementing new</span></span><br><span class="line"><span class="comment"> * data types. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveUnsigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">uint64_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load an unsigned 64 bit value from the RDB file. This function should only</span></span><br><span class="line"><span class="comment"> * be called in the context of the rdb_load method of modules implementing</span></span><br><span class="line"><span class="comment"> * new data types. */</span></span><br><span class="line"><span class="keyword">uint64_t</span> RedisModule_LoadUnsigned(RedisModuleIO *io);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveSigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">int64_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */</span></span><br><span class="line"><span class="keyword">int64_t</span> RedisModule_LoadSigned(RedisModuleIO *io);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module type, saves a</span></span><br><span class="line"><span class="comment"> * string into the RDB file taking as input a RedisModuleString.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string can be later loaded with RedisModule_LoadString() or</span></span><br><span class="line"><span class="comment"> * other Load family functions expecting a serialized string inside</span></span><br><span class="line"><span class="comment"> * the RDB file. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveString</span><span class="params">(RedisModuleIO *io, RedisModuleString *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_load method of a module data type, loads a string</span></span><br><span class="line"><span class="comment"> * from the RDB file, that was previously saved with RedisModule_SaveString()</span></span><br><span class="line"><span class="comment"> * functions family.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned string is a newly allocated RedisModuleString object, and</span></span><br><span class="line"><span class="comment"> * the user should at some point free it with a call to RedisModule_FreeString().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the data structure does not store strings as RedisModuleString objects,</span></span><br><span class="line"><span class="comment"> * the similar function RedisModule_LoadStringBuffer() could be used instead. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_LoadString</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_SaveString() but takes a raw C pointer and length as input. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveStringBuffer</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_LoadString() but returns an heap allocated string that</span></span><br><span class="line"><span class="comment"> * was allocated with RedisModule_Alloc(), and can be resized or freed with</span></span><br><span class="line"><span class="comment"> * RedisModule_Realloc() or RedisModule_Free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size of the string is stored at '*lenptr' if not NULL.</span></span><br><span class="line"><span class="comment"> * The returned string is not automatically NULL terminated, it is loaded</span></span><br><span class="line"><span class="comment"> * exactly as it was stored inisde the RDB file. */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_LoadStringBuffer</span><span class="params">(RedisModuleIO *io, <span class="keyword">size_t</span> *lenptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a double</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The double can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveDouble</span><span class="params">(RedisModuleIO *io, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * double value saved by RedisModule_SaveDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RedisModule_LoadDouble</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a float</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The float can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadFloat(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveFloat</span><span class="params">(RedisModuleIO *io, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * float value saved by RedisModule_SaveFloat(). */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RedisModule_LoadFloat</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a long double</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The double can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadLongDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveLongDouble</span><span class="params">(RedisModuleIO *io, <span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * long double value saved by RedisModule_SaveLongDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">RedisModule_LoadLongDouble</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="key-digest-api">Key digest API</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new element to the digest. This function can be called multiple times</span></span><br><span class="line"><span class="comment"> * one element after the other, for all the elements that constitute a given</span></span><br><span class="line"><span class="comment"> * data structure. The function call must be followed by the call to</span></span><br><span class="line"><span class="comment"> * `RedisModule_DigestEndSequence` eventually, when all the elements that are</span></span><br><span class="line"><span class="comment"> * always in a given order are added. See the Redis Modules data types</span></span><br><span class="line"><span class="comment"> * documentation for more info. However this is a quick example that uses Redis</span></span><br><span class="line"><span class="comment"> * data types as an example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To add a sequence of unordered elements (for example in the case of a Redis</span></span><br><span class="line"><span class="comment"> * Set), the pattern to use is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach element &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(element);</span></span><br><span class="line"><span class="comment"> *         EndSequence();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because Sets are not ordered, so every element added has a position that</span></span><br><span class="line"><span class="comment"> * does not depend from the other. However if instead our elements are</span></span><br><span class="line"><span class="comment"> * ordered in pairs, like field-value pairs of an Hash, then one should</span></span><br><span class="line"><span class="comment"> * use:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach key,value &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(key);</span></span><br><span class="line"><span class="comment"> *         AddElement(value);</span></span><br><span class="line"><span class="comment"> *         EndSquence();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because the key and value will be always in the above order, while instead</span></span><br><span class="line"><span class="comment"> * the single key-value pairs, can appear in any position into a Redis hash.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A list of ordered elements would be implemented with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach element &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(element);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *     EndSequence();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestAddStringBuffer</span><span class="params">(RedisModuleDigest *md,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input</span></span><br><span class="line"><span class="comment"> * that gets converted into a string before adding it to the digest. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestAddLongLong</span><span class="params">(RedisModuleDigest *md, <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestEndSequence</span><span class="params">(RedisModuleDigest *md)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode a serialized representation of a module data type 'mt' from string</span></span><br><span class="line"><span class="comment"> * 'str' and return a newly allocated value, or NULL if decoding failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call basically reuses the 'rdb_load' callback which module data types</span></span><br><span class="line"><span class="comment"> * implement in order to allow a module to arbitrarily serialize/de-serialize</span></span><br><span class="line"><span class="comment"> * keys, similar to how the Redis 'DUMP' and 'RESTORE' commands are implemented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Modules should generally use the REDISMODULE_OPTIONS_HANDLE_IO_ERRORS flag and</span></span><br><span class="line"><span class="comment"> * make sure the de-serialization code properly checks and handles IO errors</span></span><br><span class="line"><span class="comment"> * (freeing allocated buffers and returning a NULL).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this is NOT done, Redis will handle corrupted (or just truncated) serialized</span></span><br><span class="line"><span class="comment"> * data by producing an error message and terminating the process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_LoadDataTypeFromString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> RedisModuleString *str, <span class="keyword">const</span> moduleType *mt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode a module data type 'mt' value 'data' into serialized form, and return it</span></span><br><span class="line"><span class="comment"> * as a newly allocated RedisModuleString.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call basically reuses the 'rdb_save' callback which module data types</span></span><br><span class="line"><span class="comment"> * implement in order to allow a module to arbitrarily serialize/de-serialize</span></span><br><span class="line"><span class="comment"> * keys, similar to how the Redis 'DUMP' and 'RESTORE' commands are implemented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_SaveDataTypeToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, <span class="keyword">void</span> *data, <span class="keyword">const</span> moduleType *md)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="aof-api-for-modules-data-types">AOF API for modules data types</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Emits a command into the AOF during the AOF rewriting process. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_EmitAOF</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数只在 <code>aof_rewrite</code> 函数中调用</li>
<li>执行模式和 <code>RedisModule_Call()</code> 相同，但是无返回值，异常情况由 Redis 自身处理</li>
</ul>
<h3 id="io-context-handling">IO context handling</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleCtx *<span class="title">RedisModule_GetContextFromIO</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a RedisModuleString with the name of the key currently saving or</span></span><br><span class="line"><span class="comment"> * loading, when an IO data type callback is called.  There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the key name is always available, so this may return NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_GetKeyNameFromIO</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a RedisModuleString with the name of the key from RedisModuleKey */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_GetKeyNameFromModuleKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="输出日志">输出日志</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Produces a log message to the standard Redis log, the format accepts</span></span><br><span class="line"><span class="comment"> * printf-alike specifiers. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Log</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">char</span> *levelstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>levelstr</code> 描述了指定的日志级别，日志级别可为以下四种之一:</p>
<ul>
<li><code>debug</code></li>
<li><code>verbose</code></li>
<li><code>notice</code></li>
<li><code>warning</code></li>
</ul>
<p>当传入的 <code>levelstr</code> 内容不为以上四种之一时，日志级别默认设置为 <code>verbose</code>。传入的上下文指针可以为 <code>NULL</code>，此时在日志输出时，会以 <code>module</code> 代替 module name。 &gt;日志长度有上限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Log errors from RDB / AOF serialization callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used when a callback is returning a critical</span></span><br><span class="line"><span class="comment"> * error to the caller since cannot load or save the data for some</span></span><br><span class="line"><span class="comment"> * critical reason. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_LogIOError</span><span class="params">(RedisModuleIO *io,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span> *levelstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Redis-like assert function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A failed assertion will shut down the server and produce logging information</span></span><br><span class="line"><span class="comment"> * that looks identical to information generated by Redis itself. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule__Assert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *estr, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allows adding event to the latency monitor to be observed by the LATENCY</span></span><br><span class="line"><span class="comment"> * command. The call is skipped if the latency is smaller than the configured</span></span><br><span class="line"><span class="comment"> * latency-monitor-threshold. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_LatencyAddSample</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *event, <span class="keyword">mstime_t</span> latency)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="blocking-clients-from-modules">Blocking clients from modules</h2>
<h3 id="block-client">Block Client</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Block a client in the context of a blocking command. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_BlockClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc reply_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc timeout_callback,</span></span></span><br><span class="line">    void (*free_privdata)(RedisModuleCtx*,void*),</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeout_ms);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>reply_callback</code>: called after a successful <code>RedisModule_UnblockClient()</code> call in order to reply to the client and unblock it.</li>
<li><code>timeout_callback</code>: called when the timeout is reached in order to send an error to the client.</li>
<li><code>free_privdata</code>: called in order to free the private data that is passed by <code>RedisModule_UnblockClient()</code> call.</li>
<li><code>timeout_ms</code>: a timeout after which the client is unblocked.</li>
</ul>
<p>在以下情况下不该调用该函数，如在这些情况下，调用该函数并不会阻塞客户端，会返回错误回复。</p>
<ul>
<li>If the client is a Lua script.</li>
<li>If the client is executing a <code>MULTI</code> block.</li>
</ul>
<p>函数执行成功会会返回 <code>RedisModuleBlockedClient</code> 对象，用于之后调用 <code>RedisModule_UnblockClient()</code> 以解除对客户端的阻塞及释放该对象占用的内存。因此，无论该客户端被 killed, time-out 或 disconnected，都应该调用 <code>RedisModule_UnblockClient()</code>，否则会有内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unblock a client blocked by `RedisModule_BlockedClient`. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnblockClient</span><span class="params">(RedisModuleBlockedClient *bc, <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用该函数，会触发 <code>reply_callback</code>，按需将数据通过 <code>privdata</code> 指针传递至 <code>reply_callback</code>。</li>
<li>可在模块派生出的线程中调用此函数</li>
<li>当对 <code>RedisModule_BlockClientOnKeys</code> 的返回值调用该函数时，<code>privdata</code> 指针无用，客户端被视为超时，触发 <code>timeout_callback</code>。</li>
</ul>
<h3 id="block-client-on-keys">Block Client On Keys</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This call is similar to RedisModule_BlockClient(), however in this case we</span></span><br><span class="line"><span class="comment"> * don't just block the client, but also ask Redis to unblock it automatically</span></span><br><span class="line"><span class="comment"> * once certain keys become "ready", that is, contain more data. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_BlockClientOnKeys</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc reply_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc timeout_callback,</span></span></span><br><span class="line">    void (*free_privdata)(RedisModuleCtx*,void*),</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeout_ms,</span><br><span class="line">    RedisModuleString **keys,</span><br><span class="line">    <span class="keyword">int</span> numkeys,</span><br><span class="line">    <span class="keyword">void</span> *privdata);</span><br></pre></td></tr></table></figure>
<p>该函数的运行模式和 <a href="https://redis.io/commands/blpop" target="_blank" rel="noopener">BLPOP</a> 或 <a href="https://redis.io/commands/bzpopmax" target="_blank" rel="noopener">BZPOPMAX</a> 等可阻塞客户端的命令类似 —— 当不能立马获取数据时，客户端阻塞，随后当数据可获取时，客户端解除阻塞并返回数据。调用该函数后，解除阻塞条件分为两种：</p>
<ol type="1">
<li>If you block on a key of a type that has blocking operations associated, like a list, a sorted set, a stream, and so forth, the client may be unblocked once the relevant key is targeted by an operation that normally unblocks the native blocking operations for that type. So if we block on a list key, an <code>RPUSH</code> command may unblock our client and so forth.</li>
<li>If you are implementing your native data type, or if you want to add new unblocking conditions in addition to <code>1</code>, you can call the modules API <code>RedisModule_SignalKeyAsReady()</code>.</li>
</ol>
<p>我们不能在收到 key 已准备好的信号后，立马解除对客户端的阻塞，因为在此期间 key 可能又被修改。因此在调用 <code>RedisModule_BlockClientOnKeys()</code> 时，<code>reply_callback</code> 并不是在调用 <code>RedisModule_UnblockClient()</code> 之后调用，而是在每次收到 key 已准备好的信号后调用：如果此时 <code>reply_callback</code> 可以返回客户端期待的数据时，其返回 <code>REDISMODULE_OK</code> 并解除对客户端的阻塞；否则其返回 <code>REDISMODULE_ERR</code> 并在之后重试。<code>reply_callback</code> 可以在收到 <code>key</code> 已准备的信号后，通过调用 <code>RedisModule_GetBlockedClientReadyKey()</code> 访问该 <code>key</code>。</p>
<p>在 <code>RedisModule_BlockClient()</code> 中，<code>prvidata</code> 由 <code>RedisModule_UnblockClient()</code> 提供，由于 <code>RedisModule_BlockClientOnKeys()</code> 中解除阻塞无须调用 <code>RedisModule_UnblockClient()</code>，所以我们直接传递了 <code>prvidata</code> 指针，供 <code>reply_callback</code>/<code>timeout_callback</code> 访问。</p>
<p>在 Block client on keys 的情况下，通常无需调用 <code>RedisModule_UnblockClient()</code>，若因某些原因而调用 <code>RedisModule_UnblockClient()</code> 时，此时客户端视为超时，因此此时必须实现 <code>timeout_callback</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is used in order to potentially unblock a client blocked</span></span><br><span class="line"><span class="comment"> * on keys with RedisModule_BlockClientOnKeys(). When this function is called,</span></span><br><span class="line"><span class="comment"> * all the clients blocked for this key will get their reply callback called,</span></span><br><span class="line"><span class="comment"> * and if the callback returns REDISMODULE_OK the client will be unblocked. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SignalKeyAsReady</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the key that is ready when the reply callback is called in the context</span></span><br><span class="line"><span class="comment"> * of a client blocked by RedisModule_BlockClientOnKeys(). */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_GetBlockedClientReadyKey</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="utils">Utils</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Abort a blocked client blocking operation: the client will be unblocked</span></span><br><span class="line"><span class="comment"> * without firing any callback. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AbortBlock</span><span class="params">(RedisModuleBlockedClient *bc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a callback that will be called if a blocked client disconnects</span></span><br><span class="line"><span class="comment"> * before the module has a chance to call RedisModule_UnblockClient()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usually what you want to do there, is to cleanup your module state</span></span><br><span class="line"><span class="comment"> * so that you can call RedisModule_UnblockClient() safely, otherwise</span></span><br><span class="line"><span class="comment"> * the client will remain blocked forever if the timeout is large.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. It is not safe to call Reply* family functions here, it is also</span></span><br><span class="line"><span class="comment"> *    useless since the client is gone.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. This callback is not called if the client disconnects because of</span></span><br><span class="line"><span class="comment"> *    a timeout. In such a case, the client is unblocked automatically</span></span><br><span class="line"><span class="comment"> *    and the timeout callback is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetDisconnectCallback</span><span class="params">(RedisModuleBlockedClient *bc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       RedisModuleDisconnectFunc callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command was called in order to fill the</span></span><br><span class="line"><span class="comment"> * reply for a blocked client. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedReplyRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command was called in order to fill the</span></span><br><span class="line"><span class="comment"> * reply for a blocked client that timed out. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedTimeoutRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the private data set by RedisModule_UnblockClient() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_GetBlockedClientPrivateData</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the blocked client associated with a given context.</span></span><br><span class="line"><span class="comment"> * This is useful in the reply and timeout callbacks of blocked clients,</span></span><br><span class="line"><span class="comment"> * before sometimes the module has the blocked client handle references</span></span><br><span class="line"><span class="comment"> * around, and wants to cleanup it. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_GetBlockedClientHandle</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if when the free callback of a blocked client is called,</span></span><br><span class="line"><span class="comment"> * the reason for the client to be unblocked is that it disconnected</span></span><br><span class="line"><span class="comment"> * while it was blocked. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_BlockedClientDisconnected</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="thread-safe-contexts">Thread Safe Contexts</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return a context which can be used inside threads to make Redis context</span></span><br><span class="line"><span class="comment"> * calls with certain modules APIs. If 'bc' is not NULL then the module will</span></span><br><span class="line"><span class="comment"> * be bound to a blocked client, and it will be possible to use the</span></span><br><span class="line"><span class="comment"> * `RedisModule_Reply*` family of functions to accumulate a reply for when the</span></span><br><span class="line"><span class="comment"> * client will be unblocked. Otherwise the thread safe context will be</span></span><br><span class="line"><span class="comment"> * detached by a specific client.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To call non-reply APIs, the thread safe context must be prepared with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *     ... make your call here ...</span></span><br><span class="line"><span class="comment"> *     RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is not needed when using `RedisModule_Reply*` functions, assuming</span></span><br><span class="line"><span class="comment"> * that a blocked client was used when the context was created, otherwise</span></span><br><span class="line"><span class="comment"> * no RedisModule_Reply* call should be made at all.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> thread safe contexts do not inherit the blocked client</span></span><br><span class="line"><span class="comment"> * selected database. */</span></span><br><span class="line"><span class="function">RedisModuleCtx *<span class="title">RedisModule_GetThreadSafeContext</span><span class="params">(RedisModuleBlockedClient *bc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release a thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeThreadSafeContext</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire the server lock before executing a thread safe API call.</span></span><br><span class="line"><span class="comment"> * This is not needed for `RedisModule_Reply*` calls when there is</span></span><br><span class="line"><span class="comment"> * a blocked client connected to the thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ThreadSafeContextLock</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the server lock after a thread safe API call was executed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ThreadSafeContextUnlock</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="module-keyspace-notifications-api">Module Keyspace Notifications API</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Subscribe to keyspace notifications. This is a low-level version of the</span></span><br><span class="line"><span class="comment"> * keyspace-notifications API. A module can register callbacks to be notified</span></span><br><span class="line"><span class="comment"> * when keyspce events occur. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SubscribeToKeyspaceEvents</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> types, RedisModuleNotificationFunc callback)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>types</code> 表示我们想订阅的 events 类型，其种类如下：</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">types</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_GENERIC</td>
<td style="text-align: left;">Generic commands like DEL, EXPIRE, RENAME</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_STRING</td>
<td style="text-align: left;">String events</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_LIST</td>
<td style="text-align: left;">List events</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_SET</td>
<td style="text-align: left;">Set events</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_HASH</td>
<td style="text-align: left;">Hash events</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_ZSET</td>
<td style="text-align: left;">Sorted Set events</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_EXPIRED</td>
<td style="text-align: left;">Expiration events</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_EVICTED</td>
<td style="text-align: left;">Eviction events</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_STREAM</td>
<td style="text-align: left;">Stream events</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_KEYMISS</td>
<td style="text-align: left;">Key-miss events</td>
</tr>
<tr class="odd">
<td style="text-align: left;">REDISMODULE_NOTIFY_ALL</td>
<td style="text-align: left;">All events (Excluding REDISMODULE_NOTIFY_KEYMISS)</td>
</tr>
<tr class="even">
<td style="text-align: left;">REDISMODULE_NOTIFY_LOADED</td>
<td style="text-align: left;">A special notification available only for modules, indicates that the key was loaded from persistence. Notice, when this event fires, the given key can not be retained, use RM_CreateStringFromString instead.</td>
</tr>
</tbody>
</table>
<p>回调函数 <code>RedisModuleNotificationFunc</code> 的 <code>signature</code> 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx,</span><br><span class="line">                                    <span class="keyword">int</span> type,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">char</span> *event,</span><br><span class="line">                                    RedisModuleString *key);</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>type</code> 必须和注册时相同</li>
<li><code>event</code> 指的是正在执行的 command</li>
<li><code>key</code> 为相关的 redis key</li>
</ul>
<p>需要注意以下几点：</p>
<ul>
<li>不可再 <code>RedisModuleNotificationFunc</code> 中向客户端发送信息</li>
<li>为了使 module notifications 工作无需在 <code>redis.conf</code> 中启用 <code>notifications</code></li>
<li>由于 <code>RedisModuleNotificationFunc</code> 是同步运行的，因此要保证该函数的运行够快</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get the configured bitmap of notify-keyspace-events (Could be used</span></span><br><span class="line"><span class="comment"> * for additional filtering in RedisModuleNotificationFunc) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetNotifyKeyspaceEvents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expose notifyKeyspaceEvent to modules */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_NotifyKeyspaceEvent</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">char</span> *event, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-cluster-api">Modules Cluster API</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a callback receiver for cluster messages of type 'type'. If there</span></span><br><span class="line"><span class="comment"> * was already a registered callback, this will replace the callback function</span></span><br><span class="line"><span class="comment"> * with the one provided, otherwise if the callback is set to NULL and there</span></span><br><span class="line"><span class="comment"> * is already a callback for this function, the callback is unregistered</span></span><br><span class="line"><span class="comment"> * (so this API call is also used in order to delete the receiver). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_RegisterClusterMessageReceiver</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint8_t</span> type, RedisModuleClusterMessageReceiver callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a message to all the nodes in the cluster if `target` is NULL, otherwise</span></span><br><span class="line"><span class="comment"> * at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as</span></span><br><span class="line"><span class="comment"> * returned by the receiver callback or by the nodes iteration functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK if the message was successfully sent,</span></span><br><span class="line"><span class="comment"> * otherwise if the node is not connected or such node ID does not map to any</span></span><br><span class="line"><span class="comment"> * known cluster node, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SendClusterMessage</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> *target_id, <span class="keyword">uint8_t</span> type, <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">uint32_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return an array of string pointers, each string pointer points to a cluster</span></span><br><span class="line"><span class="comment"> * node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).</span></span><br><span class="line"><span class="comment"> * The number of returned node IDs is stored into `*numnodes`.</span></span><br><span class="line"><span class="comment"> * However if this function is called by a module not running an a Redis</span></span><br><span class="line"><span class="comment"> * instance with Redis Cluster enabled, NULL is returned instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order</span></span><br><span class="line"><span class="comment"> * to get more information about single nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array returned by this function must be freed using the function</span></span><br><span class="line"><span class="comment"> * RedisModule_FreeClusterNodesList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     size_t count, j;</span></span><br><span class="line"><span class="comment"> *     char **ids = RedisModule_GetClusterNodesList(ctx,&amp;count);</span></span><br><span class="line"><span class="comment"> *     for (j = 0; j &lt; count; j++) &#123;</span></span><br><span class="line"><span class="comment"> *         RedisModule_Log("notice","Node %.*s",</span></span><br><span class="line"><span class="comment"> *             REDISMODULE_NODE_ID_LEN,ids[j]);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *     RedisModule_FreeClusterNodesList(ids);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">RedisModule_GetClusterNodesList</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">size_t</span> *numnodes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the node list obtained with RedisModule_GetClusterNodesList. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeClusterNodesList</span><span class="params">(<span class="keyword">char</span> **ids)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster</span></span><br><span class="line"><span class="comment"> * is disabled. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_GetMyClusterID</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of nodes in the cluster, regardless of their state</span></span><br><span class="line"><span class="comment"> * (handshake, noaddress, ...) so that the number of active nodes may actually</span></span><br><span class="line"><span class="comment"> * be smaller, but not greater than this number. If the instance is not in</span></span><br><span class="line"><span class="comment"> * cluster mode, zero is returned. */</span></span><br><span class="line"><span class="keyword">size_t</span> RedisModule_GetClusterSize(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate the specified info for the node having as ID the specified 'id',</span></span><br><span class="line"><span class="comment"> * then returns REDISMODULE_OK. Otherwise if the node ID does not exist from</span></span><br><span class="line"><span class="comment"> * the POV of this local node, REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The arguments ip, master_id, port and flags can be NULL in case we don't</span></span><br><span class="line"><span class="comment"> * need to populate back certain info. If an ip and master_id (only populated</span></span><br><span class="line"><span class="comment"> * if the instance is a slave) are specified, they point to buffers holding</span></span><br><span class="line"><span class="comment"> * at least REDISMODULE_NODE_ID_LEN bytes. The strings written back as ip</span></span><br><span class="line"><span class="comment"> * and master_id are not null terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The list of flags reported is the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_MYSELF        This node</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_MASTER        The node is a master</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_SLAVE         The node is a replica</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_PFAIL         We see the node as failing</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_FAIL          The cluster agrees the node is failing</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetClusterNodeInfo</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">char</span> *ip, <span class="keyword">char</span> *master_id, <span class="keyword">int</span> *port, <span class="keyword">int</span> *flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set Redis Cluster flags in order to change the normal behavior of</span></span><br><span class="line"><span class="comment"> * Redis Cluster, especially with the goal of disabling certain functions.</span></span><br><span class="line"><span class="comment"> * This is useful for modules that use the Cluster API in order to create</span></span><br><span class="line"><span class="comment"> * a different distributed system, but still want to use the Redis Cluster</span></span><br><span class="line"><span class="comment"> * message bus. Flags that can be set:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  CLUSTER_MODULE_FLAG_NO_FAILOVER</span></span><br><span class="line"><span class="comment"> *  CLUSTER_MODULE_FLAG_NO_REDIRECTION</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * With the following effects:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  NO_FAILOVER: prevent Redis Cluster slaves to failover a failing master.</span></span><br><span class="line"><span class="comment"> *               Also disables the replica migration feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  NO_REDIRECTION: Every node will accept any key, without trying to perform</span></span><br><span class="line"><span class="comment"> *                  partitioning according to the user Redis Cluster algorithm.</span></span><br><span class="line"><span class="comment"> *                  Slots informations will still be propagated across the</span></span><br><span class="line"><span class="comment"> *                  cluster, but without effects. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetClusterFlags</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">uint64_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-timers-api">Modules Timers API</h2>
<p>Module timers are an high precision "green timers" abstraction where every module can register even millions of timers without problems, even if the actual event loop will just have a single timer that is used to awake the module timers subsystem in order to process the next event.</p>
<p>All the timers are stored into a radix tree, ordered by expire time, when the main Redis event loop timer callback is called, we try to process all the timers already expired one after the other. Then we re-enter the event loop registering a timer that will expire when the next to process module timer will expire.</p>
<p>Every time the list of active timers drops to zero, we unregister the main event loop timer, so that there is no overhead when such feature is not used.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new timer that will fire after `period` milliseconds, and will call</span></span><br><span class="line"><span class="comment"> * the specified function using `data` as argument. The returned timer ID can be</span></span><br><span class="line"><span class="comment"> * used to get information from the timer or to stop it before it fires. */</span></span><br><span class="line"><span class="function">RedisModuleTimerID <span class="title">RedisModule_CreateTimer</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">mstime_t</span> period, RedisModuleTimerProc callback, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the</span></span><br><span class="line"><span class="comment"> * calling module, and was stopped, otherwise REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> * If not NULL, the data pointer is set to the value of the data argument when</span></span><br><span class="line"><span class="comment"> * the timer was created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StopTimer</span><span class="params">(RedisModuleCtx *ctx, RedisModuleTimerID id, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Obtain information about a timer: its remaining time before firing</span></span><br><span class="line"><span class="comment"> * (in milliseconds), and the private data pointer associated with the timer.</span></span><br><span class="line"><span class="comment"> * If the timer specified does not exist or belongs to a different module</span></span><br><span class="line"><span class="comment"> * no information is returned and the function returns REDISMODULE_ERR, otherwise</span></span><br><span class="line"><span class="comment"> * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if</span></span><br><span class="line"><span class="comment"> * the caller does not need certain information. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetTimerInfo</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleTimerID id, <span class="keyword">uint64_t</span> *remaining, <span class="keyword">void</span> **data)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-acl-api">Modules ACL API</h2>
<p>Implements a hook into the authentication and authorization within Redis.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Creates a Redis ACL user that the module can use to authenticate a client.</span></span><br><span class="line"><span class="comment"> * After obtaining the user, the module should set what such user can do</span></span><br><span class="line"><span class="comment"> * using the RM_SetUserACL() function. Once configured, the user</span></span><br><span class="line"><span class="comment"> * can be used in order to authenticate a connection, with the specified</span></span><br><span class="line"><span class="comment"> * ACL rules, using the RedisModule_AuthClientWithUser() function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Users created here are not listed by the ACL command.</span></span><br><span class="line"><span class="comment"> * * Users created here are not checked for duplicated name, so it's up to</span></span><br><span class="line"><span class="comment"> *   the module calling this function to take care of not creating users</span></span><br><span class="line"><span class="comment"> *   with the same name.</span></span><br><span class="line"><span class="comment"> * * The created user can be used to authenticate multiple Redis connections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller can later free the user using the function</span></span><br><span class="line"><span class="comment"> * RM_FreeModuleUser(). When this function is called, if there are</span></span><br><span class="line"><span class="comment"> * still clients authenticated with this user, they are disconnected.</span></span><br><span class="line"><span class="comment"> * The function to free the user should only be used when the caller really</span></span><br><span class="line"><span class="comment"> * wants to invalidate the user to define a new one with different</span></span><br><span class="line"><span class="comment"> * capabilities. */</span></span><br><span class="line"><span class="function">RedisModuleUser *<span class="title">RedisModule_CreateModuleUser</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Frees a given user and disconnects all of the clients that have been</span></span><br><span class="line"><span class="comment"> * authenticated with it. See RM_CreateModuleUser for detailed usage.*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_FreeModuleUser</span><span class="params">(RedisModuleUser *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets the permissions of a user created through the redis module</span></span><br><span class="line"><span class="comment"> * interface. The syntax is the same as ACL SETUSER, so refer to the</span></span><br><span class="line"><span class="comment"> * documentation in acl.c for more information. See RM_CreateModuleUser</span></span><br><span class="line"><span class="comment"> * for detailed usage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_OK on success and REDISMODULE_ERR on failure</span></span><br><span class="line"><span class="comment"> * and will set an errno describing why the operation failed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetModuleUserACL</span><span class="params">(RedisModuleUser *user, <span class="keyword">const</span> <span class="keyword">char</span>* acl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Authenticate the current context's user with the provided redis acl user.</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_ERR if the user is disabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See authenticateClientWithUser for information about callback, client_id,</span></span><br><span class="line"><span class="comment"> * and general usage for authentication. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AuthenticateClientWithUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUser *module_user,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUserChangedFunc callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *privdata,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> *client_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Authenticate the current context's user with the provided redis acl user.</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_ERR if the user is disabled or the user does not exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See authenticateClientWithUser for information about callback, client_id,</span></span><br><span class="line"><span class="comment"> * and general usage for authentication. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AuthenticateClientWithACLUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUserChangedFunc callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *privdata,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> *client_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deauthenticate and close the client. The client resources will not be</span></span><br><span class="line"><span class="comment"> * be immediately freed, but will be cleaned up in a background job. This is</span></span><br><span class="line"><span class="comment"> * the recommended way to deauthenicate a client since most clients can't</span></span><br><span class="line"><span class="comment"> * handle users becomming deauthenticated. Returns REDISMODULE_ERR when the</span></span><br><span class="line"><span class="comment"> * client doesn't exist and REDISMODULE_OK when the operation was successful.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The client ID is returned from the RM_AuthenticateClientWithUser and</span></span><br><span class="line"><span class="comment"> * RM_AuthenticateClientWithACLUser APIs, but can be obtained through</span></span><br><span class="line"><span class="comment"> * the CLIENT api or through server events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is not thread safe, and must be executed within the context</span></span><br><span class="line"><span class="comment"> * of a command or thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DeauthenticateAndCloseClient</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">uint64_t</span> client_id)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-dictionary-api">Modules Dictionary API</h2>
<p>Implements a sorted dictionary (actually backed by a radix tree) with the usual get / set / del / num-items API, together with an iterator capable of going back and forth.</p>
<h3 id="base-1">Base</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new dictionary. */</span></span><br><span class="line"><span class="function">RedisModuleDict *<span class="title">RedisModule_CreateDict</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure>
<p>新建一个 Dictionary，传入的 <code>ctx</code> 可以为 <code>NULL</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a dictionary created with RM_CreateDict(). You need to pass the</span></span><br><span class="line"><span class="comment"> * context pointer 'ctx' only if the dictionary was created using the</span></span><br><span class="line"><span class="comment"> * context instead of passing NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeDict</span><span class="params">(RedisModuleCtx *ctx, RedisModuleDict *d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the size of the dictionary (number of keys). */</span></span><br><span class="line"><span class="keyword">uint64_t</span> RedisModule_DictSize(RedisModuleDict *d);</span><br></pre></td></tr></table></figure>
<h3 id="setgetdel">Set/Get/Del</h3>
<p><strong>Take key as a cstring</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the specified key into the dictionary, setting its value to the</span></span><br><span class="line"><span class="comment"> * pointer 'ptr'. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictSetC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>key</code> 已存在时，返回 <code>REDISMODULE_ERR</code>，否则返回 <code>REDISMODULE_OK</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Like RedisModule_DictSetC() but will replace the key with the new</span></span><br><span class="line"><span class="comment"> * value if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictReplaceC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value stored at the specified key. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictGetC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> *nokey)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>RedisModule_DictGetC</code> 在 <code>key</code> 不存在或 <code>key</code> 对应的 <code>value</code> 为 <code>NULL</code> 时，返回 <code>NULL</code>。因此，若想确定 <code>key</code> 是否存在时，可传入非空的 <code>nokey</code>，当 <code>key</code> 不存在时，其会被设置为 1，否则为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified key from the dictionary. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictDelC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *oldval)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>key</code> 存在并被删除时，返回 <code>REDISMODULE_OK</code>，若 <code>key</code> 不存在时，返回 <code>REDISMODULE_ERR</code>。返回 <code>REDISMODULE_OK</code> 时，若传入的 <code>oldval</code> 不为空，其会保存 <code>key</code> 被删除前对应的 <code>value</code>。</p>
<p><strong>Take key as a RedisModuleString</strong></p>
<p><code>key</code> 的数据类型为 <code>RedisModuleString</code>，功能和上述四个接口相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictSet</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictReplace</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictGet</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">int</span> *nokey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictDel</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *oldval)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="iterator">Iterator</h3>
<p><strong>Take key as a cstring</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleDictIter *<span class="title">RedisModule_DictIteratorStartC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDict *d, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>基于传入的 <code>key</code> 和 <code>op</code>，返回 Dictionary 的迭代器，其中 <code>op</code> 的种类如下:</p>
<ul>
<li><code>^</code> -- Seek the first (lexicographically smaller) key.</li>
<li><code>$</code> -- Seek the last (lexicographically biffer) key.</li>
<li><code>&gt;</code> -- Seek the first element greter than the specified key.</li>
<li><code>&gt;=</code> -- Seek the first element greater or equal than the specified key.</li>
<li><code>&lt;</code> -- Seek the first element smaller than the specified key.</li>
<li><code>&lt;=</code> -- Seek the first element smaller or equal than the specified key.</li>
<li><code>==</code> -- Seek the first element matching exactly the specified key.</li>
</ul>
<p>当 <code>op</code> 为 <code>^</code> 或 <code>$</code> 时，传入的 <code>key</code> 不会被使用，此时传入 <code>key</code> 可为 <code>NULL</code>，<code>keylen</code> 为 0.</p>
<p>如果根据 <code>key</code> 和 <code>op</code> 无法获取迭代器，那么初次调用 <code>RedisModule_DictNextC() / PrevC()</code> 时会返回 <code>REDISMODULE_ERR</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictIteratorReseekC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在调用 <code>RedisModule_DictIteratorStartC()</code> 获得迭代器之后，可以通过调用该函数改变迭代器当前所指向的元素</li>
<li><code>op</code> 和 <code>key</code> 的含义和 <code>RedisModule_DictIteratorStartC()</code> 相同</li>
<li>查找到指定的元素后，返回 <code>REDISMODULE_OK</code>，无法查找指定的元素时，返回 <code>REDISMODULE_ERR</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the current item of the dictionary iterator 'di' and steps to the</span></span><br><span class="line"><span class="comment"> * next element. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictNextC</span><span class="params">(RedisModuleDictIter *di, <span class="keyword">size_t</span> *keylen, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is exactly like RedisModule_DictNext() but after returning</span></span><br><span class="line"><span class="comment"> * the currently selected element in the iterator, it selects the previous</span></span><br><span class="line"><span class="comment"> * element (laxicographically smaller) instead of the next one. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictPrevC</span><span class="params">(RedisModuleDictIter *di, <span class="keyword">size_t</span> *keylen, <span class="keyword">void</span> **dataptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两函数执行模式类似，下述仅提及 <code>RedisModule_DictNextC()</code>。</p>
<p>如果迭代器已指向最后一个元素，返回 <code>NULL</code>，否则返回指向 <code>key</code> 的指针，此时：</p>
<ul>
<li>若 <code>keylen</code> 不为 <code>NULL</code>，则会被赋值为 <code>key</code> 的长度</li>
<li>若 <code>*dataptr</code> 不为 <code>NULL</code>，则会被赋值为指向 <code>value</code> 的指针</li>
</ul>
<p>由于返回的值都是指针，因此返回值仅在 <code>di</code> 未被释放且未调用 <code>RedisModule_DictNextC()</code> 或 <code>RedisModule_DictPrevC()</code> 之前有效。</p>
<p>使用示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... create the iteator here ... */</span></span><br><span class="line"><span class="keyword">char</span> *key;</span><br><span class="line"><span class="keyword">size_t</span> keylen;</span><br><span class="line"><span class="keyword">void</span> *data;</span><br><span class="line"><span class="keyword">while</span>((key = RedisModule_DictNextC(iter, &amp;keylen, &amp;data)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.*s %p\n"</span>, (<span class="keyword">int</span>)keylen, key, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare the element currently pointed by the iterator to the specified</span></span><br><span class="line"><span class="comment"> * element given by key/keylen, according to the operator 'op' (the set of</span></span><br><span class="line"><span class="comment"> * valid operators are the same valid for RedisModule_DictIteratorStart).</span></span><br><span class="line"><span class="comment"> * If the comparision is successful the command returns REDISMODULE_OK</span></span><br><span class="line"><span class="comment"> * otherwise REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is useful when we want to just emit a lexicographical range, so</span></span><br><span class="line"><span class="comment"> * in the loop, as we iterate elements, we can also check if we are still</span></span><br><span class="line"><span class="comment"> * on range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returne REDISMODULE_ERR if the iterator reached the</span></span><br><span class="line"><span class="comment"> * end of elements condition as well. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictCompareC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Take key as a RedisModuleString</strong></p>
<p><code>key</code> 的数据类型为 <code>RedisModuleString</code>，功能和上述五个接口相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleDictIter *<span class="title">RedisModule_DictIteratorStart</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDict *d, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictIteratorReseek</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_DictNext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleDictIter *di, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_DictPrev</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleDictIter *di, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictCompare</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Stop</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Release the iterator created with RedisModule_DictIteratorStart(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DictIteratorStop</span><span class="params">(RedisModuleDictIter *di)</span></span>;</span><br></pre></td></tr></table></figure>
<p>必须调用该函数以释放 <code>RedisModuleDictIter</code> 对象。</p>
<h2 id="modules-info-fields">Modules Info fields</h2>
<p>可以使用以下接口在 <code>INFO</code> 命令中显示我们想展示的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used to start a new section, before adding any fields. the section name will</span></span><br><span class="line"><span class="comment"> * be prefixed by "&lt;modulename&gt;_" and must only include A-Z,a-z,0-9.</span></span><br><span class="line"><span class="comment"> * NULL or empty string indicates the default section (only &lt;modulename&gt;) is used.</span></span><br><span class="line"><span class="comment"> * When return value is REDISMODULE_ERR, the section should and will be skipped. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddSection</span><span class="params">(RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Starts a dict field, similar to the ones in INFO KEYSPACE. Use normal</span></span><br><span class="line"><span class="comment"> * RedisModule_InfoAddField* functions to add the items to this field, and</span></span><br><span class="line"><span class="comment"> * terminate with RedisModule_InfoEndDictField. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoBeginDictField</span><span class="params">(RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ends a dict field, see RedisModule_InfoBeginDictField */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoEndDictField</span><span class="params">(RedisModuleInfoCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by RedisModuleInfoFunc to add info fields.</span></span><br><span class="line"><span class="comment"> * Each field will be automatically prefixed by "&lt;modulename&gt;_".</span></span><br><span class="line"><span class="comment"> * Field names or values must not include \r\n of ":" */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, RedisModuleString *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldCString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldLongLong</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldULongLong</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_RegisterInfoFunc</span><span class="params">(RedisModuleCtx *ctx, RedisModuleInfoFunc cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get information about the server similar to the one that returns from the</span></span><br><span class="line"><span class="comment"> * INFO command. This function takes an optional 'section' argument that may</span></span><br><span class="line"><span class="comment"> * be NULL. The return value holds the output and can be used with</span></span><br><span class="line"><span class="comment"> * RedisModule_ServerInfoGetField and alike to get the individual fields.</span></span><br><span class="line"><span class="comment"> * When done, it needs to be freed with RedisModule_FreeServerInfo or with the</span></span><br><span class="line"><span class="comment"> * automatic memory management mechanism if enabled. */</span></span><br><span class="line"><span class="function">RedisModuleServerInfoData *<span class="title">RedisModule_GetServerInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *section)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free data created with RM_GetServerInfo(). You need to pass the</span></span><br><span class="line"><span class="comment"> * context pointer 'ctx' only if the dictionary was created using the</span></span><br><span class="line"><span class="comment"> * context instead of passing NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeServerInfo</span><span class="params">(RedisModuleCtx *ctx, RedisModuleServerInfoData *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). You</span></span><br><span class="line"><span class="comment"> * need to pass the context pointer 'ctx' only if you want to use auto memory</span></span><br><span class="line"><span class="comment"> * mechanism to release the returned string. Return value will be NULL if the</span></span><br><span class="line"><span class="comment"> * field was not found. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ServerInfoGetField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Similar to RM_ServerInfoGetField, but returns a char* which should not be </span></span><br><span class="line"><span class="comment"> * freed but the caller. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_ServerInfoGetFieldC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not numerical or out of range, return value will be</span></span><br><span class="line"><span class="comment"> * 0, and the optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_ServerInfoGetFieldSigned</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not numerical or out of range, return value will be</span></span><br><span class="line"><span class="comment"> * 0, and the optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_ServerInfoGetFieldUnsigned</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not a double, return value will be 0, and the</span></span><br><span class="line"><span class="comment"> * optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RedisModule_ServerInfoGetFieldDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-utility-apis">Modules utility APIs</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return random bytes using SHA1 in counter mode with a /dev/urandom</span></span><br><span class="line"><span class="comment"> * initialized seed. This function is fast so can be used to generate</span></span><br><span class="line"><span class="comment"> * many bytes without any effect on the operating system entropy pool.</span></span><br><span class="line"><span class="comment"> * Currently this function is not thread safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_GetRandomBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_GetRandomBytes() but instead of setting the string to</span></span><br><span class="line"><span class="comment"> * random bytes the string is set to random characters in the in the</span></span><br><span class="line"><span class="comment"> * hex charset [0-9a-f]. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_GetRandomHexChars</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-api-exporting-importing">Modules API exporting / importing</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called by a module in order to export some API with a</span></span><br><span class="line"><span class="comment"> * given name. Other modules will be able to use this API by calling the</span></span><br><span class="line"><span class="comment"> * symmetrical function RM_GetSharedAPI() and casting the return value to</span></span><br><span class="line"><span class="comment"> * the right function pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return REDISMODULE_OK if the name is not already taken,</span></span><br><span class="line"><span class="comment"> * otherwise REDISMODULE_ERR will be returned and no operation will be</span></span><br><span class="line"><span class="comment"> * performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMPORTANT: the apiname argument should be a string literal with static</span></span><br><span class="line"><span class="comment"> * lifetime. The API relies on the fact that it will always be valid in</span></span><br><span class="line"><span class="comment"> * the future. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ExportSharedAPI</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *apiname, <span class="keyword">void</span> *func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Request an exported API pointer. The return value is just a void pointer</span></span><br><span class="line"><span class="comment"> * that the caller of this function will be required to cast to the right</span></span><br><span class="line"><span class="comment"> * function pointer, so this is a private contract between modules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the requested API is not available then NULL is returned. Because</span></span><br><span class="line"><span class="comment"> * modules can be loaded at different times with different order, this</span></span><br><span class="line"><span class="comment"> * function calls should be put inside some module generic API registering</span></span><br><span class="line"><span class="comment"> * step, that is called every time a module attempts to execute a</span></span><br><span class="line"><span class="comment"> * command that requires external APIs: if some API cannot be resolved, the</span></span><br><span class="line"><span class="comment"> * command should return an error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here is an exmaple:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int ... myCommandImplementation() &#123;</span></span><br><span class="line"><span class="comment"> *        if (getExternalAPIs() == 0) &#123;</span></span><br><span class="line"><span class="comment"> *             reply with an error here if we cannot have the APIs</span></span><br><span class="line"><span class="comment"> *        &#125;</span></span><br><span class="line"><span class="comment"> *        // Use the API:</span></span><br><span class="line"><span class="comment"> *        myFunctionPointer(foo);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And the function registerAPI() is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int getExternalAPIs(void) &#123;</span></span><br><span class="line"><span class="comment"> *         static int api_loaded = 0;</span></span><br><span class="line"><span class="comment"> *         if (api_loaded != 0) return 1; // APIs already resolved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         myFunctionPointer = RedisModule_GetOtherModuleAPI("...");</span></span><br><span class="line"><span class="comment"> *         if (myFunctionPointer == NULL) return 0;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         return 1;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_GetSharedAPI</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *apiname)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="module-command-filter-api">Module Command Filter API</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a new command filter function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Command filtering makes it possible for modules to extend Redis by plugging</span></span><br><span class="line"><span class="comment"> * into the execution flow of all commands.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A registered filter gets called before Redis executes *any* command.  This</span></span><br><span class="line"><span class="comment"> * includes both core Redis commands and commands registered by any module.  The</span></span><br><span class="line"><span class="comment"> * filter applies in all execution paths including:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Invocation by a client.</span></span><br><span class="line"><span class="comment"> * 2. Invocation through `RedisModule_Call()` by any module.</span></span><br><span class="line"><span class="comment"> * 3. Invocation through Lua 'redis.call()`.</span></span><br><span class="line"><span class="comment"> * 4. Replication of a command from a master.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The filter executes in a special filter context, which is different and more</span></span><br><span class="line"><span class="comment"> * limited than a RedisModuleCtx.  Because the filter affects any command, it</span></span><br><span class="line"><span class="comment"> * must be implemented in a very efficient way to reduce the performance impact</span></span><br><span class="line"><span class="comment"> * on Redis.  All Redis Module API calls that require a valid context (such as</span></span><br><span class="line"><span class="comment"> * `RedisModule_Call()`, `RedisModule_OpenKey()`, etc.) are not supported in a</span></span><br><span class="line"><span class="comment"> * filter context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The `RedisModuleCommandFilterCtx` can be used to inspect or modify the</span></span><br><span class="line"><span class="comment"> * executed command and its arguments.  As the filter executes before Redis</span></span><br><span class="line"><span class="comment"> * begins processing the command, any change will affect the way the command is</span></span><br><span class="line"><span class="comment"> * processed.  For example, a module can override Redis commands this way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Register a `MODULE.SET` command which implements an extended version of</span></span><br><span class="line"><span class="comment"> *    the Redis `SET` command.</span></span><br><span class="line"><span class="comment"> * 2. Register a command filter which detects invocation of `SET` on a specific</span></span><br><span class="line"><span class="comment"> *    pattern of keys.  Once detected, the filter will replace the first</span></span><br><span class="line"><span class="comment"> *    argument from `SET` to `MODULE.SET`.</span></span><br><span class="line"><span class="comment"> * 3. When filter execution is complete, Redis considers the new command name</span></span><br><span class="line"><span class="comment"> *    and therefore executes the module's own command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that in the above use case, if `MODULE.SET` itself uses</span></span><br><span class="line"><span class="comment"> * `RedisModule_Call()` the filter will be applied on that call as well.  If</span></span><br><span class="line"><span class="comment"> * that is not desired, the `REDISMODULE_CMDFILTER_NOSELF` flag can be set when</span></span><br><span class="line"><span class="comment"> * registering the filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The `REDISMODULE_CMDFILTER_NOSELF` flag prevents execution flows that</span></span><br><span class="line"><span class="comment"> * originate from the module's own `RM_Call()` from reaching the filter.  This</span></span><br><span class="line"><span class="comment"> * flag is effective for all execution flows, including nested ones, as long as</span></span><br><span class="line"><span class="comment"> * the execution begins from the module's command context or a thread-safe</span></span><br><span class="line"><span class="comment"> * context that is associated with a blocking command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detached thread-safe contexts are *not* associated with the module and cannot</span></span><br><span class="line"><span class="comment"> * be protected by this flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If multiple filters are registered (by the same or different modules), they</span></span><br><span class="line"><span class="comment"> * are executed in the order of registration. */</span></span><br><span class="line"><span class="function">RedisModuleCommandFilter *<span class="title">RedisModule_RegisterCommandFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unregister a command filter. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnregisterCommandFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleCommandFilter *filter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of arguments a filtered command has.  The number of</span></span><br><span class="line"><span class="comment"> * arguments include the command itself. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgsCount</span><span class="params">(RedisModuleCommandFilterCtx *fctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the specified command argument.  The first argument (position 0) is</span></span><br><span class="line"><span class="comment"> * the command itself, and the rest are user-provided args. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_CommandFilterArgGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by inserting a new argument at the specified</span></span><br><span class="line"><span class="comment"> * position.  The specified RedisModuleString argument may be used by Redis</span></span><br><span class="line"><span class="comment"> * after the filter context is destroyed, so it must not be auto-memory</span></span><br><span class="line"><span class="comment"> * allocated, freed or used elsewhere. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgInsert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos, RedisModuleString *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by replacing an existing argument with a new one.</span></span><br><span class="line"><span class="comment"> * The specified RedisModuleString argument may be used by Redis after the</span></span><br><span class="line"><span class="comment"> * filter context is destroyed, so it must not be auto-memory allocated, freed</span></span><br><span class="line"><span class="comment"> * or used elsewhere. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgReplace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos, RedisModuleString *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by deleting an argument at the specified position. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgDelete</span><span class="params">(RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="scanning-keyspace-and-hashes">Scanning keyspace and hashes</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new cursor to be used with RedisModule_Scan */</span></span><br><span class="line"><span class="function">RedisModuleScanCursor *<span class="title">RedisModule_ScanCursorCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restart an existing cursor. The keys will be rescanned. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ScanCursorRestart</span><span class="params">(RedisModuleScanCursor *cursor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy the cursor struct. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ScanCursorDestroy</span><span class="params">(RedisModuleScanCursor *cursor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scan API that allows a module to scan all the keys and value in</span></span><br><span class="line"><span class="comment"> * the selected db.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callback for scan implementation.</span></span><br><span class="line"><span class="comment"> * void scan_callback(RedisModuleCtx *ctx, RedisModuleString *keyname,</span></span><br><span class="line"><span class="comment"> *                    RedisModuleKey *key, void *privdata);</span></span><br><span class="line"><span class="comment"> * ctx - the redis module context provided to for the scan.</span></span><br><span class="line"><span class="comment"> * keyname - owned by the caller and need to be retained if used after this</span></span><br><span class="line"><span class="comment"> * function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key - holds info on the key and value, it is provided as best effort, in</span></span><br><span class="line"><span class="comment"> * some cases it might be NULL, in which case the user should (can) use</span></span><br><span class="line"><span class="comment"> * RedisModule_OpenKey (and CloseKey too).</span></span><br><span class="line"><span class="comment"> * when it is provided, it is owned by the caller and will be free when the</span></span><br><span class="line"><span class="comment"> * callback returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * privdata - the user data provided to RedisModule_Scan.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way it should be used:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_Scan(ctx, c, callback, privateData));</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to use this API from another thread while the lock</span></span><br><span class="line"><span class="comment"> * is acquired durring the actuall call to RM_Scan:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_Scan(ctx, c, callback, privateData))&#123;</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *          // do some background job</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return 1 if there are more elements to scan and</span></span><br><span class="line"><span class="comment"> * 0 otherwise, possibly setting errno if the call failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to restart an existing cursor using RM_ScanCursorRestart.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMPORTANT: This API is very similar to the Redis SCAN command from the</span></span><br><span class="line"><span class="comment"> * point of view of the guarantees it provides. This means that the API</span></span><br><span class="line"><span class="comment"> * may report duplicated keys, but guarantees to report at least one time</span></span><br><span class="line"><span class="comment"> * every key that was there from the start to the end of the scanning process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> If you do database changes within the callback, you should be aware</span></span><br><span class="line"><span class="comment"> * that the internal state of the database may change. For instance it is safe</span></span><br><span class="line"><span class="comment"> * to delete or modify the current key, but may not be safe to delete any</span></span><br><span class="line"><span class="comment"> * other key.</span></span><br><span class="line"><span class="comment"> * Moreover playing with the Redis keyspace while iterating may have the</span></span><br><span class="line"><span class="comment"> * effect of returning more duplicates. A safe pattern is to store the keys</span></span><br><span class="line"><span class="comment"> * names you want to modify elsewhere, and perform the actions on the keys</span></span><br><span class="line"><span class="comment"> * later when the iteration is complete. Howerver this can cost a lot of</span></span><br><span class="line"><span class="comment"> * memory, so it may make sense to just operate on the current key when</span></span><br><span class="line"><span class="comment"> * possible during the iteration, given that this is safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Scan</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleScanCursor *cursor, RedisModuleScanCB fn, <span class="keyword">void</span> *privdata)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scan api that allows a module to scan the elements in a hash, set or sorted set key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callback for scan implementation.</span></span><br><span class="line"><span class="comment"> * void scan_callback(RedisModuleKey *key, RedisModuleString* field,</span></span><br><span class="line"><span class="comment"> *                    RedisModuleString* value, void *privdata);</span></span><br><span class="line"><span class="comment"> * - key - the redis key context provided to for the scan.</span></span><br><span class="line"><span class="comment"> * - field - field name, owned by the caller and need to be retained if used</span></span><br><span class="line"><span class="comment"> *   after this function.</span></span><br><span class="line"><span class="comment"> * - value - value string or NULL for set type, owned by the caller and need to</span></span><br><span class="line"><span class="comment"> *   be retained if used after this function.</span></span><br><span class="line"><span class="comment"> * - privdata - the user data provided to RedisModule_ScanKey.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way it should be used:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_ScanKey(key, c, callback, privateData));</span></span><br><span class="line"><span class="comment"> *      RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to use this API from another thread while the lock is acquired</span></span><br><span class="line"><span class="comment"> * during the actuall call to RM_ScanKey, and re-opening the key each time:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_ScanKey(ctx, c, callback, privateData))&#123;</span></span><br><span class="line"><span class="comment"> *          RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *          // do some background job</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *          RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return 1 if there are more elements to scan and 0 otherwise,</span></span><br><span class="line"><span class="comment"> * possibly setting errno if the call failed.</span></span><br><span class="line"><span class="comment"> * It is also possible to restart an existing cursor using RM_ScanCursorRestart.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Certain operations are unsafe while iterating the object. For instance</span></span><br><span class="line"><span class="comment"> * while the API guarantees to return at least one time all the elements that</span></span><br><span class="line"><span class="comment"> * are present in the data structure consistently from the start to the end</span></span><br><span class="line"><span class="comment"> * of the iteration (see HSCAN and similar commands documentation), the more</span></span><br><span class="line"><span class="comment"> * you play with the elements, the more duplicates you may get. In general</span></span><br><span class="line"><span class="comment"> * deleting the current element of the data structure is safe, while removing</span></span><br><span class="line"><span class="comment"> * the key you are iterating is not safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ScanKey</span><span class="params">(RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="module-fork-api">Module fork API</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a background child process with the current frozen snaphost of the</span></span><br><span class="line"><span class="comment"> * main process where you can do some processing in the background without</span></span><br><span class="line"><span class="comment"> * affecting / freezing the traffic and no need for threads and GIL locking.</span></span><br><span class="line"><span class="comment"> * Note that Redis allows for only one concurrent fork.</span></span><br><span class="line"><span class="comment"> * When the child wants to exit, it should call RedisModule_ExitFromChild.</span></span><br><span class="line"><span class="comment"> * If the parent wants to kill the child it should call RedisModule_KillForkChild</span></span><br><span class="line"><span class="comment"> * The done handler callback will be executed on the parent process when the</span></span><br><span class="line"><span class="comment"> * child existed (but not when killed)</span></span><br><span class="line"><span class="comment"> * Return: -1 on failure, on success the parent process will get a positive PID</span></span><br><span class="line"><span class="comment"> * of the child, and the child process will get 0. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Fork</span><span class="params">(RedisModuleForkDoneHandler cb, <span class="keyword">void</span> *user_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call from the child process when you want to terminate it.</span></span><br><span class="line"><span class="comment"> * retcode will be provided to the done handler executed on the parent process. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ExitFromChild</span><span class="params">(<span class="keyword">int</span> retcode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can be used to kill the forked child process from the parent process.</span></span><br><span class="line"><span class="comment"> * child_pid whould be the return value of RedisModule_Fork. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_KillForkChild</span><span class="params">(<span class="keyword">int</span> child_pid)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="server-hooks-implementation">Server hooks implementation</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register to be notified, via a callback, when the specified server event</span></span><br><span class="line"><span class="comment"> * happens. The callback is called with the event as argument, and an additional</span></span><br><span class="line"><span class="comment"> * argument which is a void pointer and should be cased to a specific type</span></span><br><span class="line"><span class="comment"> * that is event-specific (but many events will just use NULL since they do not</span></span><br><span class="line"><span class="comment"> * have additional information to pass to the callback).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the callback is NULL and there was a previous subscription, the module</span></span><br><span class="line"><span class="comment"> * will be unsubscribed. If there was a previous subscription and the callback</span></span><br><span class="line"><span class="comment"> * is not null, the old callback will be replaced with the new one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The callback must be of this type:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  int (*RedisModuleEventCallback)(RedisModuleCtx *ctx,</span></span><br><span class="line"><span class="comment"> *                                  RedisModuleEvent eid,</span></span><br><span class="line"><span class="comment"> *                                  uint64_t subevent,</span></span><br><span class="line"><span class="comment"> *                                  void *data);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The 'ctx' is a normal Redis module context that the callback can use in</span></span><br><span class="line"><span class="comment"> * order to call other modules APIs. The 'eid' is the event itself, this</span></span><br><span class="line"><span class="comment"> * is only useful in the case the module subscribed to multiple events: using</span></span><br><span class="line"><span class="comment"> * the 'id' field of this structure it is possible to check if the event</span></span><br><span class="line"><span class="comment"> * is one of the events we registered with this callback. The 'subevent' field</span></span><br><span class="line"><span class="comment"> * depends on the event that fired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally the 'data' pointer may be populated, only for certain events, with</span></span><br><span class="line"><span class="comment"> * more relevant data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here is a list of events you can use as 'eid' and related sub events:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_ReplicationRoleChanged</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when the instance switches from master</span></span><br><span class="line"><span class="comment"> *          to replica or the other way around, however the event is</span></span><br><span class="line"><span class="comment"> *          also called when the replica remains a replica but starts to</span></span><br><span class="line"><span class="comment"> *          replicate with a different master.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_MASTER</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The 'data' field can be casted by the callback to a</span></span><br><span class="line"><span class="comment"> *          RedisModuleReplicationInfo structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int master; // true if master, false if replica</span></span><br><span class="line"><span class="comment"> *              char *masterhost; // master instance hostname for NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *              int masterport; // master instance port for NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *              char *replid1; // Main replication ID</span></span><br><span class="line"><span class="comment"> *              char *replid2; // Secondary replication ID</span></span><br><span class="line"><span class="comment"> *              uint64_t repl1_offset; // Main replication offset</span></span><br><span class="line"><span class="comment"> *              uint64_t repl2_offset; // Offset of replid2 validity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Persistence</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when RDB saving or AOF rewriting starts</span></span><br><span class="line"><span class="comment"> *          and ends. The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_ENDED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_FAILED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The above events are triggered not just when the user calls the</span></span><br><span class="line"><span class="comment"> *          relevant commands like BGSAVE, but also when a saving operation</span></span><br><span class="line"><span class="comment"> *          or AOF rewriting occurs because of internal server triggers.</span></span><br><span class="line"><span class="comment"> *          The SYNC_RDB_START sub events are happening in the forground due to</span></span><br><span class="line"><span class="comment"> *          SAVE command, FLUSHALL, or server shutdown, and the other RDB and</span></span><br><span class="line"><span class="comment"> *          AOF sub events are executed in a background fork child, so any</span></span><br><span class="line"><span class="comment"> *          action the module takes can only affect the generated AOF or RDB,</span></span><br><span class="line"><span class="comment"> *          but will not be reflected in the parent process and affect connected</span></span><br><span class="line"><span class="comment"> *          clients and commands. Also note that the AOF_START sub event may end</span></span><br><span class="line"><span class="comment"> *          up saving RDB content in case of an AOF with rdb-preamble.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_FlushDB</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The FLUSHALL, FLUSHDB or an internal flush (for instance</span></span><br><span class="line"><span class="comment"> *          because of replication, after the replica synchronization)</span></span><br><span class="line"><span class="comment"> *          happened. The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_FLUSHDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_FLUSHDB_END</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleFlushInfo</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t async;  // True if the flush is done in a thread.</span></span><br><span class="line"><span class="comment"> *                                 See for instance FLUSHALL ASYNC.</span></span><br><span class="line"><span class="comment"> *                                 In this case the END callback is invoked</span></span><br><span class="line"><span class="comment"> *                                 immediately after the database is put</span></span><br><span class="line"><span class="comment"> *                                 in the free list of the thread.</span></span><br><span class="line"><span class="comment"> *              int32_t dbnum;  // Flushed database number, -1 for all the DBs</span></span><br><span class="line"><span class="comment"> *                                 in the case of the FLUSHALL operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The start event is called *before* the operation is initated, thus</span></span><br><span class="line"><span class="comment"> *          allowing the callback to call DBSIZE or other operation on the</span></span><br><span class="line"><span class="comment"> *          yet-to-free keyspace.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Loading</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Called on loading operations: at startup when the server is</span></span><br><span class="line"><span class="comment"> *          started, but also after a first synchronization when the</span></span><br><span class="line"><span class="comment"> *          replica is loading the RDB file from the master.</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_AOF_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_REPL_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_ENDED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_FAILED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Note that AOF loading may start with an RDB data in case of</span></span><br><span class="line"><span class="comment"> *          rdb-preamble, in which case you'll only recieve an AOF_START event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_ClientChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Called when a client connects or disconnects.</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleClientInfo</span></span><br><span class="line"><span class="comment"> *          structure, documented in RedisModule_GetClientInfoById().</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Shutdown</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The server is shutting down. No subevents are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_ReplicaChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when the instance (that can be both a</span></span><br><span class="line"><span class="comment"> *          master or a replica) get a new online replica, or lose a</span></span><br><span class="line"><span class="comment"> *          replica since it gets disconnected.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          No additional information is available so far: future versions</span></span><br><span class="line"><span class="comment"> *          of Redis will have an API in order to enumerate the replicas</span></span><br><span class="line"><span class="comment"> *          connected and their state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_CronLoop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called every time Redis calls the serverCron()</span></span><br><span class="line"><span class="comment"> *          function in order to do certain bookkeeping. Modules that are</span></span><br><span class="line"><span class="comment"> *          required to do operations from time to time may use this callback.</span></span><br><span class="line"><span class="comment"> *          Normally Redis calls this function 10 times per second, but</span></span><br><span class="line"><span class="comment"> *          this changes depending on the "hz" configuration.</span></span><br><span class="line"><span class="comment"> *          No sub events are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleCronLoop</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t hz;  // Approximate number of events per second.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_MasterLinkChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This is called for replicas in order to notify when the</span></span><br><span class="line"><span class="comment"> *          replication link becomes functional (up) with our master,</span></span><br><span class="line"><span class="comment"> *          or when it goes down. Note that the link is not considered</span></span><br><span class="line"><span class="comment"> *          up when we just connected to the master, but only if the</span></span><br><span class="line"><span class="comment"> *          replication is happening correctly.</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MASTER_LINK_UP</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_ModuleChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when a new module is loaded or one is unloaded.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MODULE_LOADED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MODULE_UNLOADED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleModuleChange</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              const char* module_name;  // Name of module loaded or unloaded.</span></span><br><span class="line"><span class="comment"> *              int32_t module_version;  // Module version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_LoadingProgress</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called repeatedly called while an RDB or AOF file</span></span><br><span class="line"><span class="comment"> *          is being loaded.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleLoadingProgress</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t hz;  // Approximate number of events per second.</span></span><br><span class="line"><span class="comment"> *              int32_t progress;  // Approximate progress between 0 and 1024,</span></span><br><span class="line"><span class="comment"> *                                    or -1 if unknown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK if the module was successfully subscrived</span></span><br><span class="line"><span class="comment"> * for the specified event. If the API is called from a wrong context then</span></span><br><span class="line"><span class="comment"> * REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SubscribeToServerEvent</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleEvent event, RedisModuleEventCallback callback)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="modules-api-internals">Modules API internals</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the key last access time for LRU based eviction. not relevent if the</span></span><br><span class="line"><span class="comment"> * servers's maxmemory policy is LFU based. Value is idle time in milliseconds.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if the LRU was updated, REDISMODULE_ERR otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetLRU</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> lru_idle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gets the key last access time.</span></span><br><span class="line"><span class="comment"> * Value is idletime in milliseconds or -1 if the server's eviction policy is</span></span><br><span class="line"><span class="comment"> * LFU based.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if when key is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetLRU</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> *lru_idle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the key access frequency. only relevant if the server's maxmemory policy</span></span><br><span class="line"><span class="comment"> * is LFU based.</span></span><br><span class="line"><span class="comment"> * The frequency is a logarithmic counter that provides an indication of</span></span><br><span class="line"><span class="comment"> * the access frequencyonly (must be &lt;= 255).</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if the LFU was updated, REDISMODULE_ERR otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetLFU</span><span class="params">(RedisModuleKey *key, <span class="keyword">long</span> <span class="keyword">long</span> lfu_freq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gets the key access frequency or -1 if the server's eviction policy is not</span></span><br><span class="line"><span class="comment"> * LFU based.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if when key is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetLFU</span><span class="params">(RedisModuleKey *key, <span class="keyword">long</span> <span class="keyword">long</span> *lfu_freq)</span></span>;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/3ac765ba/" rel="next" title="NVM-notes">
                  <i class="fa fa-chevron-left"></i> NVM-notes
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#service-api-exported-to-modules"><span class="nav-number">2.</span> <span class="nav-text">Service API exported to modules</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册命令"><span class="nav-number">2.1.</span> <span class="nav-text">注册命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">2.2.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redismodulestring-objects-apis"><span class="nav-number">3.</span> <span class="nav-text">RedisModuleString objects APIs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#create"><span class="nav-number">3.1.</span> <span class="nav-text">Create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">3.2.</span> <span class="nav-text">Free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retain"><span class="nav-number">3.3.</span> <span class="nav-text">Retain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#convert"><span class="nav-number">3.4.</span> <span class="nav-text">Convert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operators"><span class="nav-number">3.5.</span> <span class="nav-text">Operators</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reply-apis"><span class="nav-number">4.</span> <span class="nav-text">Reply APIs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reply-with-numeral"><span class="nav-number">4.1.</span> <span class="nav-text">Reply with numeral</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reply-with-string"><span class="nav-number">4.2.</span> <span class="nav-text">Reply with string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reply-with-array"><span class="nav-number">4.3.</span> <span class="nav-text">Reply with array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#others"><span class="nav-number">4.4.</span> <span class="nav-text">Others</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commands-replication-apis"><span class="nav-number">5.</span> <span class="nav-text">Commands replication APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#db-and-key-apis----generic-apis"><span class="nav-number">6.</span> <span class="nav-text">DB and Key APIs -- Generic APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#low-level-key-apis"><span class="nav-number">7.</span> <span class="nav-text">Low level Key APIs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#base"><span class="nav-number">7.1.</span> <span class="nav-text">Base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-type"><span class="nav-number">7.2.</span> <span class="nav-text">String type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-type"><span class="nav-number">7.3.</span> <span class="nav-text">List type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorted-set-type"><span class="nav-number">7.4.</span> <span class="nav-text">Sorted Set type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-type"><span class="nav-number">7.5.</span> <span class="nav-text">Hash type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#high-level-key-apis----call"><span class="nav-number">8.</span> <span class="nav-text">High level Key APIs -- Call</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义数据类型"><span class="nav-number">9.</span> <span class="nav-text">自定义数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#create-data-type"><span class="nav-number">9.1.</span> <span class="nav-text">Create Data Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-to-moduletype"><span class="nav-number">9.2.</span> <span class="nav-text">Access to moduleType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb-loading-and-saving-functions"><span class="nav-number">9.3.</span> <span class="nav-text">RDB loading and saving functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-digest-api"><span class="nav-number">9.4.</span> <span class="nav-text">Key digest API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof-api-for-modules-data-types"><span class="nav-number">9.5.</span> <span class="nav-text">AOF API for modules data types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-context-handling"><span class="nav-number">9.6.</span> <span class="nav-text">IO context handling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出日志"><span class="nav-number">10.</span> <span class="nav-text">输出日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#blocking-clients-from-modules"><span class="nav-number">11.</span> <span class="nav-text">Blocking clients from modules</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#block-client"><span class="nav-number">11.1.</span> <span class="nav-text">Block Client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block-client-on-keys"><span class="nav-number">11.2.</span> <span class="nav-text">Block Client On Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#utils"><span class="nav-number">11.3.</span> <span class="nav-text">Utils</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-safe-contexts"><span class="nav-number">12.</span> <span class="nav-text">Thread Safe Contexts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#module-keyspace-notifications-api"><span class="nav-number">13.</span> <span class="nav-text">Module Keyspace Notifications API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-cluster-api"><span class="nav-number">14.</span> <span class="nav-text">Modules Cluster API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-timers-api"><span class="nav-number">15.</span> <span class="nav-text">Modules Timers API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-acl-api"><span class="nav-number">16.</span> <span class="nav-text">Modules ACL API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-dictionary-api"><span class="nav-number">17.</span> <span class="nav-text">Modules Dictionary API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#base-1"><span class="nav-number">17.1.</span> <span class="nav-text">Base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setgetdel"><span class="nav-number">17.2.</span> <span class="nav-text">Set/Get/Del</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterator"><span class="nav-number">17.3.</span> <span class="nav-text">Iterator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-info-fields"><span class="nav-number">18.</span> <span class="nav-text">Modules Info fields</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-utility-apis"><span class="nav-number">19.</span> <span class="nav-text">Modules utility APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-api-exporting-importing"><span class="nav-number">20.</span> <span class="nav-text">Modules API exporting / importing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#module-command-filter-api"><span class="nav-number">21.</span> <span class="nav-text">Module Command Filter API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scanning-keyspace-and-hashes"><span class="nav-number">22.</span> <span class="nav-text">Scanning keyspace and hashes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#module-fork-api"><span class="nav-number">23.</span> <span class="nav-text">Module fork API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#server-hooks-implementation"><span class="nav-number">24.</span> <span class="nav-text">Server hooks implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules-api-internals"><span class="nav-number">25.</span> <span class="nav-text">Modules API internals</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="KyoAni"
    src="/images/k-on.jpg">
  <p class="site-author-name" itemprop="name">KyoAni</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yz1509" title="GitHub &rarr; https://github.com/yz1509" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pro-765@qq.com" title="E-Mail &rarr; mailto:pro-765@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KyoAni</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
