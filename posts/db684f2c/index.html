<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="面试可能会遇到的与 C++ 相关的问答记录。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试知识点">
<meta property="og:url" content="https://yz1509.github.io/posts/db684f2c/index.html">
<meta property="og:site_name" content="HTT">
<meta property="og:description" content="面试可能会遇到的与 C++ 相关的问答记录。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yz1509.github.io/posts/db684f2c/001.png">
<meta property="og:image" content="https://yz1509.github.io/posts/db684f2c/002.png">
<meta property="og:image" content="https://yz1509.github.io/posts/db684f2c/003.png">
<meta property="og:image" content="https://yz1509.github.io/posts/db684f2c/004.png">
<meta property="og:image" content="https://yz1509.github.io/posts/db684f2c/005.png">
<meta property="og:updated_time" content="2020-03-09T08:28:42.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面试知识点">
<meta name="twitter:description" content="面试可能会遇到的与 C++ 相关的问答记录。">
<meta name="twitter:image" content="https://yz1509.github.io/posts/db684f2c/001.png">

<link rel="canonical" href="https://yz1509.github.io/posts/db684f2c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>C++面试知识点 | HTT</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HTT</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">ふわふわ時間</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yz1509.github.io/posts/db684f2c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/k-on.jpg">
      <meta itemprop="name" content="KyoAni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HTT">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++面试知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-28 10:52:52" itemprop="dateCreated datePublished" datetime="2018-07-28T10:52:52+08:00">2018-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-09 16:28:42" itemprop="dateModified" datetime="2020-03-09T16:28:42+08:00">2020-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/秋招/" itemprop="url" rel="index">
                    <span itemprop="name">秋招</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试可能会遇到的与 C++ 相关的问答记录。</p>
<a id="more"></a>
<hr>
<p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。</p>
<h1 id="c-基础知识点">C++ 基础知识点</h1>
<h2 id="有符号类型和无符号类型">有符号类型和无符号类型</h2>
<ol type="1">
<li>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数。</li>
<li>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的；此时，程序可能继续工作、可能崩溃。也可能生成垃圾数据。</li>
<li>如果表达式中既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动转换成无符号数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-2</span>;	<span class="comment">// case 1, b = 4294967294 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 输出 4294967295</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;			<span class="comment">// c = -1</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> e = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d + e &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// case 3， 输出 4294967295</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="引用与指针">引用与指针</h2>
<p>引用并非对象，它只是为一个已经存在的对象起的一个别名。在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<p>指针是指向另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有许多不同点：</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝。而且在指针的生命周期内它可以先后指向几个不同的对象。引用不是对象，所以也不能定义指向引用的指针。</li>
<li>指针无须在定义时赋值。</li>
</ul>
<p>void* 是一种特殊的指针类型，可以存放任意对象的地址。但我们对该地址中存放的是什么类型的对象并不了解，所以也不能直接操作 void* 指针所指的对象。</p>
<h2 id="static-关键字">static 关键字</h2>
<ul>
<li>声明为 static 的局部变量，存储在静态存储区，其生存期不再局限于当前作用域，而是整个程序的生存期。</li>
<li>对于全局变量而言， 普通的全局变量和函数，其作用域为整个程序或项目，外部文件（其它 cpp文件）可以通过 extern 关键字访问该变量和函数；static 全局变量和函数，其作用域为当前 cpp 文件，其它的 cpp 文件不能访问该变量和函数。</li>
<li>当使用 static 修饰成员变量和成员函数时，表示该变量或函数属于一个类，而不是该类的某个实例化对象。</li>
</ul>
<h2 id="const-限定符">const 限定符</h2>
<p>const 的作用： 1. 在定义常变量时必须同时对它初始化，此后它的值不能再改变。常变量不能出现在赋值号的左边（不为“左值”）； 2. 对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const； 3. 在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； 4. 对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量； 5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为"左值"。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator*的返回结果必须是一个const对象，否则下列代码编译出错</span></span><br><span class="line"><span class="keyword">const</span> classA <span class="keyword">operator</span>*(<span class="keyword">const</span> classA&amp; a1,<span class="keyword">const</span> classA&amp; a2);  </span><br><span class="line">classA a, b, c;</span><br><span class="line">(a*b) = c;  <span class="comment">//对a*b的结果赋值。操作(a*b) = c显然不符合编程者的初衷，也没有任何意义</span></span><br></pre></td></tr></table></figure></p>
<p>用 const 修饰符号常量的区别： * const 位于 * 的左边，表示被指物是常量 * const 位于 * 的右边，表示指针自身是常量（常量指针）。（口诀：左定值，右定向） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p;  <span class="comment">//指向const对象的指针，指针可以被修改，但指向的对象不能被修改。</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p; <span class="comment">//指向char类型的常量指针，指针不能被修改，但指向的对象可以被修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p;  <span class="comment">//指针及指向对象都不能修改。</span></span><br></pre></td></tr></table></figure></p>
<p>const 与 #define 的区别： * const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。 * 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。 * 在 C++ 程序中只使用 const 常量而不使用宏常量，即 const 常量完全取代宏常量。</p>
<h2 id="数组与指针的区别">数组与指针的区别</h2>
<ul>
<li>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</li>
<li>用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量。C/C++ 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</li>
<li>C++ 编译系统将形参数组名一律作为指针变量来处理。实际上在函数调用时并不存在一个占有存储空间的形参数组，只有指针变量。
<ul>
<li>实参数组名 a 代表一个固定的地址，或者说是指针型常量，因此要改变 a 的值是不可能的。例如：<span class="math inline">\(a++;\)</span> 是错误的。</li>
<li>形参数组名 array 是指针变量，并不是一个固定的地址值。它的值是可以改变的。例如：<span class="math inline">\(array++;\)</span> 是合法的。</li>
</ul></li>
</ul>
<p>为了节省内存，C/C++ 把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量字符串初始化数组时，情况却有所不同。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 会为它们分配两个长度为12个字节的空间</span></span><br><span class="line"><span class="comment">// 并把 “Hello World” 的内容分别复制到数组中去，这是两个初始地址不同的数组。</span></span><br><span class="line"><span class="keyword">char</span> str1[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> str2[] = “Hello World”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str3 和 str4 是两个指针，我们无须为它们分配内存以存储字符串的内容</span></span><br><span class="line"><span class="comment">// 而只需要把它们指向 “Hello World” 在内存中的地址就可以了。</span></span><br><span class="line"><span class="comment">// 由于 “Hello World” 是常量字符串，它在内存中只有一个拷贝，</span></span><br><span class="line"><span class="comment">// 因此 str3 和 str4 指向的是同一个地址。</span></span><br><span class="line"><span class="keyword">char</span> *str3[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> *str4[] = “Hello World”;</span><br></pre></td></tr></table></figure></p>
<h2 id="sizeof-运算符">sizeof 运算符</h2>
<p>sizeof 是 C 语言的一种单目操作符，它并不是函数。操作数可以是一个表达式或类型名。数据类型必须用括号括住，<span class="math inline">\(sizeof(int);\)</span>， 变量名可以不用括号括住。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>];				<span class="comment">//sizeof(a)=200</span></span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];		<span class="comment">//sizeof(a)=4;</span></span><br><span class="line">Class Test&#123;<span class="keyword">int</span> a; <span class="keyword">static</span> <span class="keyword">double</span> c&#125;;  <span class="comment">//sizeof(Test)=4</span></span><br><span class="line">Test *s;				<span class="comment">//sizeof(s)=4</span></span><br><span class="line">Class Test&#123; &#125;;			<span class="comment">//sizeof(Test)=1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> s[<span class="number">5</span>])</span></span>;	<span class="comment">//sizeof(s)=4;</span></span><br></pre></td></tr></table></figure></p>
<p>当操作数不同时需要注意： * 数组类型，其结果是数组的总字节数；指向数组的指针，其结果是该指针的字节数。 * 函数中的数组形参或函数类型的形参，其结果是指针的字节数。 * 联合类型，其结果采用成员最大长度对齐。 * 结构类型或类类型，其结果是这种类型对象的总字节数，包括任何填充在内。 对类进行操作时需要注意： * 类中的静态成员不对结果产生影响，因为静态变量的存储位置与结构或者类的实例地址无关; * 没有成员变量的类的大小为 1，因为必须保证类的每一个实例在内存中都有唯一的地址; * 有虚函数的类都会建立一张虚函数表，表中存放的是虚函数的函数指针，这个表的地址存放在类中，所以不管有几个虚函数，都只占据一个指针大小。</p>
<h3 id="例题">例题</h3>
<ol type="1">
<li>下列联合体的 sizeof(sampleUnion) 的值为多少。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">short</span> value;</span><br><span class="line">&#125; sampleUnion;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>答案：4。联合体占用大小采用成员最大长度的对齐，最大长度是 short 的2字节。但 char flag[3] 需要 3 个字节，所以 sizeof(sampleUnion) = 2 * (2字节) = 4。注意对齐有两层含义，一个是按本身的字节大小数对齐，一个是整体按照最大的字节数对齐。 2. 在 32 位系统中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;	<span class="comment">// 没有引号，为 ASCLL 值</span></span><br><span class="line"><span class="keyword">char</span> *str = arr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 5，strlen 函数求取字符串长度以 ASCII 值为 0 为止。</span></span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>定义一个空的类型，里面没有任何成员变量和成员函数。 问：对该类型求sizeof，得到的结果是什么？ 答：1。 问：为什么不是0？ 答：当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio 中每个空类型的实例占用 1 字节的空间。 问：如果在该类型中添加一个构造函数和析构函数，结果又是什么？ 答：还是 1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。 问：那如果把析构函数标记为虚函数呢？ 答：C++ 的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在 32 位的机器上，指针占用 4 字节，因此求 sizeof 得到4；如果是 64位机器，将得到 8。</li>
</ol>
<h2 id="结构体的内存对齐">结构体的内存对齐</h2>
<p>内存对齐规则： * 每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍。为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。 * 最终占用字节数为成员类型中最大占用字节数的整数倍。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体在编译以后，为了字节对齐，会被整理成这个样子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">3</span>];</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p>
<p>所以编译前总的结构体大小为：8 个字节。编译以后字节大小变为：12 个字节。 但是，如果调整顺序： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p>
<p>那么这个结构体在编译前后的大小都是 8 个字节。编译后不用填充字节就能保持所有的成员都按各自默认的地址对齐。这样可以节约不少内存！所以一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少。</p>
<h2 id="强制类型转换">强制类型转换</h2>
<p>C++ 中有以下四种命名的强制类型转换： 1. static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 2. const_cast：去const属性，只能改变运算对象的底层const。常用于有函数重载的上下文中。 3. reninterpret_cast：通常为运算对象的位模式提供较低层次的重新解释，本质依赖与机器。 4. dynamic_cast：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。主要用于多态类之间的转换。</p>
<p>一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告；但是当我们执行了显式的类型转换之后，警告信息就被关闭了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>,i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何非常量对象的地址都能存入void*，通过static_cast可以将指针转换会初始的指针类型</span></span><br><span class="line"><span class="keyword">void</span>* p = &amp;slope;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<p>只有 const_cast 能够改变表达式的常量属性，其他形式的强制类型转换改变表达式的常量属性都将引发编译器错误。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用const_cast去除底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc = &amp;c;</span><br><span class="line"><span class="keyword">char</span>* cp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line">*cp = <span class="string">'c'</span>;</span><br></pre></td></tr></table></figure></p>
<p>reinterpret_cast 常用于函数指针类型之间进行转换。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;return0;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FuncPtr)</span><span class="params">()</span></span>; <span class="comment">// FuncPtr是一个指向函数的指针，该函数没有参数，返回值类型为void</span></span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>]; <span class="comment">// 假设你希望把一个指向下面函数的指针存入funcPtrArray数组</span></span><br><span class="line"></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = &amp;doSomething;<span class="comment">// 编译错误！类型不匹配</span></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething); <span class="comment">// 不同函数指针类型之间进行转换</span></span><br></pre></td></tr></table></figure></p>
<p>dynamic_cast：有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)： * 安全的基类和子类之间转换。 * 必须要有虚函数。 * 相同基类不同子类之间的交叉转换。但结果是NULL。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iNum;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//基类必须有虚函数。保持多态特性才能使用dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span>*m_szName[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* pb =<span class="keyword">new</span> Derive();</span><br><span class="line">Derive *pd1 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，静态类型转换，正确但不推荐</span></span><br><span class="line">Derive *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，动态类型转换，正确</span></span><br><span class="line"></span><br><span class="line">Base* pb2 =<span class="keyword">new</span> Base();</span><br><span class="line">Derive *pd21 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></span><br><span class="line">Derive *pd22 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></span><br></pre></td></tr></table></figure></p>
<h2 id="mallocfree-与-newdelete-的区别">malloc/free 与 new/delete 的区别</h2>
<ul>
<li>malloc 与 free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请和释放动态内存。</li>
<li>对于非内部数据类型的对象而言，用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free，因此C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，和一个能完成清理与释放内存工作的运算符 delete。</li>
<li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void* 指针。new/delete 在实现上其实调用了 malloc/free 函数。</li>
<li>new 建立的是一个对象；malloc 分配的是一块内存。</li>
</ul>
<h1 id="面向对象编程">面向对象编程</h1>
<h2 id="string-类的实现">String 类的实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString();</span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    ~MyString()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> length();	<span class="comment">// 返回字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;		<span class="comment">// 返回字符串是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">c_str</span><span class="params">()</span></span>;	<span class="comment">// 返回 c 风格的 str 的指针</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;, MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add operation</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compare operations</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数实现运算符重载,其实一般需要返回自身对象的，成员函数运算符重载会好一些</span></span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>)<span class="keyword">const</span>;</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员操作函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">append</span><span class="params">(<span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">insert</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">size_t</span> index = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p_str;</span><br><span class="line">    <span class="keyword">size_t</span> strLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="派生类中构造函数与析构函数的调用顺序">派生类中构造函数与析构函数的调用顺序</h2>
<p>构造函数的调用顺序总是如下： 1. 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。 2. 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。 3. 派生类构造函数。 析构函数正好和构造函数相反。</p>
<h2 id="虚函数的实现原理">虚函数的实现原理</h2>
<p><strong>虚函数表</strong>：编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的虚函数表是一块连续的内存，每个内存单元中记录一个 JMP 指令的地址。类的每个虚函数占据虚函数表中的一块，如果类中有 N 个虚函数，那么其虚函数表将有 4N 字节的大小。</p>
<p>编译器在有虚函数的类的实例中创建了一个指向这个表的指针，该指针通常存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能）。这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<p>有虚函数或虚继承的类实例化后的对象大小至少为 4 字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为 1 字节（没有非静态数据成员的情况下也要有 1 个字节来记录它的地址）。</p>
<p><strong>哪些函数适合声明为虚函数，哪些不能？</strong> * 当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果； * 内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； * 构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数； * 静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。</p>
<h2 id="虚继承的实现原理">虚继承的实现原理</h2>
<p>为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p>
<p>构造函数和析构函数的顺序：虚基类总是先于非虚基类构造，与它们在集成体系中的次序和位置无关。如果有多个虚基类，则按它们在派生列表中出现的顺序从左到右依次构造。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ZooAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ToyAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ToyAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Character()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Character construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BookCharacter()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BookCharacter construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter, <span class="keyword">public</span> Bear, <span class="keyword">virtual</span> <span class="keyword">public</span> ToyAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    TeddyBear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"TeddyBear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TeddyBear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器按照直接基类的声明顺序依次检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明顺序依次构造其他非虚基类。构造函数的顺序是：ZooAnimal, ToyAnimal, Character, BookCharacter, Bear, TeddyBear。析构过程与构造过程正好相反。</p>
<h1 id="内存管理">内存管理</h1>
<h2 id="程序加载时的内存分布">程序加载时的内存分布</h2>
<p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。</p>
<figure>
<img src="/posts/db684f2c/001.png" alt=""><figcaption>内存分布</figcaption>
</figure>
<ul>
<li>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</li>
<li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局 const 变量等。</li>
<li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li>
<li>BSS 段(.bss)：未初始化的全局变量和局部静态变量一般放在 .bss 的段里，以节省内存空间。</li>
<li>堆：用来容纳应用程序动态分配的内存区域。当程序使用 malloc 或 new 分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li>
<li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li>
<li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li>
<li>保留区：内存中受到保护而禁止访问的内存区域。</li>
</ul>
<h2 id="堆与栈的区别">堆与栈的区别</h2>
<ol type="1">
<li>申请管理方式
<ul>
<li>栈：由编译器自动管理，无需我们手工控制。</li>
<li>堆：堆的申请和释放工作由程序员控制，容易产生内存泄漏。</li>
</ul></li>
<li>申请后系统的响应
<ul>
<li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li>
</ul></li>
<li>申请大小的限制
<ul>
<li>栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 1 M（可修改），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</li>
<li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul></li>
<li>申请效率的比较
<ul>
<li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li>
<li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在 Windows 下，最好的方式是用 VirtualAlloc 分配内存，它不是在堆，也不是在栈而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li>
</ul></li>
<li>堆与栈中的存储内容
<ul>
<li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li>
</ul></li>
</ol>
<p><strong>总结</strong>：堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；并且可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，ebp 和局部变量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是向堆申请内存更加灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<h2 id="常见的内存错误及其对策">常见的内存错误及其对策</h2>
<ol type="1">
<li>内存分配未成功，却使用了它，因为没有意识到内存分配会不成功。 解决办法：在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 <span class="math inline">\(assert(p != NULL)\)</span> 进行检查。如果是用 malloc 或 new 来申请内存，应该用 <span class="math inline">\(if(p == NULL)\)</span> 或 <span class="math inline">\(if(p != NULL)\)</span> 进行防错处理。</li>
<li>内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：
<ul>
<li>一是没有初始化的观念；</li>
<li>二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 解决方法：不要忘记为数组和动态内存赋初值，即便是赋零值也不可省略。防止将未被初始化的内存作为右值使用。</li>
</ul></li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1 ” 或者“少 1 ”的操作。特别是在 for 循环语句中，循环次数很容易搞错，导致数组操作越界。 解决方法：避免数组或指针的下标越界，特别要当心发生“多 1 ”或者“少 1 ”操作。</li>
<li>忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。 解决方法：动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定有错误（new/delete 同理）。</li>
<li>释放了内存却继续使用它。有三种情况：
<ul>
<li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li>
<li>函数的 return 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li>
<li>使用 free 或 delete 释放了内存后，没有将指针设置为 NULL。导致产生“野指针”。 解决方法：用 free 或 delete 释放了内存之后，立即将指针设置为 NULL，防止产生“野指针”。</li>
</ul></li>
</ol>
<h2 id="智能指针">智能指针</h2>
<p>智能指针是在 &lt;memory&gt; 头文件中的 std 命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对 RAII “获取资源即初始化”编程至关重要，RAII 的主要原则是将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数，包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。在 C++11 中，定义了 3 种智能指针（unique_ptr、shared_ptr、weak_ptr），并删除了 C++98 中的 auto_ptr。</p>
<p>智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写 delete 语句删除指针指向的内存空间。</p>
<p><strong>unique_ptr</strong> “独占”所指向的对象。unique_ptr 小巧高效；大小等同于一个指针且支持 rvalue 引用，从而可实现快速插入和对 STL 集合的检索。</p>
<p><strong>shared_ptr</strong> 采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用 make_shared 标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的 shared_ptr。</p>
<p>智能指针支持的操作： * 使用重载的 -&gt; 和 * 运算符访问对象。 * 使用get成员函数获取原始指针，提供对原始指针的直接访问。你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。 * 使用删除器定义自己的释放操作。 * 使用 release 成员函数，作用是放弃智能指针对指针的控制权，将智能指针置空，并返回原始指针。（只支持unique_ptr） * 使用 reset 释放智能指针对对象的所有权。</p>
<p>智能指针的使用示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> _a): a(_a)&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up1(<span class="keyword">new</span> Base(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Base&gt; up2 = up1;   //编译器提示未定义</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up2 = move(up1);  <span class="comment">//转移对象的所有权 </span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; up1-&gt;a &lt;&lt; endl; //运行时错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; up2-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//通过解引用运算符获取封装的原始指针 </span></span><br><span class="line">    up2.reset(); <span class="comment">// 显式释放内存 </span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp1(<span class="keyword">new</span> Base(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp2 = sp1;  <span class="comment">//增加引用计数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//2</span></span><br><span class="line">    sp1.reset();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sp2-&gt;a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">auto</span> sp3 = make_shared&lt;base&gt;(<span class="number">4</span>);<span class="comment">//利用make_shared函数动态分配内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="c-对象内存模型">C++ 对象内存模型</h1>
<p>在 C++ 中有两种类的数据成员：static 和 nonstatic，以及三种类的成员函数：static、nonstatic和virtual。</p>
<p>在 C++ 对象模型中 * 非静态数据<strong>成员</strong>被配置于每一个类的对象之中，静态数据<strong>成员</strong>则被存放在所有的类对象之外； * 静态及非静态成员<strong>函数</strong>也被放在类对象之外，虚函数则通过以下两个步骤支持： 1. 每一个类产生出一堆指向虚函数的指针，放在表格之中，这个表格被称为虚函数表（virtual table, vtbl）。 2. 每一个类对象被添加了一个指针，指向相关的虚函数表，通常这个指针被称为 vptr。vptr 的设定和重置都由每一个类的构造函数、析构函数和拷贝赋值运算符自动完成。另外，虚函数表地址的前面设置了一个指向 type_info 的指针，RTTI（Run Time Type Identification）运行时类型识别是由编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI 是为多态而生成的信息，所以只有具有虚函数的对象才会生成。</p>
<h2 id="继承下的对象内存模型">继承下的对象内存模型</h2>
<p>C++支持单一继承、多重继承和虚继承。在虚继承的情况下，虚基类不管在继承链中被派生多少次，永远只会存在一个实体。 1. 单一继承，继承关系为 class Derived : public Base。其对象的内存布局为：虚函数表指针、Base 类的非 static 成员变量、Derived 类的非 static 成员变量。 2. 多重继承，继承关系为 class Derived : public Base1, public Base2。其对象的内存布局为：基类 Base1 子对象和基类 Base2 子对象及 Derived 类的非 static 成员变量组成。基类子对象包括其虚函数表指针和其非 static 的成员变量。 3. 重复继承，继承关系如下。Derived 类的对象的内存布局与多继承相似，但是可以看到基类Base 的子对象在 Derived 类的对象的内存中存在一份拷贝。这样直接使用 Derived 中基类 Base 的相关成员时，就会引发歧义，可使用多重虚拟继承消除之。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>虚继承，继承关系如下。其对象的内存布局与重复继承的类的对象的内存分布类似，但是基类Base 的子对象没有拷贝，在对象的内存中仅存在一个 Base 类的子对象。但是它的非 static 成员变量放置在对象的末尾处。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></li>
</ol>
<figure>
<img src="/posts/db684f2c/002.png" alt=""><figcaption>继承下的对象内存模型</figcaption>
</figure>
<h1 id="常见的设计模式">常见的设计模式</h1>
<h2 id="单例模式">单例模式</h2>
<p>当仅允许类的一个实例在应用中被创建的时候，我们使用单例模式（Singleton Pattern）。它保护类的创建过程来确保只有一个实例被创建，它通过设置类的构造方法为私有（private）来实现。要获得类的实例，单例类可以提供一个方法，如 GetInstance()，来返回类的实例。该方法是唯一可以访问类来创建实例的方法。</p>
<p><strong>优点</strong> 1. 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。 2. 减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 3. 避免对资源的多重占用。如避免对同一个资源文件的同时写操作。 4. 单例模式可以在系统设置全局的访问点，优化和共享资源访问。</p>
<p><strong>缺点</strong>：单例模式一般没有接口，扩展困难。不利于测试。</p>
<p><strong>使用场景</strong> 1. 在整个项目中需要一个共享访问点或共享数据。 2. 创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。 3. 需要定义大量的静态常量和静态方法的环境。</p>
<p><strong>实现</strong>：懒汉实现与饿汉实现 1. 懒汉实现，即实例化在对象首次被访问时进行。可以使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。同时需将默认构造函数声明为 private，防止用户调用默认构造函数创建对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Lock();</span><br><span class="line">        <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该类有以下特征： * 它的构造函数是私有的，这样就不能从别处创建该类的实例。 * 它有一个唯一实例的静态指针 m_pInstance，且是私有的。 * 它有一个公有的函数，可以获取这个唯一的实例，并在需要的时候创建该实例。 * 此处进行了两次 m_Instance == NULL 的判断，是借鉴了 Java 的单例模式实现时，使用的所谓的“双检锁”机制。因为进行一次加锁和解锁是需要付出对应的代价的，而进行两次判断，就可以避免多次加锁与解锁操作，同时也保证了线程安全。</p>
<p>上面的实现存在一个问题，就是没有提供删除对象的方法。一个妥善的方法是让这个类自己知道在合适的时候把自己删除。程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如下面的代码中的 CGarbo 类（Garbo意为垃圾工人）: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="comment">//CGarbo类的唯一工作就是在析构函数中删除CSingleton的实例</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//定义一个静态成员，在程序结束时，系统会调用它的析构函数</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类 CGarbo 被定义为 Singleton 的私有内嵌类，以防该类被在其他地方滥用。程序运行结束时，系统会调用 Singleton 的静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p>
<ol start="2" type="1">
<li>饿汉实现：在程序开始时就自行创建实例。如果说懒汉实现是“时间换空间”，那么饿汉实现就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo garbo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="简单工厂模式">简单工厂模式</h2>
<p>简单工厂模式的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。 <img src="/posts/db684f2c/003.png" alt="简单工厂模式"> <strong>例子</strong>：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显式地告诉生产工厂。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CTYPE &#123;COREA, COREB&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctype == COREA) <span class="comment">//工厂内部判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();  <span class="comment">//生产核A</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctype == COREB)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB();  <span class="comment">//生产核B</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样设计的主要缺点之前也提到过，就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。于是，工厂方法模式出现了。</p>
<h2 id="工厂方法模式">工厂方法模式</h2>
<p>工厂方法模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。 <img src="/posts/db684f2c/004.png" alt="工厂方法模式"> 例子：这家生产处理器核的厂家赚了不少钱，于是决定再开设一个工厂专门用来生产 B 型号的单核，而原来的工厂专门用来生产 A 型号的单核。这时，客户要做的是找好工厂，比如要 A 型号的核，就找 A 工厂要；否则找 B 工厂要，不再需要告诉工厂具体要什么型号的处理器核了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产A核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产B核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在 C++ 实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。</p>
<h2 id="抽象工厂模式">抽象工厂模式</h2>
<p>抽象工厂模式的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 <img src="/posts/db684f2c/005.png" alt="抽象工厂模式"> 例子：这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span><span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreA</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreB</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span><span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MultiCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span> <span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MultiCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/ee040603/" rel="next" title="图">
                  <i class="fa fa-chevron-left"></i> 图
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/64d148d3/" rel="prev" title="认识STL">
                  认识STL <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-基础知识点"><span class="nav-number">1.</span> <span class="nav-text">C++ 基础知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有符号类型和无符号类型"><span class="nav-number">1.1.</span> <span class="nav-text">有符号类型和无符号类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用与指针"><span class="nav-number">1.2.</span> <span class="nav-text">引用与指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-关键字"><span class="nav-number">1.3.</span> <span class="nav-text">static 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-限定符"><span class="nav-number">1.4.</span> <span class="nav-text">const 限定符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组与指针的区别"><span class="nav-number">1.5.</span> <span class="nav-text">数组与指针的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-运算符"><span class="nav-number">1.6.</span> <span class="nav-text">sizeof 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例题"><span class="nav-number">1.6.1.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体的内存对齐"><span class="nav-number">1.7.</span> <span class="nav-text">结构体的内存对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.8.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mallocfree-与-newdelete-的区别"><span class="nav-number">1.9.</span> <span class="nav-text">malloc/free 与 new/delete 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程"><span class="nav-number">2.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string-类的实现"><span class="nav-number">2.1.</span> <span class="nav-text">String 类的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#派生类中构造函数与析构函数的调用顺序"><span class="nav-number">2.2.</span> <span class="nav-text">派生类中构造函数与析构函数的调用顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数的实现原理"><span class="nav-number">2.3.</span> <span class="nav-text">虚函数的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚继承的实现原理"><span class="nav-number">2.4.</span> <span class="nav-text">虚继承的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序加载时的内存分布"><span class="nav-number">3.1.</span> <span class="nav-text">程序加载时的内存分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆与栈的区别"><span class="nav-number">3.2.</span> <span class="nav-text">堆与栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的内存错误及其对策"><span class="nav-number">3.3.</span> <span class="nav-text">常见的内存错误及其对策</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针"><span class="nav-number">3.4.</span> <span class="nav-text">智能指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-对象内存模型"><span class="nav-number">4.</span> <span class="nav-text">C++ 对象内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承下的对象内存模型"><span class="nav-number">4.1.</span> <span class="nav-text">继承下的对象内存模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见的设计模式"><span class="nav-number">5.</span> <span class="nav-text">常见的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">5.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单工厂模式"><span class="nav-number">5.2.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂方法模式"><span class="nav-number">5.3.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">5.4.</span> <span class="nav-text">抽象工厂模式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="KyoAni"
    src="/images/k-on.jpg">
  <p class="site-author-name" itemprop="name">KyoAni</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yz1509" title="GitHub &rarr; https://github.com/yz1509" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:pro-765@qq.com" title="E-Mail &rarr; mailto:pro-765@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KyoAni</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
