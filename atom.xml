<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>兔子和阿铁</title>
  
  <subtitle>旅の途中</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yz1509.github.io/"/>
  <updated>2019-07-26T15:50:02.766Z</updated>
  <id>https://yz1509.github.io/</id>
  
  <author>
    <name>yz1509</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thrift-Thrift概述</title>
    <link href="https://yz1509.github.io//posts/56b70/"/>
    <id>https://yz1509.github.io//posts/56b70/</id>
    <published>2019-07-26T15:48:45.000Z</published>
    <updated>2019-07-26T15:50:02.766Z</updated>
    
    <content type="html"><![CDATA[<p>Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括 C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。</p><h1 id="软件栈"><a href="#软件栈" class="headerlink" title="软件栈"></a>软件栈</h1><p>Thrift 对软件栈的定义非常的清晰, 使得各个组件能够松散的耦合, 针对不同的应用场景, 选择不同的方式去搭建服务。</p><p><img src="/posts/56b70/技术栈.PNG" alt="技术栈" width="304"></p><ul><li>传输层(Transport Layer)：传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议；比如说 TCP/IP 传输、MemoryBuffer 等</li><li>协议层(Protocol Layer)：协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化；比如说 JSON、XML、二进制数据等</li><li>处理层(Processor Layer)：处理层作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口，是由具体的IDL（接口描述语言）生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的 Handler 进行处理</li><li>服务层(Server Layer)：整合上述组件，根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架，提供具体的网络线程/IO 服务模型，形成最终的服务</li><li>业务逻辑层(Your code)</li></ul><p>接下来我们按照自底向上的顺序介绍 thrift 的各个模块。</p><h2 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层(Transport Layer)"></a>传输层(Transport Layer)</h2><p>Transport 与网络数据通信相关，thrift 通信协议有基于 TCP/IP 协议的实现。在现在的网络通信服务器中， TCP/IP 协议栈由 socket 来实现。Thrift 也不例外，在 thrift 源码中，是通过将 socket 包装成各种功能不同的 <code>TTransport</code> 来使用：</p><ul><li><code>TSocket</code>：使用阻塞式 I/O 进行传输，是常见的模式</li><li><code>TNonblockingTransport</code>：使用非阻塞方式，用于构建异步客户端</li><li><code>TFrameTransport</code>：使用非阻塞方式，按块的大小进行传输</li></ul><h2 id="协议层-Protocol-Layer"><a href="#协议层-Protocol-Layer" class="headerlink" title="协议层(Protocol Layer)"></a>协议层(Protocol Layer)</h2><p>Protocol 是 transport 的上一层，transport 负责数据传输，protocol 负责对数据进行解析，将数据解析成对应的数据结构代码，供程序直接调用。Thrift 支持各种语言，通过一个 <code>x.thrift</code> 的接口描述文件来通信。Thrift 的接口描述文件是各种语言通用的，其通过 thrift compiler 来生成对应的源代码，例如 C++ 对应的命令为 <code>thrift --gen cpp x.thrift</code>。</p><p>Thrift 可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本(text)和二进制(binary)传输协议。为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li><code>TBinaryProtocol</code>：二进制编码格式进行数据传输</li><li><code>TCompactProtocol</code>：高效率的、密集的二进制编码格式进行数据传输</li><li><code>TJSONProtocol</code>：使用 JSON 文本的数据编码协议进行数据传输</li><li><code>TSimpleJSONProtocol</code>：只提供 JSON 只写的协议，适用于通过脚本语言解析</li></ul><h2 id="处理层-Processor-Layer"><a href="#处理层-Processor-Layer" class="headerlink" title="处理层(Processor Layer)"></a>处理层(Processor Layer)</h2><p>服务调用组件。 Processor 封装了从输入流读取数据和向输出流写入数据的能力。输入和输出流由 Protocol objectss 表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface TProcessor &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(TProtocol in, TProtocol out)</span> throws TException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务层-Server-Layer"><a href="#服务层-Server-Layer" class="headerlink" title="服务层(Server Layer)"></a>服务层(Server Layer)</h2><p>Server 主要做以下工作:</p><ul><li>Create a transport</li><li>Create input/output protocols for the transport</li><li>Create a processor based on the input/output protocols</li><li>Wait for incoming connections and hand them off to the processor</li></ul><p>根据单线程/多线程，同步/异步分为以下几种：</p><ul><li><code>TSimpleServer</code>：单线程服务器端，使用标准的阻塞式 I/O</li><li><code>TThreadPoolServer</code>：多线程服务器端，使用标准的阻塞式 I/O</li><li><code>TNonblockingServer</code>：单线程服务器端，使用非阻塞式 I/O</li><li><code>THsHaServer</code>：半同步半异步服务器端，基于非阻塞式 I/O 读写和多线程工作任务处理</li><li><code>TThreadedSelectorServer</code>：多线程选择器服务器端，对 <code>THsHaServer</code> 在异步 I/O 模型上进行增强</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><p>开发速度快</p><p>通过编写 RPC 接口 Thrift IDL 文件，利用编译生成器自动生成服务端骨架(Skeletons)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p><ul><li>服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(Handler)即实现类即可。</li><li>客户端：只需要拷贝 IDL 定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。</li></ul></li><li><p>接口维护简单</p><p>通过维护 Thrift 格式的 IDL（接口描述语言）文件（注意写好注释），即可作为给 Client 使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且 Thrift 协议可灵活支持接口的可扩展性。</p></li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Thrifty 的数据类型包括预定义的基本类型，容器类型，用户自定义的结构体和异常，以及服务。</p><ol><li><p>基本类型(Base Type)</p><ul><li><code>bool</code>：布尔值，一个字节</li><li><code>i8(byte)</code>：8 位有符号整数</li><li><code>i16</code>：16 位有符号整数</li><li><code>i32</code>：32 位有符号整数</li><li><code>i64</code>：64 位有符号整数</li><li><code>double</code>：64 位浮点数</li><li><code>binary</code>：一个字节数组</li><li><code>string</code>：编码不可知的文本或二进制字符串</li></ul></li><li><p>容器类型(Container)</p><ul><li><code>list&lt;t&gt;</code>：元素类型为 t 的有序列表，容许元素重复</li><li><code>set&lt;t&gt;</code>：元素类型为 t 的无序表，不容许元素重复</li><li><code>map&lt;k,v&gt;</code>：key/value 映射，key 不允许重复</li><li>其中容器中的元素类型可以是除了 <code>service</code> 外的任何合法 Thrift 类型（包括结构体和异常）</li></ul></li><li><p>结构体类型 <code>struct</code></p><p>Thrift 中的 <code>struct</code> 类似于 C 语言，其在面向对象的语言中转换为 <code>class</code>。一个 <code>struct</code> 其由多个 <code>field</code> 组成，每个 <code>field</code> 包括唯一的整数标识符、<code>type</code>、<code>name</code> 和可选的默认值组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;    <span class="comment">// 没有逗号</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;</span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;</span><br><span class="line">    <span class="number">5</span>: optional TweetType tweetType = TweetType.TWEET;    <span class="comment">// 详见 enum</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"Endlish"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>field</code> 可用关键字 <code>optional</code> 或 <code>required</code> 进行标识</li><li><code>struct</code> 不能继承，但是可以嵌套，但不能嵌套自己</li><li>同一文件可以定义多个 <code>struct</code>，也可以定义在不同的文件中，利用 <code>include</code> 导入</li></ul></li><li><p>异常类型 <code>exception</code></p><p>异常在语法和功能上相当于结构体，差别是异常使用关键字 <code>exception</code> 而不是 <code>struct</code> 声明。它在语义上不同于结构体：当定义一个 RPC 服务时，开发者可能需要声明一个远程方法抛出一个异常。</p></li><li><p>服务类型 <code>service</code></p><p>服务的定义方法在语义上等同于面向对象语言中的接口，Thrift compiler 将用你所选择的语言据此生成 service interface code (for the server) and stubs (for the client)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service Twitter&#123;</span><br><span class="line">    <span class="comment">// A method definition looks like C code. It has a return type, arguments</span></span><br><span class="line">    <span class="comment">// and optionally a list of exceptions that it may throw. Note that argument</span></span><br><span class="line">    <span class="comment">// lists and exception list are specified using the exact same syntax as</span></span><br><span class="line">    <span class="comment">// field lists in structs.</span></span><br><span class="line">    void ping(),</span><br><span class="line">    bool postTweet(1:Tweet tweet) throws (1:TwitterUnavailable unavailable),</span><br><span class="line">    <span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 'oneway' modifier indicates that the client only makes a request and</span></span><br><span class="line">    <span class="comment">// does not wait for any response at all. Oneway methods MUST be void.</span></span><br><span class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数定义可以用分号或者逗号结尾</li><li>参数和返回值类型可以是基本类型或者结构体</li><li><code>void</code> 是函数的有效返回类型</li><li>服务支持继承，一个 <code>service</code> 可使用 <code>extends</code> 关键字继承另一个 <code>service</code></li><li>服务不支持重载</li></ul></li></ol><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><h2 id="Typedef"><a href="#Typedef" class="headerlink" title="Typedef"></a>Typedef</h2><p>Thrift 支持 C/C++ 风格的 typedef</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> i32 MyInteger   <span class="comment">// 结尾无分号</span></span><br><span class="line"><span class="keyword">typedef</span> Tweet ReTweet   <span class="comment">// struct 也可 typedef</span></span><br></pre></td></tr></table></figure><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>Thrift 支持 C 风格的 enum ，编译器从 0 开始分配默认值。Thrift 还不支持嵌套枚举，枚举常量大小不超过 32 位正整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType&#123;</span><br><span class="line">    TWEET,</span><br><span class="line">    RETWEET = <span class="number">2</span>,    <span class="comment">// 可以设置特定的整数值</span></span><br><span class="line">    DM = <span class="number">0xa</span>,       <span class="comment">// 支持 16 进制</span></span><br><span class="line">    REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h2><p>Thrift 允许定义跨语言使用的常量，复杂类型和结构体使用 JSON 格式赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i32 INT_CONST = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; MAP_CONST = &#123;<span class="string">"hello"</span>: <span class="string">"world"</span>, <span class="string">"goodnight"</span>: <span class="string">"Kyoani"</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="Generated-Files-C"><a href="#Generated-Files-C" class="headerlink" title="Generated Files(C++)"></a>Generated Files(C++)</h1><ul><li>All constants go into a single <code>.cpp/.h</code> pair</li><li>All type definitions (enums and structs) go into another <code>.cpp/.h</code> pair</li><li>Each service gets its own <code>.cpp/.h</code> pair</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree gen-cpp</span><br><span class="line">|-- example_constants.cpp</span><br><span class="line">|-- example_constants.h</span><br><span class="line">|-- example_types.cpp</span><br><span class="line">|-- example_types.h</span><br><span class="line">|-- Twitter.cpp</span><br><span class="line">|-- Twitter.h</span><br><span class="line">`-- Twitter_server.skeleton.cpp</span><br></pre></td></tr></table></figure><p>Thrift 数据类型和 C++ 数据类型对应表<br>Thrift | C++<br>:— | :—<br>bool | bool<br>byte | int8_t<br>i16 | int16_t<br>i32 | int32_t<br>i64 | int64_t<br>double | double<br>binary | std::string<br>string | std::string<br>list<t1> | std::vector<t1><br>set<t1> | std::set<t1><br>map&lt;t1, t2&gt; | std::map&lt;t1, t2&gt;</t1></t1></t1></t1></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括 C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。&lt;/p&gt;
&lt;h1 id=&quot;软件
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="thrift" scheme="https://yz1509.github.io/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>Redis-12-开发运维的陷阱</title>
    <link href="https://yz1509.github.io//posts/d3488cd7/"/>
    <id>https://yz1509.github.io//posts/d3488cd7/</id>
    <published>2019-07-25T16:37:57.000Z</published>
    <updated>2019-07-25T17:00:32.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-配置优化"><a href="#Linux-配置优化" class="headerlink" title="Linux 配置优化"></a>Linux 配置优化</h1><ol><li>vm.overcommit_memory</li><li>swappiness</li><li>THP(Transparent Huge Pages)</li><li>OOM killer</li><li>NTP(Network Time Protocol)</li><li>ulimit</li><li>TCP backlog</li></ol><h1 id="安全的-redis"><a href="#安全的-redis" class="headerlink" title="安全的 redis"></a>安全的 redis</h1><ol><li><p>Redis 密码机制</p><p>简单的密码机制</p><ul><li>Redis 提供了 requirepass 配置为 Redis 提供密码功能：<code>redis-server --requirepass &lt;password&gt;</code></li><li>Redis 提供了两种方式访问配置了密码的 Redis：<ul><li><code>redis-cli -h &lt;ip&gt; -p &lt;port&gt; -a &lt;password&gt;</code></li><li>通过 redis-cli 连接后，执行 <code>auth &lt;password&gt;</code> 命令<br>运维建议</li></ul></li><li>密码要足够复杂</li><li>如果是主从结构的 Redis，不要忘记在从节点的配置中加入 masterauth(master 的密码)配置，否则会造成主从节点同步失效</li><li>auth 是通过明文进行传输的，比较危险</li></ul></li><li><p>伪装危险命令</p><p>“危险”命令</p><ul><li>keys：如果键值较多，存在阻塞 Redis 的可能性</li><li>flushall/flushdb：数据全部被清除</li><li>save：如果键值较多，存在阻塞 Redis 的可能性</li><li>debug：例如 debug reload 会重启Redis</li><li>config：config 应该交给管理员使用</li><li>shutdown：停止 Redis</li></ul><p>引入 <code>rename-command</code> 可以屏蔽危险命令，但可能会带来如下麻烦：</p><ul><li>管理员要对自己的客户端进行修改</li><li>rename-command 配置不支持 config set，所以在启动前一定要确定哪些命令需要使用 rename-command</li><li>如果 AOF 和 RDB 文件包含了 rename-command 之前的命令，Redis 将无法启动，因为此时它识别不了 rename-command 之前的命令</li><li>Redis 源码中有一些命令是写死的，rename-command 可能造成 Redis 无法正常工作。例如Sentinel 节点在修改配置时直接使用了config命令，如果对 config 使用 rename-command，会造成 Redis Sentinel 无法正常工作</li></ul><p>实践建议</p><ul><li>对于一些危险的命令（例如flushall），不管是内网还是外网，一律使用 rename-command 配置</li><li>建议第一次配置 Redis 时，就应该配置 rename-command，因为 rename-command 不支持 config set</li><li>如果涉及主从关系，一定要保持主从节点配置的一致性，否则存在主从数据不一致的可能性</li></ul></li><li><p>防火墙</p><p>可以使用防火墙限制输入和输出的 IP 或者 IP 范围、端口或者端口范围</p></li><li><p>bind</p><p>bind 指定的是 Redis 和哪个网卡进行绑定，和客户端是什么网段没有关系</p></li><li><p>定期备份数据</p></li><li><p>不使用默认端口</p></li><li><p>使用非 root 用户启动</p></li></ol><h1 id="处理-bigkey"><a href="#处理-bigkey" class="headerlink" title="处理 bigkey"></a>处理 bigkey</h1><p>bigkey 是指 key 对应的 value 所占的内存空间比较大</p><h2 id="bigkey-的危害"><a href="#bigkey-的危害" class="headerlink" title="bigkey 的危害"></a>bigkey 的危害</h2><ol><li>内存空间不均匀</li><li>超时阻塞</li><li>网络阻塞</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-配置优化&quot;&gt;&lt;a href=&quot;#Linux-配置优化&quot; class=&quot;headerlink&quot; title=&quot;Linux 配置优化&quot;&gt;&lt;/a&gt;Linux 配置优化&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;vm.overcommit_memory&lt;/li&gt;
&lt;li&gt;sw
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-11-缓存设计</title>
    <link href="https://yz1509.github.io//posts/3d2c9df2/"/>
    <id>https://yz1509.github.io//posts/3d2c9df2/</id>
    <published>2019-07-25T16:37:24.000Z</published>
    <updated>2019-07-25T17:00:32.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存的收益和成本"><a href="#缓存的收益和成本" class="headerlink" title="缓存的收益和成本"></a>缓存的收益和成本</h1><p>收益：</p><ul><li>加速读写</li><li>降低后端负载</li></ul><p>成本：</p><ul><li>数据不一致性</li><li>代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本</li><li>运维成本</li></ul><p>使用场景：</p><ul><li>开销大的复杂计算</li><li>加速请求响应</li></ul><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><ol><li><p>LRU/LFU/FIFO 算法剔除</p><ul><li>使用场景：通常用于缓存使用量超过了预设最大值的时候</li><li>一致性：要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所以数据的一致性是最差的。</li><li>维护成本：算法不需要开发人员自己来实现，通常只需要配置最大 maxmemory 和对应的策略即可</li></ul></li><li><p>超时剔除</p><ul><li>使用场景：通过给缓存数据设置过期时间，让其在过期时间后自动删除</li><li>一致性：一段时间窗口内（取决于过期时间长短）存在一致性问题，即缓存数据和真实数据源的数据不一致</li><li>维护成本：只需设置 expire 过期时间即可</li></ul></li><li><p>主动更新</p><ul><li>使用场景：应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据</li><li>一致性：一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超时剔除一起使用效果会更好</li><li>维护成本：维护成本会比较高，开发者需要自己来完成更新，并保证更新操作的正确性</li></ul></li><li><p>实践建议</p><ul><li>低一致性业务建议配置最大内存和淘汰策略的方式使用</li><li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据</li></ul></li></ol><h1 id="穿透优化"><a href="#穿透优化" class="headerlink" title="穿透优化"></a>穿透优化</h1><p><strong>缓存穿透</strong>是指查询一个根本不存在的数据，缓存层和存储层都不会命中。整个过程可分为如下三步：</p><ol><li>缓存层不命中</li><li>存储层不命中，不将空结果写回缓存</li><li>返回空结果</li></ol><p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p><p>解决办法：</p><ol><li><p>缓存空对象</p><p>缓存空对象会有两个问题：</p><ul><li>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除</li><li>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响</li></ul></li><li><p>布隆过滤器拦截</p><p>在访问缓存层和存储层之前，将存在的 key 用<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器</a>提前保存起来，做第一层拦截。</p><p>这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。</p></li></ol><h1 id="无底洞优化"><a href="#无底洞优化" class="headerlink" title="无底洞优化"></a>无底洞优化</h1><p>无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。</p><p>无底洞问题分析：</p><ul><li>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大</li><li>网络连接数变多，对节点的性能也有一定影响</li></ul><p>批量操作优化：</p><ol><li><p>串行命令</p><p>逐次执行 n 个命令(如 get)</p><ul><li>操作时间 = n 次网络时间 + n 次命令时间</li><li>优点<ul><li>编程简单</li><li>如果少量 keys，性能可以满足要求</li></ul></li><li>缺点：大量 keys 请求延迟严重</li></ul></li><li><p>串行 IO</p><p>将属于同一个节点的 key 进行归档，得到每个节点的 key 子列表，之后对每个节点执行 mget 或者 Pipeline 操作</p><ul><li>操作时间 = node 次网络时间 + n 次命令时间</li><li>优点<ul><li>编程简单</li><li>少量节点，性能满足要求</li></ul></li><li>缺点：大量 node 延迟严重</li></ul></li><li><p>并行 IO</p><p>串行 IO 中的最后一步改为多线程执行</p><ul><li>操作时间 = max_slow(node 网络时间) + n 次命令时间</li><li>优点：利用并行特性，延迟取决于最慢的节点</li><li>缺点<ul><li>编程复杂</li><li>多线程，问题定位可能较难</li></ul></li></ul></li><li><p>hash-tag 实现</p><p>将多个 key 强制分配到一个节点上</p><ul><li>操作时间 = 1 次网络时间 + n 次命令时间</li><li>优点：性能最高</li><li>缺点<ul><li>业务维护成本较高</li><li>容易出现数据倾斜</li></ul></li></ul></li></ol><h1 id="雪崩优化"><a href="#雪崩优化" class="headerlink" title="雪崩优化"></a>雪崩优化</h1><p>缓存雪崩：由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。</p><p>解决方法：</p><ul><li>保证缓存层服务高可用性</li><li>依赖隔离组件为后端限流并降级</li><li>提前测试，在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定</li></ul><h1 id="热点-key-重建优化"><a href="#热点-key-重建优化" class="headerlink" title="热点 key 重建优化"></a>热点 key 重建优化</h1><p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是以下两个问题如果同时出现，可能就会对应用造成致命的危害：</p><ul><li>当前 key 是一个热点 key（例如一个热门的娱乐新闻），并发量非常大</li><li>重建缓存不能在短时间完成</li></ul><ol><li><p>互斥锁(mutex key)</p><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p><p>优点</p><ul><li>思路简单</li><li>保证一致性</li></ul><p>缺点</p><ul><li>代码复杂度增大</li><li>存在死锁的风险</li><li>存在线程池阻塞的风险</li></ul></li><li><p>永远不过期</p><p>“永远不过期” 包含两层意思：</p><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期</li><li>从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存</li></ul><p>优点</p><ul><li>基本杜绝热点 key 问题</li></ul><p>缺点</p><ul><li>不保证一致性</li><li>逻辑过期时间增加代码维护成本和内存成本</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存的收益和成本&quot;&gt;&lt;a href=&quot;#缓存的收益和成本&quot; class=&quot;headerlink&quot; title=&quot;缓存的收益和成本&quot;&gt;&lt;/a&gt;缓存的收益和成本&lt;/h1&gt;&lt;p&gt;收益：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加速读写&lt;/li&gt;
&lt;li&gt;降低后端负载&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-10-集群</title>
    <link href="https://yz1509.github.io//posts/1572a53d/"/>
    <id>https://yz1509.github.io//posts/1572a53d/</id>
    <published>2019-07-25T16:37:14.000Z</published>
    <updated>2019-07-25T17:00:32.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h1><h2 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h2><p>常见的分区规则有哈希分区和顺序分区</p><table><thead><tr><th style="text-align:left">分区方式</th><th style="text-align:left">特点</th><th style="text-align:left">代表产品</th></tr></thead><tbody><tr><td style="text-align:left">哈希分区</td><td style="text-align:left">离散度好；数据分布业务无关；无法顺序访问</td><td style="text-align:left">Redis Cluster; Cassandra; Dynamo</td></tr><tr><td style="text-align:left">顺序分区</td><td style="text-align:left">离散度易倾斜；数据分布业务相关；可顺序访问</td><td style="text-align:left">Bigtable; HBase; Hypertable</td></tr></tbody></table><p>Redis Cluster 采用哈希分区规则，常见的哈希分区规则有几种：</p><ol><li><p>节点取余分区</p><p>使用特定的数据，如 Redis 的键或用户 ID，再根据节点数量 N 使用公式：$hash(key) \% N$ 计算出哈希值，用来决定数据映射到哪一个节点上。</p><ul><li>优点：简单，常用于数据库的分库分表规则</li><li>缺点：当节点数量变化时，数据节点映射关系需要重新计算，会导致数据的重新迁移</li></ul></li><li><p>一致性哈希分区</p><p>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个 token，范围一般在 $0 - 2^{32}$，这些 token 构成一个哈希环。数据读写执行节点查找操作时，先根据 key 计算 hash 值，然后顺时针找到第一个大于等于该哈希值的 token 节点。</p><ul><li>优点：加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响</li><li>缺点：<ul><li>加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景</li><li>当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案</li><li>普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡</li></ul></li></ul></li><li><p>虚拟槽分区</p><p>使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，这个范围一般远远大于节点数。整数定义为槽(slot)，槽是集群内数据管理和迁移的基本单位，每个节点会负责一定数量的槽。</p></li></ol><h2 id="Redis-数据分区"><a href="#Redis-数据分区" class="headerlink" title="Redis 数据分区"></a>Redis 数据分区</h2><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式为 $slot = CRC(key) \&amp; 16383$。每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p>Redis 虚拟槽分区的特点</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景</li></ul><h2 id="集群功能限制"><a href="#集群功能限制" class="headerlink" title="集群功能限制"></a>集群功能限制</h2><p>Redis 集群相对单机在功能上存在一些限制：</p><ol><li>key 批量操作支持有限，目前只支持具有相同 slot 值的 key 执行批量操作</li><li>key 事务操作支持有限，只支持多 key 在同一节点上的事务操作</li><li>key 作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点</li><li>不支持多数据库空间，单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 db0</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构</li></ol><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><p>搭建集群工作需要以下三个步骤：</p><ol><li>准备节点</li><li>节点握手</li><li>分配槽</li></ol><h2 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h2><p>Redis 集群一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群。</p><p>节点 ID 在集群初始化时只创建一次，节点重启时会加载集群配置文件进行重用，而 Redis 的运行 ID 每次重启都会变化。</p><p>每个节点目前只能识别出自己的节点信息，每个节点彼此并不知道对方的存在。</p><h2 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h2><p>节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信，达到感知对方的过程，由客户端发起命令：<code>cluster meet {ip} {port}</code></p><p>cluster meet 命令是一个异步命令，执行之后立刻返回，内部发起与目标节点握手通信：</p><ol><li>节点 6379 本地创建 6380 节点信息对象，并发送 meet 消息</li><li>节点 6380 接受到 meet 消息后，保存 6379 节点信息并回复 pong 消息</li><li>之后节点 6379 和 6380 彼此定期通过 ping/pong 消息进行正常的节点通信</li></ol><p>节点建立握手之后，由于目前所有的槽没有分配到节点，因此集群无法完成槽到节点的映射，这时集群处于下线状态，还不能正常工作，所有的数据读写都被禁止。</p><h2 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h2><p>Redis 集群把所有的数据映射到 16384 个槽中，通过 <code>cluster addslots</code> 命令为节点分配槽。如 <code>redis-cli -h 127.0.0.1 -p 6379 cluster addslots {0..5461}</code>。</p><p>作为一个完整的集群，每个负责处理槽的节点都应该具有从节点，保证当它出故障时可以自动进行故障转移。使用 <code>cluster replicate {nodeId}</code> 命令让一个节点成为从节点，该命令执行必须在对应的从节点上执行，nodeId 是要复制的主节点的节点 ID。</p><h2 id="用-redis-trib-rb-搭建集群"><a href="#用-redis-trib-rb-搭建集群" class="headerlink" title="用 redis-trib.rb 搭建集群"></a>用 redis-trib.rb 搭建集群</h2><p>redis-trib.rb 是采用 Ruby 实现的 Redis 集群管理工具。内部通过 Cluster 相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用之前需要安装 Ruby 依赖环境。</p><ol><li>Ruby 环境准备</li><li>准备节点</li><li><p>创建集群</p><ul><li><code>redis-cli --cluster create &lt;ip1:port1&gt;...&lt;ipN:portN&gt; --cluster-replicas 1</code></li><li>–replicas 参数指定集群中每个主节点配备几个从节点，这里设置为 1</li></ul></li><li><p>集群完整性检查</p><ul><li>集群完整性指所有的槽都分配到存活的主节点上，只要 16384 个槽中有一个没有分配给节点则表示集群不完整。check 命令只需要给出集群中任意一个节点地址就可以完成整个集群的检查工作，命令 <code>redis-cli --cluster check ip:port</code></li></ul></li></ol><h1 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h1><h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><p>节点元数据是指：节点负责哪些数据，是否出现故障等状态信息。</p><p>常见的元数据维护方式为：集中式和 P2P 方式。</p><p>Redis 集群采用 P2P 的 Gossip(流言) 协议，该协议的工作原理是节点彼此不断通信交换信息，一段时间后所有节点都会知道集群完整的信息，这种方式类似流言传播。</p><p>通信过程说明：</p><ol><li>集群中的每个节点都会单独开辟一个 TCP 通道，用于节点之间彼此通信，通信端口号在基础端口上加 10000</li><li>每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息</li><li>接收到 ping 消息的节点用 pong 消息作为响应</li></ol><h2 id="Gossip-消息"><a href="#Gossip-消息" class="headerlink" title="Gossip 消息"></a>Gossip 消息</h2><p>常用的 Gossip 消息可分为：ping 消息、pong 消息、meet 消息、fail 消息</p><ul><li>meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换</li><li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。</li><li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li><li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li></ul><p>所有的消息格式划分为：消息头和消息体。</p><p>接收节点收到ping/meet消息时，执行解析消息头和消息体流程：</p><ol><li>解析消息头过程：消息头包含了发送节点的信息，如果发送节点是新节点且消息是 meet 类型，则加入到本地节点列表；如果是已知节点，则尝试更新发送节点的状态，如槽映射关系、主从角色等状态。</li><li>解析消息体过程：如果消息体的 clusterMsgDataGossip 数组包含的节点是新节点，则尝试发起与新节点的 meet 握手流程；如果是已知节点，则根据 clusterMsgDataGossip 中的 flags 字段判断该节点是否下线，用于故障转移。</li></ol><h2 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h2><p>消息交换的成本主要体现在单位时间选择发送消息的节点数量和每个消息携带的数据量。</p><ol><li><p>选择发送消息的节点数量</p><ul><li>每个节点维护定时任务默认每秒执行 10 次，每秒会随机选取 5 个节点找出最久没有通信的节点发送 ping 消息</li><li>每 100 毫秒都会扫描本地节点列表，如果发现节点最近一次接受 pong 消息的时间大于$cluster_node_timeout / 2$，则立刻发送 ping 消息</li></ul></li><li><p>消息数据量</p><ul><li>消息头主要占用空间的字段是 myslots[CLUSTER_SLOTS/8] ，占用 2KB，这块空间占用相对固定</li><li>消息体会携带一定数量的其他节点信息用于信息交换，消息体携带数据量跟集群的节点数息息相关，更大的集群每次消息通信的成本也就更高</li></ul></li></ol><h1 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h1><h2 id="伸缩原理"><a href="#伸缩原理" class="headerlink" title="伸缩原理"></a>伸缩原理</h2><p>上层原理：集群伸缩 = 槽和数据在节点之间的移动</p><h2 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h2><p>Redis 集群扩容操作可分为如下步骤：</p><ol><li><p>准备新节点</p></li><li><p>加入集群<br>对于加入集群的新节点的后续操作一般有两种选择：</p><ul><li>为它迁移槽和数据实现扩容</li><li>作为其他主节点的从节点负责故障转移</li></ul></li><li><p>迁移槽和数据<br>1) 制定槽迁移计划：迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀<br>2) 迁移数据：数据迁移过程是逐个槽进行的<br>3) 添加从节点：从节点内部除了对主节点发起全量复制之外，还需要更新本地节点的集群相关状态</p></li></ol><h2 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h2><p>流程说明：</p><ol><li>首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性</li><li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭</li></ol><p>当下线主节点具有从节点时需要把该从节点指向到其他主节点，因此对于主从节点都下线的情况，建议先下线从节点再下线主节点，防止不必要的全量复制</p><h1 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h1><h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p>在集群模式下，Redis 接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点</p><ul><li>如果节点是自身，则处理建键命令</li><li>否则回复 MOVED 重定向错误，通知客户端请求正确的节点</li></ul><p>这个过程称为 MOVED 重定向。</p><p>使用 redis-cli 命令时，可以加入 <code>-c</code> 参数以支持自动重定向</p><ul><li>redis-cli 自动帮我们连接到正确的节点执行命令，这个过程是在 redis-cli 内部维护，实质上是 client 端接到 MOVED 信息之后再次发起请求，并不在 Redis 节点中完成请求转发</li><li>节点对于不属于它的键命令只回复重定向响应，并不负责转发</li></ul><h2 id="Smart-客户端"><a href="#Smart-客户端" class="headerlink" title="Smart 客户端"></a>Smart 客户端</h2><p>原理：<a href="http://redis.io/clients" target="_blank" rel="noopener">Smart 客户端</a>通过在内部维护 slot→node 的映射关系，本地就可实现键到节点的查找，从而保证 IO 效率的最大化，而 MOVED 重定向负责协助 Smart 客户端更新 slot→node 映射。</p><h2 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h2><ol><li><p>客户端 ASK 重定向流程</p><p>Redis 集群支持在线迁移槽（slot）和数据来完成水平伸缩，当 slot 对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。客户端键命令执行流程：<br>1) 客户端根据本地 slots 缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端<br>2) 如果键对象不存在，则可能存在于目标节点，这时源节点会回复 ASK 重定向异常。格式如下：<code>(error) ASK {slot} {targetIP}:{targetPort}</code><br>3) 客户端从 ASK 重定向异常提取出目标节点信息，发送 asking 命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息</p><p>ASK 与 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别</p><ul><li>ASK 重定向说明集群正在进行 slot 数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slots 缓存</li><li>MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新 slots 缓存</li></ul></li><li><p>节点内部处理</p><p>为了支持 ASK 重定向，源节点和目标节点在内部的 clusterState 结构中维护当前正在迁移的槽信息，用于识别槽迁移情况</p><p>节点每次接收到键命令时，都会根据clusterState内的迁移属性进行命令处理，如下所示：</p><ul><li>如果键所在的槽由当前节点负责，但键不存在则查找 migrating_slots_to 数组查看槽是否正在迁出，如果是，返回 ASK 重定向</li><li>如果客户端发送 asking 命令打开了 CLIENT_ASKING 标识，则该客户端下次发送键命令时查找 importing_slots_from 数组获取 clusterNode，如果指向自身则执行命令</li><li>需要注意的是，asking 命令是一次性命令，每次执行完后客户端标识都会修改回原状态，因此每次客户端接收到 ASK 重定向后都需要发送 asking 命令</li><li>批量操作。ASK 重定向对单键命令支持得很完善，但是，在开发中我们经常使用批量操作，如 mget 或 pipeline。当槽处于迁移状态时，批量操作会受到影响</li></ul></li></ol><h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><ol><li><p>主观下线</p><p>如果在 cluster-node-timeout 时间内通信一直失败，则发送节点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态</p></li><li><p>客观下线</p><p>当半数以上持有槽的<strong>主节点</strong>都标记某个节点是主观下线时，触发客观下线流程</p><p>流程说明：<br>1) 当消息体内含有其他节点的 pfail 状态时，会判断发送节点的状态，如果发送节点是主节点则对报告的 pfail 状态处理，从节点则忽略<br>2) 找到 pfail 对应的节点结构，更新 clusterNode 内部下线报告链表<br>3) 根据更新后的下线报告链表告尝试进行客观下线</p><ul><li>维护下线报告链表<ul><li>每个节点 ClusterNode 结构中都会存在一个下线链表结构，保存了其他主节点针对当前节点的下线报告</li><li>每个下线报告都存在有效期，每次在尝试触发客观下线时，都会检测下线报告是否过期，对于过期的下线报告将被删除</li></ul></li><li>尝试客观下线<ul><li>首先统计有效的下线报告数量，如果小于集群内持有槽的主节点总数的一半则退出</li><li>当下线报告大于槽主节点数量一半时，标记对应故障节点为客观下线状态</li><li>向集群广播一条 fail 消息，通知所有的节点将故障节点标记为客观下线，fail 消息的消息体只包含故障节点的 ID。该步骤职责如下<ul><li>通知集群内所有的节点标记故障节点为客观下线状态并立刻生效 </li><li>通知故障节点的从节点触发故障转移流程</li></ul></li></ul></li></ul></li></ol><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用。</p><p>故障恢复流程：</p><ol><li><p>资格检查</p><p>每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。如果从节点与主节点断线时间超过 $cluster-node-time * cluster-slave-validity-factor$，则当前从节点不具备故障转移资格。</p></li><li><p>准备选举时间</p><p>当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。</p><ul><li>之所以采用延迟触发机制，主要是通过对多个从节点使用不同的延迟选举时间来支持优先级问题。复制偏移量越大说明从节点延迟越低，那么它应该具有更高的优先级来替换故障主节点。</li></ul></li><li><p>发起选举</p><p>当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程如下：<br>1) 更新配置纪元<br>2) 广播选举消息：在一个配置纪元内只能发起一次选举</p></li><li><p>选举投票</p><ul><li>只有持有槽的主节点才会处理故障选举消息</li><li>每个持有槽的节点在一个配置纪元内都有唯一的一张选票</li><li>投票过程其实是一个领导者选举的过程</li><li>故障主节点也算在投票数内</li><li>投票作废：每个配置纪元代表了一次选举周期，如果在开始投票之后的 $cluster-node-timeout * 2$ 时间内从节点没有获取足够数量的投票，则本次选举作废。从节点对配置纪元自增并发起下一轮投票，直到选举成功为止</li></ul></li><li><p>替换主节点</p><p>当从节点收集到足够的选票之后，触发替换主节点操作：<br>1) 当前从节点取消复制变为主节点。<br>2) 执行 <code>clusterDelSlot</code> 操作撤销故障主节点负责的槽，并执行 <code>clusterAddSlot</code>把这些槽委派给自己。<br>3) 向集群广播自己的 pong 消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息。</p></li></ol><h2 id="故障转移时间"><a href="#故障转移时间" class="headerlink" title="故障转移时间"></a>故障转移时间</h2><ol><li>主观下线（pfail）识别时间 = cluster-node-timeout</li><li>主观下线状态消息传播时间 &lt;= cluster-node-timeout / 2</li><li>从节点转移时间 &lt;= 1000毫秒</li></ol><h1 id="集群运维"><a href="#集群运维" class="headerlink" title="集群运维"></a>集群运维</h1><h2 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h2><p>默认情况下，当集群 16384 个槽中任意一个没有指派到节点时，整个集群不可用。但是当持有槽的主节点下线时，从故障发生到自动完成转移操作期间整个集群都是不可用状态，对于大多数业务来说，无法容忍这种情况，因此建议将参数 <code>cluster-require-full-coverage</code> 配置为 no，当主节点故障时只影响它所负责槽的相关命令，不会影响其他主节点的可用性。</p><h2 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h2><p>集群带宽消耗主要分为：读写命令消耗 + Gossip 消息消耗。</p><p>搭建 Redis 集群时需要根据业务数据规模和消息通信成本做出合理规划：</p><ul><li>在满足业务需要的情况下尽量避免大集群。同一个系统可以针对不同业务场景拆分使用多套集群。这样每个集群既满足伸缩性和故障转移要求，还可以规避大规模集群的弊端。</li><li>适度提高 <code>cluster-node-timeout</code> 以降低消息发送频率，但同时 <code>cluster-nodetimeout</code> 还影响故障转移的速度，因此需要根据自身业务场景兼顾二者的平<br>衡。</li><li>如果条件允许集群尽量均匀部署在更多机器上，避免集中部署。</li></ul><h2 id="Pub-Sub-问题"><a href="#Pub-Sub-问题" class="headerlink" title="Pub/Sub 问题"></a>Pub/Sub 问题</h2><p>当频繁应用 Pub/Sub 功能时应该避免在大量节点的集群内使用，否则会严重消耗集群内网络带宽。针对这种情况建议使用 sentinel 结构专门用于 Pub/Sub 功能，从而规避这一问题。</p><h2 id="集群倾斜"><a href="#集群倾斜" class="headerlink" title="集群倾斜"></a>集群倾斜</h2><p>集群倾斜指不同节点之间数据量和请求量出现明显差异</p><ol><li><p>数据倾斜</p><ul><li>节点和槽分配严重不均。<ul><li>可使用 <code>redis-cli --cluster info ip:port</code> 进行查看</li><li>当节点对应槽数量不均匀时，可使用 <code>redis-cli --cluster rebalance ip:port</code> 进行平衡</li></ul></li><li>不同槽对应键数量差异过大<ul><li>键通过 CRC16 哈希函数映射到槽上，正常情况下槽内键数量会相对均匀。但当大量使用 hash_tag 时，会产生不同的键映射到同一个槽的情况</li><li>通过命令 <code>cluster countkeysinslot {slot}</code> 可以获取槽对应的键数量，识别出哪些槽映射了过多的键。</li><li>通过命令 <code>cluster getkeysinslot {slot} {count}</code> 循环迭代出槽下所有的键。从而发现过度使用 hash_tag 的键。</li></ul></li><li>集合对象包含大量元素<ul><li>可使用 <code>redis-cli --bigkeys</code> 识别大集合对象</li></ul></li><li>内存相关配置不一致<ul><li>内存相关配置指 hash-max-ziplist-value、setmax-intset-entries 等压缩数据结构配置   </li><li>当集群大量使用 hash、set 等数据结构时，如果内存压缩数据结构配置不一致，极端情况下会相差数倍的内存，从而造成节点内存量倾斜</li></ul></li></ul></li><li><p>请求倾斜</p><p>集群内特定节点请求量/流量过大将导致节点之间负载不均，影响集群均衡和运维成本。避免方式如下：</p><ul><li>合理设计键，热点大集合对象做拆分或使用 <code>hmget</code> 替代 <code>hgetall</code> 避免整体读取</li><li>不要使用热键作为 hash_tag，避免映射到同一槽</li><li>对于一致性要求不高的场景，客户端可使用本地缓存以减少热键调用</li></ul></li></ol><h2 id="集群读写分离"><a href="#集群读写分离" class="headerlink" title="集群读写分离"></a>集群读写分离</h2><p>集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上（其中包括它的主节点）</p><ol><li><p>只读连接</p><ul><li>当需要使用从节点分担主节点读压力时，可以使用 <code>readonly</code> 命令打开客户端连接只读状态。</li><li>当开启只读状态时，从节点接收读命令处理流程为：如果对应的槽属于自己正在复制的主节点则直接执行读命令，否则返回重定向信息。</li><li><code>readonly</code> 命令时连接级别生效，因此每次新建连接时都需要执行 <code>redaonly</code> 开启只读状态。</li><li>执行 <code>readwrite</code> 命令可以关闭连接只读状态</li></ul></li><li><p>读写分离</p><p>集群模式下读写分离涉及对客户端修改如下：</p><ul><li>维护每个主节点可用从节点列表</li><li>针对读命令维护请求节点路由</li><li>从节点新建连接开启 readonly 状态</li></ul><p>集群模式下读写分离成本比较高，可以直接扩展主节点数量提高集群性能，一般不建议集群模式下做读写分离。</p></li></ol><h2 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h2><p>Redis 集群提供了手动故障转移功能：指定从节点发起转移流程，主从节点角色进行切换，从节点变为新的主节点对外提供服务，旧的主节点变为它的从节点。</p><p>在从节点上执行 <code>cluster failover</code> 命令发起转移流程，默认情况下转移期间客户端请求会有短暂的阻塞，但不会丢失数据，流程如下：</p><ol><li>从节点通知主节点停止处理所有客户端请求</li><li>主节点发送对应从节点延迟复制的数据</li><li>从节点接收处理复制延迟的数据，直到主从复制偏移量一致为止，保证复制数据不丢失</li><li>从节点立刻发起投票选举（这里不需要延迟触发选举）。选举成功后断开复制变为新的主节点，之后向集群广播主节点 pong 消息</li><li>旧主节点接受到消息后更新自身配置变为从节点，解除所有客户端请求阻塞，这些请求会被重定向到新主节点上执行</li><li>旧主节点变为从节点后，向新的主节点发起全量复制流程</li></ol><p>手动故障转移的应用场景主要如下:</p><ol><li>主节点迁移</li><li><p>强制故障转移</p><p><code>cluster failover</code> 命令提供了两个参数 force/takeover</p><ul><li><code>cluster failover force</code>：用于当主节点宕机且无法自动完成故障转移情况。从节点接到 <code>cluster failover force</code> 请求时，从节点直接发起选举，不再跟主节点确认复制偏移量（从节点复制延迟的数据会丢失），当从节点选举成功后替换为新的主节点并广播集群配置。</li><li><code>cluster failover takeover</code>：用于集群内超过一半以上主节点故障的场景，因为从节点无法收到半数以上主节点投票，所以无法完成选举过程。可以执行 <code>cluster failover takeover</code> 强制转移，接到命令的从节点不再进行选举流程而是直接更新本地配置纪元并替换主节点。会导致配置纪元存在冲突的可能，当冲突发生时，集群会以 nodeId 字典序更大的一方配置为准</li></ul></li></ol><p>手动故障转移时，在满足当前需求的情况下建议优先级：<code>cluster failver</code> &gt; <code>cluster failover force</code> &gt; <code>cluster failover takeover</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据分布&quot;&gt;&lt;a href=&quot;#数据分布&quot; class=&quot;headerlink&quot; title=&quot;数据分布&quot;&gt;&lt;/a&gt;数据分布&lt;/h1&gt;&lt;h2 id=&quot;数据分布理论&quot;&gt;&lt;a href=&quot;#数据分布理论&quot; class=&quot;headerlink&quot; title=&quot;数据分布理
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-09-哨兵</title>
    <link href="https://yz1509.github.io//posts/4f9fe246/"/>
    <id>https://yz1509.github.io//posts/4f9fe246/</id>
    <published>2019-07-25T16:37:05.000Z</published>
    <updated>2019-07-25T17:00:32.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Redis Sentinel 相关名词解释</p><table><thead><tr><th style="text-align:left">名词</th><th style="text-align:left">逻辑结构</th><th style="text-align:left">物理结构</th></tr></thead><tbody><tr><td style="text-align:left">主节点(master)</td><td style="text-align:left">Redis 主服务/数据库</td><td style="text-align:left">一个独立的 Redis 进程</td></tr><tr><td style="text-align:left">从节点(slave)</td><td style="text-align:left">Redis 从服务/数据库</td><td style="text-align:left">一个独立的 Redis 进程</td></tr><tr><td style="text-align:left">Redis 数据节点</td><td style="text-align:left">主节点和从节点</td><td style="text-align:left">主节点和从节点的进程</td></tr><tr><td style="text-align:left">Sentinel 节点</td><td style="text-align:left">监控 Redis 数据节点</td><td style="text-align:left">一个独立的 Sentinel 进程</td></tr><tr><td style="text-align:left">Sentinel 节点集合</td><td style="text-align:left">若干 Sentinel 节点的抽象组合</td><td style="text-align:left">若干 Sentinel 节点进程</td></tr><tr><td style="text-align:left">Redis Sentinel</td><td style="text-align:left">Redis 高可用实现方案</td><td style="text-align:left">Sentinel 节点集合和 Redis 数据节点进程</td></tr><tr><td style="text-align:left">应用方</td><td style="text-align:left">泛指一个或多个客户端</td><td style="text-align:left">一个或者多个客户端进程或线程</td></tr></tbody></table><h2 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h2><ul><li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预</li><li>主节点的写能力受到单机的限制</li><li>主节点的存储能力受到单机的限制</li></ul><h2 id="Redis-Sentinel-的高可用性"><a href="#Redis-Sentinel-的高可用性" class="headerlink" title="Redis Sentinel 的高可用性"></a>Redis Sentinel 的高可用性</h2><p>Redis Sentinel 是一个分布式架构，其中包含若干个 Sentinel 节点和 Redis 数据节点，每个 Sentinel 节点会对数据节点和其余 Sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他 Sentinel 节点进行“协商”，当大多数Sentinel 节点都认为主节点不可达时，它们会选举出一个 Sentinel 节点来完成自动故障转移的工作，同时会将这个变化实时通知给 Redis 应用方。整个过程完全是自动的，不需要人工<br>来介入，所以这套方案很有效地解决了 Redis 的高可用问题。</p><p>注意：这里的分布式是指 Redis 数据节点、Sentinel 节点集合、客户端分布在多个物理节点的架构。</p><p>Redis Sentinel 具有以下几个功能：</p><ul><li>监控：Sentinel 节点会定期检测 Redis 数据节点、其余 Sentinel 节点是否可达</li><li>通知：Sentinel 节点会将故障转移的结果通知给应用方</li><li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系</li><li>配置提供者：在 Redis Sentinel 结构中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息</li></ul><p>Sentinel 节点本身就是独立的 Redis 节点，它们不存储数据，只支持部分命令。</p><h1 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h1><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><ol><li>部署拓扑结构</li><li><p>部署 Redis 数据节点<br>a) 启动主节点<br>b) 启动从节点<br>c) 确认主从关系</p></li><li><p>部署 Sentinel 节点<br>a) 配置 Sentinel 节点<br>b) 启动 Sentinel 节点<br>c) 确认节点信息</p></li></ol><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><ol><li><p>配置说明和优化</p><ul><li><code>sentinel monitor &lt;matser-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code><ul><li>quorum 代表要判定主节点最终不可达所需要的票数</li></ul></li><li><code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;</code><ul><li>每个 Sentinel 节点都要通过定期发送 ping 命令来判断 Redis 数据节点和其余Sentinel 节点是否可达，如果超过了 down-after-milliseconds 配置的时间且没有有效的回复，则判定节点不可达，times（单位为毫秒）就是超时时间。</li><li>down-after-milliseconds 虽然以 master-name 为参数，但实际上对 Sentinel节点、主节点、从节点的失败判定同时有效。</li></ul></li><li><code>sentinel parallel-sysncs &lt;master-name&gt; &lt;nums&gt;</code><ul><li>parallel-syncs 是用来限制在一次故障转移之后，每次向新的主节点发起复制操作的从节点个数</li></ul></li><li><code>sentinel failover-timeout &lt;master-name&gt; &lt;times&gt;</code> <ul><li>failover-timeout 通常被解释成故障转移超时时间，但实际上它作用于故障转移的各个阶段：<br>  1) 选择合适从节点<br>  2) 将选出的从节点晋升为主节点<br>  3) 命令其他从节点复制新的主节点<br>  4) 等待原主节点恢复后命令它去复制新的主节点</li><li>failover-timeout 的作用具体体现在四个方面：<ul><li>如果 Redis Sentinel 对一个主节点故障转移失败，那么下次再对该主节点做故障转移的起始时间是 failover-timeout 的 2 倍</li><li>在 2) 阶段时，如果 Sentinel 节点向 1) 阶段选出来的从节点执行 slaveof no one 一直失败（例如该从节点此时出现故障），当此过程超 failover-timeout 时，则故障转移失败</li><li>在 2) 阶段如果执行成功，Sentinel 节点还会执行 <code>info</code> 命令来确认 1) 阶段选出来的节点确实晋升为主节点，如果此过程执行时间超过 failover-timeout时，则故障转移失败</li><li>如果 3) 阶段执行时间超过了 failover-timeout（不包含复制时间），则故障转移失败。注意即使超过了这个时间，Sentinel 节点也会最终配置从节点去同步最新的主节点</li></ul></li></ul></li><li><code>sentinel auth-pass &lt;mymaster-name&gt; &lt;password&gt;</code> <ul><li>如果 Sentinel 监控的主节点配置了密码，sentinel auth-pass 配置通过添加主节点的密码，防止 Sentinel 节点对主节点无法监控</li></ul></li><li><code>sentinel notification-script &lt;mymaster-name&gt; &lt;script-path&gt;</code><ul><li>sentinel notification-script 的作用是在故障转移期间，当一些警告级别的Sentinel 事件发生（指重要事件，例如-sdown：客观下线、-odown：主观下线）时，会触发对应路径的脚本，并向脚本发送相应的事件参数 </li></ul></li><li><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code> <ul><li>sentinel client-reconfig-script 的作用是在故障转移结束后，会触发对应路径的脚本，并向脚本发送故障转移结果的相关参数</li></ul></li></ul></li><li><p>监控多个节点</p><p>Redis Sentinel 可以同时监控多个主节点，只需要指定多个 masterName 来区分不同的主节点即可。</p></li><li><p>调整配置</p><p><code>sentinel set &lt;param&gt; &lt;value&gt;</code></p><p>注意:</p><ul><li>sentinel set 命令只对当前 Sentinel 节点有效</li><li>sentinel set 命令如果执行成功会立即刷新配置文件，这点和 Redis 普通数据节点设置配置需要执行 <code>config rewrite</code> 刷新到配置文件不同</li><li>建议所有 Sentinel 节点的配置尽可能一致，这样在故障发现和转移时比较容易达成一致</li><li>Sentinel 对外不支持 config 命令</li></ul></li></ol><h2 id="部署技巧"><a href="#部署技巧" class="headerlink" title="部署技巧"></a>部署技巧</h2><ol><li>Sentinel 节点不应该部署在一台物理机器上</li><li>部署至少三个且奇数个的 Sentinel 节点</li><li>只有一套 Sentinel，还是每个主节点配置一套 Sentinel？<ul><li>如果 Sentinel 节点集合监控的是同一个业务的多个主节点集合，那么使用一套 Sentinel，否则一般建议采用多套 Sentinel</li></ul></li></ol><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ol><li><code>sentinel masters</code>：展示被监控的主节点状态以及相关的统计信息</li><li><code>sentinel master &lt;master name&gt;</code>：展示指定 master name 的主节点状态以及相关的统计信息</li><li><code>sentinel slaves &lt;master name&gt;</code>：展示指定 master name 的从节点状态以及相关的统计信息</li><li><code>sentinel sentinels &lt;master name&gt;</code>：展示指定 master name 的 sentinel 节点集合（不包含当前 sentinel 节点）</li><li><code>sentinel get-master-addr-by-name &lt;master name&gt;</code>：返回指定 master name 主节点的 IP 地址和端口</li><li><code>sentinel reset &lt;pattern&gt;</code>：当前 Sentinel 节点对符合 pattern（通配符风格）主节点的配置进行重置，包含清除主节点的相关状态（例如故障转移），重新发现从节点和 Sentinel 节点</li><li><code>sentinel failover &lt;master name&gt;</code>：对指定 master name 主节点进行强制故障转移（没有和其他 Sentinel 节点“协商”），当故障转移完成后，其他 Sentinel 节点按照故障转移的结果更新自身配置</li><li><code>sentinel ckquorum &lt;master name&gt;</code>：检测当前可达的 Sentinel 节点总数是否达到 quorum 的个数</li><li><code>sentinel flushconfig</code>：将 Sentinel 节点的配置强制刷到磁盘上</li><li><code>sentinel remove &lt;master name&gt;</code>：取消当前 Sentinel 节点对于指定 master name 主节点的监控，注意这个命令仅仅对当前 Sentinel 节点有效</li><li><code>sentinel monitor &lt;matser name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></li><li><code>sentinel set &lt;master name&gt;</code>：动态修改 Sentinel 节点配置选项</li><li><code>sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>：Sentinel 节点之间用来交换对主节点是否下线的判断，根据参数的不同，还可以作为 Sentinel 领导者选举的通信方式</li></ol><p>Sentinel 节点只支持如下命令：ping、sentinel、subscribe、unsubscribe、psubscribe、punsubscribe、publish、info、role、client、shutdown。</p><h1 id="Redis-Sentinel-客户端"><a href="#Redis-Sentinel-客户端" class="headerlink" title="Redis Sentinel 客户端"></a>Redis Sentinel 客户端</h1><p>实现一个 Redis Sentinel 客户端的基本步骤如下：</p><ol><li>遍历 Sentinel 节点集合获取一个可用的 Sentinel 节点</li><li>通过 <code>sentinel get-master-addr-by-name master-name</code> 这个 API 来获取对应主节点的相关信息</li><li>验证当前获取的“主节点”是真正的主节点，这样做的目的是为了防止故障转移期间主节点的变化</li><li>保持和 Sentinel 节点集合的“联系”，时刻获取关于主节点的相关“信息”</li></ol><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="三个定时监控任务"><a href="#三个定时监控任务" class="headerlink" title="三个定时监控任务"></a>三个定时监控任务</h2><ol><li><p>每隔 10 秒，每个 Sentinel 节点会向主节点和从节点发送 <code>info</code> 命令获取最新的拓扑结构</p><ul><li>通过向主节点执行 <code>info</code> 命令，获取从节点的信息，这也是为什么 Sentinel 节点不需要显式配置监控从节点</li><li>当有新的从节点加入时都可以立刻感知出来</li><li>节点不可达或者故障转移后，可以通过 <code>info</code> 命令实时更新节点拓扑信息</li></ul></li><li><p>每隔 2 秒，每个 Sentinel 节点会向 Redis 数据节点的 <code>__sentinel__：hello</code> 频道上发送该 Sentinel 节点对于主节点的判断以及当前 Sentinel 节点的信息，同时每个 Sentinel 节点也会订阅该频道，来了解其他 Sentinel 节点以及它们对主节点的判断，所以这个定时任务可以完成以下两个工作：</p><ul><li>发现新的 Sentinel 节点</li><li>Sentinel 节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据</li><li>Sentinel 节点 publish 的消息格式：<code>&lt;Sentinel IP&gt; &lt;Sentinel port&gt; &lt;Sentinel runId&gt; &lt;Sentinel 节点配置版本&gt; &lt;主节点名字&gt; &lt;主节点 IP&gt; &lt;主节点端口&gt; &lt;主节点配置版本&gt;</code></li></ul></li><li><p>每隔 1 秒，每个 Sentinel 节点会向主节点、从节点、其余 Sentinel 节点发送一条 <code>ping</code> 命令做一次心跳检测，来确认这些节点当前是否可达</p></li></ol><h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><ol><li>主观下线：心跳检测中超过 down-after-milliseconds 没有进行有效回复，Sentinel 节点就会对该节点做失败判定，这个行为叫做主观下线</li><li>当 Sentinel 主观下线的节点是主节点时，该 Sentinel 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令向其他 Sentinel 节点询问对主节点的判断，当超过 quorum 个数，Sentinel 节点认为主节点确实有问题，这时该 Sentinel 节点会做出客观下线的决定</li></ol><p><code>sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code></p><ul><li>ip：主节点 IP</li><li>port：主节点端口</li><li>current_epoch：当前配置纪元</li><li>runid：此参数有两种类型，不同类型决定了此 API 作用的不同<ul><li>当 runid 等于 * 时，作用是 Sentinel 节点直接交换对主节点下线的判定</li><li>当 runid 等于当前 Sentinel 节点的 runid 时，作用是当前 Sentinel 节点希望目标 Sentinel 节点同意自己成为领导者的请求</li></ul></li></ul><p>询问对主节点的判断命令的返回结果包括：</p><ul><li>down_state：目标 Sentinel 节点对于主节点的下线判断，1 是下线，0 是在线</li><li>leader_runid：当 leader_runid 等于 * 时，代表返回结果是用来做主节点是否不可达，当leader_runid等于具体的 runid，代表目标节点同意 runid 成为领导者</li><li>leader_epoch：领导者纪元</li></ul><h2 id="领导者-Sentinel-节点选举"><a href="#领导者-Sentinel-节点选举" class="headerlink" title="领导者 Sentinel 节点选举"></a>领导者 Sentinel 节点选举</h2><p>Redis 使用了 <a href="https://raft.github.io/" target="_blank" rel="noopener">Raft 算法</a> 实现领导者选举</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>领导者选举出的 Sentinel 节点负责故障转移，具体步骤如下：</p><ol><li><p>在从节点列表中选出一个节点作为新的主节点，选择方法如下：</p><ol><li>过滤：“不健康”（主观下线、断线）、5 秒内没有回复过 Sentinel 节点 ping 响应、与主节点失联超过 $down-after-milliseconds * 10$ 秒</li><li>选择 slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续</li><li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续</li><li>选择 runid 最小的从节点</li></ol></li><li><p>Sentinel 领导者节点会对第一步选出来的从节点执行 <code>slaveof no one</code> 命令让其成为主节点</p></li><li><p>Sentinel 领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和 parallel-syncs 参数有关</p></li><li><p>Sentinel 节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;Redis Sentinel 相关名词解释&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-08-理解内存</title>
    <link href="https://yz1509.github.io//posts/bb9ea4f2/"/>
    <id>https://yz1509.github.io//posts/bb9ea4f2/</id>
    <published>2019-07-25T16:36:51.000Z</published>
    <updated>2019-07-25T17:00:32.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h1><p>内存消耗可以分为进程自身消耗和子进程消耗。</p><h2 id="内存使用统计"><a href="#内存使用统计" class="headerlink" title="内存使用统计"></a>内存使用统计</h2><p>可通过执行 <code>info memory</code> 命令获取内存相关指标，各项指标详细解释如下：</p><ul><li><em>used_memory</em>：Redis 分配器分配的内存总量，也就是内部存储的所有数据内存占有量</li><li>used_memory_human：以可读的格式返回 used_memory</li><li><em>used_memory_rss</em>：从操作系统的角度显式 Redis 进程占用的物理内存总量</li><li>used_memory_peak：内存使用的最大值，表示 used_memory 的峰值</li><li>used_memory_peak_human：以可读的格式返回 used_memory_peak</li><li>used_memory_lua：Lua 引擎所消耗的内存大小</li><li><em>mem_gragmentation_ratio</em>：used_memory_rss / used_memory 比值，表示内存碎片率<ul><li>当 mem_fragmentation_ratio &gt; 1 时，说明 used_memory_rss - used_memory 多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重。</li><li>当 mem_fragmentation_ratio &lt; 1 时，这种情况一般出现在操作系统把 Redis 内存交换（Swap）到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis 性能会变得很差，甚至僵死。</li></ul></li><li>mem_allocator：Redis 所使用的内存分配器，默认为 jemalloc</li></ul><h2 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h2><ol><li>自身内存：一个空的Redis进程消耗内存可以忽略不计。</li><li>对象内存：Redis 内存占用最大的一块，存储着用户所有的数据。</li><li>缓冲内存：主要包括客户端缓冲、复制积压缓冲区和AOF缓冲区。<ul><li>客户端缓冲指的是所有接入到 Redis 服务器 TCP 连接的输入输出缓冲。输入缓冲无法控制，最大空间为 1G，如果超过将断开连接。输出缓冲通过参数<code>client-output-buffer-limit</code>控制：<ul><li>普通客户端：默认配置 <code>client-output-buffer-limit normal 1000</code></li><li>从客户端：主节点会为每个从节点单独建立一条连接用于命令复制，默认配置是：<code>client-output-buffer-limit slave 256mb 64mb 60</code></li><li>订阅客户端：当使用发布订阅功能时，连接客户端使用单独的输出缓冲区，默认配置为：<code>client-output-buffer-limit pubsub 32mb 8mb 60</code></li></ul></li><li>复制积压缓冲区：提供了一个可重用的固定大小缓冲区用于实现部分复制功能，根据 <code>repl-backlog-size</code> 参数控制，默认 1MB。对于复制积压缓冲区整个主节点只有一个，所有的从节点共享此缓冲区，因此可以设置较大的缓冲区空间</li><li>AOF 缓冲区：用于在 Redis 重写期间保存最近的写入命令，AOF 缓冲区空间消耗用户无法控制，消耗的内存取决于 AOF 重写时间和写入命令量，占用通常很小</li></ul></li><li>内存碎片<ul><li>Redis 默认的内存分配器采用 jemalloc，可选的分配器还有：glibc、tcmalloc</li><li>内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配</li><li>以下场景容易出现高内存碎片问题：<ul><li>频繁做更新操作</li><li>大量过期键删除，释放的空间无法得到充分利用</li></ul></li><li>常见的解决方式：<ul><li>数据对齐</li><li>安全重启：重启节点可以做到内存碎片重新整理，因此可以利用高可用架构，如Sentinel 或 Cluster，将碎片率过高的主节点转换为从节点，进行安全重启</li></ul></li></ul></li></ol><h2 id="子进程内存消耗"><a href="#子进程内存消耗" class="headerlink" title="子进程内存消耗"></a>子进程内存消耗</h2><ol><li>Redis 产生的子进程并不需要消耗 1 倍的父进程内存，实际消耗根据期间写入命令量决定，但是依然要预留出一些内存防止溢出</li><li>需要设置 <code>sysctl vm.overcommit_memory = 1</code> 允许内核可以分配所有的物理内存，防止Redis 进程执行 fork 时因系统剩余内存不足而失败</li><li>排查当前系统是否支持并开启 THP，如果开启建议关闭，防止 copy-on-write 期间内存过度消耗</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="设置内存上限"><a href="#设置内存上限" class="headerlink" title="设置内存上限"></a>设置内存上限</h2><p>Redis 默认无限使用服务器内存，为防止极端情况下导致系统内存耗尽，建议所有的 Redis 进程都要配置 maxmemory。</p><p>限制内存的主要目的有：</p><ul><li>用于缓存场景，当超出内存上限 maxmemory 时使用 LRU 等删除策略释放空间</li><li>防止所用内存超过服务器物理内存。但需注意，maxmemory 限制的是 Redis 实际使用的内存量，也就是 used_memory 统计项对应的内存。由于内存碎片率的存在，实际消耗的内存可能会比 maxmemory 设置的更大，实际使用时要小心这部分内存溢出。</li></ul><h2 id="动态调整内存上限"><a href="#动态调整内存上限" class="headerlink" title="动态调整内存上限"></a>动态调整内存上限</h2><p>Redis 的内存上限可以通过 <code>config set mammemory</code> 进行动态修改，即修改最大可用内存。</p><p>在保证物理内存可用的情况下，系统中所有 Redis 实例可以调整 maxmemory 参数来达到自由伸缩内存的目的。</p><h2 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h2><ol><li><p>删除过期键对象</p><p>Redis 所有的键都可以设置过期属性，内部保存在过期字典中。</p><ul><li>惰性删除：惰性删除用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空<ul><li>节省 CPU 成本，不需要单独维护 TTL 链表来处理过期键的删除</li><li>当过期键一直没有访问将无法及时得到删除，从而导致内存不能及时释放，存在内存泄露的问题</li></ul></li><li>定时任务删除：Redis 内部维护一个定时任务，默认每秒运行 10 次（通过配置 hz 控制），定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键</li></ul></li><li><p>内存溢出控制策略</p><p>当 Redis 所用内存达到 maxmemory 上限时会触发相应的溢出控制策略。具体策略受<code>maxmemory-policy</code> 参数控制，Redis 支持 6 种策略，如下所示：<br>1) noevicition：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息 <code>(error) OOM command not allowed when used memory</code>，此时 Redis 只响应读操作<br>2) volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到noeviction 策略<br>3) volatile-lru：根据 LRU 算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到 noeviction 策略<br>4) volatile-random：随机删除过期键，直到腾出足够空间为止<br>5) allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止<br>6) allkeys-random：随机删除所有键，直到腾出足够空间为止</p><p>内存溢出控制策略可以采用 <code>config set maxmemory-policy {policy}</code> 动态配置。当Redis 因为内存溢出删除键时，可以通过执行 <code>info stats</code> 命令查看 evicted_keys 指标找出当前 Redis 服务器已剔除的键数量。</p></li></ol><h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><h2 id="redisObeject-对象"><a href="#redisObeject-对象" class="headerlink" title="redisObeject 对象"></a>redisObeject 对象</h2><p>Redis 存储的所有值对象在内部定义为 redisObject 结构体，主要包含五个字段：</p><ol><li><p>type 字段：表示当前对象使用的数据类型</p><ul><li>Redis 主要支持 5 种数据类型：string、hash、list、set、zset</li><li>可以使用 <code>type {key}</code> 命令查看对象所属类型，type 命令返回的是值对象类型，键都是string 类型</li></ul></li><li><p>encoding 字段：表示 Redis 内部编码类型，encoding 在 Redis 内部使用，代表当前对象内部采用哪种数据结构实现</p></li><li><p>lru 字段：记录对象最后一次被访问的时间</p><ul><li>当配置了 maxmemory 和 <code>maxmemory-policy = volatile-lru</code> 或者 <code>allkeys-lru</code>时，用于辅助 LRU 算法删除键数据</li><li>可以使用 <code>object idletime {key}</code> 命令在不更新 lru 字段情况下查看当前键的空闲时间</li><li>可以使用 <code>scan</code> + <code>object idletime</code> 命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理，可降低内存占用</li></ul></li><li><p>refcount 字段：记录当前对象被引用的次数</p><ul><li>当 refcount = 0 时，可以安全回收当前对象空间</li><li>使用 <code>object refcount {key}</code>获取当前对象引用次数</li><li>当对象为整数且范围在 [0-9999] 时，Redis 可以使用共享对象的方式来节省内存</li></ul></li><li><p>*ptr 字段：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针</p><ul><li>值对象是字符串且长度 &lt;= 39字节的数据，内部编码为 embstr 类型，字符串 sds 和redisObject 一起分配，从而只要一次内存操作即可</li></ul></li></ol><h2 id="缩减键值对象"><a href="#缩减键值对象" class="headerlink" title="缩减键值对象"></a>缩减键值对象</h2><p>降低 Redis 内存使用最直接的方式就是缩减键和值的长度。</p><ul><li>key 长度：在设计键时，在完整描述业务情况下，键值越短越好</li><li>value 长度<ul><li>在业务上精简业务对象，去掉不必要的属性避免存储无效数据</li><li>将业务对象序列化城二进制数组放入 Redis，且应该选择高效的序列化工具</li><li>值对象除了存储二进制数据之外，通常还会使用通用格式（如 json 和 XML 等）作为字符串存储在 Redis 中，可使用通用压缩算法（如 Snappy）进行存储从而降低内存占用</li></ul></li></ul><h2 id="共享对象池"><a href="#共享对象池" class="headerlink" title="共享对象池"></a>共享对象池</h2><p>共享对象池是指 Redis 内部维护 [0-9999] 的整数对象池。</p><ul><li>除了整数值对象，其他类型如 list、hash、set、zset 内部元素也可以使用整数对象池。但对于 ziplist 编码的值对象，即使内部数据为整数也无法使用共享对象池，因为 ziplist 是用压缩且内存连续的结构</li><li>整数对象池在 Redis 中通过变量 <code>REDIS_SHARED_INTEGERS</code> 定义，不能通过配置修改</li><li>可以通过 <code>object refcount</code> 命令查看对象引用数验证是否启用整数对象池技术</li><li>当设置 maxmemory 并启用 LRU 相关淘汰策略如：volatile-lru，allkeys-lru 时，Redis 禁止使用共享对象池</li></ul><h2 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h2><ol><li><p>字符串结构：简单动态字符串 (simple dynamic string, SDS)</p><ul><li>结构<ul><li>int len：已用字节长度</li><li>int free：未用字节长度</li><li>char buf[]：字节数组</li></ul></li><li>特点<ul><li>获取字符串长度、已用长度和未用长度为 O(1) 时间复杂度</li><li>可用于保存字节数组，支持安全的二进制数据存储</li><li>内部实现空间预分配机制，降低内存再分配次数</li><li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留</li></ul></li></ul></li><li><p>预分配机制</p><ul><li>空间预分配机制：<ul><li>第一次创建时，len 属性等于数据实际大小，free = 0，不做预分配</li><li>修改后如果已有 free 空间不够且数据小于 1MB，每次预分配数据实际大小一倍容量</li><li>修改后如果已有 free 空间不够且数据大于 1MB，每次预分配 1MB 数据</li></ul></li><li>尽量减少字符串频繁修改操作如 append、setrange，改为直接使用 set 修改字符串，降低预分配带来的内存浪费和内存碎片化</li></ul></li><li><p>字符串重构：指不一定把每份数据作为字符串整体存储，像 json 这样的数据可以使用 hash 结构，使用二级结构存储也能帮我们节省内存。同时可以使用 <code>hmget</code>、<code>hmset</code> 命令支持字段的部分读取修改，而不用每次整体存取。</p></li></ol><h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><p>Redis 对外提供了 string、list、hash、set、zet 等类型，但是 Redis 内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。每种数据类型（type）可以采用至少两种编码方式来实现，编码不同将直接影响数据的内存占用和读写效率。使用 <code>object encoding {key}</code> 命令获取编码类型。</p><ol><li><p>编码类型转换</p><ul><li>编码类型转换在 Redis 写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换</li><li>可以使用 <code>config set</code> 命令设置编码相关参数来满足使用压缩编码的条件。对于已经采用非压缩编码类型的数据如 hashtable、linkedlist 等，设置参数后即使数据满足压缩编码条件，Redis 也不会做转换，需要重启 Redis 重新加载数据才能完成转换。</li></ul></li><li><p>ziplist 编码</p><p>ziplist 编码中所有数据都是采用线性连续的内存结构，主要的目的是为了节省内存。</p><p>ziplist 内部结构：<code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry-1&gt;&lt;entry-2&gt;...&lt;entry-n&gt;&lt;zlend&gt;</code>，每个 entry 保存具体的数据，内部结构为：<code>&lt;prev_entry_bytes_length&gt;&lt;encoding&gt;&lt;contents&gt;</code>。</p><p>ziplist 结构字段含义：</p><ul><li>zlbytes：记录整个压缩列表所占字节长度，方便重新调整 ziplist 空间。类型是 int-32，长度为 4 字节</li><li>zltail：记录压缩列表尾节点距离起始位置的偏移量，方便尾节点弹出操作。类型是 int-32，长度为 4 字节</li><li>zllen：记录压缩列表节点数量。类型是 int-16，长度为 2 字节</li><li>entry：记录具体的节点，长度根据实际存储的数据而定</li><li>prev_entry_bytes_length：记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代</li><li>encoding：标示当前节点编码和长度，前两位表示编码类型：字符串/整数，其余位表示数据长度</li><li>contents：保存节点的值，针对实际数据长度做内存占用优化</li><li>zlend：记录列表结尾，占用一个字节</li></ul><p>ziplist 数据结构特点：</p><ul><li>内部表现为数据紧凑排列的一块连续内存数组</li><li>可以模拟双向链表结构，以 O(1) 时间复杂度入队和出队</li><li>新增删除操作涉及内存重新分配或释放，加大了操作的复杂性</li><li>读写操作涉及复杂的指针移动，最坏时间复杂度为 $O(n^2)$</li><li>适合存储小对象和长度有限的数据</li></ul></li><li><p>inset 编码</p><p>intset 编码是集合(set)类型编码的一种，内部表现为存储有序、不重复的整数集。当集合只包含整数且长度不超过 <code>set-max-intset-entries</code> 配置时被启用。</p><p>intset 字段结构：<code>&lt;encoding&gt;&lt;length&gt;&lt;contents&gt;</code></p><ul><li>encoding：整数表示类型，根据集合内最长整数值确定类型，整数类型划分为三种：int-16、int-32、int-64</li><li>length：表示集合元素个数</li><li>contents：整数数组，按从小到大顺序保存</li></ul><p>intset 保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再做回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组。因此，使用 intset 编码的集合时，尽量保持整数范围一致，防止个别大整数触发集合升级操作，产生内存浪费。</p></li></ol><h2 id="控制键的数量"><a href="#控制键的数量" class="headerlink" title="控制键的数量"></a>控制键的数量</h2><p>对于存储相同的数据内容，利用 Redis 的数据结构降低外层键的数量，也可以节省大量内存。</p><p>ziplist 编码的 hash 结构降低键数量：</p><ul><li>通过在客户端预估键规模，把大量键分组映射到多个 hash 结构中降低键的数量</li><li>hash 的 field 可用于记录原始 key 字符串，方便哈希查找</li><li>hash 的 value 保存原始值对象，确保不要超过 <code>hash-max-ziplist-value</code> 限制</li></ul><p>这种内存优化技巧的关键点：</p><ul><li>hash 类型节省内存的原理是使用 ziplist 编码，如果使用 hashtable 编码方式反而会增加内存消耗</li><li>ziplist 长度需要控制在 1000 以内，否则由于存取操作时间复杂度在 $O(n)$ 到 $O(n^2)$ 之间，长列表会导致 CPU 消耗严重，得不偿失</li><li>ziplist 适合存储小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时</li><li>需要预估键的规模，从而确定每个 hash 结构需要存储的元素数量</li><li>根据 hash 长度和元素大小，调整 <code>hash-max-ziplist-entries</code> 和 <code>hash-maxziplist-value</code> 参数，确保 hash 类型使用 ziplist 编码</li></ul><p>关于 hash 键和 field 键的设计：</p><ul><li>当键离散度较高时，可以按字符串位截取，如把后三位作为哈希的 field，之前部分作为哈希的键</li><li>当键离散度较低时，可以使用哈希算法打散键</li><li>尽量减少 hash 键和 field 的长度，如使用部分键内容</li></ul><p>hash 重构后所有的键无法再使用超时（expire）和 LRU 淘汰机制自动删除，需要手动维护删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存消耗&quot;&gt;&lt;a href=&quot;#内存消耗&quot; class=&quot;headerlink&quot; title=&quot;内存消耗&quot;&gt;&lt;/a&gt;内存消耗&lt;/h1&gt;&lt;p&gt;内存消耗可以分为进程自身消耗和子进程消耗。&lt;/p&gt;
&lt;h2 id=&quot;内存使用统计&quot;&gt;&lt;a href=&quot;#内存使用统计&quot; cl
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-07-阻塞</title>
    <link href="https://yz1509.github.io//posts/45ffe189/"/>
    <id>https://yz1509.github.io//posts/45ffe189/</id>
    <published>2019-07-25T16:36:40.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内在原因"><a href="#内在原因" class="headerlink" title="内在原因"></a>内在原因</h1><ol><li><p>API 或数据结构使用不合理</p><p>对于高并发的场景我们应该尽量避免在大对象上执行算法复杂度超过 O(n) 的命令</p><ul><li>发现慢查询：执行 <code>slowlog get {n}</code>命令可以获取最近的 n 条慢查询命令</li><li>发现大对象：<code>redis-cli -h {ip} -p {port} --bigkeys</code></li></ul></li><li><p>CPU 饱和</p><p>使用统计命令 <code>redis-cli -h {ip} -p {port} --stat</code>获取当前 Redis 使用情况，该命令每秒输出一行统计信息</p></li><li><p>持久化相关阻塞</p><ul><li>fork 阻塞：fork 操作本身耗时过长，会导致主线程的阻塞</li><li>AOF 刷盘阻塞</li><li>HugePage 写操作阻塞</li></ul></li></ol><h1 id="外在原因"><a href="#外在原因" class="headerlink" title="外在原因"></a>外在原因</h1><ol><li><p>CPU 竞争</p><ul><li>进程竞争</li><li>绑定 CPU</li></ul></li><li><p>内存交换</p><p>识别 Redis 内存交换的检查方法：<br>1) 查询 Redis 进程号：<code>redis-cli -p {port} info server | grep process_id</code><br>2) 根据进程号查询内存交换信息：<code>cat /proc/{process_id}/smaps | grep Swap</code></p><p>如果交换量都是 0KB 或者个别的是 4KB，则是正常现象，说明 Redis 进程内存没有被交换。预防内存交换的方法有：</p><ul><li>保证机器充足的可用内存</li><li>确保所有 Redis 实例设置都已最大可用内存（maxmemory），防止极端情况下 Redis 内存不可控的增长</li><li>降低系统使用 swap 优先级，如 <code>echo10&gt;/proc/sys/vm/swappiness</code></li></ul></li><li><p>网络问题</p><ul><li>连接拒绝<ul><li>网络闪断：一般发生在网络割接或者带宽耗尽的情况，对于网络闪断的识别比较困难，常见的做法可以通过 <code>sar-n DEV</code> 查看本机历史流量是否正常，或者借助外部系统监控工具（如Ganglia）进行识别</li><li>Redis 连接拒绝：Redis 通过 maxclients 参数控制客户端最大连接数，默认10000。当 Redis 连接数大于 maxclients 时会拒绝新的连接进入，info stats的rejected_connections 统计指标记录所有被拒绝连接的数量</li><li>连接溢出：这是指操作系统或者 Redis 客户端在连接时的问题，可能是以下原因：<ul><li>进程限制：客户端想成功连接上 Redis 服务需要操作系统和 Redis 的限制都通过才可以</li><li>backlog 队列溢出：系统对于特定端口的 TCP 连接使用 backlog 队列保存。Redis 默认的长度为 511，通过 tcp-backlog 参数设置。如果怀疑是 backlog 队列溢出，线上可以使用 cron 定时执行 <code>netstat -s | grep overflowed</code> 统计，查看是否有持续增长的连接拒绝情况</li></ul></li></ul></li><li>网络延迟：Redis 提供了测量机器之间网络延迟的工具，在 <code>redis-cli -h {host} -p {port}</code> 命令后面加入如下参数进行延迟测试：<ul><li><code>--latency</code>：持续进行延迟测试，分别统计：最小值、最大值、平均值、采样次数</li><li><code>--latency-history</code>：统计结果同 <code>--latency</code>，但默认每 15 秒完成一行统计，可通过 <code>-i</code> 参数控制采样时间</li><li><code>--latency-dist</code>：使用统计图的形式展示延迟统计，每 1 秒采样一次</li></ul></li><li>网卡软中断：指由于单个网卡队列只能使用一个 CPU，高并发下网卡数据交互都集中在同一个 CPU，导致无法充分利用多核 CPU 的情况</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内在原因&quot;&gt;&lt;a href=&quot;#内在原因&quot; class=&quot;headerlink&quot; title=&quot;内在原因&quot;&gt;&lt;/a&gt;内在原因&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;API 或数据结构使用不合理&lt;/p&gt;
&lt;p&gt;对于高并发的场景我们应该尽量避免在大对象上执行算法复杂度超过 
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-06-复制</title>
    <link href="https://yz1509.github.io//posts/3ef5e487/"/>
    <id>https://yz1509.github.io//posts/3ef5e487/</id>
    <published>2019-07-25T16:36:27.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>复制的数据流是单向的，只能从主节点复制到从节点。配置复制的方式有以下三种：</p><ol><li>在配置文件中加入 <code>slaveof {masterHost} {masterPort}</code> 随 Redis 启动生效</li><li>在 <code>redis-server</code> 启动命令后加入 <code>--slaveof {masterHost} {masterPort}</code> 生效</li><li>直接使用命令：<code>slaveof {masterHost} {masterPort}</code> 生效</li></ol><p>slaveof 本身是异步命令，执行 slaveof 命令时，节点只保存主节点信息后返回，后续复制流程在节点内部异步执行，主从节点复制成功建立后，可以使用 <code>info replication</code> 命令查看复制相关状态。</p><h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p>在从节点执行 <code>slaveof no one</code> 来断开与主节点复制关系，断开复制主要流程：</p><ol><li>断开与主节点复制关系</li><li>从节点晋升为主节点</li></ol><p>通过执行 <code>slaveof {newMasterHost} {newMasterPort}</code> 命令可以实现切主操作，切主操作流程如下：</p><ol><li>断开与旧主节点复制关系</li><li>与新主节点建立复制关系</li><li>删除从节点当前所有数据</li><li>对新主节点进行复制操作</li></ol><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>主节点可设置 <code>requirepass</code> 参数进行密码验证，这时所有的客户端访问必须使用 <code>auth</code> 命令实行校验，因此需要配置从节点的 <code>masterauth</code> 参数与主节点密码保持一致，这样从节点才可以正确地连接到主节点并发起复制流程。</p><h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p>默认情况下，从节点使用 <code>slaveof-read-only = yes</code> 配置为只读模式。</p><h2 id="传输延迟"><a href="#传输延迟" class="headerlink" title="传输延迟"></a>传输延迟</h2><p>Redis 提供了 <code>repl-disable-tcp-nodelay</code> 参数用于控制是否关闭 TCP_NODELAY，默认关闭。</p><ul><li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗</li><li>当开启时，主节点会合并较小的 TCP 数据包从而节省带宽，但增大了主从之间的延迟</li></ul><h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p>Redis 的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从和树状主从结构。</p><ol><li>一主一从结构<br>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。当应用写命令并发量较高且需要持久化时，可以只在从节点上开启 AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。</li><li>一主多从结构<br>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</li><li>树状主从结构<br>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。</li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><ol><li>保存主节点信息</li><li>主从建立 socket 连接：从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接</li><li>发送 <code>ping</code> 命令</li><li>权限验证</li><li>同步数据集</li><li>命令持续复制</li></ol><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>Redis 使用 <code>psync</code> 命令完成主从数据同步，同步过程分为全量复制和部分复制。</p><p><code>psync</code> 命令运行需要以下组件支持：</p><ol><li>主从节点复制偏移量<ul><li>主节点（master）在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 <code>info relication</code> 中的 <code>master_repl_offset</code> 指标中</li><li>从节点（slave）每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量</li><li>从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在 <code>info relication</code> 中的 <code>slave_repl_offset</code> 指标中</li></ul></li><li>主节点复制积压缓冲区<ul><li>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为 1 MB，本质上是先进先出的定长队列</li><li>当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区</li></ul></li><li>主节点运行 ID<ul><li>每个 Redis 节点启动后都会动态分配一个40位的十六进制字符串作为运行 ID</li><li>如果只使用 ip+port 的方式识别主节点，那么主节点重启变更了整体数据集（如替换 RDB/AOF 文件），从节点再基于偏移量复制数据将是不安全的，因此当运行 ID 变化后从节点将做全量复制</li><li>可以使用 <code>debug reload</code> 命令重新加载 RDB 并保持运行 ID 不变，从而有效避免不必要的全量复制</li><li>注意：debug reload 命令会阻塞当前 Redis 节点主线程，阻塞期间会生成本地 RDB 快照并清空数据之后再加载 RDB 文件。因此对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。</li></ul></li></ol><p>从节点使用 <code>psync</code> 命令完成部分复制和全量复制功能，命令格式 <code>psync {runId} {offset}</code>，<code>psync</code> 命令运行流程：</p><ol><li>从节点（slave）发送 <code>psync</code> 命令给主节点，参数 runId 是当前从节点保存的主节点运行ID，如果没有则默认值为 ?，参数 offset 是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为 -1。</li><li>主节点（master）根据 <code>psync</code> 参数和自身数据情况决定响应结果：<ul><li>如果回复 <code>+FULLRESYNC {runId} {offset}</code>，那么从节点将触发全量复制流程</li><li>如果回复 <code>+CONTINUE</code>，从节点将触发部分复制流程</li><li>如果回复 <code>+ERR</code>，说明主节点版本低于 Redis2.8，无法识别 <code>psync</code> 命令，从节点将发送旧版的 <code>sync</code> 命令触发全量复制流程。</li></ul></li></ol><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ol><li>从节点发送 <code>psync</code> 命令进行数据同步，如果是第一次进行复制，从节点没有复制偏移量和主节点的运行 ID，所以发送 <code>psync ? -1</code></li><li>主节点根据 <code>psync ? -1</code> 解析出当前为全量复制，回复 <code>+FULLRESYNC</code> 响应</li><li>从节点接收主节点的响应数据保存运行 ID 和偏移量 offset</li><li>主节点执行 <code>bgsave</code> 保存 RDB 文件到本地</li><li>主节点发送 RDB 文件给从节点，从节点把接收的 RDB 文件保存在本地并直接作为从节点的数据文件<ul><li>针对数据量较大的节点，建议调大 <code>repl-timeout</code> 参数防止出现全量同步数据超时</li><li>关于无盘复制：为了降低主节点磁盘开销，Redis 支持无盘复制，生成的 RDB 文件不保存到硬盘而是直接通过网络发送给从节点，通过 <code>repldiskless-sync</code> 参数控制，默认关闭。无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。</li></ul></li><li>对于从节点开始接收 RDB 快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完 RDB 文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性</li><li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li><li>从节点清空数据后开始加载 RDB 文件</li><li>从节点成功加载完 RDB 后，如果当前节点开启了 AOF 持久化功能，它会立刻做 <code>bgrewriteaof</code> 操作，为了保证全量复制后 AOF 持久化文件立刻可用</li></ol><h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p>使用 <code>psync {runId} {offset}</code>命令实现。当从节点（slave）正在复制主节点（master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。</p><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>主从节点在建立复制后，它们之间维护着长连接并彼此发送心跳命令，主从心跳判断机制：</p><ol><li>主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 <code>client list</code> 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点连接状态为 flags = S。</li><li>主节点默认每隔 10 秒对从节点发送 <code>ping</code> 命令，判断从节点的存活性和连接状态。可通过参数 <code>repl-ping-slave-period</code> 控制发送频率。</li><li>从节点在主线程中每隔 1 秒发送 <code>replconf ack {offset}</code> 命令，给主节点上报自身当前的复制偏移量。<code>replconf</code> 命令主要作用如下：<ul><li>实时监测主从节点网络状态</li><li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据</li><li>实现保证从节点的数量和延迟性功能，通过 <code>min-slaves-to-write</code>、<code>minslaves-max-lag</code> 参数配置定义</li></ul></li></ol><h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。</p><h1 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>对于读占比较高的场景，可以通过把一部分读流量分摊到从节点（slave）来减轻主节点（master）压力，同时需要注意永远只对主节点执行写操作。</p><p>当使用从节点响应读请求时，业务端可能会遇到如下问题：</p><ul><li>数据延迟</li><li>读到过期数据</li><li>从节点故障</li></ul><h2 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h2><h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><p>全量复制的场景：</p><ol><li><p>第一次建立复制</p><ul><li>无法规避，当对数据量较大且流量较高的主节点添加从节点时，建议在低峰时进行操作，或者尽量规避使用大数据量的 Redis 节点。</li></ul></li><li><p>节点运行 ID 不匹配</p><ul><li>起因：如果主节点因故障重启，那么它的运行 ID 会改变，从节点发现主节点运行 ID 不匹配时，会认为自己复制的是一个新的主节点从而进行全量复制。</li><li>方法：对于这种情况应该从架构上规避，比如提供故障转移功能。当主节点发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。</li></ul></li><li><p>复制积压缓冲区不足</p><ul><li>起因：当主从节点网络中断后，从节点再次连上主节点时会发送 <code>psync {offset} {runId}</code> 命令请求部分复制，如果请求的偏移量不在主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为全量复制。</li><li>方法：针对这种情况需要根据网络中断时长，写命令数据量分析出合理的积压缓冲区大小。</li></ul></li></ol><h2 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h2><p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。</p><ol><li><p>单主节点复制风暴</p><p>单主节点复制风暴一般发生在主节点挂载多个从节点的场景，解决方案有：</p><ul><li>可以减少主节点（master）挂载从节点（slave）的数量</li><li>采用树状复制结构，加入中间层从节点用来保护主节点</li></ul></li><li><p>单机器复制风暴<br>当一台机器（machine）上同时部署多个主节点（master）时，如果这台机器出现故障或网络长时间中断，当它重启恢复后，会有大量从节点（slave）针对这台机器的主节点进行全量复制，会造成当前机器网络带宽耗尽。解决方案有：</p><ul><li>应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点</li><li>当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h2 id=&quot;建立复制&quot;&gt;&lt;a href=&quot;#建立复制&quot; class=&quot;headerlink&quot; title=&quot;建立复制&quot;&gt;&lt;/a&gt;建立复制&lt;/h
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-05-持久化</title>
    <link href="https://yz1509.github.io//posts/35524ba0/"/>
    <id>https://yz1509.github.io//posts/35524ba0/</id>
    <published>2019-07-25T16:36:17.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。</p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>手动触发分别对应 save 和 bgsave 命令</p><ul><li>save 命令：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用</li><li>bgsave 命令：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短</li></ul><p>除了执行命令手动触发之外，Redis 内部还存在自动触发 RDB 的持久化机制，如：</p><ul><li>使用 save 相关配置，<code>save m n</code>：m 秒内数据集存在 n 次修改时，自动触发 bgsave</li><li>如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点</li><li>执行 debug reload 命令重新加载 Redis 时，也会自动触发 save 操作</li><li>默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li><li>···</li></ul><h2 id="RDB-文件的处理"><a href="#RDB-文件的处理" class="headerlink" title="RDB 文件的处理"></a>RDB 文件的处理</h2><ul><li><strong>保存</strong>：RDB 文件保存在 dir 配置指定的目录下，文件名通过 dbfilename 配置指定。可以通过执行 <code>config set dir {newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时 RDB 文件会保存到新目录。</li><li><strong>压缩</strong>：Redis 默认采用 LZF 算法对生成的 RDB 文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 <code>config set rdbcompression {yes|no}</code>动态修改。</li><li><strong>校验</strong>：如果 Redis 加载损坏的 RDB 文件时拒绝启动，并打印错误日志，这时可以使用 Redis提供的 redis-check-dump 工具检测 RDB 文件并获取对应的错误报告。</li></ul><h2 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h2><ul><li>优点<ol><li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。非常适用于备份，全量复制等场景</li><li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</li></ol></li><li>缺点<ol><li>RDB 方式数据没办法做到实时持久化/秒级持久化</li><li>RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个格式的 RDB 版本，存在老版本 Redis 服务无法兼容新版 RDB 格式的问题</li></ol></li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF(append only file) 持久化：以独立日志的方式记录每次写命令，重启时再重新执行 AOF 文件中的命令达到恢复数据的目的。</p><ul><li>开启 AOF 功能需要设置配置：appendonly yes，默认不开启</li><li>AOF 文件名通过 <code>appendfilename</code> 配置设置，默认文件名是 appendonly.aof</li><li>保存路径同 RDB 持久化方式一致，通过 <code>dir</code> 配置指定</li><li>AOF 的工作流程操作：<ol><li>命令写入（append）：所有的写入命令会追加到 aof_buf（缓冲区）中</li><li>文件同步（sync）：AOF 缓冲区根据对应的策略向硬盘做同步操作</li><li>文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的</li><li>重启加载（load）：当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复</li></ol></li></ul><h2 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h2><p>AOF 命令写入的内容直接是文本协议格式，采用文本协议格式的理由可能有：</p><ul><li>文本协议具有很好的兼容性</li><li>开启 AOF 后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销</li><li>文本协议具有可读性，方便直接修改和处理</li></ul><p>AOF 为什么把命令追加到 aof_buf 中？<br>答：Redis 使用单线程响应命令，如果每次写 AOF 文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区 aof_buf 中，还有另一个好处，Redis 可以提供多种缓冲区<br>同步硬盘的策略，在性能和安全性方面做出平衡。</p><h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p>Redis 提供了多种 AOF 缓冲区同步文件策略，由参数 <code>appendfsync</code> 控制</p><ul><li><code>always</code>：命令写入 aof_buf 后调用系统 fsync 操作同步到 AOF 文件，fsync 完成后线程返回。每次写入都要同步 AOF 文件，低效。</li><li><code>no</code>：命令写入 aof_buf 后调用系统 write 操作，不对 AOF 文件做 fsync 同步，同步硬盘操作由操作系统负责，通常同步周期最长为 30 秒。由于操作系统每次同步 AOF 文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</li><li><code>everysec</code>：命令写入 aof_buf 后调用系统 write 操作，write 完成后线程返回。fsync 同步文件操作由专门线程每秒调用一次，最多可能丢失 2 秒的数据。默认配置，兼顾性能和数据安全性。</li></ul><p>系统调用 write 和 fsync：</p><ul><li>write 操作会触发延迟写（delayed write）机制</li><li>fsync 针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync 将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li></ul><h2 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h2><p>AOF 文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件的过程。</p><p>重写后的 AOF 文件为什么可以变小？</p><ul><li>进程内已经超时的数据不再写入文件</li><li>旧的 AOF 文件含有无效命令，重写使用进程内数据直接生成，这样新的 AOF 文件只保留最终数据的写入命令</li><li>多条写命令可以合并为一个。为了防止单条命令过大造成客户端缓冲区溢出，对于 list、set、hash、zset 等类型操作，以 64 个元素为界拆分为多条</li></ul><p>AOF 重写过程可以手动触发和自动触发：</p><ul><li>手动触发：直接调用 <code>bgrewriteaof</code> 命令</li><li>自动触发：根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定自动触发时机<ul><li><code>auto-aof-rewrite-min-size</code>：表示运行 AOF 重写时文件最小体积，默认为 64MB</li><li><code>auto-aof-rewrite-percentage</code>：代表当前 AOF 文件空间（aof_current_size）和上一次重写后 AOF 文件空间（aof_base_size）的比值。</li><li>自动触发时机 = [<code>aof_current_size</code> &gt; <code>auto-aof-rewrite-min-size</code>] &amp;&amp; [(<code>aof_current_size</code> - <code>aof_base_size</code>) / <code>aof_base_size</code> &gt;= <code>auto-aof-rewrite-percentage</code>]</li></ul></li></ul><h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><ol><li>AOF 持久化开启且存在 AOF 文件时，优先加载 AOF 文件</li><li>AOF 关闭或者 AOF 文件不存在时，加载 RDB 文件</li><li>加载 AOF/RDB 文件成功后，Redis 启动成功</li><li>AOF/RDB 文件存在错误时，Redis 启动失败并打印错误信息</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB&quot; class=&quot;headerlink&quot; title=&quot;RDB&quot;&gt;&lt;/a&gt;RDB&lt;/h1&gt;&lt;p&gt;RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。&lt;/p&gt;
&lt;h2 id=&quot;触
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-04-客户端</title>
    <link href="https://yz1509.github.io//posts/85b8009b/"/>
    <id>https://yz1509.github.io//posts/85b8009b/</id>
    <published>2019-07-25T16:36:05.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端通信协议"><a href="#客户端通信协议" class="headerlink" title="客户端通信协议"></a>客户端通信协议</h1><ul><li>客户端与服务端之间的通信协议是在 TCP 协议之上构建的</li><li>Redis 制定了 RESP(REdis Serialization Protocol，Redis 序列化协议) 实现客户端与服务端的正常交互</li></ul><ol><li><p>发送命令格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt;CRLF</span><br><span class="line">$&lt;参数 <span class="number">1</span> 的字节数&gt;CRLF</span><br><span class="line">&lt;参数 <span class="number">1</span>&gt;CRLF</span><br><span class="line">···</span><br><span class="line">&lt;参数 N 的字节数&gt;CRLF</span><br><span class="line">&lt;参数 N&gt;CRLF</span><br></pre></td></tr></table></figure><p>注：CRLF 代表 “\r\n”</p></li><li><p>返回结果格式</p><ul><li>状态回复：在 RESP 中第一个字节为 “+”</li><li>错误回复：在 RESP 中第一个字节为 “-“</li><li>整数回复：在 RESP 中第一个字节为 “:”</li><li>字符串回复：在 RESP 中第一个字节为 “$”</li><li>多条字符串回复：在 RESP 中第一个字节为 “*”</li></ul></li></ol><h1 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h1><h2 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h2><ol><li><p>client list 命令能列出与 Redis 服务端相连的所有客户端连接信息</p><ul><li><p>标识：id、addr、fd、name</p><ul><li>id：客户端连接的唯一标识，这个 id 随着 Redis 的连接自增，重启 Redis 后会重置为 0</li><li>addr：客户端连接的 ip 和端口</li><li>fd：socket 的文件描述符，与 lsof 命令结果中的 fd 是同一个，如果 fd = -1 代表当前客户端不是外部客户端，而是 Redis 内部的伪装客户端</li><li>name：客户端的名字<ul><li>输入缓冲区：qbuf、qbuf-free</li></ul></li><li>qbuf 和 qbuf-free 分别代表这个缓冲区的总容量和剩余容量</li><li>输入缓冲区使用不当会产生两个问题<ul><li>一旦某个客户端的输入缓冲区超过1G，客户端将会被关闭</li><li>输入缓冲区不受 maxmemory 控制，一旦超过 maxmemory 限制，可能会产生数据丢失、键值淘汰、OOM 等情况</li></ul></li><li>监控输入缓冲区异常的两种方法<ul><li>通过定期执行 client list 命令，收集 qbuf 和 qbuf-free 找到异常的连接记录并分析，最终找到可能出问题的客户端</li><li>通过 info 命令的 info clients 模块，找到最大的输入缓冲区<ul><li>输出缓冲区：obl、ool、omem</li></ul></li></ul></li><li>输出缓冲区的容量可以通过参数 client-outputbuffer-limit 来进行设置</li><li>按照客户端的不同分为三种：普通客户端、发布订阅客户端、slave 客户端</li><li><p>配置规则</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;<span class="class"><span class="keyword">class</span>&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;class&gt;</code>：客户端类型，分为三种。1)normal：普通客户端；2)slave：slave客户端，用于复制；3)pubsub：发布订阅客户端</li><li><code>&lt;hard limit&gt;</code>：如果客户端使用的输出缓冲区大于 <code>&lt;hard limit&gt;</code>，客户端会被立即关闭</li><li><code>&lt;soft limit&gt;</code> 和 <code>&lt;soft seconds&gt;</code>：如果客户端使用的输出缓冲区超过了<code>&lt;soft limit&gt;</code> 并且持续了 <code>&lt;soft limit&gt;</code> 秒，客户端会被立即关闭</li></ul></li><li>输出缓冲区由两部分组成<ul><li>固定缓冲区：返回比较小的执行结果，使用字节数组实现</li><li>动态缓冲区：返回比较大的结果，使用列表实现</li><li>当固定缓冲区存满后会将 Redis 新的返回结果存放在动态缓冲区的队列中</li></ul></li><li>obl 代表固定缓冲区的长度，oll 代表动态缓冲区列表的长度，omem 代表使用的字节数</li><li>输出缓冲区不会受到 maxmemory 的限制，如果使用不当会造成 maxmemory 用满产生的数据丢失、键值淘汰、OOM 等情况。</li><li>两种监控输出缓冲区的方法<ul><li>通过定期执行 client list 命令，收集 obl、oll、omem 找到异常的连接记录并分析，最终找到可能出问题的客户端</li><li>通过 info 命令的 info clients 模块，找到输出缓冲区列表最大对象数</li></ul></li><li>输出缓冲区出现异常的概率比输入缓冲区大，主要预防方法：<ul><li>进行上述监控，设置阀值，超过阀值及时处理</li><li>限制普通客户端输出缓冲区</li><li>适当增大 slave 的输出缓冲区</li><li>限制容易让输出缓冲区增大的命令</li><li>及时监控内存，一旦发现内存抖动频繁，可能就是输出缓冲区过大<ul><li>客户端的存活状态：age、idle</li></ul></li></ul></li><li>age 代表当前客户端已经连接的时间</li><li>idle 代表当前客户端最近一次的空闲时间<ul><li>客户端的限制：maxclients、timeout</li></ul></li><li>maxclients 参数用来限制最大客户端连接数，一旦连接数超过maxclients，新的连接将被拒绝<ul><li>可以通过 <code>config set maxclients</code> 对最大客户端连接数进行动态设置</li></ul></li><li>timeout（单位为秒）参数来限制客户端连接的最大空闲时间，一旦客户端连接的 idle 时间超过了 timeout，客户端将会被关闭，如果设置为 0 就不进行检测<ul><li>客户端类型：flag</li></ul></li><li>11 种客户端类型<ul><li>其他</li></ul></li></ul></li></ul></li><li><p>client setName 和 client getName</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client setName xx    <span class="comment">//给当前客户端设置 name</span></span><br><span class="line">client getName       <span class="comment">//查看当前客户端的 name</span></span><br></pre></td></tr></table></figure></li><li><p>client kill</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client kill ip:port  <span class="comment">//杀掉指定 IP 地址和端口的客户端</span></span><br></pre></td></tr></table></figure></li><li><p>client pause</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client pause timeout <span class="comment">//单位：ms</span></span><br></pre></td></tr></table></figure><ul><li><code>client pause</code> 命令用于阻塞客户端 timeout 毫秒数，在此期间客户端连接将被阻塞</li><li><code>client pause</code> 只对普通和发布订阅客户端有效，对于主从复制（从节点内部伪装了一个客户端）是无效的，也就是此期间主从复制是正常进行的，所以此命令可以用来让主从复制保持一致</li><li><code>client pause</code> 可以用一种可控的方式将客户端连接从一个 Redis 节点切换到另一个Redis 节点</li></ul></li><li><p>monitor</p><ul><li><code>monitor</code> 命令用于监控 Redis 正在执行的命令</li><li><code>monitor</code> 能监听到所有的命令，一旦 Redis 的并发量过大，monitor 客户端的输出缓冲会暴涨，可能瞬间会占用大量内存</li></ul></li></ol><h2 id="客户端相关配置"><a href="#客户端相关配置" class="headerlink" title="客户端相关配置"></a>客户端相关配置</h2><ul><li><code>tcp-keepalive</code>：检测 TCP 连接活性的周期，默认值为 0，也就是不进行检测，如果需要设置，建议为 60（单位：s)</li><li><code>tcp-backlog</code>：TCP 三次握手后，会将接受的连接放入队列中，tcpbacklog 就是队列的大小，它在 Redis 中的默认值是511</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;客户端通信协议&quot;&gt;&lt;a href=&quot;#客户端通信协议&quot; class=&quot;headerlink&quot; title=&quot;客户端通信协议&quot;&gt;&lt;/a&gt;客户端通信协议&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;客户端与服务端之间的通信协议是在 TCP 协议之上构建的&lt;/li&gt;
&lt;li&gt;Redis 
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-03-独立功能</title>
    <link href="https://yz1509.github.io//posts/e7c5f62e/"/>
    <id>https://yz1509.github.io//posts/e7c5f62e/</id>
    <published>2019-07-25T16:35:42.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h1><p>慢查询日志：系统在命令执行前后计算每条命令的<strong>执行时间</strong>，当超过预设阀值，就将这条命令的相关信息（例如：发生时间，耗时，命令的详细信息）记录下来。</p><h2 id="慢查询的两个配置参数"><a href="#慢查询的两个配置参数" class="headerlink" title="慢查询的两个配置参数"></a>慢查询的两个配置参数</h2><ol><li>预设阈值：slowlog-log-slower-than<ul><li>slowlog-log-slower-than = 0：记录所有命令</li><li>slowlog-log-slower-than &lt; 0：对于任何命令都不会进行记录</li></ul></li><li>慢查询记录：slowlog-max-len（记录条数上限）</li></ol><h2 id="修改配置的方法"><a href="#修改配置的方法" class="headerlink" title="修改配置的方法"></a>修改配置的方法</h2><ul><li>修改配置文件</li><li>使用 <code>config set</code> 命令动态修改，还可使用 <code>config rewrite</code> 命令将配置持久化到本地配置文件</li></ul><h2 id="访问和管理慢查询日志"><a href="#访问和管理慢查询日志" class="headerlink" title="访问和管理慢查询日志"></a>访问和管理慢查询日志</h2><ol><li><p>获取慢查询日志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog get [n]</span><br></pre></td></tr></table></figure><p>慢查询日志由四部分组成</p><ul><li>标识 id</li><li>发生时间戳</li><li>命令耗时</li><li>执行命令及参数</li></ul></li><li><p>获取慢查询日志列表当前的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志重置（对列表做清理操作）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></li></ol><h2 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h2><ul><li>slowlog-max-len 配置建议：线上建议调大慢查询列表，记录慢查询时 Redis 会对长命令做截断操作，并不会占用大量内存。</li><li>slowlog-log-slower-than 配置建议：默认值超过 10 毫秒判定为慢查询，需要根据 Redis 并发量调整该值，对于高 OPS 场景的 Redis 建议设置为 1 毫秒。</li><li>慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。</li><li>可以定期执行 slow get 命令将慢查询日志持久化到其他存储中（例如 MySQL），然后可以制作可视化界面进行查询。</li></ul><h1 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h1><h2 id="redis-cli-详解"><a href="#redis-cli-详解" class="headerlink" title="redis-cli 详解"></a>redis-cli 详解</h2><ol><li><p><code>-r</code>：代表将命令执行多次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -r <span class="number">3</span> ping</span><br></pre></td></tr></table></figure></li><li><p><code>-i</code>：代表每隔几秒执行一次命令，但是 <code>-i</code> 选项必须和 <code>-r</code> 选项一起使用，<code>-i</code> 的单位是秒，不支持毫秒为单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -r <span class="number">5</span> -i <span class="number">1</span> ping</span><br></pre></td></tr></table></figure></li><li><p><code>-x</code>：代表从标准输入（stdin）读取数据作为 redis-cli 的最后一个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"wolrd"</span> | redis-cli -x <span class="built_in">set</span> hello</span><br></pre></td></tr></table></figure></li><li><p><code>-c</code>：是连接 Redis Cluster 节点时需要使用的，该选项可以防止 moved 和 ask 异常</p></li><li><code>-a</code>：如果 Redis 配置了密码，可以用 <code>-a</code>（auth）选项</li><li><code>--scan</code> 和 <code>--pattern</code>：用于扫描指定模式的键，相当于使用 scan 命令</li><li><p><code>--slave</code>: 把当前客户端模拟成当前 Redis 节点的从节点，可以用来获取当前 Redis 节点的更新操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redsi-cli --slave</span><br></pre></td></tr></table></figure></li><li><p><code>--rdb</code>：请求 Redis 实例生成并发送 RDB 持久化文件，保存在本地。</p></li><li><code>--pipe</code>：用于将命令封装成 Redis 通信协议定义的数据格式，批量发送给 Redis 执行</li><li><code>--bigkeys</code>：使用 scan 命令对 Redis 的键进行采样，从中找到内存占用比较大的键值，这些键可能是系统的瓶颈</li><li><code>--eval</code>：用于执行指定 Lua 脚本</li><li>检测网络延迟<ul><li><code>--latency</code>：测试客户端到目标 Redis 的网络延迟</li><li><code>--latency-history</code>：以分时段的形式了解延迟信息，可以通过 <code>-i</code> 参数控制间隔时间。</li><li><code>--latency-dist</code>：使用统计图表的形式从控制台输出延迟统计信息</li></ul></li><li><code>--stat</code>：可以实时获取 Redis 的重要统计信息</li><li><code>--raw</code>：要求命令的返回结果是格式化后的结果</li><li><code>--no-raw</code>：要求命令的返回结果必须是原始的格式</li></ol><h2 id="redis-server-详解"><a href="#redis-server-详解" class="headerlink" title="redis-server 详解"></a>redis-server 详解</h2><p>redis-server 除了启动 Redis 外，还有一个 <code>--test-memory</code> 选项。<code>redis-server --test-memory</code> 可以用来检测当前操作系统能否稳定地分配指定容量的内存给 Redis<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --test-memory <span class="number">1024</span>     <span class="comment">//单位 MB</span></span><br></pre></td></tr></table></figure></p><h2 id="redis-benchmark-详解"><a href="#redis-benchmark-详解" class="headerlink" title="redis-benchmark 详解"></a>redis-benchmark 详解</h2><p>redis-benchmark 可以为 Redis 做基准性能测试</p><ol><li><code>-c</code>(clients)：代表客户端的并发数量（默认是50）</li><li><code>-n &lt;requests&gt;</code>：代表客户端请求总量（默认是100000）</li><li><p><code>-q</code>：仅仅显示 redis-benchmark 的 requests per second 信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c <span class="number">100</span> -n <span class="number">20000</span> -q</span><br></pre></td></tr></table></figure></li><li><p><code>-r</code>：向 Redis 插入随机的键，<code>-r</code> 选项会在 key、counter 键上加一个 12 位的后缀，<code>-r 10000</code> 代表只对后四位做随机处理（<code>-r</code> 不是随机数的个数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c <span class="number">100</span> -n <span class="number">20000</span> -r <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p><code>-p</code>：代表每个请求 pipeline 的数据量（默认为1）</p></li><li><code>k &lt;boolean&gt;</code>：代表客户端是否使用 keepalive，1 为使用，0 为不使用，默认值为 1。</li><li><p><code>-t</code>：可以对指定命令进行基准测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -t get <span class="built_in">set</span> -q</span><br></pre></td></tr></table></figure></li><li><p><code>--csv</code>：将结果按照 csv 格式输出，便于后续处理，如导出到 Excel等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -t get,<span class="built_in">set</span> --csv</span><br></pre></td></tr></table></figure></li></ol><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><h2 id="Pipeline-概念"><a href="#Pipeline-概念" class="headerlink" title="Pipeline 概念"></a>Pipeline 概念</h2><p>Redis 客户端执行一条命令分为如下四个过程：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果<br>其中，1 + 4 称为往返时间(Round Trip Time, RTT)，Pipeline 可以将一组 Redis 命令进行组装，通过一次 RTT 传输给 Redis，再将这组 Redis 命令的执行结果按顺序返回给客户端，从而有效地节约 RTT。</li></ol><h2 id="原生批量命令与-Pipeline-对比"><a href="#原生批量命令与-Pipeline-对比" class="headerlink" title="原生批量命令与 Pipeline 对比"></a>原生批量命令与 Pipeline 对比</h2><ul><li>原生批量命令是原子的，Pipeline是非原子的</li><li>原生批量命令是一个命令对应多个 key，Pipeline 支持多个命令</li><li>原生批量命令是 Redis 服务端支持实现的，而 Pipeline 需要服务端和客户端的共同实现</li></ul><h1 id="事务与-Lua"><a href="#事务与-Lua" class="headerlink" title="事务与 Lua"></a>事务与 Lua</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到 multi 和 exec 两个命令之间。multi 命令代表事务开始，exec 命令代表事务结束，它们之间的命令是原子顺序执行的。</p><ul><li>如果要停止事务的执行，可以使用 discard 命令代替 exec 命令即可。</li><li>命令错误会造成整个事务无法执行</li><li>运行时错误可能让事务执行一部分，但 Redis 不支持回滚功能</li><li>有些应用场景需要在事务之前，确保事务中的 key 没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。Redis 提供了 watch 命令来解决这类问题，在执行 multi 之前执行watch 命令。</li></ul><h2 id="Lua-用法简述"><a href="#Lua-用法简述" class="headerlink" title="Lua 用法简述"></a>Lua 用法简述</h2><ol><li><p>数据类型及其逻辑处理</p><p> Lua 语言提供了如下几种数据类型：booleans（布尔）、numbers（数值）、strings（字符串）、tables（表格）</p><ul><li><p>字符串</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--local 代表 val 是一个局部变量，缺省则为全局变量</span></span><br><span class="line"><span class="keyword">local</span> strings val = <span class="string">"world"</span></span><br></pre></td></tr></table></figure></li><li><p>数组</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用 tables 类型实现类似数组的功能，下标从 1 开始</span></span><br><span class="line"><span class="keyword">local</span> tables myArray = &#123;<span class="string">"redis"</span>, <span class="string">"jedis"</span>, ture, <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="comment">--true</span></span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用 for 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray   <span class="comment">--获得 tables 的长度，变量名前加 #</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用内置函数 ipairs 遍历出所有的索引下标和值</span></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(myArray)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(index)</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--while 循环同样以 end 作为结束符</span></span><br><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> int i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        sum = sum + i</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum)    <span class="comment">--5050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--if 以 end 结尾，if 后紧跟 then</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> myArray[i] == <span class="string">"jedis"</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"true"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">--do nothing</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>哈希</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用 tables 类型实现类似哈希的功能</span></span><br><span class="line"><span class="keyword">local</span> tables user_1 = &#123;age = <span class="number">28</span>, name = <span class="string">"tome"</span>&#125;</span><br><span class="line"><span class="comment">--strings1 .. strings2：字符串连接</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"user_1 age is "</span> .. user_1[<span class="string">"age"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用内置函数 pairs 遍历 user_1</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(user_1)</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">print</span>(key .. value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数定义</p><p> 在 Lua 中，函数以 function 开头，以 end 结尾，funcName 是函数名，中间部分是函数体。</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis-与-Lua"><a href="#Redis-与-Lua" class="headerlink" title="Redis 与 Lua"></a>Redis 与 Lua</h2><ol><li><p>在 Redis 中执行 Lua 脚本有两种方法：eval 和 evalsha</p><ul><li><p>eval</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--命令格式</span></span><br><span class="line">eval script numkeys key [key ...] <span class="built_in">arg</span> [<span class="built_in">arg</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">--"hello redisworld"</span></span><br><span class="line">eval <span class="string">'return "hello " .. KEYS[1] .. ARGV[1]'</span> <span class="number">1</span> redis world</span><br></pre></td></tr></table></figure><p>如果 Lua 脚本较长，还可以使用 <code>redis-cli --eval</code> 直接执行文件。</p></li><li>evalsha<ul><li>首先将 Lua 脚本加载到 Redis 服务端，得到该脚本的 SHA1 校验和</li><li>evalsha 命令使用 SHA1 作为参数可以直接执行对应 Lua 脚本，避免每次发送 Lua 脚本的开销<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载脚本：script load 命令可以将脚本内容加载到 Redis 内存中</span></span><br><span class="line">redis-cli script load <span class="string">"$(cat lua_get.lua)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行脚本</span></span><br><span class="line">evalsha sha1 numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Lua 的 Redis API</p><ul><li>Lua 可以使用 Redis.call 和 Redis.pcall 函数实现对 Redis 的访问<ul><li>如果 Redis.call 执行失败，那么脚本执行结束会直接返回错误</li><li>Redis.pcall 则会忽略错误继续执行脚本</li></ul></li><li>Lua 可以使用 redis.log 函数将 Lua 脚本的日志输出到 Redis 的日志文件中，但是一定要控制日志级别</li></ul></li><li><p>Redis 管理 Lua 脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">script load script   <span class="comment">//用于将 Lua 脚本加载到 Redis 内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用于判断 sha1 是否已经加载到 Redis 内存中</span></span><br><span class="line"><span class="comment">  * 返回结果代表 sha1 [sha1…] 被加载到 Redis 内存的个数</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">script exists sha1 [sha1 ...] </span><br><span class="line"></span><br><span class="line">script flush     <span class="comment">//用于清除 Redis 内存已经加载的所有 Lua 脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用于杀掉正在执行的 Lua 脚本</span></span><br><span class="line"><span class="comment">  * 如果当前 Lua 脚本正在执行写操作，那么 script kill 将不会生效</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">script kill</span><br></pre></td></tr></table></figure></li></ol><h1 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h1><p>Bitmaps：以 bit 为单位的数组，可以实现对 bit 的操作，实际上为字符串。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p>设置值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value  <span class="comment">//offset 从 0 开始</span></span><br></pre></td></tr></table></figure></li><li><p>获取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset    <span class="comment">//返回 0 也有可能是该 offset 位并不存在</span></span><br></pre></td></tr></table></figure></li><li><p>获取 Bitmaps 指定范围中值为 1 的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start] [end]   <span class="comment">//start 和 end 的单位是**字节**</span></span><br></pre></td></tr></table></figure></li><li><p>Bitmaps 间的运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop operation destkey key [key ...]    <span class="comment">//and(交)、or(并)、not(非)、xor(异或)</span></span><br></pre></td></tr></table></figure></li><li><p>计算 Bitmaps 中第一个值为 targetBit 的偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   bitpos key targetBit [start] [end]   <span class="comment">//start 和 end 的单位是**字节**</span></span><br><span class="line">   ``` </span><br><span class="line"></span><br><span class="line"># HyperLogLog</span><br><span class="line"></span><br><span class="line">* 通过 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等</span><br><span class="line">* HyperLogLog 提供了 <span class="number">3</span> 个命令：pfadd、pfcount、pfmerge</span><br><span class="line">  ```c</span><br><span class="line">  pfadd key element [element ...]   <span class="comment">//用于向 HyperLogLog 添加元素，如果添加成功返回 1</span></span><br><span class="line"></span><br><span class="line">  pfcount key [key ...]     <span class="comment">//用于计算一个或多个 HyperLogLog 的独立总数</span></span><br><span class="line"></span><br><span class="line">  pfmerge destkey sourcekey [sourcekey ...]     <span class="comment">//求出多个 HyperLogLog 的并集并赋值给 destkey</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>HyperLogLog 内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条即可：<ul><li>只为了计算独立总数，不需要获取单条数据</li><li>可以容忍一定误差率</li></ul></li></ul><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis 提供了基于“发布/订阅”模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消息，订阅该频道的每个客户端都可以收到该消息。</p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><ol><li><p>发布消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure></li><li><p>订阅消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel ...]</span><br></pre></td></tr></table></figure><ul><li>客户端在执行订阅命令之后进入了订阅状态，只能接收 subscribe、psubscribe、unsubscribe、punsubscribe 的四个命令。</li><li>新开启的订阅客户端，无法收到该频道之前的消息，因为 Redis 不会对发布的消息进行持久化。</li></ul></li><li><p>取消订阅</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe [channel [channel ...]]</span><br></pre></td></tr></table></figure></li><li><p>按照模式订阅和取消订阅</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psubscribe pattern [pattern ...]</span><br><span class="line">punsubscribe [pattern [pattern ...]]</span><br></pre></td></tr></table></figure></li><li><p>查询订阅</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubsub channels [pattern]    <span class="comment">//查看活跃的频道</span></span><br><span class="line">pubsub numsub [channel ...]  <span class="comment">//查看频道订阅数</span></span><br><span class="line">pubsub numpat        <span class="comment">//查看模式订阅数</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><p>GEO（地理信息定位）功能，支持存储地理位置信息。</p><ol><li><p>增加地理位置信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude layitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><ul><li>返回结果代表添加成功的个数</li><li>如 member 已存在，则返回 0，更新地理位置信息返回结果依然为 0</li></ul></li><li><p>获取地理位置信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure></li><li><p>获取两个地理位置之间的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><p>其中 unit 代表返回结果的单位，包含四种：m(米)、km(公里)、mi(英里)、ft(尺)</p></li><li><p>获取指定位置范围内的地理信息位置集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radiusm | km | ft | mi [withcoord] [withdist] [withhash] [COUNT count] [asc | desc] [store key] [storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm | km | ft | mi [withcoord] [withdist] [withhash] [COUNT count] [asc | desc] [store key] [storedist key]</span><br></pre></td></tr></table></figure><ul><li>radiusm | km | ft | mi：必需参数，指定了半径（带单位）</li><li>withcoord：返回结果中包含经纬度</li><li>withdist：返回结果中包含离中心节点位置的距离</li><li>withhash：返回结果中包含 geohash</li><li>COUNT count：指定返回结果的数量</li><li>asc | desc：返回结果按照离中心节点的距离做升序或者降序</li><li>store key：将返回结果的地理位置信息保存到指定键</li><li>storedist key：将返回结果离中心节点的距离保存到指定键</li></ul></li><li><p>获取 geohash</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure><p>Redis 使用 geohash 将二维经纬度转换为一维字符串，geohash 有如下特点：</p><ul><li>GEO 的数据类型为zset，Redis 将所有地理位置信息的 geohash 存放在 zset 中</li><li>字符串越长，表示的位置更精确</li><li>两个字符串越相似，它们之间的距离越近，Redis 利用字符串前缀匹配算法实现相关的命令</li><li>geohash 编码和经纬度是可以相互转换的</li></ul></li><li><p>删除地理位置信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;慢查询分析&quot;&gt;&lt;a href=&quot;#慢查询分析&quot; class=&quot;headerlink&quot; title=&quot;慢查询分析&quot;&gt;&lt;/a&gt;慢查询分析&lt;/h1&gt;&lt;p&gt;慢查询日志：系统在命令执行前后计算每条命令的&lt;strong&gt;执行时间&lt;/strong&gt;，当超过预设阀值，就将这条命令
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-02-API介绍</title>
    <link href="https://yz1509.github.io//posts/6036d77e/"/>
    <id>https://yz1509.github.io//posts/6036d77e/</id>
    <published>2019-07-25T16:35:24.000Z</published>
    <updated>2019-07-26T15:46:57.429Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令与参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://redisdoc.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis命令与参考&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis:01-初识Redis</title>
    <link href="https://yz1509.github.io//posts/dc21cdf4/"/>
    <id>https://yz1509.github.io//posts/dc21cdf4/</id>
    <published>2019-07-25T16:29:47.000Z</published>
    <updated>2019-07-25T17:00:32.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h1><ol><li>速度快<ul><li>Redis 的所有数据都是存放在内存中</li><li>Redis 是用 C 语言实现</li><li>Redis 使用了单线程架构</li><li>Redis 源码性能佳</li></ul></li><li>基于键值对的数据结构服务器</li><li>功能丰富<ul><li>提供了键过期功能，可以用来实现缓存</li><li>提供了发布订阅功能，可以用来实现消息系统</li><li>支持 Lua 脚本功能，可以利用 Lua 创造出新的 Redis 命令</li><li>提供了简单的事务功能，能在一定程度上保证事务特性</li><li>提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到<br>Redis，减少了网络的开销。</li></ul></li><li>简单稳定</li><li>客户端语言多</li><li>持久化</li><li>主从复制</li><li>高可用和分布式</li></ol><h1 id="Redis-可以用来作什么"><a href="#Redis-可以用来作什么" class="headerlink" title="Redis 可以用来作什么"></a>Redis 可以用来作什么</h1><ul><li>缓存</li><li>排行榜系统</li><li>计数器应用</li><li>社交网络</li><li>消息队列系统</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-特性&quot;&gt;&lt;a href=&quot;#Redis-特性&quot; class=&quot;headerlink&quot; title=&quot;Redis 特性&quot;&gt;&lt;/a&gt;Redis 特性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;速度快&lt;ul&gt;
&lt;li&gt;Redis 的所有数据都是存放在内存中&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>gflags</title>
    <link href="https://yz1509.github.io//posts/691428e6/"/>
    <id>https://yz1509.github.io//posts/691428e6/</id>
    <published>2019-07-23T15:55:45.000Z</published>
    <updated>2019-07-23T16:02:22.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>Commandline flags</strong> are flags that users specify on the command line when they run an executable.</p><p>eg: In the command <code>fgrep -l -f /var/tmp/foo johanners brahms</code></p><ul><li><code>-i</code> and <code>-f /var/tmp/foo</code> are two <em>commandline flags</em></li><li><code>johannes</code> and <code>brahms</code>, which don’t start with a dash,are <em>commandline arguments</em></li></ul><h1 id="DEFINE-Defining-Flags-In-Program"><a href="#DEFINE-Defining-Flags-In-Program" class="headerlink" title="DEFINE: Defining Flags In Program"></a>DEFINE: Defining Flags In Program</h1><p>Defining a flag is easy: just use the appropriate macro for the type you want the flag to be, as defined at the bottom of <code>gflags/gflags.h</code>, Heres an example file <code>foo.cc</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DEFINE_bool(big_menu, <span class="literal">true</span>, <span class="string">"Include 'advanced' options in the menu listing"</span>);</span><br><span class="line">DEFINE_string(languages, <span class="string">"english, french, german"</span>, <span class="string">"comma-separated list of languages to offer in the 'lang' menu"</span>);</span><br></pre></td></tr></table></figure><p>Here are the types supported:</p><ul><li><code>DEFINE_bool</code>: boolean</li><li><code>DEFINE_int32</code>: 32-bit integer</li><li><code>DEFINE_int64</code>: 64-bit integer</li><li><code>DEFINE_uint64</code>: unsigned 64-bit integer</li><li><code>DEFINE_double</code>: double</li><li><code>DEFINE_string</code>: C++ string</li></ul><p>All DEFINE macros take the same three argument:</p><ul><li>the name of the flag</li><li>its default value</li><li>a ‘help’ string that describes its use, the ‘help’ string is displayed when the users runs the application with the <code>--help flag</code></li></ul><p>You can define a flag in any soucre-code file in your executable. Only define a flag once! If you want to access a falg in more than one source file, DEFINE it in one file, and DECLARE it in the others. Even better, DEFINE it in <code>foo.cc</code> and DECLARE it in <code>foo.h</code>; then everyone who <code>#include &quot;foo.h&quot;</code> can use the flag.</p><h1 id="Accessing-the-Flag"><a href="#Accessing-the-Flag" class="headerlink" title="Accessing the Flag"></a>Accessing the Flag</h1><p>All defined flags are available to the program as just a normal variable, with the prefix <code>FLAGS_</code> prepended. You can read and write to the flag just like any other variable:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FLAGS_consider_made_up_language)</span><br><span class="line">    FLAGS_languages += <span class="string">",klingon"</span>;      <span class="comment">// implied by --consider_made_up_languages</span></span><br><span class="line"><span class="keyword">if</span>(FLAGS_languages.find(<span class="string">"finnish"</span>) != <span class="built_in">string</span>::npos)</span><br><span class="line">    HandleFinnish();</span><br></pre></td></tr></table></figure><p>You can also get and set flag values via special functions in <code>gflags.h</code>. That’s a rarer use case, though.</p><h1 id="DECLARE-Using-the-Flag-in-a-DIfferent-File"><a href="#DECLARE-Using-the-Flag-in-a-DIfferent-File" class="headerlink" title="DECLARE: Using the Flag in a DIfferent File"></a>DECLARE: Using the Flag in a DIfferent File</h1><p>The <code>DECLARE_type</code> macro is available when you want to use a flag that’s defined in another file. For instance, if I were writing <code>bar.cc</code> but wanted to access the <code>big_menu</code> flag, I would put this near the top of <code>bar.cc</code>: </p><p><code>DECLARE_bool(big_menu);</code></p><p>This id functionally equivalent to saying <code>extern FLAGS_big_menu</code>.</p><p>Note that such an extern declaration introduces a dependency between your file and the file that defines the <code>big_menu</code> flag: <code>foo.cc</code>, in this case, such implicit dependencies can be difficult to manage in large projects. For that reason we recommend the following guideline:</p><p><em>If you DEFINE a flag in <code>foo.cc</code>, either don’t DECLARE it at all, only DECLARE it in tightly related tests, or only DECLARE it in <code>foo.h</code></em>.</p><h1 id="RegisterFlagValidator-Sanity-checking-Flag-Values"><a href="#RegisterFlagValidator-Sanity-checking-Flag-Values" class="headerlink" title="RegisterFlagValidator: Sanity-checking Flag Values"></a>RegisterFlagValidator: Sanity-checking Flag Values</h1><p>After DEFINE-ing a flag, you may optionally register a validator function with the flag.</p><ul><li>If you do this, after the flag is parsed from the commandline, and whenever its value is changed via a call to <code>SetCommanfLineOption()</code>, the validator function is called with the new value as an argument.</li><li>If the function returns false for the new setting of the flag, the flag will retain its current value.</li><li>If it returns false for the default value, ParseCommandLineFlags will die</li></ul><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ValidatePort</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * flagname, int32 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span> &amp;&amp; value &lt; <span class="number">32768</span>)     <span class="comment">// value is ok</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Invalid value for - %s : %d\n"</span>, flagname, (<span class="keyword">int</span>)value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_int32(port, <span class="number">0</span>, <span class="string">"What port to listen on"</span>);</span><br><span class="line">DEFINE_validator(port, &amp;ValidatePort);</span><br></pre></td></tr></table></figure><p>By doing the registration at global initialization time (right after the DEFINE_int32), we ensure that the registration happens before the commandline is parsed at the beginning of <code>main()</code>.</p><p>The above used <code>DEFINE_validator</code> macro calls the <code>RegisterFlagValidator()</code> function which returns true if the registration is successful. It returns false if the registration fails because:</p><ul><li>the first argument does noe refer to a commandline flag</li><li>a different validator has already been registered for this flag</li></ul><p>The return value is available as global static boolean variable named <code>&lt;flag&gt;_validator_registered</code>.</p><h1 id="Putting-It-TOgether-How-to-Set-Up-Flags"><a href="#Putting-It-TOgether-How-to-Set-Up-Flags" class="headerlink" title="Putting It TOgether: How to Set Up Flags"></a>Putting It TOgether: How to Set Up Flags</h1><p>The final piece is the one that tells the executable to process the commandline flags, and set the <code>FLAG_*</code> variables to the appropriate, non-default value on what is seen on the commandline. In fact, it’s just a single function call:</p><p><code>gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</code></p><p> Usually, this code is at the beginning of  <code>main()</code>. <code>argc</code> and <code>argv</code> are exactly as passed in to <code>main()</code>.</p><p> The last argument is called “remove_flag”:</p><ul><li>If true, then <code>ParseCommandLineFlags</code> removes the flags and their arguments from <code>argv</code>, and modifies <code>argc</code> appropriately. In this case, after the function call, <code>argv</code> will hold only commandline arguments, and noe commandline flags</li><li>If false, then <code>ParseCommandLineFlags</code> will leave argc unchanged, but will rearrange the arguments in argv so that the flags are all at the beginning. In this case, <code>ParseCommandLineFlags</code> returns the index into argv that holds the first commandline argument: that is, the index past the last flag. eg:<ul><li>input : <code>/bin/foo</code>, <code>arg1</code>, <code>-q</code>, <code>arg2</code></li><li>after rearange : <code>/bin/foo</code>, <code>-q</code>, <code>arg1</code>, <code>arg2</code></li><li>return : 2  </li></ul></li></ul><h1 id="Setting-Flags-on-the-Command-Line"><a href="#Setting-Flags-on-the-Command-Line" class="headerlink" title="Setting Flags on the Command Line"></a>Setting Flags on the Command Line</h1><p>The reason you make something a flag instead of a compile-time constant, is so users can specify  a non-default value on the commandline.</p><p>We recommend using only a single form:</p><ul><li><code>--variable = value</code> for non-boolean flags</li><li><code>--variable / --novariable</code> for boolean flags</li></ul><p>Example:</p><p><code>app_containning_foo --nobig_menu --languages = &quot;chinese, japanses, korean&quot;</code></p><p>This sets <code>FLAGS_big_menu = false</code>; and <code>FLAGS_languages = &quot;chinese, japanese, korean&quot;</code>, when <code>ParseCommandLineFlags</code> is run.</p><p>It is a fatal error to specify a flag on the commandline that has not been DEFINED somewhere in the executable.</p><h1 id="Changing-the-Default-Flag-Value"><a href="#Changing-the-Default-Flag-Value" class="headerlink" title="Changing the Default Flag Value"></a>Changing the Default Flag Value</h1><p>Sometimes a flag is defined in a library, and you want to change its default value in one application but not others. It’s simple to do this: just assign a new value th the flag in <code>main()</code> before calling <code>ParseCommandLineFlags()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_bool(lib_verbose)   <span class="comment">// mylib has a lib_verbose flag, default is false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FLAGS_lib_verbose = <span class="literal">true</span>;   <span class="comment">// in my app, i want a lib_verbose = true by default</span></span><br><span class="line">    ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Special-Flags"><a href="#Special-Flags" class="headerlink" title="Special Flags"></a>Special Flags</h1><p>There ara a few flags defined by the commandlineflags module itself, and are available to all applications that use commandlineflags. There fall into three categories:</p><ol><li>reporting flags, when found, cause the application to print some information about itself and exit:<ul><li><code>--help</code>: shows all flags from all files, sorted by file and then by name; shows the flagname, its default value, and its help string</li><li><code>--helpfull</code>: same as <code>--help</code>, but unambiguously asks for all flags (in case <code>--help</code> changes in the future)</li><li><code>--helpshort</code>: shows only flags for the file with the same name as the executable (usually the one containing <code>main()</code>)</li><li><code>--helpxml</code>: like <code>--help</code>, but output is in xml for easier parsing</li><li><code>--heplon=FILE</code>: shows only flags defined in FILE.*</li><li><code>--helpmatch=S</code>: shows only flags defined in *S*.*</li><li><code>--helppackage</code>: shows flags defined in files in same directory as <code>main()</code></li><li><code>--version</code>: prints version info for the executable</li></ul></li><li>the flags affect how other flags are parsed<ul><li><code>--undefok=flagname,flagname,...</code><br> for those names listed as the argument to <code>--undefok</code>, suppress the normal error-exit that occurs when <code>--name</code> is seen on the commandline, but <code>name</code> has not been DEFINED anywhere in the application</li></ul></li><li>recursive flags, that cause other flag values to be set<ul><li><code>--fromenv</code></li><li><code>--tryfromenv</code></li><li><code>--flagfile</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Commandline flags&lt;/str
      
    
    </summary>
    
      <category term="后端技术栈" scheme="https://yz1509.github.io/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="gflags" scheme="https://yz1509.github.io/tags/gflags/"/>
    
  </entry>
  
  <entry>
    <title>后台开发面经</title>
    <link href="https://yz1509.github.io//posts/afaab92b/"/>
    <id>https://yz1509.github.io//posts/afaab92b/</id>
    <published>2018-08-28T03:01:15.000Z</published>
    <updated>2019-07-23T15:45:59.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="virtual-关键字的作用、构造和析构函数能不能定义虚函数？为什么？"><a href="#virtual-关键字的作用、构造和析构函数能不能定义虚函数？为什么？" class="headerlink" title="virtual 关键字的作用、构造和析构函数能不能定义虚函数？为什么？"></a>virtual 关键字的作用、构造和析构函数能不能定义虚函数？为什么？</h2><p>基类希望其派生类覆盖的函数，通常将其定义为虚函数，通过指针或引用调用虚函数时，会在运行时解析该调用，在这种情况下对象的动态类型有可能与静态类型不同。这便是 OOP 的核心思想：多态性。</p><p>构造函数不能为虚函数，而析构函数可以且常常是虚函数。</p><p>首先，虚函数的实现原理是：在定义具有虚函数的类或者继承类的继承的时候，会相应建立一个虚函数表 vtable，即每个类都对应一个虚函数表，而在定义类的对象的时候，每个对象都会有一个指向相应类的虚表指针 vptr，vptr 指向虚表的入口地址，在调用相应的虚函数的时候，根据该入口地址寻找对应的函数。</p><p>对于构造函数，其作用是在对象实例化的时候自动调用，对该对象进行初始化操作。前述中提到，虚函数是通过 vptr 来调用的，而调用构造函数的时候实例化并未完成，也就是说此时并不存在vptr，因而，无法使用 vptr 来调用构造函数。</p><p>另一方面，虚函数的调用是虚调用，通过在运行时查询虚函数表得到具体函数入口地址，相当于只需要有部分信息就可以调用该函数。然而定义具体类的对象的时候，需要明确指定对象类型，而且在定义子类对象的时候首先调用的是父类的构造函数然后才是调用子类构造函数，如果使用了虚函数，那么仅仅是调用子类构造函数并不能完成对象的初始化。</p><p>而对于析构函数，则需要定义为虚析构函数，防止内存泄露的发生。在继承的时候， 我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p><h2 id="static-关键字修饰类的成员作用，和其他成员函数的区别？"><a href="#static-关键字修饰类的成员作用，和其他成员函数的区别？" class="headerlink" title="static 关键字修饰类的成员作用，和其他成员函数的区别？"></a>static 关键字修饰类的成员作用，和其他成员函数的区别？</h2><p>当使用 static 修饰成员变量和成员函数时，表示该变量或函数属于一个类，而不是该类的某个实例化对象。</p><h2 id="C-调用-C-的关键字-extern-的作用？"><a href="#C-调用-C-的关键字-extern-的作用？" class="headerlink" title="C++ 调用 C 的关键字 extern 的作用？"></a>C++ 调用 C 的关键字 extern 的作用？</h2><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。也就是说extern有两个作用，</p><ul><li>第一，当它与 “C” 一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code> 则告诉编译器在编译 fun 这个函数名时按着 C 的规则去翻译相应的函数名而不是 C++ 的，C++ 的规则在翻译这个函数名时会把 fun 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，为什么这么做呢，因为 C++ 支持函数的重载。</li><li>第二，当 extern 不与 “C” 在一起修饰变量或函数时，如在头文件中: <code>extern int g_Int;</code> 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义！也就是说 B 模块(编译单元)要是引用模块(编译单元) A 中定义的全局变量或函数时，它只要包含 A 模块的头文件即可。在编译阶段，模块 B 虽然找不到该函数或变量，但它不会报错，它会在连接时从模块 A 生成的目标代码中找到此函数。</li></ul><h2 id="map-和-unodered-map-的区别，底层的实现"><a href="#map-和-unodered-map-的区别，底层的实现" class="headerlink" title="map 和 unodered_map 的区别，底层的实现"></a>map 和 unodered_map 的区别，底层的实现</h2><ul><li>map：自动排序，底层数据结构为红黑树。</li><li>unoredered_map：乱序，底层数据结构为哈希表（开链法解决哈希冲突）。<ul><li>用一个 vector 来作为一个指针数组来存储节点的指针，_size 来保存当前哈希表中的有效元素个数。</li><li>由于是 K/V 结构，所以选择一个 pair 的结构来存储 K/V。</li><li>vector 中的每一个元素都指向一个链表，所有节点中需要一个 next 域的指针来指向下一个节点（采用单链表表结构）。</li><li>采用模板来实现哈希表可以存储任意数据类型的目的。</li><li>使用了仿函数技术。</li></ul></li></ul><h2 id="哈希冲突如何解决"><a href="#哈希冲突如何解决" class="headerlink" title="哈希冲突如何解决"></a>哈希冲突如何解决</h2><ul><li>开放定址法<ul><li>线性探测再散列</li><li>二次探测再散列</li><li>伪随机探测再散列：增量序列伪随机</li></ul></li><li>再哈希法：同时构造多个不同的哈希函数</li><li>开链（哈希桶）</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ul><h2 id="C-的重载"><a href="#C-的重载" class="headerlink" title="C++ 的重载"></a>C++ 的重载</h2><ul><li>函数名字相同但形参列表不同，称之为函数重载(overloaded)</li><li>main 函数不能重载</li><li>顶层 const 的形参和另一个没有顶层 const 不能区分，底层 const 则相反</li></ul><h2 id="C-程序的编译过程"><a href="#C-程序的编译过程" class="headerlink" title="C 程序的编译过程"></a>C 程序的编译过程</h2><p><img src="/posts/afaab92b/GCC_CompilationProcess.png" alt="编译过程"></p><ol><li>预处理(Preprocessing)：预处理用于将所有的 #include 头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。</li><li>编译(Compilation)：这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码 (assembly code) 的过程。</li><li>汇编(Assemble)：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。</li><li>链接(Linking)：符号解析和重定位，将程序每一个全局变量和全局函数的引用和符号表里的一个符号对应起来，重定位确定每一个模板模块的全局变量和函数在可执行文件内存空间的位置，将多个目标文以及所需的库文件 (.so等) 链接成最终的可执行文件 (executable file)。</li></ol><h2 id="C-程序的内存空间"><a href="#C-程序的内存空间" class="headerlink" title="C 程序的内存空间"></a>C 程序的内存空间</h2><p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。</p><p><img src="/posts/afaab92b/001.png" alt="内存分布"></p><ul><li>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</li><li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局 const 变量等。</li><li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li><li>BSS 段(.bss)：未初始化的全局变量和局部静态变量一般放在 .bss 的段里，以节省内存空间。</li><li>堆：用来容纳应用程序动态分配的内存区域。当程序使用 malloc 或 new 分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li><li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li><li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li><li>保留区：内存中受到保护而禁止访问的内存区域。</li></ul><h2 id="malloc-free-与-new-delete-的区别"><a href="#malloc-free-与-new-delete-的区别" class="headerlink" title="malloc/free 与 new/delete 的区别"></a>malloc/free 与 new/delete 的区别</h2><ul><li>malloc 与 free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请和释放动态内存。</li><li>对于非内部数据类型的对象而言，用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free，因此C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，和一个能完成清理与释放内存工作的运算符 delete。</li><li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void* 指针。new/delete 在实现上其实调用了 malloc/free 函数。</li><li>new 建立的是一个对象；malloc 分配的是一块内存。</li></ul><h2 id="析构函数的作用"><a href="#析构函数的作用" class="headerlink" title="析构函数的作用"></a>析构函数的作用</h2><p>释放对象使用的资源，并销毁非 static 成员。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ol><li>申请管理方式<ul><li>栈：由编译器自动管理，无需我们手工控制。</li><li>堆：堆的申请和释放工作由程序员控制，容易产生内存泄漏。</li></ul></li><li>申请后系统的响应<ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li>申请大小的限制<ul><li>栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 1 M（可修改），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li>申请效率的比较<ul><li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li><li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在 Windows 下，最好的方式是用 VirtualAlloc 分配内存，它不是在堆，也不是在栈而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li></ul></li><li>堆与栈中的存储内容<ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li></ul></li></ol><p><strong>总结</strong>：堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；并且可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，ebp 和局部变量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是向堆申请内存更加灵活，有时候分配大量的内存空间，还是用堆好一些。</p><h2 id="重载-new-运算符：什么时候需要重载"><a href="#重载-new-运算符：什么时候需要重载" class="headerlink" title="重载 new 运算符：什么时候需要重载"></a>重载 new 运算符：什么时候需要重载</h2><ul><li>为了检测运用上的错误</li><li>为了收集动态分配内存的使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><hr><ul><li>lambda 的实质（编译器层面）</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="大端小端的区别、应用以及如何判断大端小端？"><a href="#大端小端的区别、应用以及如何判断大端小端？" class="headerlink" title="大端小端的区别、应用以及如何判断大端小端？"></a>大端小端的区别、应用以及如何判断大端小端？</h2><p><code>低地址 --------------------&gt; 高地址</code><br><code>0x12  |  0x34  |  0x56  |  0x78</code></p><ul><li>大端模式：Big-Endian 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</li></ul><p><code>低地址 --------------------&gt; 高地址</code><br><code>0x78  |  0x56  |  0x34  |  0x12</code></p><ul><li>小端模式：Little-Endian 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li></ul><p><strong>区别</strong>：大端小端没有谁优谁劣，各自优势便是对方劣势</p><ul><li>大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</li><li>小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。</li></ul><p><strong>应用</strong>：一般操作系统都是小端，而通讯协议是大端的。</p><ul><li><p>常见 CPU 的字节序</p><ul><li>Big Endian : PowerPC、IBM、Sun</li><li>Little Endian : x86、DEC</li><li>ARM既可以工作在大端模式，也可以工作在小端模式。</li></ul></li><li><p>常见文件的字节序</p><ul><li>Big Endian：Adobe PS、JPEG、MacPaint</li><li>Little Endian：BMP、GIF、RTF</li></ul></li></ul><p><strong>判断</strong></p><ul><li>通过将 int 强制类型转换成 char 单字节，通过判断起始存储位置</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">char</span> b = *(<span class="keyword">char</span> *)&amp;a;  <span class="comment">//等于 取b等于a的低地址部分  </span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>联合体 union 的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了 CPU 对内存采用 Little-endian 还是 Big-endian 模式读写</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> NUM</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">    &#125;num;</span><br><span class="line">    num.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">if</span> (num.b == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>进程是资源分配的基本单位；线程是独立调度的基本单位。</p><p><strong>区别</strong></p><p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p><h2 id="一个进程有-10-个线程，如果-down-掉一个线程会不会对其他的有影响？"><a href="#一个进程有-10-个线程，如果-down-掉一个线程会不会对其他的有影响？" class="headerlink" title="一个进程有 10 个线程，如果 down 掉一个线程会不会对其他的有影响？"></a>一个进程有 10 个线程，如果 down 掉一个线程会不会对其他的有影响？</h2><p>有！因为线程没有自己单独的内存地址空间，所以一个线程挂掉会导致整个进程挂掉。</p><h2 id="什么情况下会发生死锁，解决策略有哪些？"><a href="#什么情况下会发生死锁，解决策略有哪些？" class="headerlink" title="什么情况下会发生死锁，解决策略有哪些？"></a>什么情况下会发生死锁，解决策略有哪些？</h2><p><strong>死锁的必要条件</strong></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><p><strong>解决策略</strong></p><ul><li>鸵鸟策略：忽略它。</li><li>死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。三种恢复手段：<ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul></li><li>死锁预防：在程序运行之前预防发生死锁。<ul><li>破坏互斥条件</li><li>破坏占有和等待条件</li><li>破坏不可抢占条件</li><li>破坏环路等待</li></ul></li><li>死锁避免：在程序运行时避免发生死锁。</li></ul><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><ul><li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。只能受限的访问内存, 且不允许访问外围设备. 占用 CPU 的能力被剥夺, CPU 资源可以被其他程序获取</li><li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。CPU 可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU 也可以将自己从一个程序切换到另一个程序</li></ul><p><strong>用户态切换为内核态的三种情况</strong></p><ol><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断。</li><li>异常事件： 当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li><li>外围设备的中断：当外围设备完成用户的请求操作后，会向 CPU 发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li></ol><p>从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h2 id="执行一个系统调用时，OS-发生的过程，越详细越好"><a href="#执行一个系统调用时，OS-发生的过程，越详细越好" class="headerlink" title="执行一个系统调用时，OS 发生的过程，越详细越好"></a>执行一个系统调用时，OS 发生的过程，越详细越好</h2><p>系统调用, 在 CPU 中的实现称之为陷阱指令 (Trap Instruction)，工作流程如下:</p><ol><li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.</li><li>用户态程序执行陷阱指令</li><li>CPU 切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li><li>这些指令称之为陷阱 (trap) 或者系统调用处理器 (system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li><li>系统调用完成后, 操作系统会重置 CPU 为用户态并返回系统调用的结果</li></ol><h2 id="执行一个-IO-调用读-写文件，到把数据写进磁盘发生的所有过程，越详细越好"><a href="#执行一个-IO-调用读-写文件，到把数据写进磁盘发生的所有过程，越详细越好" class="headerlink" title="执行一个 IO 调用读/写文件，到把数据写进磁盘发生的所有过程，越详细越好"></a>执行一个 IO 调用读/写文件，到把数据写进磁盘发生的所有过程，越详细越好</h2><p><strong>读文件</strong></p><ol><li>进程调用库函数向内核发起读文件请求；</li><li>内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</li><li>调用该文件可用的系统调用函数 read()</li><li>read() 函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的 inode；</li><li>在 inode 中，通过文件内容偏移量计算出要读取的页；</li><li>通过 inode 找到文件对应的 address_space；</li><li>在 address_space 中访问该文件的页缓存树，查找对应的页缓存结点：<ul><li>如果页缓存命中，那么直接返回文件内容；</li><li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode 找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第 7 步查找页缓存；</li></ul></li><li>文件内容读取成功。</li></ol><p><strong>写文件</strong></p><p>前 6 步和读文件一致，在 address_space 中查询对应页的页缓存是否存在：</p><ol><li>如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</li><li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode 找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第 7 步。</li><li>一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：<ul><li>手动调用 sync() 或者 fsync() 系统调用把脏页写回</li><li>pdflush 进程会定时把脏页写回到磁盘<br>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</li></ul></li></ol><hr><ul><li><p>内核态的函数调用和用户态的函数调用有何区别？</p></li><li><p>一个二进制文件从执行到打印结果操作系统做了什么（从切换（PCB、寄存器）、权限、内存（缺页异常、地址转化之类的）、磁盘（inode之类的）、用户态内核态之类的说了一遍，把还记着的操作系统知识全部编进去了）</p></li><li><p>项目里如何设计缓存来减少不必要的 IO？</p></li><li><p>GDB 用过吗？怎么下断点，怎么追踪？死锁应该怎么调试？</p><ul><li>GDB：UNIX及UNIX-like下的调试工具。</li></ul></li><li><p>查内存泄露用什么工具？</p><ul><li>Leakdiag.</li></ul></li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络的-4-层结构？TCP协议属于哪一层？"><a href="#网络的-4-层结构？TCP协议属于哪一层？" class="headerlink" title="网络的 4 层结构？TCP协议属于哪一层？"></a>网络的 4 层结构？TCP协议属于哪一层？</h2><p><div align="center"> <img src="/posts/afaab92b/426df589-6f97-4622-b74d-4a81fcb1da8e.png" width="600"> </div><br></p><p><strong>五层协议</strong></p><ul><li><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</p></li><li><p><strong>运输层</strong> ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p><strong>网络层</strong> ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</p></li><li><p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h2 id="TCP-和-UDP-的优缺点"><a href="#TCP-和-UDP-的优缺点" class="headerlink" title="TCP 和 UDP 的优缺点"></a>TCP 和 UDP 的优缺点</h2><ul><li><p>TCP</p><ul><li>优点：可靠，稳定。TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，会断开连接用来节约系统资源。</li><li>缺点：慢，效率低，占用系统资源高，易被攻击。TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。 而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</li><li>使用场景：当对网络通讯可靠性有要求的时候。比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。 在日常生活中，常见使用 TCP 协议的应用如下： 浏览器，用的 HTTP；FlashFXP，用的 FTP；Outlook，用的POP、SMTP；Putty，用的 Telnet、SSH QQ 文件传输</li></ul></li><li><p>UDP</p><ul><li>优点：快，比TCP稍安全。UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood攻击</li><li>缺点：不可靠，不稳定。因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li><li>使用场景： 当对网络通讯可靠性要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 比如，日常生活中，常见使用U DP 协议的应用如下： QQ 语音、QQ 视频、TFTP、长视频等</li></ul></li></ul><h2 id="UDP-如何实现可靠性传输"><a href="#UDP-如何实现可靠性传输" class="headerlink" title="UDP 如何实现可靠性传输"></a>UDP 如何实现可靠性传输</h2><p>UDP 它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 TCP 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><p>实现确认机制、重传机制、窗口确认机制。</p><p>如果你不利用 Linux 协议栈以及上层 socket 机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</p><ul><li>发送：包的分片、包确认、包的重发</li><li>接收：包的调序、包的序号确认</li></ul><p>目前有如下开源程序利用 UDP 实现了可靠的数据传输。分别为 RUDP、RTP、UDT。</p><ul><li>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</li><li>实时传输协议（RTP）为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码</li><li>基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</li></ul><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><div align="center"> <img src="/posts/afaab92b/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"> </div><br></p><ul><li><p><strong>序号</strong>  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong>  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong>  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong>  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong>  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="TCP-三次握手，四次挥手的过程？最后等待关闭连接要多长时间？"><a href="#TCP-三次握手，四次挥手的过程？最后等待关闭连接要多长时间？" class="headerlink" title="TCP 三次握手，四次挥手的过程？最后等待关闭连接要多长时间？"></a>TCP 三次握手，四次挥手的过程？最后等待关闭连接要多长时间？</h2><p><strong>三次握手</strong></p><p><div align="center"> <img src="/posts/afaab92b/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"> </div><br></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>四次挥手</strong></p><p><div align="center"> <img src="/posts/afaab92b/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"> </div><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong> </p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h2 id="TCP-有哪些状态，CLOSED-状态出现在什么时候？"><a href="#TCP-有哪些状态，CLOSED-状态出现在什么时候？" class="headerlink" title="TCP 有哪些状态，CLOSED 状态出现在什么时候？"></a>TCP 有哪些状态，CLOSED 状态出现在什么时候？</h2><p><img src="/posts/afaab92b/1350996969_2313.jpg" alt="TCP 状态"></p><p>全部共 11 种状态。</p><ul><li>客户端独有的：<ul><li>SYN_SENT</li><li>FIN_WAIT1</li><li>FIN_WAIT2 </li><li>CLOSING </li><li>TIME_WAIT </li></ul></li><li>服务器独有的：<ul><li>LISTEN</li><li>SYN_RCVD</li><li>CLOSE_WAIT</li><li>LAST_ACK </li></ul></li><li>共有的<ul><li>CLOSED</li><li>ESTABLISHED </li></ul></li></ul><p>客户端 TCP 状态迁移：<br><code>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</code></p><p>服务器 TCP 状态迁移：<br><code>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</code></p><h2 id="TCP-用了哪些措施保证其可靠性"><a href="#TCP-用了哪些措施保证其可靠性" class="headerlink" title="TCP 用了哪些措施保证其可靠性"></a>TCP 用了哪些措施保证其可靠性</h2><ul><li>连接管理：TCP 是面向连接的，三次握手和四次挥手都是为了保证本次数据传送的可靠性</li><li>序号：TCP 是面向字节流的，它对每一个字节都进行了编号，保证数据段的按序到达</li><li>确认应答机制：TCP 通过确认应答机制实现可靠的数据传输。在 TCP 的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位 ACK = 1 时确认首部的确认字段有效。进行确认时，确认号的值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。 </li><li>超时重传机制：主机A发送给主机B数据报后一段时间内如果没有收到主机B对应的确认报文，就认为这一个或者这几个数据报都丢失了，即触发重传机制，重新发送没有被确认的报文。</li><li>流量控制：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。 因此 TCP 中引入了流量控制机制，意思就是根据接收端处理数据的能力来控制发送端发送数据的速度。 </li><li>拥塞控制：如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</li></ul><h2 id="http-100-206-304-是什么？-304-中-xxxxx-的-header-有什么作用？"><a href="#http-100-206-304-是什么？-304-中-xxxxx-的-header-有什么作用？" class="headerlink" title="http 100 206 304 是什么？ 304 中 xxxxx 的 header 有什么作用？"></a>http 100 206 304 是什么？ 304 中 xxxxx 的 header 有什么作用？</h2><ul><li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li><li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li></ul><h2 id="HTTP-2-0了解吗？做了什么优化处理？"><a href="#HTTP-2-0了解吗？做了什么优化处理？" class="headerlink" title="HTTP/2.0了解吗？做了什么优化处理？"></a>HTTP/2.0了解吗？做了什么优化处理？</h2><p><strong>HTTP/1.x 缺陷</strong></p><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><p><strong>HTTP/2.0 优化</strong></p><p>（1） 二进制分帧层</p><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p>（2） 服务端推送</p><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p>（3） 首部压缩</p><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><h2 id="SACK-和-MSS-这两个东西了解过吗？"><a href="#SACK-和-MSS-这两个东西了解过吗？" class="headerlink" title="SACK 和 MSS 这两个东西了解过吗？"></a>SACK 和 MSS 这两个东西了解过吗？</h2><ul><li>SACK：SACK(Selective ACK) 是 TCP 选项，它使得接收方能告诉发送方哪些报文段丢失，哪些报文段重传了，哪些报文段已经提前收到等信息。根据这些信息 TCP 就可以只重传哪些真正丢失的报文段。需要注意的是只有收到失序的分组时才会可能会发送 SACK，TCP 的 ACK 还是建立在累积确认的基础上的。也就是说如果收到的报文段与期望收到的报文段的序号相同就会发送累积的 ACK，SACK 只是针对失序到达的报文段的。SACK 包括了两个 TCP 选项，一个选项用于标识是否支持 SACK，是在 TCP 连接建立时发送；另一种选项则包含了具体的 SACK 信息。当我们接收到 ACK 的时候，我们会判断 SACK 段，如果包含 SACK 段的话，我们就要进行处理。</li><li>MSS：最大报文段长度 MSS 选项是 TCP 协议定义的一个选项，MSS 选项用于在TCP 连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。</li></ul><hr><ul><li><p>如何完全消除 time await？</p><ul><li>当初回答的时候设置属性和reuse都是判错的，要求从最后挥手的阶段开始分析</li></ul></li><li><p>怎么样设计一个比较好的函数完全读出一个 socket 的所有数据</p></li></ul><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><p>(1) 二叉树两个节点之间距离</p><p>假设 lca 是两个节点的最低公共祖先节点：<br>$Dist(n_1,n_2) = Dist(root,n_1) + Dist(root,n_2) - 2 \cdot Dist(root,lca)$</p><hr><ul><li><p>一个不知道头节点的单链表，如何在 p 节点前插入一个节点？</p></li><li><p>1 亿个数字取 Top K。分成多个小文件，用小跟堆，堆排取小文件 Top k。之后再用外排或者继续堆排取所有的 Top k。</p></li><li><p>1000w个整数排序，范围0到100w，8g内存</p></li><li><p>非递归完成二叉树的先序遍历</p></li><li><p>实现查询链表的倒数第1000个节点</p></li><li><p>1000万个关键字，每个关键字小于等于50字节，求前K个热词，内存为1M</p></li><li><p>无向图两点之间最小跳数（深度优先）</p></li><li><p>数字数组中最长连续递增序列</p></li><li><p>100W个无序数中是否包含给出的K个元素</p></li><li><p>100W个数字中前K大的数字</p></li><li><p>两个 1T 文件使用 4G 内存比较相似度</p></li><li><p>对单词进行排序，比如 aa cee ee bb a 排序过后为 a aa bb cee ee</p></li><li><p>反转链表</p></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>数据库有啥索引，区别是什么，哪个插入快？为什么？你刚才提到了 B+Tree 索引，介绍一下B TREE 和 B+TREE，他们的区别是啥？</li><li>左连接</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li><p>Linux 下改变文件权限的命令有哪些？</p></li><li><p>硬链接和软链接的区别？</p></li><li><p>Linux 下查看程序内存状况</p><ul><li>top 指令可以查看按内存大小排序的查询内存状况，或者查看 /proc/pid/status 文件，这个文件会记录进程 id 所代表的进程的内存状态</li></ul></li><li><p>Linux 统计文本中每行第二个字段的和（awk搞定）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h1&gt;&lt;h2 id=&quot;virtual-关键字的作用、构造和析构函数能不能定义虚函数？为什么？&quot;&gt;&lt;a href=&quot;#virtual-关键字的作用、构造和
      
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="后台开发" scheme="https://yz1509.github.io/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="面经" scheme="https://yz1509.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="https://yz1509.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="https://yz1509.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://yz1509.github.io/tags/Linux/"/>
    
      <category term="算法" scheme="https://yz1509.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>运维开发工程师面经</title>
    <link href="https://yz1509.github.io//posts/7543f9ab/"/>
    <id>https://yz1509.github.io//posts/7543f9ab/</id>
    <published>2018-08-18T04:34:54.000Z</published>
    <updated>2019-07-25T17:11:45.833Z</updated>
    
    <content type="html"><![CDATA[<p>整理自牛客网<strong>傻妞妞-MM</strong>的<a href="https://www.nowcoder.com/discuss/50625" target="_blank" rel="noopener">面经</a>。</p><h1 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h1><ul><li>基本命令（系统性能信息的各种查看命令、可能会继续向下延伸：比如实时 CPU 负载的获取、网卡流量的抓包获取等，建议有多详细整理多详细。防火墙，文件查看，各种常用命令，请参考鸟哥基础等等。）；</li><li>开机启动过程，run level 各个级别的意思；</li><li>文件系统区别；</li><li>shell 脚本对于日志文件获取有用信息的处理；</li><li>shell 中常使用参数的意义；</li><li>Awk、sed 等工具的使用；</li><li>软链接、硬链接；</li><li>常见的运维相关知识；</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h3 id="三次握手四次挥手，以及其中各个状态的转换，为什么是三次和四次？Time-wait-等待的意义？"><a href="#三次握手四次挥手，以及其中各个状态的转换，为什么是三次和四次？Time-wait-等待的意义？" class="headerlink" title="三次握手四次挥手，以及其中各个状态的转换，为什么是三次和四次？Time_wait 等待的意义？"></a>三次握手四次挥手，以及其中各个状态的转换，为什么是三次和四次？Time_wait 等待的意义？</h3><p><strong>TCP 的三次握手</strong></p><p><div align="center"> <img src="/posts/7543f9ab/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"> </div><br></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>TCP 的四次挥手</strong></p><p><div align="center"> <img src="/posts/7543f9ab/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"> </div><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong> </p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h3 id="TCP-保证可靠的传输机制"><a href="#TCP-保证可靠的传输机制" class="headerlink" title="TCP 保证可靠的传输机制"></a>TCP 保证可靠的传输机制</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h3 id="TCP-滑动窗口和回退-N-帧协议"><a href="#TCP-滑动窗口和回退-N-帧协议" class="headerlink" title="TCP 滑动窗口和回退 N 帧协议"></a>TCP 滑动窗口和回退 N 帧协议</h3><p><strong>TCP 滑动窗口</strong></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><div align="center"> <img src="/posts/7543f9ab/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"> </div><br></p><p><strong>回退 N 帧协议</strong></p><p>当有错误帧出现后，总是要重发该帧之后的所有帧</p><h3 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="TCP-的拥塞控制，拥塞控制中的四个算法"><a href="#TCP-的拥塞控制，拥塞控制中的四个算法" class="headerlink" title="TCP 的拥塞控制，拥塞控制中的四个算法"></a>TCP 的拥塞控制，拥塞控制中的四个算法</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><div align="center"> <img src="/posts/7543f9ab/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"> </div><br></p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p><div align="center"> <img src="/posts/7543f9ab/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"> </div><br></p><p><div align="center"> <img src="/posts/7543f9ab/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"> </div><br></p><h3 id="SYN-攻击以及解决办法"><a href="#SYN-攻击以及解决办法" class="headerlink" title="SYN 攻击以及解决办法"></a>SYN 攻击以及解决办法</h3><p><strong>SYN 攻击原理</strong></p><p>SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以实施。</p><p>服务器接收到连接请求（syn=j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p><p><strong>SYN 攻击防范技术</strong></p><p>主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固 TCP/IP 协议栈防范。但必须清楚的是，SYN 攻击不能完全被阻止，我们所做的是尽可能的减轻 SYN 攻击的危害，除非将 TCP 协议重新设计。</p><ol><li>过滤网关防护</li></ol><p>这里，过滤网关主要指明防火墙，当然路由器也能成为过滤网关。防火墙部署在不同网络之间，防范外来非法攻击和防止保密信息外泄，它处于客户端和服务器之间，利用它来防护 SYN 攻击能起到很好的效果。过滤网关防护主要包括超时设置，SYN 网关和 SYN 代理三种。</p><ul><li>网关超时设置：防火墙设置 SYN 转发超时参数（状态检测的防火墙可在状态表里面设置），该参数远小于服务器的 timeout 时间。当客户端发送完 SYN 包，服务端发送确认包后（SYN+ACK），防火墙如果在计数器到期时还未收到客户端的确认包（ACK），则往服务器发送 RST 包，以使服务器从队列中删去该半连接。值得注意的是，网关超时参数设置不宜过小也不宜过大，超时参数设置过小会影响正常的通讯，设置太大，又会影响防范 SYN 攻击的效果，必须根据所处的网络应用环境来设置此参数。</li><li>SYN 网关：SYN 网关收到客户端的 SYN 包时，直接转发给服务器；SYN 网关收到服务器的 SYN/ACK 包后，将该包转发给客户端，同时以客户端的名义给服务器发 ACK 确认包。此时服务器由半连接状态进入连接状态。当客户端确认包到达时，如果有数据则转发，否则丢弃。事实上，服务器除了维持半连接队列外，还要有一个连接队列，如果发生 SYN 攻击时，将使连接队列数目增加，但一般服务器所能承受的连接数量比半连接数量大得多，所以这种方法能有效地减轻对服务器的攻击。</li><li>SYN 代理：当客户端 SYN 包到达过滤网关时，SYN 代理并不转发 SYN 包，而是以服务器的名义主动回复SYN/ACK包给客户，如果收到客户的ACK包，表明这是正常的访问，此时防火墙向服务器发送ACK包并完成三次握手。SYN代理事实上代替了服务器去处理SYN攻击，此时要求过滤网关自身具有很强的防范SYN攻击能力。</li></ul><ol><li>加固 TCP/IP 协议栈</li></ol><p>防范 SYN 攻击的另一项主要技术是调整 TCP/IP 协议栈，修改 TCP 协议实现。主要方法有 SynAttackProtect 保护机制、SYN cookies 技术、增加最大半连接和缩短超时时间等。TCP/IP 协议栈的调整可能会引起某些功能的受限，管理员应该在进行充分了解和测试的前提下进行此项工作。</p><ul><li>SynAttackProtect 机制：SynAttackProtect 机制是通过关闭某些 socket 选项，增加额外的连接指示和减少超时时间，使系统能处理更多的 SYN 连接，以达到防范 SYN 攻击的目的。</li><li>SYN cookies 技术：我们知道，TCP 协议开辟了一个比较大的内存空间 backlog 队列来存储半连接条目，当 SYN 请求不断增加， 致使系统丢弃 SYN 连接。为使半连接队列被塞满的情况下，服务器仍能处理新到的 SYN 请求，SYN cookies技术被设计出来。</li></ul><p>SYN cookies 应用于 linux、FreeBSD 等操作系统，当半连接队列满时，SYN　cookies 并不丢弃 SYN 请求，而是通过加密技术来标识半连接状态。</p><p>在 TCP 实现中，当收到客户端的 SYN 请求时，服务器需要回复 SYN+ACK 包给客户端，客户端也要发送确认包给服务器。通常，服务器的初始序列号由服务器按照一定的规律计算得到或采用随机数，但在 SYN cookies 中，服务器的初始序列号是通过对客户端 IP 地址、客户端端囗、服务器 IP 地址和服务器端囗以及其他一些安全数值等要素进行 hash 运算，加密得到的，称之为 cookie。当服务器遭受 SYN 攻击使得 backlog 队列满时，服务器并不拒绝新的 SYN 请求，而是回复 cookie（回复包的 SYN 序列号）给客户端， 如果收到客户端的 ACK 包，服务器将客户端的ACK序列号减去1得到 cookie 比较值，并将上述要素进行一次 hash 运算，看看是否等于此 cookie。如果相等，直接完成三次握手（注意：此时并不用查看此连接是否属于 backlog 队列）。</p><ul><li>增加最大半连接数：大量的 SYN 请求导致未连接队列被塞满，使正常的 TCP 连接无法顺利完成三次握手，通过增大未连接队列空间可以缓解这种压力。当然 backlog 队列需要占用大量的内存资源，不能被无限的扩大。</li><li>增加最大半连接数：大量的 SYN 请求导致未连接队列被塞满，使正常的 TCP 连接无法顺利完成三次握手，通过增大未连接队列空间可以缓解这种压力。当然 backlog 队列需要占用大量的内存资源，不能被无限的扩大。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">原因短语</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a>Get 和 Post 的区别</h3><p>（一） 作用</p><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><p>（二） 参数</p><ul><li>GET 和 POST 的请求都能使用额外的参数</li><li>GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中</li><li>URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参考支持标准字符集。</li></ul><p>（三） 安全</p><ul><li>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</li><li>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li></ul><p>（四） 幂等性</p><ul><li>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</li><li>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。<blockquote><p>DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>（五） 可缓存</p><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><p>（六） XMLHttpRequest</p><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h3 id="HTTP-版本的区别"><a href="#HTTP-版本的区别" class="headerlink" title="HTTP 版本的区别"></a>HTTP 版本的区别</h3><ul><li><p>HTTP/1.1 默认是长连接</p></li><li><p>HTTP/1.1 支持管线化处理</p></li><li><p>HTTP/1.1 支持同时打开多个 TCP 连接</p></li><li><p>HTTP/1.1 支持虚拟主机</p></li><li><p>HTTP/1.1 新增状态码 100</p></li><li><p>HTTP/1.1 支持分块传输编码</p></li><li><p>HTTP/1.1 新增缓存处理指令 max-age</p></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><div align="center"> <img src="/posts/7543f9ab/ssl-offloading.jpg" width="700"> </div><br></p><p><strong>加密</strong></p><p>（一） 对称密钥加密</p><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><p><div align="center"> <img src="/posts/7543f9ab/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"> </div><br></p><p>（二） 非对称密钥加密</p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><p><div align="center"> <img src="/posts/7543f9ab/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"> </div><br></p><p>（三） HTTPs 采用的加密方式</p><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p><p><div align="center"> <img src="/posts/7543f9ab/How-HTTPS-Works.png" width="600"> </div><br></p><p><strong>认证</strong></p><p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><p><div align="center"> <img src="/posts/7543f9ab/2017-06-11-ca.png" width=""> </div><br></p><p><strong>完整性保护</strong></p><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><p><strong>HTTPs 的缺点</strong></p><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS-的解析过程"><a href="#DNS-的解析过程" class="headerlink" title="DNS 的解析过程"></a>DNS 的解析过程</h3><p><div align="center"> <img src="/posts/7543f9ab/dns.jpg" width=""> </div><br></p><ul><li>DNS 中的字段</li><li>DNS 的工作原理是什么？</li><li>如果 DNS 解析出现错误，怎么解决？</li></ul><h2 id="常见的其他问题"><a href="#常见的其他问题" class="headerlink" title="常见的其他问题"></a>常见的其他问题</h2><h3 id="Ping-和-Traceroute-的工作原理"><a href="#Ping-和-Traceroute-的工作原理" class="headerlink" title="Ping 和 Traceroute 的工作原理"></a>Ping 和 Traceroute 的工作原理</h3><p>网际控制报文协议 ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p><strong>Traceroute</strong></p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3><p><strong>路由器</strong></p><p>路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。</p><p><strong>交换机</strong></p><p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p><p><strong>区别</strong></p><p>（一） 工作所在的OSI层次不一样（根本区别，导致接下来的区别） </p><ul><li>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； </li><li>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。</li></ul><p>（二） 数据转发所依据的对象也不一样。 </p><ul><li>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 </li><li>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。</li></ul><p>（三） 是否可以分割广播域 </p><ul><li>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； </li><li>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。</li></ul><h3 id="输入网址后，背后发生了什么？"><a href="#输入网址后，背后发生了什么？" class="headerlink" title="输入网址后，背后发生了什么？"></a>输入网址后，背后发生了什么？</h3><ol><li>浏览器发起 DNS 查询请求</li><li>域名服务器向客户端返回查询结果域名，从而完成域名到 IP 地址的转换。</li><li>客户端向 web 服务器发送 HTTP 请求</li><li>web 服务器发送响应数据给客户端</li></ol><h3 id="I-O-模型以及同步异步阻塞非阻塞的区别"><a href="#I-O-模型以及同步异步阻塞非阻塞的区别" class="headerlink" title="I/O 模型以及同步异步阻塞非阻塞的区别"></a>I/O 模型以及同步异步阻塞非阻塞的区别</h3><p><strong>I/O 模型</strong><br>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 下有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><p><strong>阻塞式 I/O</strong></p><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p><div align="center"> <img src="/posts/7543f9ab/1492928416812_4.png"> </div><br></p><p><strong>非阻塞式 I/O</strong></p><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><p><div align="center"> <img src="/posts/7543f9ab/1492928416812_4.png"> </div><br></p><p><strong>同步 I/O 与异步 I/O</strong></p><ul><li>同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。</li><li>异步 I/O：不会阻塞。<br>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</li></ul><h3 id="B-S和C-S的区别"><a href="#B-S和C-S的区别" class="headerlink" title="B/S和C/S的区别"></a>B/S和C/S的区别</h3><p>Client/Server 是建立在局域网的基础上的。Browser/Server 是建立在广域网的基础上的，但并不是说B/S结构不能在局域网上使用，如智赢 IPOWER，在单机，局限网，广域网均能使用。</p><p>1．硬件环境不同: </p><ul><li>C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. </li><li>B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 </li></ul><p>2．对安全要求不同 </p><ul><li>C/S 对服务端、客户端都安全都要考虑。</li><li>B/S 因没有客户端，所以只注重服务端安全即可。</li></ul><p>3．对程序架构不同 </p><ul><li>C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. </li><li>B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. 例如智赢IPOWER，采用AJAX和数据存储优化技术，相比一般B/S架构软件速度提高 30%至99%。</li></ul><p>4．软件重用不同 </p><ul><li>C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好. </li><li>B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 </li></ul><p>5．系统维护不同 </p><ul><li>C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统 </li><li>B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. </li></ul><p>6．处理问题不同 </p><ul><li>C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统 </li><li>B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. </li></ul><p>7．用户接口不同 </p><ul><li>C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高 </li><li>B/S 建立在浏览器上, 通过WEB服务或其他公共可识别描述语言可跨平台，使用更灵活。不仅可应用在Window平台上，还可应用于unix/Linux等平台。</li></ul><p>8．信息流不同 </p><ul><li>C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低 </li><li>B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更象交易中心。</li></ul><hr><ol><li>路由协议OSPF、BGP的区别（这个一般很少问，除非你说你懂网络协议）</li></ol><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是资源分配的基本单位，线程是独立调度的基本单位。<br>（一）拥有资源<br>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>（二）调度<br>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>（三）系统开销<br>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>（四）通信方面<br>进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p><h2 id="进程的状态？进程的切换方式？"><a href="#进程的状态？进程的切换方式？" class="headerlink" title="进程的状态？进程的切换方式？"></a>进程的状态？进程的切换方式？</h2><p><div align="center"> <img src="/posts/7543f9ab/ProcessState.png" width="480"> </div><br></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="进程同步的方式有哪些"><a href="#进程同步的方式有哪些" class="headerlink" title="进程同步的方式有哪些"></a>进程同步的方式有哪些</h2><ul><li>信号量</li><li>管程</li></ul><h2 id="进程的通信方式有哪些"><a href="#进程的通信方式有哪些" class="headerlink" title="进程的通信方式有哪些"></a>进程的通信方式有哪些</h2><ul><li>管道</li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>套接字</li></ul><h2 id="操作系统的常见进程调度算法"><a href="#操作系统的常见进程调度算法" class="headerlink" title="操作系统的常见进程调度算法"></a>操作系统的常见进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><p><strong>批处理系统</strong><br>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><ul><li>先来先服务 first-come first-serverd（FCFS）</li><li>短作业优先 shortest job first（SJF）</li><li>最短剩余时间优先 shortest remaining time next（SRTN）</li></ul><p><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><ul><li>时间片轮转</li><li>优先级调度</li><li>多级反馈队列</li></ul><h2 id="死锁的四个条件，解决与避免的方法"><a href="#死锁的四个条件，解决与避免的方法" class="headerlink" title="死锁的四个条件，解决与避免的方法"></a>死锁的四个条件，解决与避免的方法</h2><p><strong>死锁的四个条件</strong></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><p><strong>办法</strong></p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h2 id="分页和分段有什么区别"><a href="#分页和分段有什么区别" class="headerlink" title="分页和分段有什么区别"></a>分页和分段有什么区别</h2><ul><li>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</li><li>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</li><li><strong>段页式</strong>：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</li></ul><p><strong>分页与分段的比较</strong></p><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><hr><ol><li>数据从内存写到磁盘上发生的过程，具体行为是什么？</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h3 id="ACID性质，其中各个性质的含义"><a href="#ACID性质，其中各个性质的含义" class="headerlink" title="ACID性质，其中各个性质的含义"></a>ACID性质，其中各个性质的含义</h3><ol><li>原子性（Atomicity）</li></ol><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><ol><li>一致性（Consistency）</li></ol><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><ol><li>隔离性（Isolation）</li></ol><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><ol><li>持久性（Durability）</li></ol><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><h3 id="脏读、丢失修改、不可重复读、幻影读"><a href="#脏读、丢失修改、不可重复读、幻影读" class="headerlink" title="脏读、丢失修改、不可重复读、幻影读"></a>脏读、丢失修改、不可重复读、幻影读</h3><p><strong>丢失修改</strong></p><p>$T_1$ 和 $T_2$ 两个事务都对一个数据进行修改，$T_1$ 先修改，$T_2$ 随后修改，$T_2$ 的修改覆盖了 $T_1$ 的修改。</p><p><strong>脏读</strong></p><p>$T_1$ 修改一个数据，$T_2$ 随后读取这个数据。如果 $T_1$ 撤销了这次修改，那么 $T_2$ 读取的数据是脏数据。</p><p><strong>不可重复读</strong></p><p>$T_2$ 读取一个数据，$T_1$ 对该数据做了修改。如果 $T_2$ 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><strong>幻影读</strong></p><p>$T_1$ 读取某个范围的数据，$T_2$ 在这个范围内插入新的数据，$T_1$ 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。（统计求和等）</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同样数据的结果是一样的。</li><li>可串行化（SERIALIZABLE）：强制事务串行执行。</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻影读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><h2 id="数据库的锁机制"><a href="#数据库的锁机制" class="headerlink" title="数据库的锁机制"></a>数据库的锁机制</h2><p><strong>封锁粒度</strong></p><ul><li>行级锁</li><li>表级锁</li></ul><p><strong>封锁类型</strong></p><ul><li><p>读写锁</p><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul></li><li><p>意向锁：IX 、IS</p></li></ul><p><strong>封锁协议</strong></p><ul><li><p>三级封锁协议</p><ul><li>一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</li><li>二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</li><li>三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</li></ul></li><li><p>两段锁协议</p><ul><li>加锁和解锁分为两个阶段进行。</li><li>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</li></ul></li></ul><hr><ul><li>常见的SQL语句（内外联结）</li><li>索引、视图</li><li>Mysql 常见的引擎及区别</li><li>Mysql 的四种日志的意义</li><li>数据库的备份等</li><li>Mysql 的优化</li><li>Mysql 的复制</li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>在 python 中，对象赋值实际上是对象的引用。当创建一个对象，然后把它赋给另一个变量的时候，python 并没有拷贝这个对象，而只是拷贝了这个对象的引用。</p><ol><li>直接赋值，传递对象的引用而已，原始列表改变，被赋值的 b 也会做相同的改变</li><li>copy 浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>deepcopy 深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变</li></ol><hr><ul><li>闭包、装饰器</li><li>迭代器、生成器</li><li>多线程</li><li>内存管理</li><li>垃圾回收机制</li><li>*args,**kwargs</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>常见的<a href="https://yz1509.xyz/posts/7474c898/" target="_blank" rel="noopener">查找</a>、<a href="https://yz1509.xyz/posts/735e5788/" target="_blank" rel="noopener">排序</a>算法</li><li><a href="https://yz1509.xyz/posts/ee040603/" target="_blank" rel="noopener">图</a>、<a href="https://yz1509.xyz/posts/7b216a3b/" target="_blank" rel="noopener">树</a>、链表等各种知识点</li></ul><h1 id="运维相关"><a href="#运维相关" class="headerlink" title="运维相关"></a>运维相关</h1><h2 id="高可用性、负载均衡"><a href="#高可用性、负载均衡" class="headerlink" title="高可用性、负载均衡"></a>高可用性、负载均衡</h2><p><strong>高可用性</strong></p><p>计算机系统的可用性用 [1]  平均无故障时间（MTTF）来度量，即计算机系统平均能够正常运行多长时间，才发生一次故障。系统的可用性越高，平均无故障时间越长。可维护性用平均维修时间（MTTR）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修时间越短。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%。由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。</p><p>工作方式：</p><ol><li><p>主从方式 （非对称方式）<br>工作原理：主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。</p></li><li><p>双机双工方式（互备互援）<br>工作原理：两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。</p></li><li><p>集群工作方式（多服务器互备方式）<br>工作原理：多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。</p></li></ol><p><strong>负载均衡</strong></p><p>负载均衡可以将任务分摊到多个处理单元，从而提高并发处理能力。</p><p>（一） [协议层] HTTP 重定向协议实现负载均衡</p><ul><li>原理：根据用户的 HTTP 请求计算出一个真实的 web 服务器地址，并将该 web 服务器地址写入 HTTP 重定向响应中返回给浏览器，由浏览器重新进行访问。</li><li>优点：比较简单</li><li>缺点：<ul><li>浏览器需要两次请求服务器才能完成一次访问，性能较差。</li><li>HTTP 重定向服务器自身的处理能力可能成为瓶颈。</li><li>使用 HTTP302 响应重定向，有可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</li></ul></li></ul><p>（二） [协议层] DNS 域名解析负载均衡</p><ul><li>原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 对应一组 web 服务器 IP 地址，域名解析时经过 DNS 服务器的算法将一个域名请求分配到合适的真实服务器上。</li><li>优点：将负载均衡的工作交给了 DNS，省却了网站管理维护负载均衡服务器的麻烦，同时许多 DNS 还支持基于地理位置的域名解析，将域名解析成距离用户地理最近的一个服务器地址，加快访问速度吗，改善性能。</li><li>缺点：<ul><li>目前的 DNS 解析是多级解析，每一级DNS都可能化缓存记录A，当某一服务器下线后，该服务器对应的 DNS 记录 A 可能仍然存在，导致分配到该服务器的用户访问失败。</li><li>DNS负载均衡的控制权在域名服务商手里，网站可能无法做出过多的改善和管理。不能够按服务器的处理能力来分配负载。</li><li>DNS 负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。</li><li>可能会造成额外的网络问题。为了使本 DNS 服务器和其他 DNS 服务器及时交互，保证 DNS 数据及时更新，使地址能随机分配，一般都要将 DNS 的刷新时间设置的较小，但太小将会使 DNS 流量大增造成额外的网络问题。</li></ul></li></ul><p>（三） [协议层] 反向代理负载均衡</p><ul><li>原理：反向代理处于 web 服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组 web 服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的web 服务器处理，处理结果经过反向服务器返回给浏览器。</li><li>优点：部署简单，处于 HTTP 协议层面。</li><li>缺点：使用了反向代理服务器后，web 服务器地址不能直接暴露在外，因此 web服务器不需要使用外部 IP 地址，而反向代理服务作为沟通桥梁就需要配置双网卡、外部内部两套 IP 地址。</li></ul><p>（四） [网络层] IP负载均衡</p><ul><li>原理：在网络层通过修改目标地址进行负载均衡。用户访问请求到达负载均衡服务器，负载均衡服务器在操作系统内核进程获取网络数据包，根据算法得到一台真实服务器地址，然后将用户请求的目标地址修改成该真实服务器地址，数据处理完后返回给负载均衡服务器，负载均衡服务器收到响应后将自身的地址修改成原用户访问地址后再讲数据返回回去。类似于反向服务器负载均衡。</li><li>优点：在响应请求时速度较反向服务器负载均衡要快。</li><li>缺点：当请求数据较大（大型视频或文件）时，速度较慢。</li></ul><p>（五） [链路层] 数据链路层负载均衡</p><ul><li>原理：在数据链路层修改 MAC 地址进行负载均衡。负载均衡服务器的 IP 和它所管理的 web 服务群的虚拟 IP 一致；负载均衡数据分发过程中不修改访问地址的 IP 地址，而是修改 MAC 地址；通过这两点达到不修改数据包的原地址和目标地址就可以进行正常的访问。</li><li>优点：不需要负载均衡服务器进行地址的转换。数据响应时不需要经过负载均衡服务器。是目前大型网站所使用得最广的一种均衡手段。</li><li>缺点：负载均衡服务器的网卡带宽要求较高。</li></ul><hr><ol><li><p><strong>Docker</strong></p></li><li><p><strong>Nginx、lvs、keepalived、监控、cdn 等</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理自牛客网&lt;strong&gt;傻妞妞-MM&lt;/strong&gt;的&lt;a href=&quot;https://www.nowcoder.com/discuss/50625&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面经&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Linux-系
      
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="面经" scheme="https://yz1509.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="https://yz1509.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="https://yz1509.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://yz1509.github.io/tags/Linux/"/>
    
      <category term="运维开发工程师" scheme="https://yz1509.github.io/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="Python" scheme="https://yz1509.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>认识STL</title>
    <link href="https://yz1509.github.io//posts/64d148d3/"/>
    <id>https://yz1509.github.io//posts/64d148d3/</id>
    <published>2018-07-31T02:48:06.000Z</published>
    <updated>2019-07-23T15:46:16.281Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。</p><h1 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h1><p>标准库类型 string 表示可变长的字符序列。</p><h2 id="定义和初始化-string-对象"><a href="#定义和初始化-string-对象" class="headerlink" title="定义和初始化 string 对象"></a>定义和初始化 string 对象</h2><ul><li><p>初始化 string 对象的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;              <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;          <span class="comment">// s2 是 s1 的一个副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;         <span class="comment">// 等价于 s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;     <span class="comment">// s3 是字面值 "value" 的副本，不包含字面值最后的空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;    <span class="comment">// 等价于 s3("value")</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;      <span class="comment">// 把 s4 初始化为连续 n 个字符 c 组成的串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 string 的其他方法</span></span><br><span class="line"><span class="comment">// n, len2 和 pos2 都是无符号值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp, n)</span></span>;<span class="comment">// s 是指向 cp 指向的数组中的前 n 个字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 此数组至少应该包含 n 个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2)</span></span>;<span class="comment">// s 是 string s2 从下标 pos2 开始的字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2, len2)</span></span>;<span class="comment">// s 是 string s2 从下标 pos2 开始 len2 个字符的  // 拷贝，若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line">                        <span class="comment">// 不管 len2 的值为多少，至多拷贝 s2.size()-pos2个字符</span></span><br></pre></td></tr></table></figure></li><li><p>直接初始化和拷贝初始化</p><ul><li>如果使用等号 = 初始化一个变量，实际执行的是拷贝初始化</li><li>如果不使用等号，则执行的是直接初始化（direct initialization）</li></ul></li></ul><h2 id="string-对象上的操作"><a href="#string-对象上的操作" class="headerlink" title="string 对象上的操作"></a>string 对象上的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s;            <span class="comment">// 将 s 写到输出流 os 中，返回 os</span></span><br><span class="line">is &gt;&gt; s;            <span class="comment">// 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is</span></span><br><span class="line">                <span class="comment">// string 对象会自动忽略开头的空白并从第一个非空白字符开始</span></span><br><span class="line">                <span class="comment">// 直至遇见下一处空白为止。</span></span><br><span class="line">getline(is, s);     <span class="comment">// 从 is 中读取一行赋给 s，返回 is</span></span><br><span class="line">                    <span class="comment">// getline 函数从给定的流中读入内容，直到遇到</span></span><br><span class="line">                    <span class="comment">// 换行符为止（换行符也被读进来），</span></span><br><span class="line">                    <span class="comment">// 然后把所读内容存入到 string 对象中（注意不存换行符）</span></span><br><span class="line">s.empty();          <span class="comment">// s 为空返回 true</span></span><br><span class="line">s.size();           <span class="comment">// 返回 s 中字符的个数</span></span><br><span class="line">s[n];               <span class="comment">// 返回 s 中第 n 个字符的引用，位置 n 从 0 开始</span></span><br><span class="line">s1 + s2;            <span class="comment">// 返回 s1 和 s2 连接后的结果</span></span><br><span class="line">s1 = s2;            <span class="comment">// 用 s2 的副本代替 s1 中原来的字符</span></span><br><span class="line">s1 == s2;</span><br><span class="line">s1 != s2;           <span class="comment">// 大小写敏感</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=        <span class="comment">// 字典序比较，且大小写敏感</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子字符串操作</span></span><br><span class="line">s.substr(pos, n);<span class="comment">// 返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。</span></span><br><span class="line">                    <span class="comment">// pos 的默认值为 0，n 的默认值为 s.size() - pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 string 的操作</span></span><br><span class="line">s.insert(pos, args)<span class="comment">// 在 pos 之前插入 args 指定的字符</span></span><br><span class="line">                    <span class="comment">// pos 为下标的版本返回一个指向 s 的引用</span></span><br><span class="line">                    <span class="comment">// pos 为迭代器的版本返回指向第一个插入字符的迭代器</span></span><br><span class="line">s.erase(pos, len)<span class="comment">// 删除从位置 pos 开始的 len 个字符。如果 len 被省略，</span></span><br><span class="line">                    <span class="comment">// 则删除从 pos 开始直至 s 末尾的所有字符</span></span><br><span class="line">                    <span class="comment">// 返回一个指向 s 的引用</span></span><br><span class="line">s.assign(args)<span class="comment">// 将 s 中的字符替换为 args 指定的字符，返回一个指向 s 的引用</span></span><br><span class="line">s.append(args)<span class="comment">// 将 args 追加到 s, 返回一个指向 s 的引用</span></span><br><span class="line">s.replace(range, args)<span class="comment">// 删除 s 中范围 range 内的字符，替换为 args 指定的字符</span></span><br><span class="line">                        <span class="comment">// range 为一个下标+长度，或为一对指向 s 的迭代器</span></span><br><span class="line">                        <span class="comment">// 返回一个指向 s 的引用</span></span><br></pre></td></tr></table></figure><p>args 可以是下列形式之一，str 不能与 s 相同，迭代器 b 和 e 不能指向 s</p><table><thead><tr><th>args</th><th>说明</th></tr></thead><tbody><tr><td>str</td><td>字符串 str</td></tr><tr><td>str, pos, len</td><td>str 中从 pos 开始最多 len 个字符</td></tr><tr><td>cp, len</td><td>从 cp 指向的字符数组的前(最多)len 个字符</td></tr><tr><td>cp</td><td>cp 指向的以空字符结尾的字符数组</td></tr><tr><td>n, c</td><td>n 个字符 c</td></tr><tr><td>b, e</td><td>迭代器 b 和 e 指定的范围内的字符</td></tr><tr><td>初始化列表</td><td>花括号包围的，以逗号分隔的字符列表</td></tr></tbody></table><p>append 和 assign 可以使用所有形式的 args</p><table><thead><tr><th>args</th><th>replace(pos,len,args)</th><th>replace(b,e,args)</th><th>insert(pos,args)</th><th>insert(iter,args)</th></tr></thead><tbody><tr><td>str</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>str, pos, len</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>cp, len</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>cp</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>n, c</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>b, e</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr><td>初始化列表</td><td>否</td><td>是</td><td>否</td><td>是</td></tr></tbody></table><ul><li>size 函数返回的是一个 string::size_type 类型的值，它是一个无符号类型。这种配套类型体现了标准库类型与机器无关的特性。</li></ul><blockquote><p>Tip：如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。</p></blockquote><ul><li>当把 string 对象和字符（或字符串）字面值混在一条语句中使用时，必须确保每个加法运算符 (+) 的两侧的运算对象至少有一个是 string。（字符串字面值与 string 是不同的的类型）</li></ul><h1 id="标准库类型-vector"><a href="#标准库类型-vector" class="headerlink" title="标准库类型 vector"></a>标准库类型 vector</h1><p>标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。因为引用不是对象，所以不存在引用的 vector。</p><h2 id="定义和初始化-vector-对象"><a href="#定义和初始化-vector-对象" class="headerlink" title="定义和初始化 vector 对象"></a>定义和初始化 vector 对象</h2><ul><li><p>初始化 vector 对象的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1;                   <span class="comment">// v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2(v1);               <span class="comment">// v2 中包含有 v1 所有元素的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2 = v1;              <span class="comment">// 等价于 v2(v1)</span></span><br><span class="line">                                <span class="comment">// 注意两个 vector 对象的类型必须相同</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val);           <span class="comment">// v3 包含了 n 个重复的元素，每个元素的值都为 val</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v4(n);                <span class="comment">// v4 包含了 n 个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5&#123;a, b, c, ... &#125;;    <span class="comment">// v5 包含了初始值个数的元素，每个元素被赋予相应的初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5 = &#123;a, b, c, ... &#125;; <span class="comment">// 等价于 v5&#123;a, b, c, ... &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在大多数情况下这些初始化的方式可以相互等价地使用，不过也有例外：</p><ul><li>使用拷贝初始化（即使用 =）时，只能提供一个初始值</li><li>如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化</li><li>如果提供的是初始元素值的列表，则只能把初始值放在花括号内执行列表初始化，而不能放圆括号内</li></ul></li><li><p>值初始化的两个特殊限制：</p><ul><li>有些类要求必须明确提供初始值时，只提供元素的数量而不设定初始值无法完成初始化工作</li><li>如果只提供了元素而没有设定初始值，只能使用直接初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = <span class="number">10</span>;    <span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(<span class="number">10</span>);     <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125;;        <span class="comment">// 列表初始化，v5 有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>);        <span class="comment">// 错误：不能用字符串字面值构造 vector 对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;          <span class="comment">// v7 有 10 个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;    <span class="comment">// v8 有 10 个值为 “hi” 的元素</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="vector-支持的操作"><a href="#vector-支持的操作" class="headerlink" title="vector 支持的操作"></a>vector 支持的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v.empty();              <span class="comment">// 如果 v 不含有任何元素，返回真；否则返回假</span></span><br><span class="line">v.size();               <span class="comment">// 返回 v 中元素的个数</span></span><br><span class="line">                        <span class="comment">// 返回值的类型是由 vector 定义的 size_type 类型</span></span><br><span class="line">v.push_back(t);         <span class="comment">// 向 v 的尾端添加一个值为 t 的元素</span></span><br><span class="line">v[n];                   <span class="comment">// 返回 v 中第 n 个位置上元素的引用</span></span><br><span class="line">v1 = v2;                <span class="comment">// 用 v2 中元素的拷贝替换 v1 中的元素</span></span><br><span class="line">v1 = &#123;a, b, c, ... &#125;;   <span class="comment">// 用列表中元素的拷贝替换 v1 中元素</span></span><br><span class="line">v1 == v2;               <span class="comment">// v1 和 v2 相等当且它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2;</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=            <span class="comment">// 字典序进行比较（前提是 vector 对象中元素的值可比较）</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用 size_type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type      <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type           <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h2><p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 begin 和 end 的成员：</p><ul><li>begin 成员负责返回指向第一个元素（或第一个字符）的迭代器</li><li>end 成员则负责返回指向容器（或 string 对象）“尾元素的下一个位置（one past the end）”的迭代器，称为尾后迭代器（off-the-end iterator）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end();    <span class="comment">// b 和 e 的类型相同</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。</p></blockquote><h2 id="标准容器迭代器的运算符"><a href="#标准容器迭代器的运算符" class="headerlink" title="标准容器迭代器的运算符"></a>标准容器迭代器的运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*iter               <span class="comment">// 返回迭代器 iter 所指元素的引用</span></span><br><span class="line">iter-&gt;mem           <span class="comment">// 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem</span></span><br><span class="line">                    <span class="comment">// 箭头运算符 -&gt; 将解引用和成员访问两个操作结合在一起</span></span><br><span class="line">++iter              <span class="comment">// 令 iter 指示容器中的下一个元素</span></span><br><span class="line">--iter              <span class="comment">// 令 iter 指示容器中的上一个元素</span></span><br><span class="line">iter1 == iter2      <span class="comment">// 如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等</span></span><br><span class="line">iter1 != iter2      <span class="comment">// 反之，不相等</span></span><br></pre></td></tr></table></figure><blockquote><p>因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p></blockquote><h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>实际上，那些拥有迭代器的标准库类型使用 iteration 和 const_iterator 来表示迭代器的类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;           <span class="comment">// it 能读写 vector&lt;int&gt; 的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;               <span class="comment">// it2 能读写 string 对象中的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;    <span class="comment">// it3 只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;         <span class="comment">// it4 只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure></p><ul><li>如果标准库类型对象是常量，只能使用 const_iterator</li><li>如果标准库类型对象不是常量，那么既能使用 iterator，也能使用 const_iterator</li><li>begin 和 end 返回的具体类型由对象是否是常量决定<ul><li>对象是常量，返回 const_iterator</li><li>对象不是常量，返回 iterator</li><li>专门返回 const_iterator 类型的函数：cbegin 和 cend</li></ul></li></ul><blockquote><p>WARNING：谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，这会使迭代器失效。</p></blockquote><h2 id="vector-和-string-迭代器支持的运算"><a href="#vector-和-string-迭代器支持的运算" class="headerlink" title="vector 和 string 迭代器支持的运算"></a>vector 和 string 迭代器支持的运算</h2><p>string 和 vector 的迭代器比标准库容器迭代器提供了更多额外的运算符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter + n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter - n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter += n       <span class="comment">// 迭代器加法的复合赋值语句</span></span><br><span class="line">iter -= n       <span class="comment">// 迭代器减法的复合赋值语句</span></span><br><span class="line">iter1 - iter2   <span class="comment">// 两个迭代器相减的结果是它们之间的距离。参与运算的两个迭代器必须指向的是同一个容器中的</span></span><br><span class="line">                <span class="comment">// 元素或者尾元素的下一个位置</span></span><br><span class="line">&gt;, &gt;=, &lt;, &lt;=    <span class="comment">// 参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置</span></span><br></pre></td></tr></table></figure></p><h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>顺序容器是将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。标准库常用顺序容器如下：</p><ul><li>vector，可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。</li><li>deque，双端队列。支持快速随机访问，在头尾部插入速度很快。</li><li>list，双向链表。支持双向顺序访问，在 list 中任何位置插入删除都很快。</li><li>forward_list，单向链表。只支持单向顺序访问，在链表任何位置插入删除都很快。<br>容器只定义了少量操作，大多数额外操作则由算法库提供。容器类型的操作集合具有以下层次结构特点：一些操作适用于所有容器类型；另外一些操作则只适用于顺序或关联容器类型；还有一些操作只适用于顺序或关联容器类型的一个子集。</li></ul><h2 id="顺序容器的定义和初始化"><a href="#顺序容器的定义和初始化" class="headerlink" title="顺序容器的定义和初始化"></a>顺序容器的定义和初始化</h2><p>所有的容器都是类模版，要定义某种特殊的容器，必须在容器后的尖括号内提供存放元素的数据类型。容器元素类型必须满足以下两个约束：</p><ul><li>元素类型必须支持赋值运算；</li><li>元素类型的对象必须可以复制。</li></ul><p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。除了默认构造函数，容器类型还提供其他的构造函数，使程序员可以指定元素初值。在 C++11 中，我们可以对容器进行列表初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;  <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(svec);  <span class="comment">//将一个容器复制给另一个容器时，类型必须匹配</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());   <span class="comment">//初始化为一段元素的副本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::size_type list_size = <span class="number">64</span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(list_size, <span class="string">"eh"</span>);  <span class="comment">//分配和初始化指定数目的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Qin"</span>,<span class="string">"Li"</span>&#125;;  <span class="comment">//C++11列表初始化</span></span><br></pre></td></tr></table></figure></p><h2 id="顺序容器的常用操作"><a href="#顺序容器的常用操作" class="headerlink" title="顺序容器的常用操作"></a>顺序容器的常用操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><img src="/posts/64d148d3/001.png" alt="顺序容器添加元素"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; container;</span><br><span class="line"><span class="built_in">string</span> text_word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; text_word) </span><br><span class="line">     container.push_back(text_word); </span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">4</span>; ++ix) </span><br><span class="line">     ilist.push_front(ix);</span><br></pre></td></tr></table></figure></p><p>任何 insert 或 push 操作都可能导致迭代器失效。当编写循环将元素插入到 vector 或 deque 容器中时，程序必须确保迭代器在每次循环后都得到更新。为了避免存储 end 迭代器，可以在每次做完插入运算后重新计算 end 迭代器值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first = v.begin(); <span class="comment">//不要令last = v.end();</span></span><br><span class="line"><span class="keyword">while</span> (first != v.end()) </span><br><span class="line">&#123; </span><br><span class="line">     first = v.insert(first, <span class="number">42</span>); <span class="comment">// insert new value </span></span><br><span class="line">     ++first; <span class="comment">// advance first just past the element we added </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="改变容器的大小"><a href="#改变容器的大小" class="headerlink" title="改变容器的大小"></a>改变容器的大小</h3><p>为避免每次添加元素都会执行内存分配和释放的操作，vector 和 string 每次获取新的内存空间时，都会分配比需求更大的空间作为备用，以此减少内存分配的次数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> a = c.size();  <span class="comment">//返回容器c中的元素个数</span></span><br><span class="line"><span class="keyword">bool</span> b = c.empty();  <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">c.resize(<span class="number">15</span>);<span class="comment">// 将 5 个值为 0 的元素添加到 c 的末尾</span></span><br><span class="line">c.resize(<span class="number">20</span>, <span class="number">-1</span>);<span class="comment">// 将 5 个值为 -1 的元素添加到 c 的末尾</span></span><br><span class="line">c.reserve(<span class="number">30</span>);  <span class="comment">// 分配至少能容纳 30 个元素的内存空间</span></span><br><span class="line">c.capacity();  <span class="comment">// 返回容器可以容纳的元素个数 30，此时 c.size()=20</span></span><br></pre></td></tr></table></figure></p><p>resize() 和 reserve() 区别：</p><ul><li>size 指容器当前拥有的元素个数，调用 resize(n) 后，容器的 size 即为 n。</li><li>capacity 则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。调用 reserve(n) 后，若容器的 $capacity &lt; n$，则重新分配内存空间，从而使得 capacity 等于 n。如果 $capacity \ge n$，capacity 无变化。</li><li>容器调用 resize() 函数后，所有的空间都已经初始化了，所以可以直接访问。而 reserve() 函数预分配出的空间没有被初始化，所以不可访问。</li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="/posts/64d148d3/002.png" alt="顺序容器删除元素"><br>pop_front 和 pop_back 函数的返回值并不是删除的元素值，而是 void。要获取删除的元素值，则必须在删除元素之前调用 front 或 back 函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ilist.empty()) &#123; </span><br><span class="line">         process(ilist.front()); <span class="comment">// do something with the current top of ilist </span></span><br><span class="line">         ilist.pop_front();      <span class="comment">// done; remove first element </span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>erase 操作不会检查它的参数，因此必须确保用作参数的迭代器或迭代器范围是有效的。通常，程序员必须在容器中找出要删除的元素后，才使用 erase 操作。寻找一个指定元素的最简单方法是使用标准库的 find 算法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">searchValue</span><span class="params">(<span class="string">"Quasimodo"</span>)</span></span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = find(slist.begin(), slist.end(), searchValue); </span><br><span class="line"><span class="keyword">if</span> (iter != slist.end())    </span><br><span class="line">    slist.erase(iter);</span><br></pre></td></tr></table></figure></p><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外，标准库来提供了三种容器适配器：stack、queue 和 priority_queue。适配器（adaptor）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，使得某种事物的行为看起来像另外一件事物一样。</p><p>实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括 stack、queue 和 priority_queue 类型。</p><p>栈的常用操作：</p><ul><li>s.empty()，判断栈是否为空，为空则返回true。</li><li>s.size()，返回栈中元素个数。</li><li>s.pop()，删除栈顶元素，但不返回其值。</li><li>s.top()，返回栈顶元素的值，不降元素弹出栈。</li><li>s.push()，在栈顶压入新元素。</li></ul><p>队列的常用操作：</p><ul><li>q.empty() , q.size() 同栈</li><li>q.pop()，删除队首元素，但不返回其值。</li><li>q.push()，在队尾压入一个新元素。</li><li>q.front()，返回队首元素，但不删除此元素</li><li>q.back()，返回队尾元素。（只适用于 queue）</li><li>q.top()，返回最高优先级元素，但不删除此元素（只适用于 priority_queue）</li></ul><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器支持通过键来高效地查找和读取元素，两个基本的关联容器类型是 map 和 set。</p><ul><li>map 的元素以键-值（key-value）对的形式组织：键用于元素在 map 中的索引，而值则表示所存储和读取的数据。</li><li>set 仅包含一个键，并有效地支持关于某个键是否存在的查询。map 可理解为字典，set 可理解为一类元素的集合。</li></ul><p>关联容器和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。</p><p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。</p><h2 id="pair-类型"><a href="#pair-类型" class="headerlink" title="pair 类型"></a>pair 类型</h2><p>pair 包含两个数据值。在创建 pair 对象时，必须提供两个类型名：pair 对象所包含的两个数据成员各自对应的类型名字。如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;   <span class="comment">//利用 typedef 简化其声明</span></span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是公有的，分别命名为 first 和 second。只需使用普通的点操作符（成员访问标志）即可访问其成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook; </span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author.second == <span class="string">"Joyce"</span>) </span><br><span class="line">    firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure></p><p>除了构造函数，标准库还定义了一个 make_pair 函数，由传递给它的两个实参生成一个新的 pair 对象。可如下使用该函数创建新的 pair 对象，并赋给已存在的 pair 对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth; </span><br><span class="line"><span class="built_in">string</span> first, last; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123; </span><br><span class="line">    next_auth = make_pair(first, last); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map-类型"><a href="#map-类型" class="headerlink" title="map 类型"></a>map 类型</h2><p>map 对象的元素是键－值对，也即每个元素包含两个部分：键以及由键关联的值。map 的 value_type 就反映了这个事实。该类型比前面介绍的容器所使用的元素类型要复杂得多：value_type 是存储元素的键以及值的 pair 类型，而且键为 const。如下，word_count 数组的 value_type 为 pair<const string,="" int=""> 类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count.insert(make_pair(<span class="string">"James"</span>, <span class="string">"Joyce"</span>));</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin(); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br></pre></td></tr></table></figure></const></p><h3 id="给-map-添加元素"><a href="#给-map-添加元素" class="headerlink" title="给 map 添加元素"></a>给 map 添加元素</h3><p>map 容器中添加键－值元素对，可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。在这两种情况下，一个给定的键只能对应于一个元素这一事实影响了这些操作的行为。</p><p>用下标操作符来获取该键所关联的值。</p><ul><li>如果该键已在容器中，则返回该键所关联的值。</li><li>只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。此时，所关联的值采用值初始化：类类型的元素用默认构造函数初始化，而内置类型的元素初始化为 0。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; <span class="comment">// empty map from string to int </span></span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) </span><br><span class="line">    ++word_count[word];</span><br></pre></td></tr></table></figure></li></ul><p>使用下标给 map 容器添加新元素时，元素的值部分将采用值初始化。通常，我们会立即为其赋值，其实就是对同一个对象进行初始化并赋值。而插入元素的另一个方法是：直接使用 insert 成员，其语法更紧凑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>)); </span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure></p><p>map 对象中一个给定键只对应一个元素。如果试图插入的元素所对应的键已在容器中，则 insert 将不做任何操作。但是，带有一个键－值 pair 形参的 insert 版本将返回一个值：包含一个迭代器和一个 bool 值的 pair 对象，其中迭代器指向 map 中具有相应键的元素，而 bool 值则表示是否插入了该元素。如果该键已在容器中，则其关联的值保持不变，返回的 bool 值为 true。在这两种情况下，迭代器都将指向具有给定键的元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; </span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) &#123; </span><br><span class="line">    <span class="comment">// inserts element with key equal to word and value 1; </span></span><br><span class="line">    <span class="comment">// if word already in word_count, insert does nothing </span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret =  word_count.insert(make_pair(word, <span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!ret.second)          <span class="comment">// word already in word_count </span></span><br><span class="line">        ++ret.first-&gt;second;  <span class="comment">// increment counter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找并读取-map-中的元素"><a href="#查找并读取-map-中的元素" class="headerlink" title="查找并读取 map 中的元素"></a>查找并读取 map 中的元素</h3><p>不能使用下标来查找 map 中的某一元素是否存在，因为如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。</p><p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"foobar"</span>);</span><br><span class="line"><span class="keyword">if</span>(it != wor_count.end())</span><br><span class="line">    occurs = it-&gt;second;</span><br></pre></td></tr></table></figure></p><h3 id="从-map-对象中删除元素"><a href="#从-map-对象中删除元素" class="headerlink" title="从 map 对象中删除元素"></a>从 map 对象中删除元素</h3><p><img src="/posts/64d148d3/003.png" alt="map删除元素"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word_count.erase(removal_word)) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ok: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" removed\n"</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"oops: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" not found!\n"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="map-对象的迭代遍历"><a href="#map-对象的迭代遍历" class="headerlink" title="map 对象的迭代遍历"></a>map 对象的迭代遍历</h3><p>与其他容器一样，map 同样提供 begin 和 end 运算，以生成用于遍历整个容器的迭代器。例如，可如下将 map 容器 word_count 的内容输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = word_count.begin();</span><br><span class="line"><span class="keyword">while</span>(it != word_count.end())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs "</span></span><br><span class="line">            &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" times "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h2><p>map 容器是键－值对的集合，好比以人名为键的地址和电话号码。相反地，set 容器只是单纯的键的集合。例如，某公司可能定义了一个名为 bad_checks 的 set 容器，用于记录曾经给本公司发空头支票的客户。当只想知道一个值是否存在时，使用 set 容器是最适合的。例如，在接收一张支票前，该公司可能想查询 bad_checks 对象，看看该客户的名字是否存在。</p><p>set 容器支持大部分的 map 操作，包括上面描述的构造函数、 insert 操作、 count 和 find 操作、 erase 操作等。但是， 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。这一差别也体现了 set 存储的元素仅仅是键，而没有所关联的值。与 map 一样，set 容器存储的键也必须唯一，而且不能修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 20 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 10 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; set1;</span><br><span class="line">set1.insert(<span class="string">"the"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset2;</span><br><span class="line">iset2. insert( ivec.begin(), ivec.end() );     <span class="comment">// iset2 has 10 elements</span></span><br><span class="line"></span><br><span class="line">iset.find(<span class="number">1</span>);     <span class="comment">// returns iterator that refers to the element with key == 1</span></span><br><span class="line">iset.find(<span class="number">11</span>);   <span class="comment">// returns iterator == iset.end() </span></span><br><span class="line">iset.count(<span class="number">1</span>);    <span class="comment">// returns 1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = isec.find(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>正如不能修改 map 中元素的键部分一样，set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p><h2 id="multimap-和-multiset-类型"><a href="#multimap-和-multiset-类型" class="headerlink" title="multimap 和 multiset 类型"></a>multimap 和 multiset 类型</h2><p>map 和 set 容器中，一个键只能对应一个实例。而 multiset 和 multimap 类型则允许一个键对应多个实例。例如，在电话簿中，每个人可能有单独的电话号码列表。在作者的文章集中，每位作者可能有单独的文章标题列表。<strong>multimap 和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和 set 头文件。</strong></p><p>multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。为了顺应一个键可以对应多个值这一性质，map 和 multimap，或 set 和 multiset 中相同的操作都以不同的方式做出了一定的修改。在使用 multimap 或 multiset 时，对于某个键，必须做好处理多个值的准备，而非只有单一的值。</p><p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p><p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p><p>关联容器 map 和 set 的元素是按顺序存储的， multimap 和 multset 也一样。因此，在 multimap 和 multiset 容器中，如果某个键对应多个实例，则这些实例在容器中将相邻存放。 在 multimap 和 multiset 中查找元素有三种策略，而且三种策略都基于一个事实——在 multimap 中，同一个键所关联的元素必然相邻存放。</p><ul><li>使用 find 和 count 操作</li><li>lower_bound 和 upper_bound</li><li>enual_range 函数</li></ul><p><img src="/posts/64d148d3/004.png" alt="multimap/set查找"></p><p>equal_range 函数返回存储一对迭代器的 pair 对象。如果该值存在，则 pair 对象中的第一个迭代器指向该键关联的第一个实例，第二个迭代器指向该键关联的最后一个实例的下一位置。如果找不到匹配的元素，则 pair 对象中的两个迭代器都将指向此键应该插入的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;authors_it, authors_it&gt; pos = authors.equal_range(search_item); </span><br><span class="line"><span class="keyword">while</span> (pos.first != pos.second) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    ++pos.first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常用泛型算法"><a href="#常用泛型算法" class="headerlink" title="常用泛型算法"></a>常用泛型算法</h1><p>标准库为容器类型定义的操作很少，并没有为每个容器实现更多的操作。因为这部分操作可以抽象出来为所有的容器工作，那就是泛型算法。所谓“泛型”是指这些算法可以应用于多种容器类型上，而容器内的元素类型也可以多样化。标准库提供了 100 多个泛型算法，主要定义于头文件\&lt;algorithm> 中，还有一组泛化的算术算法定义于头文件 \&lt;numeric> 中。</p><p>大多数泛型算法是工作于容器的一对迭代器所标识的范围，并完全通过迭代器来实现其功能。这段由迭代器指定的范围称为“输入范围”。带有输入范围参数的算法总是使用前两个参数标记该范围，分别指向要处理的第一个元素和最后一个元素的下一个位置。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find 和 count 算法在输入范围中查找指定值。find 算法返回引用第一个匹配元素的迭代器，count 算法返回元素在输入序列中出现次数的计数。它们都在输入范围中查找等于 val 的元素，使用基础类型的相等（==）操作符。find 返回第一个匹配元素的迭代器，如果不存在在匹配元素就返回 end。count 返回 val 出现次数的计数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val); </span><br><span class="line">count(beg, end, val);</span><br></pre></td></tr></table></figure></p><p>find 函数的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*first == val)<span class="keyword">return</span> first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个例子，查找数组中的某个值。由于指针就像内置数组上的迭代器一样，因此可以用find在数组中查找值。使用begin和end函数可以获取指向数组首尾元素的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myints[]=&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    p = find(begin(myints), end(myints), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != myints+<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>C++ 中最经常使用的算法应该就是排序算法，也就是 sort 函数。当然还有 partial_sort 以及stable_sort。sort 函数排序默认是从小到大，如果想给自定义类型排序，可以重载运算符或者自定义比较函数。</p><ul><li>升序：sort(begin, end, less&lt;data-type>());</li><li>降序：sort(begin, end, greater&lt;data-type>());<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">43</span>,<span class="number">24</span>,<span class="number">65</span>&#125;,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a,a+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当然，也可以自己写比较函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">100</span>];   </span><br><span class="line">&#125;str[<span class="number">100</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data &amp;elem1, <span class="keyword">const</span> Data &amp;elem2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(elem1.data, elem2.data) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, i;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str[i].data;  </span><br><span class="line">          </span><br><span class="line">        sort(str, str+n, cmp);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i].data &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>unique 的作用是从输入序列中删除”所有相邻的重复元素。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器（容器的长度没变，只是元素顺序改变了），表示无重复的值范围的结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end());   <span class="comment">//排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator end_unique = </span><br><span class="line">            unique(words.begin(), words.end());  <span class="comment">//去重</span></span><br><span class="line">words.erase(end_unique, words.end());  <span class="comment">//删除结尾元素</span></span><br></pre></td></tr></table></figure></p><p>在 STL 中 unique 函数是一个去重函数， unique 的功能是去除相邻的重复元素(只保留一个)，其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中， 返回去重后最后一个元素的地址，因为 unique 去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p><p>源代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">unique</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (first==last) <span class="keyword">return</span> last;</span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (++first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*result == *first))    *(++result)=*first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>fill 函数可以可以向容器当中的一定范围能赋值，一共接受 3 个参数，类似于 memset 函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(beg, end, val)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理自&lt;a href=&quot;https://www.jianshu.com/u/ccb6e3e26ec3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mr希灵&lt;/a&gt;的博文、面经以及《C++ Primer, 5E》等。&lt;/p&gt;
&lt;h1 id=&quot;标准库类型-s
      
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="STL" scheme="https://yz1509.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++面试知识点</title>
    <link href="https://yz1509.github.io//posts/db684f2c/"/>
    <id>https://yz1509.github.io//posts/db684f2c/</id>
    <published>2018-07-28T02:52:52.000Z</published>
    <updated>2019-07-23T15:45:12.407Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。</p><h1 id="C-基础知识点"><a href="#C-基础知识点" class="headerlink" title="C++ 基础知识点"></a>C++ 基础知识点</h1><h2 id="有符号类型和无符号类型"><a href="#有符号类型和无符号类型" class="headerlink" title="有符号类型和无符号类型"></a>有符号类型和无符号类型</h2><ol><li>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数。</li><li>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的；此时，程序可能继续工作、可能崩溃。也可能生成垃圾数据。</li><li>如果表达式中既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动转换成无符号数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-2</span>;<span class="comment">// case 1, b = 4294967294 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 输出 4294967295</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;<span class="comment">// c = -1</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> e = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d + e &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// case 3， 输出 4294967295</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p>引用并非对象，它只是为一个已经存在的对象起的一个别名。在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p><p>指针是指向另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有许多不同点：</p><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝。而且在指针的生命周期内它可以先后指向几个不同的对象。引用不是对象，所以也不能定义指向引用的指针。</li><li>指针无须在定义时赋值。</li></ul><p>void* 是一种特殊的指针类型，可以存放任意对象的地址。但我们对该地址中存放的是什么类型的对象并不了解，所以也不能直接操作 void* 指针所指的对象。</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ul><li>声明为 static 的局部变量，存储在静态存储区，其生存期不再局限于当前作用域，而是整个程序的生存期。</li><li>对于全局变量而言， 普通的全局变量和函数，其作用域为整个程序或项目，外部文件（其它 cpp文件）可以通过 extern 关键字访问该变量和函数；static 全局变量和函数，其作用域为当前 cpp 文件，其它的 cpp 文件不能访问该变量和函数。</li><li>当使用 static 修饰成员变量和成员函数时，表示该变量或函数属于一个类，而不是该类的某个实例化对象。</li></ul><h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><p>const 的作用：</p><ol><li>在定义常变量时必须同时对它初始化，此后它的值不能再改变。常变量不能出现在赋值号的左边（不为“左值”）；</li><li>对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；</li><li>在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li><li>对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator*的返回结果必须是一个const对象，否则下列代码编译出错</span></span><br><span class="line"><span class="keyword">const</span> classA <span class="keyword">operator</span>*(<span class="keyword">const</span> classA&amp; a1,<span class="keyword">const</span> classA&amp; a2);  </span><br><span class="line">classA a, b, c;</span><br><span class="line">(a*b) = c;  <span class="comment">//对a*b的结果赋值。操作(a*b) = c显然不符合编程者的初衷，也没有任何意义</span></span><br></pre></td></tr></table></figure></li></ol><p>用 const 修饰符号常量的区别：</p><ul><li>const 位于 * 的左边，表示被指物是常量</li><li>const 位于 * 的右边，表示指针自身是常量（常量指针）。（口诀：左定值，右定向）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p;  <span class="comment">//指向const对象的指针，指针可以被修改，但指向的对象不能被修改。</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p; <span class="comment">//指向char类型的常量指针，指针不能被修改，但指向的对象可以被修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p;  <span class="comment">//指针及指向对象都不能修改。</span></span><br></pre></td></tr></table></figure></li></ul><p>const 与 #define 的区别：</p><ul><li>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。</li><li>有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</li><li>在 C++ 程序中只使用 const 常量而不使用宏常量，即 const 常量完全取代宏常量。</li></ul><h2 id="数组与指针的区别"><a href="#数组与指针的区别" class="headerlink" title="数组与指针的区别"></a>数组与指针的区别</h2><ul><li>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</li><li>用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量。C/C++ 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</li><li>C++ 编译系统将形参数组名一律作为指针变量来处理。实际上在函数调用时并不存在一个占有存储空间的形参数组，只有指针变量。<ul><li>实参数组名 a 代表一个固定的地址，或者说是指针型常量，因此要改变 a 的值是不可能的。例如：$a++;$ 是错误的。</li><li>形参数组名 array 是指针变量，并不是一个固定的地址值。它的值是可以改变的。例如：$array++;$ 是合法的。</li></ul></li></ul><p>为了节省内存，C/C++ 把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量字符串初始化数组时，情况却有所不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 会为它们分配两个长度为12个字节的空间</span></span><br><span class="line"><span class="comment">// 并把 “Hello World” 的内容分别复制到数组中去，这是两个初始地址不同的数组。</span></span><br><span class="line"><span class="keyword">char</span> str1[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> str2[] = “Hello World”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str3 和 str4 是两个指针，我们无须为它们分配内存以存储字符串的内容</span></span><br><span class="line"><span class="comment">// 而只需要把它们指向 “Hello World” 在内存中的地址就可以了。</span></span><br><span class="line"><span class="comment">// 由于 “Hello World” 是常量字符串，它在内存中只有一个拷贝，</span></span><br><span class="line"><span class="comment">// 因此 str3 和 str4 指向的是同一个地址。</span></span><br><span class="line"><span class="keyword">char</span> *str3[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> *str4[] = “Hello World”;</span><br></pre></td></tr></table></figure></p><h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof 是 C 语言的一种单目操作符，它并不是函数。操作数可以是一个表达式或类型名。数据类型必须用括号括住，$sizeof(int);$， 变量名可以不用括号括住。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>];<span class="comment">//sizeof(a)=200</span></span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];<span class="comment">//sizeof(a)=4;</span></span><br><span class="line">Class Test&#123;<span class="keyword">int</span> a; <span class="keyword">static</span> <span class="keyword">double</span> c&#125;;  <span class="comment">//sizeof(Test)=4</span></span><br><span class="line">Test *s;<span class="comment">//sizeof(s)=4</span></span><br><span class="line">Class Test&#123; &#125;;<span class="comment">//sizeof(Test)=1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> s[<span class="number">5</span>])</span></span>;<span class="comment">//sizeof(s)=4;</span></span><br></pre></td></tr></table></figure></p><p>当操作数不同时需要注意：</p><ul><li>数组类型，其结果是数组的总字节数；指向数组的指针，其结果是该指针的字节数。</li><li>函数中的数组形参或函数类型的形参，其结果是指针的字节数。</li><li>联合类型，其结果采用成员最大长度对齐。</li><li>结构类型或类类型，其结果是这种类型对象的总字节数，包括任何填充在内。<br>对类进行操作时需要注意：</li><li>类中的静态成员不对结果产生影响，因为静态变量的存储位置与结构或者类的实例地址无关;</li><li>没有成员变量的类的大小为 1，因为必须保证类的每一个实例在内存中都有唯一的地址;</li><li>有虚函数的类都会建立一张虚函数表，表中存放的是虚函数的函数指针，这个表的地址存放在类中，所以不管有几个虚函数，都只占据一个指针大小。</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>下列联合体的 sizeof(sampleUnion) 的值为多少。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">short</span> value;</span><br><span class="line">&#125; sampleUnion;</span><br></pre></td></tr></table></figure></li></ol><p>答案：4。联合体占用大小采用成员最大长度的对齐，最大长度是 short 的2字节。但 char flag[3] 需要 3 个字节，所以 sizeof(sampleUnion) =  2 * (2字节) = 4。注意对齐有两层含义，一个是按本身的字节大小数对齐，一个是整体按照最大的字节数对齐。</p><ol><li><p>在 32 位系统中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;<span class="comment">// 没有引号，为 ASCLL 值</span></span><br><span class="line"><span class="keyword">char</span> *str = arr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 5，strlen 函数求取字符串长度以 ASCII 值为 0 为止。</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个空的类型，里面没有任何成员变量和成员函数。<br>问：对该类型求sizeof，得到的结果是什么？<br>答：1。<br>问：为什么不是0？<br>答：当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio 中每个空类型的实例占用 1 字节的空间。<br>问：如果在该类型中添加一个构造函数和析构函数，结果又是什么？<br>答：还是 1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。<br>问：那如果把析构函数标记为虚函数呢？<br>答：C++ 的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在 32 位的机器上，指针占用 4 字节，因此求 sizeof 得到4；如果是  64位机器，将得到 8。</p></li></ol><h2 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h2><p>内存对齐规则：</p><ul><li>每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍。为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。</li><li>最终占用字节数为成员类型中最大占用字节数的整数倍。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></li></ul><p>这个结构体在编译以后，为了字节对齐，会被整理成这个样子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">3</span>];</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p><p>所以编译前总的结构体大小为：8 个字节。编译以后字节大小变为：12 个字节。<br>但是，如果调整顺序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p><p>那么这个结构体在编译前后的大小都是 8 个字节。编译后不用填充字节就能保持所有的成员都按各自默认的地址对齐。这样可以节约不少内存！所以一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少。</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>C++ 中有以下四种命名的强制类型转换：</p><ol><li>static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</li><li>const_cast：去const属性，只能改变运算对象的底层const。常用于有函数重载的上下文中。</li><li>reninterpret_cast：通常为运算对象的位模式提供较低层次的重新解释，本质依赖与机器。</li><li>dynamic_cast：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。主要用于多态类之间的转换。</li></ol><p>一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告；但是当我们执行了显式的类型转换之后，警告信息就被关闭了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>,i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何非常量对象的地址都能存入void*，通过static_cast可以将指针转换会初始的指针类型</span></span><br><span class="line"><span class="keyword">void</span>* p = &amp;slope;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p><p>只有 const_cast 能够改变表达式的常量属性，其他形式的强制类型转换改变表达式的常量属性都将引发编译器错误。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用const_cast去除底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc = &amp;c;</span><br><span class="line"><span class="keyword">char</span>* cp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line">*cp = <span class="string">'c'</span>;</span><br></pre></td></tr></table></figure></p><p>reinterpret_cast 常用于函数指针类型之间进行转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;return0;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FuncPtr)</span><span class="params">()</span></span>; <span class="comment">// FuncPtr是一个指向函数的指针，该函数没有参数，返回值类型为void</span></span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>]; <span class="comment">// 假设你希望把一个指向下面函数的指针存入funcPtrArray数组</span></span><br><span class="line"></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = &amp;doSomething;<span class="comment">// 编译错误！类型不匹配</span></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething); <span class="comment">// 不同函数指针类型之间进行转换</span></span><br></pre></td></tr></table></figure></p><p>dynamic_cast：有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：</p><ul><li>安全的基类和子类之间转换。</li><li>必须要有虚函数。</li><li>相同基类不同子类之间的交叉转换。但结果是NULL。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iNum;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//基类必须有虚函数。保持多态特性才能使用dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span>*m_szName[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* pb =<span class="keyword">new</span> Derive();</span><br><span class="line">Derive *pd1 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，静态类型转换，正确但不推荐</span></span><br><span class="line">Derive *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，动态类型转换，正确</span></span><br><span class="line"></span><br><span class="line">Base* pb2 =<span class="keyword">new</span> Base();</span><br><span class="line">Derive *pd21 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></span><br><span class="line">Derive *pd22 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="malloc-free-与-new-delete-的区别"><a href="#malloc-free-与-new-delete-的区别" class="headerlink" title="malloc/free 与 new/delete 的区别"></a>malloc/free 与 new/delete 的区别</h2><ul><li>malloc 与 free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请和释放动态内存。</li><li>对于非内部数据类型的对象而言，用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free，因此C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，和一个能完成清理与释放内存工作的运算符 delete。</li><li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void* 指针。new/delete 在实现上其实调用了 malloc/free 函数。</li><li>new 建立的是一个对象；malloc 分配的是一块内存。</li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="String-类的实现"><a href="#String-类的实现" class="headerlink" title="String 类的实现"></a>String 类的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString();</span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    ~MyString()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> length();<span class="comment">// 返回字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 返回字符串是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">c_str</span><span class="params">()</span></span>;<span class="comment">// 返回 c 风格的 str 的指针</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;, MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add operation</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compare operations</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数实现运算符重载,其实一般需要返回自身对象的，成员函数运算符重载会好一些</span></span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>)<span class="keyword">const</span>;</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员操作函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">append</span><span class="params">(<span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">insert</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">size_t</span> index = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p_str;</span><br><span class="line">    <span class="keyword">size_t</span> strLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="派生类中构造函数与析构函数的调用顺序"><a href="#派生类中构造函数与析构函数的调用顺序" class="headerlink" title="派生类中构造函数与析构函数的调用顺序"></a>派生类中构造函数与析构函数的调用顺序</h2><p>构造函数的调用顺序总是如下：</p><ol><li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li><li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。</li><li>派生类构造函数。<br>析构函数正好和构造函数相反。</li></ol><h2 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h2><p><strong>虚函数表</strong>：编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的虚函数表是一块连续的内存，每个内存单元中记录一个 JMP 指令的地址。类的每个虚函数占据虚函数表中的一块，如果类中有 N 个虚函数，那么其虚函数表将有 4N 字节的大小。</p><p>编译器在有虚函数的类的实例中创建了一个指向这个表的指针，该指针通常存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能）。这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p><p>有虚函数或虚继承的类实例化后的对象大小至少为 4 字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为 1 字节（没有非静态数据成员的情况下也要有 1 个字节来记录它的地址）。</p><p><strong>哪些函数适合声明为虚函数，哪些不能？</strong></p><ul><li>当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果；</li><li>内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；</li><li>构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数；</li><li>静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。</li></ul><h2 id="虚继承的实现原理"><a href="#虚继承的实现原理" class="headerlink" title="虚继承的实现原理"></a>虚继承的实现原理</h2><p>为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p><p>构造函数和析构函数的顺序：虚基类总是先于非虚基类构造，与它们在集成体系中的次序和位置无关。如果有多个虚基类，则按它们在派生列表中出现的顺序从左到右依次构造。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ZooAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ToyAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ToyAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Character()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Character construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BookCharacter()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BookCharacter construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter, <span class="keyword">public</span> Bear, <span class="keyword">virtual</span> <span class="keyword">public</span> ToyAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    TeddyBear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"TeddyBear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TeddyBear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器按照直接基类的声明顺序依次检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明顺序依次构造其他非虚基类。构造函数的顺序是：ZooAnimal, ToyAnimal, Character, BookCharacter, Bear, TeddyBear。析构过程与构造过程正好相反。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="程序加载时的内存分布"><a href="#程序加载时的内存分布" class="headerlink" title="程序加载时的内存分布"></a>程序加载时的内存分布</h2><p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。</p><p><img src="/posts/db684f2c/001.png" alt="内存分布"></p><ul><li>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</li><li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局 const 变量等。</li><li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li><li>BSS 段(.bss)：未初始化的全局变量和局部静态变量一般放在 .bss 的段里，以节省内存空间。</li><li>堆：用来容纳应用程序动态分配的内存区域。当程序使用 malloc 或 new 分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li><li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li><li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li><li>保留区：内存中受到保护而禁止访问的内存区域。</li></ul><h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol><li>申请管理方式<ul><li>栈：由编译器自动管理，无需我们手工控制。</li><li>堆：堆的申请和释放工作由程序员控制，容易产生内存泄漏。</li></ul></li><li>申请后系统的响应<ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li>申请大小的限制<ul><li>栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 1 M（可修改），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li>申请效率的比较<ul><li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li><li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在 Windows 下，最好的方式是用 VirtualAlloc 分配内存，它不是在堆，也不是在栈而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li></ul></li><li>堆与栈中的存储内容<ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li></ul></li></ol><p><strong>总结</strong>：堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；并且可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，ebp 和局部变量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是向堆申请内存更加灵活，有时候分配大量的内存空间，还是用堆好一些。</p><h2 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h2><ol><li>内存分配未成功，却使用了它，因为没有意识到内存分配会不成功。<br>解决办法：在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 $assert(p != NULL)$ 进行检查。如果是用 malloc 或 new 来申请内存，应该用 $if(p == NULL)$ 或 $if(p != NULL)$ 进行防错处理。</li><li>内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：<ul><li>一是没有初始化的观念；</li><li>二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。<br>解决方法：不要忘记为数组和动态内存赋初值，即便是赋零值也不可省略。防止将未被初始化的内存作为右值使用。</li></ul></li><li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1 ” 或者“少 1 ”的操作。特别是在 for 循环语句中，循环次数很容易搞错，导致数组操作越界。<br>解决方法：避免数组或指针的下标越界，特别要当心发生“多 1 ”或者“少 1 ”操作。</li><li>忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。<br>解决方法：动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定有错误（new/delete 同理）。</li><li>释放了内存却继续使用它。有三种情况：<ul><li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li><li>函数的 return 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li><li>使用 free 或 delete 释放了内存后，没有将指针设置为 NULL。导致产生“野指针”。<br>解决方法：用 free 或 delete 释放了内存之后，立即将指针设置为 NULL，防止产生“野指针”。</li></ul></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是在 \&lt;memory> 头文件中的 std 命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对 RAII “获取资源即初始化”编程至关重要，RAII 的主要原则是将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数，包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。在 C++11 中，定义了 3 种智能指针（unique_ptr、shared_ptr、weak_ptr），并删除了 C++98 中的 auto_ptr。</p><p>智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写 delete 语句删除指针指向的内存空间。</p><p><strong>unique_ptr</strong> “独占”所指向的对象。unique_ptr 小巧高效；大小等同于一个指针且支持 rvalue 引用，从而可实现快速插入和对 STL 集合的检索。</p><p><strong>shared_ptr</strong> 采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用 make_shared 标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的 shared_ptr。</p><p>智能指针支持的操作：</p><ul><li>使用重载的 -&gt; 和 * 运算符访问对象。</li><li>使用get成员函数获取原始指针，提供对原始指针的直接访问。你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</li><li>使用删除器定义自己的释放操作。</li><li>使用 release 成员函数，作用是放弃智能指针对指针的控制权，将智能指针置空，并返回原始指针。（只支持unique_ptr）</li><li>使用 reset 释放智能指针对对象的所有权。</li></ul><p>智能指针的使用示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> _a): a(_a)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up1(<span class="keyword">new</span> Base(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Base&gt; up2 = up1;   //编译器提示未定义</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up2 = move(up1);  <span class="comment">//转移对象的所有权 </span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; up1-&gt;a &lt;&lt; endl; //运行时错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; up2-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//通过解引用运算符获取封装的原始指针 </span></span><br><span class="line">    up2.reset(); <span class="comment">// 显式释放内存 </span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp1(<span class="keyword">new</span> Base(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp2 = sp1;  <span class="comment">//增加引用计数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//2</span></span><br><span class="line">    sp1.reset();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sp2-&gt;a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">auto</span> sp3 = make_shared&lt;base&gt;(<span class="number">4</span>);<span class="comment">//利用make_shared函数动态分配内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="C-对象内存模型"><a href="#C-对象内存模型" class="headerlink" title="C++ 对象内存模型"></a>C++ 对象内存模型</h1><p>在 C++ 中有两种类的数据成员：static 和 nonstatic，以及三种类的成员函数：static、nonstatic和virtual。</p><p>在 C++ 对象模型中</p><ul><li>非静态数据<strong>成员</strong>被配置于每一个类的对象之中，静态数据<strong>成员</strong>则被存放在所有的类对象之外；</li><li>静态及非静态成员<strong>函数</strong>也被放在类对象之外，虚函数则通过以下两个步骤支持：<ol><li>每一个类产生出一堆指向虚函数的指针，放在表格之中，这个表格被称为虚函数表（virtual table, vtbl）。</li><li>每一个类对象被添加了一个指针，指向相关的虚函数表，通常这个指针被称为 vptr。vptr 的设定和重置都由每一个类的构造函数、析构函数和拷贝赋值运算符自动完成。另外，虚函数表地址的前面设置了一个指向 type_info 的指针，RTTI（Run Time Type Identification）运行时类型识别是由编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI 是为多态而生成的信息，所以只有具有虚函数的对象才会生成。</li></ol></li></ul><h2 id="继承下的对象内存模型"><a href="#继承下的对象内存模型" class="headerlink" title="继承下的对象内存模型"></a>继承下的对象内存模型</h2><p>C++支持单一继承、多重继承和虚继承。在虚继承的情况下，虚基类不管在继承链中被派生多少次，永远只会存在一个实体。</p><ol><li>单一继承，继承关系为 class Derived : public Base。其对象的内存布局为：虚函数表指针、Base 类的非 static 成员变量、Derived 类的非 static 成员变量。</li><li>多重继承，继承关系为 class Derived : public Base1, public Base2。其对象的内存布局为：基类 Base1 子对象和基类 Base2 子对象及 Derived 类的非 static 成员变量组成。基类子对象包括其虚函数表指针和其非 static 的成员变量。</li><li><p>重复继承，继承关系如下。Derived 类的对象的内存布局与多继承相似，但是可以看到基类Base 的子对象在 Derived 类的对象的内存中存在一份拷贝。这样直接使用 Derived 中基类 Base 的相关成员时，就会引发歧义，可使用多重虚拟继承消除之。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></li><li><p>虚继承，继承关系如下。其对象的内存布局与重复继承的类的对象的内存分布类似，但是基类Base 的子对象没有拷贝，在对象的内存中仅存在一个 Base 类的子对象。但是它的非 static 成员变量放置在对象的末尾处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></li></ol><p><img src="/posts/db684f2c/002.png" alt="继承下的对象内存模型"></p><h1 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>当仅允许类的一个实例在应用中被创建的时候，我们使用单例模式（Singleton Pattern）。它保护类的创建过程来确保只有一个实例被创建，它通过设置类的构造方法为私有（private）来实现。要获得类的实例，单例类可以提供一个方法，如 GetInstance()，来返回类的实例。该方法是唯一可以访问类来创建实例的方法。</p><p><strong>优点</strong></p><ol><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li><li>避免对资源的多重占用。如避免对同一个资源文件的同时写操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问。</li></ol><p><strong>缺点</strong>：单例模式一般没有接口，扩展困难。不利于测试。</p><p><strong>使用场景</strong></p><ol><li>在整个项目中需要一个共享访问点或共享数据。</li><li>创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。</li><li>需要定义大量的静态常量和静态方法的环境。</li></ol><p><strong>实现</strong>：懒汉实现与饿汉实现</p><ol><li>懒汉实现，即实例化在对象首次被访问时进行。可以使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。同时需将默认构造函数声明为 private，防止用户调用默认构造函数创建对象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Lock();</span><br><span class="line">        <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该类有以下特征：</p><ul><li>它的构造函数是私有的，这样就不能从别处创建该类的实例。</li><li>它有一个唯一实例的静态指针 m_pInstance，且是私有的。</li><li>它有一个公有的函数，可以获取这个唯一的实例，并在需要的时候创建该实例。</li><li>此处进行了两次 m_Instance == NULL 的判断，是借鉴了 Java 的单例模式实现时，使用的所谓的“双检锁”机制。因为进行一次加锁和解锁是需要付出对应的代价的，而进行两次判断，就可以避免多次加锁与解锁操作，同时也保证了线程安全。</li></ul><p>上面的实现存在一个问题，就是没有提供删除对象的方法。一个妥善的方法是让这个类自己知道在合适的时候把自己删除。程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如下面的代码中的 CGarbo 类（Garbo意为垃圾工人）:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="comment">//CGarbo类的唯一工作就是在析构函数中删除CSingleton的实例</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//定义一个静态成员，在程序结束时，系统会调用它的析构函数</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>类 CGarbo 被定义为 Singleton 的私有内嵌类，以防该类被在其他地方滥用。程序运行结束时，系统会调用 Singleton 的静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p><ol><li>饿汉实现：在程序开始时就自行创建实例。如果说懒汉实现是“时间换空间”，那么饿汉实现就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo garbo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。<br><img src="/posts/db684f2c/003.png" alt="简单工厂模式"><br><strong>例子</strong>：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显式地告诉生产工厂。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CTYPE &#123;COREA, COREB&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctype == COREA) <span class="comment">//工厂内部判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();  <span class="comment">//生产核A</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctype == COREB)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB();  <span class="comment">//生产核B</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样设计的主要缺点之前也提到过，就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。于是，工厂方法模式出现了。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。<br><img src="/posts/db684f2c/004.png" alt="工厂方法模式"><br>例子：这家生产处理器核的厂家赚了不少钱，于是决定再开设一个工厂专门用来生产 B 型号的单核，而原来的工厂专门用来生产 A 型号的单核。这时，客户要做的是找好工厂，比如要 A 型号的核，就找 A 工厂要；否则找 B 工厂要，不再需要告诉工厂具体要什么型号的处理器核了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产A核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产B核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在 C++ 实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><img src="/posts/db684f2c/005.png" alt="抽象工厂模式"><br>例子：这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span><span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreA</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreB</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span><span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span> <span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理自&lt;a href=&quot;https://www.jianshu.com/u/ccb6e3e26ec3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mr希灵&lt;/a&gt;的博文、面经以及《C++ Primer, 5E》等。&lt;/p&gt;
&lt;h1 id=&quot;C-基础知识点
      
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://yz1509.github.io//posts/ee040603/"/>
    <id>https://yz1509.github.io//posts/ee040603/</id>
    <published>2018-07-26T05:17:37.000Z</published>
    <updated>2018-07-27T14:20:16.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h1><p><strong>定义</strong> 一个图 $G = (V, E)$ 由顶点（或结点）的非空集 $V$ 和边的集合 $E$ 构成，每条边有一个或两个顶点与它相连，这样的顶点称为边的端点。边连接它的端点。</p><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><ul><li>邻接链表：稀疏图</li><li>邻接矩阵：稠密图，或者需要快速判断任意两个结点之间是否有边的情况<br><img src="/posts/ee040603/001.png" alt="图的表示"></li></ul><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** u.color 存放结点 u 的颜色属性</span></span><br><span class="line"><span class="comment">  * 白色表示未被发现</span></span><br><span class="line"><span class="comment">  * 灰色表示邻接结点中还有白色结点</span></span><br><span class="line"><span class="comment">  * 黑色表示邻接结点均被发现</span></span><br><span class="line"><span class="comment">  * u.π 存放前驱结点</span></span><br><span class="line"><span class="comment">  * u.d 存放从源结点 s 到结点 u 之间的距离</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">BFS(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V - &#123;s&#125;</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = ∞</span><br><span class="line">        u.π = NIL</span><br><span class="line">    s.color = BLACK</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.π = NIL</span><br><span class="line">    Q = ∅</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅<span class="comment">// 灰色结点的集合</span></span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v in G.Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.π = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><blockquote><p>BFS 的总运行时间为 O(V + E)</p></blockquote><p><img src="/posts/ee040603/002.png" alt="BFS"></p><h2 id="BFS-的性质"><a href="#BFS-的性质" class="headerlink" title="BFS 的性质"></a>BFS 的性质</h2><ol><li>BFS 可以计算出从源结点 s 到 结点 v 的最短路径。</li><li>BFS 在对图进行搜索的过程中将创建一棵广度优先树</li></ol><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** u.color 存放结点 u 的颜色属性</span></span><br><span class="line"><span class="comment">  * 白色表示未被发现</span></span><br><span class="line"><span class="comment">  * 灰色表示邻接结点中还有白色结点</span></span><br><span class="line"><span class="comment">  * 黑色表示邻接结点均被发现</span></span><br><span class="line"><span class="comment">  * u.π 存放前驱结点</span></span><br><span class="line"><span class="comment">  * u.d 记录结点 u 第一次被发现的时间</span></span><br><span class="line"><span class="comment">  * u.f 记录搜索完成对 u 的邻接链表扫描的事件</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">DFS(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            DFS-VISIT(G, u)</span><br><span class="line"></span><br><span class="line">DFS-VISIT(G, u)</span><br><span class="line">    time = time + <span class="number">1</span><span class="comment">// white vertex u has just been discovered</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each v in G.Adj[u]<span class="comment">// explore edge (u, v)</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT(G, v)</span><br><span class="line">    u.color = BLACK<span class="comment">// blacken u, it is finished</span></span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></table></figure><blockquote><p>DFS 的总运行时间为 O(V + E)</p></blockquote><p><img src="/posts/ee040603/003.png" alt="DFS"></p><h2 id="DFS-的性质"><a href="#DFS-的性质" class="headerlink" title="DFS 的性质"></a>DFS 的性质</h2><ol><li>括号化定理：在对有向或无向图进行的任意 DFS 中，对于任意两个结点 u 和 v 来说，下面三种情况只有一种成立：<ul><li>区间 $[u.d, u.f]$ 和 区间 $[v.d, v.f$ 完全分离，在深度优先森林中，结点 u 不是结点 v 的后代，结点 v 也不是结点 u 的后代</li><li>区间 $[u.d, u.f]$ 完全包含在 区间 $[v.d, v.f$ 内，在深度优先树中，结点 u 是结点 v 的后代</li><li>区间 $[v.d, v.f]$ 完全包含在 区间 $[u.d, u.f$ 内，在深度优先树中，结点 v 是结点 u 的后代</li></ul></li><li>边的分类<ul><li>树边：是深度优先森林 $G_π$ 中的边。如果结点  v 是因算法对边 (u, v) 的探索而首先被发现，则 (u, v) 是一条树边</li><li>后向边：是将结点 u 连接到其在深度优先树中祖先结点 v 的边。由于有向图中可以有自循环，自循环也被认为是后向边</li><li>前向边：是将结点 u 连接到其在深度优先树中后代结点 v 的边</li><li>横向边：其他所有的边<blockquote><p>在对无向图 G 进行深度优先搜索时，每条边要么是树边，要么是后向边。</p></blockquote></li></ul></li></ol><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对于一个有向无环图 G(V, E) 来说，其拓扑排序是 G 中所有结点的一种线性次序，该次序满足如下条件：如果图 G 包含边 (u, v)，则结点 u 在拓扑排序中处于结点 v 的前面。<br><img src="/posts/ee040603/004.png" alt="拓扑排序"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">    call DFS(G) to compute finishing time v.f for each vertex v</span><br><span class="line">    as each vertex is finished, insert it onto the front of a linked <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">return</span> the linked of <span class="built_in">list</span> of vertices</span><br></pre></td></tr></table></figure></p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p><strong>定义：</strong> 如果一个有向图中任意两个顶点互相可达，则该有向图是强连通的。<br>图 G 的转置 $G^T = (V, E^T)$，其中 $E^T = {(u, v): (u, v) \in E}$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED-COMPONENTS(G)</span><br><span class="line">    call DFS(G) to compute finishing time u.f for each vertex u</span><br><span class="line">    compute G^T</span><br><span class="line">    call DFS(G^T), but in the main loop of DFS, consider the vertices</span><br><span class="line">        in order of decreasing u.f (as computed in line <span class="number">1</span>)</span><br><span class="line">    output the vertices of each tree in the depth-first forest formed</span><br><span class="line">        in line <span class="number">3</span> as a separate strongly connected component</span><br></pre></td></tr></table></figure></p><p><img src="/posts/ee040603/005.png" alt="强连通分量"></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>定义：</strong> 连通加权图里的最小生成树是具有边的权值之和最小的生成树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在每遍循环之前，A 是某棵最小生成树的一个子集</span></span><br><span class="line"><span class="comment">// 加入集合 A 而不会破坏 A 的循环不变式的边称为集合 A 的安全边</span></span><br><span class="line">GENERIC-MST(G, w)</span><br><span class="line">    A = ∅</span><br><span class="line">    <span class="keyword">while</span> A does <span class="keyword">not</span> form a spanning tree</span><br><span class="line">        find an edge(u, v) that is safe <span class="keyword">for</span> A</span><br><span class="line">        A = A ∪ &#123;(u, v)&#125;</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p><p><strong>定理：</strong> 设 G = (V, E) 是一个在边 E 上定义了实数值权重函数 w 的连通无向图。设集合 A 为 E 的一个子集，且 A 包括在图 G 的某棵最小生成树中，设 (S, V - S) 是图 G 中尊重集合 A 的任意一个切割（集合 A 中不存在横跨该切割的边），又设 (u, v) 是横跨切割 (S, V - S) 的一条轻边。那么边 (u, v) 对于集合 A 是安全的。</p><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>在 Kurskal 算法中，集合 A 是一个森林，其结点就是给定图的结点。每次加入集合 A 中的安全边永远是权重最小的连接两个不同分量的边。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MST-KRUSKAL(G, w)</span><br><span class="line">    A = ∅</span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V</span><br><span class="line">        MAKE-SET(v)</span><br><span class="line">    sort the edge of G.E into nondecreasing order by weight w</span><br><span class="line">    <span class="keyword">for</span> each edge (u, v) in G.E, taken in nondecreasing order by weight</span><br><span class="line">        <span class="keyword">if</span> FIND-SET(u) ≠ FIND-SET(v)</span><br><span class="line">            A = A ∪ &#123;(u, v)&#125;</span><br><span class="line">            UNION(u, v)</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p><blockquote><p>Kruskal 算法的时间复杂度为 $O(ElgV)$。</p></blockquote><p><img src="/posts/ee040603/006.png" alt="Kruskal 算法"></p><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>在 Prim 算法里，集合 A 则是一棵树。这棵树从一个任意的根结点 r 开始，一直长大到覆盖 V 中的所有结点时为止。每次加入到 A 中的安全边永远是连接 A 和 A 之外某个结点的边中权重最小的边。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MST-PRIM(G, w, r)</span><br><span class="line">    <span class="keyword">for</span> each u in G.V</span><br><span class="line">        u.key = ∞</span><br><span class="line">        u.π = NIL</span><br><span class="line">    r.key = <span class="number">0</span></span><br><span class="line">    Q = G.V</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅</span><br><span class="line">        u = EXTRACT-MIN(Q)</span><br><span class="line">        <span class="keyword">for</span> each v in G.Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v in Q <span class="keyword">and</span> w(u, v) &lt; v.key</span><br><span class="line">                v.π = u</span><br><span class="line">                v.key = w(u, v)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 $O(ElgV)$；<br>如果使用斐波那契堆来实现最小优先队列 Q，则 Prim 算法的运行时间将改进到 $O(E + VlgV)$</p></blockquote><p><img src="/posts/ee040603/007.png" alt="Prim算法"></p><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><ol><li>最短路径的子路径也是最短路径</li><li>如果从结点 s 到结点 v 的某条路径上存在权重为负值的环路，我们定义 $\delta(s, v) = -\infty$</li><li>一般地，我们假定在找到的最短路径中没有环路，即它们都是简单路径。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始化</span></span><br><span class="line"><span class="comment">  * v.d：s 到 v 的最短路径估计</span></span><br><span class="line"><span class="comment">  * v.π：前驱结点</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V</span><br><span class="line">        v.d = ∞</span><br><span class="line">        v.π = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 松弛操作</span></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v)</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.π = u</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>Dijkstra 算法和用于有向无环图的最短路径算法对每条边仅松弛一次。 Bellman-Ford 算法则对每条边松弛 |V| - 1 次。</p></blockquote><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法解决的是一般情况下的最短路径问题。该算法返回 TRUE 值当且仅当输入图不包含可以从源结点到达的权重为负值的环路。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s)</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V|<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u, v) in G.E</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge (u, v) in G.E</span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v)</span><br><span class="line">            <span class="keyword">return</span> FALSE</span><br><span class="line">    <span class="keyword">return</span> TRUE</span><br></pre></td></tr></table></figure></p><blockquote><p>Bellman-Ford 算法的总运行时间为 O(VE)<br><img src="/posts/ee040603/008.png" alt="Bellman-Ford 算法"></p></blockquote><h2 id="有向无环图中的单源最短路径问题"><a href="#有向无环图中的单源最短路径问题" class="headerlink" title="有向无环图中的单源最短路径问题"></a>有向无环图中的单源最短路径问题</h2><p>根据结点的拓扑排序次序来对带权重的有向无环图 G = (V, E) 进行边的松弛操作，我们便可以在 $O(V + E)$ 时间内计算出从单个源结点到所有结点之间的最短路径。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DAG-SHOPTEST-PATHS(G, w, s)</span><br><span class="line">    topologically sort the vertice of G</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex u, taken in topologically sorted order</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.Adj[u]</span><br><span class="line">            RELAX(u, v, w)</span><br></pre></td></tr></table></figure></p><p><img src="/posts/ee040603/009.png" alt="DAG"></p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra 算法解决的是带权重的有向图上的单源最短路径问题，该算法要求所有边的权重都为非负值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = ∅</span><br><span class="line">    Q = G.V</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅</span><br><span class="line">        u = EXTRACT-MIN(Q)</span><br><span class="line">        S = S ∪ &#123;u&#125;</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.Adj[u]</span><br><span class="line">            RELAX(u, v, w)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 $O(ElgV)$；<br>如果使用斐波那契堆来实现最小优先队列 Q，则 Dijkstra 算法的运行时间将改进到 $O(E + VlgV)$</p></blockquote><p><img src="/posts/ee040603/010.png" alt="Dijsktra算法"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是图&quot;&gt;&lt;a href=&quot;#什么是图&quot; class=&quot;headerlink&quot; title=&quot;什么是图&quot;&gt;&lt;/a&gt;什么是图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; 一个图 $G = (V, E)$ 由顶点（或结点）的非空集 $V$ 和边的集合 $E
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="图" scheme="https://yz1509.github.io/tags/%E5%9B%BE/"/>
    
      <category term="BFS" scheme="https://yz1509.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://yz1509.github.io/tags/DFS/"/>
    
      <category term="拓扑排序" scheme="https://yz1509.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="强连通分量" scheme="https://yz1509.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="最小生成树" scheme="https://yz1509.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Kruskal 算法" scheme="https://yz1509.github.io/tags/Kruskal-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Prim 算法" scheme="https://yz1509.github.io/tags/Prim-%E7%AE%97%E6%B3%95/"/>
    
      <category term="单源最短路径" scheme="https://yz1509.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Bellman-Ford 算法" scheme="https://yz1509.github.io/tags/Bellman-Ford-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra 算法" scheme="https://yz1509.github.io/tags/Dijkstra-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>吐血bug合集（持续更新）</title>
    <link href="https://yz1509.github.io//posts/afec8fb8/"/>
    <id>https://yz1509.github.io//posts/afec8fb8/</id>
    <published>2018-07-25T12:23:21.000Z</published>
    <updated>2018-08-06T08:49:30.752Z</updated>
    
    <content type="html"><![CDATA[<ol><li>图片后缀名的大小写有区别，比如 ![avatar](sample.png) 本地可以正常加载 sample.PNG，但是上传后静态网页加载失败 = =</li><li>使用表格时，一定要前后都有空行，不然显示出 bug.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;图片后缀名的大小写有区别，比如 ![avatar](sample.png) 本地可以正常加载 sample.PNG，但是上传后静态网页加载失败 = =&lt;/li&gt;
&lt;li&gt;使用表格时，一定要前后都有空行，不然显示出 bug.&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="其他" scheme="https://yz1509.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="bug" scheme="https://yz1509.github.io/tags/bug/"/>
    
      <category term="图片显示" scheme="https://yz1509.github.io/tags/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/"/>
    
  </entry>
  
</feed>
