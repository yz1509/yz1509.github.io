<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HTT</title>
  
  <subtitle>ふわふわ時間</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yz1509.github.io/"/>
  <updated>2020-09-07T04:06:24.434Z</updated>
  <id>https://yz1509.github.io/</id>
  
  <author>
    <name>KyoAni</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Efficient State-based CRDTs by Delta-Mutation</title>
    <link href="https://yz1509.github.io//posts/82db3c39/"/>
    <id>https://yz1509.github.io//posts/82db3c39/</id>
    <published>2020-09-07T04:02:54.000Z</published>
    <updated>2020-09-07T04:06:24.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Efficient State-based CRDTs by Delta-Mutation 阅读笔记。</p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Efficient State-based CRDTs by Delta-Mutation 阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过四级没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E5%9B%9B%E7%BA%A7%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="最终一致性" scheme="https://yz1509.github.io/tags/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="CRDT" scheme="https://yz1509.github.io/tags/CRDT/"/>
    
  </entry>
  
  <entry>
    <title>Redis Modules APIs</title>
    <link href="https://yz1509.github.io//posts/3720c85c/"/>
    <id>https://yz1509.github.io//posts/3720c85c/</id>
    <published>2020-08-27T02:45:48.000Z</published>
    <updated>2020-09-01T10:29:14.267Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Redis Modules APIs 介绍。</p><a id="more"></a><hr><p><a href="https://github.com/redis/redis/blob/unstable/src/module.c">源码地址</a></p><h2 id="内存管理">内存管理</h2><p>虽然在模块中可以调用 <code>malloc()</code> 和 <code>free()</code> 函数，但是通过 <code>malloc()</code> 分配的内存并不会被计算到 <code>used_memory</code> 信息中去，也不会受到 <code>maxmemory</code> 限制，所以应首先考虑使用 Redis Modules 提供的 APIs。而且，使用 APIs 分配内存实现的自定义数据结构也可以被 RDB 加载函数正确地反序列化。</p><p>在函数返回时就需释放的短期对象可使用内存池模式进行分配。内存对齐原则为：</p><ul><li>若申请的内存大于 <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word size</a>，则按 <code>word size</code> 对齐</li><li>若申请的内存小于 <code>word size</code>，则按 2 的幂字节对齐</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Use like malloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Alloc</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like calloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like realloc() for memory obtained with RedisModule_Alloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like free() for memory obtained by RedisModule_Alloc()</span></span><br><span class="line"><span class="comment"> * and RedisModule_Realloc() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use like strdup() but returns memory allocated with RedisModule_Alloc(). */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_Strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return heap allocated memory that will be freed automatically when the</span></span><br><span class="line"><span class="comment"> * module callback function returns */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_PoolAlloc</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable automatic memory management.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function must be called as the first function of a command implementation</span></span><br><span class="line"><span class="comment"> * that wants to use automatic memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_AutoMemory</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For a given pointer allocated via RedisModule_Alloc() or</span></span><br><span class="line"><span class="comment"> * RedisModule_Realloc(), return the amount of memory allocated for it.</span></span><br><span class="line"><span class="comment"> * Note that this may be different (larger) than the memory we allocated</span></span><br><span class="line"><span class="comment"> * with the allocation calls, since sometimes the underlying allocator</span></span><br><span class="line"><span class="comment"> * will allocate more memory. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">RedisModule_MallocSize</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the a number between 0 to 1 indicating the amount of memory</span></span><br><span class="line"><span class="comment"> * currently used, relative to the Redis &quot;maxmemory&quot; configuration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 - No memory limit configured.</span></span><br><span class="line"><span class="comment"> * Between 0 and 1 - The percentage of the memory used normalized in 0-1 range.</span></span><br><span class="line"><span class="comment"> * Exactly 1 - Memory limit reached.</span></span><br><span class="line"><span class="comment"> * Greater 1 - More memory used than the configured limit. */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RedisModule_GetUsedMemoryRatio</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="service-api-exported-to-modules">Service API exported to modules</h2><h3 id="注册命令">注册命令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a new command in the Redis server. The function returns REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if the specified command name is already busy or a set of invalid flags were</span></span><br><span class="line"><span class="comment"> * passed, otherwise REDISMODULE_OK is returned and the new command is registered. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CreateCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name, RedisModuleCmdFunc cmdfunc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *strflags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> firstkey, <span class="keyword">int</span> lastkey, <span class="keyword">int</span> keystep)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数必须在 <code>RedisModule_OnLoad()</code> 中调用，命令的执行由传入的 <code>cmdfunc</code> 完成，其 <code>prototype</code> 如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The command function type is the following,</span></span><br><span class="line"><span class="comment"> * and is supposed to always return REDIMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCmd_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span>;</span><br></pre></td></tr></table></figure><p><code>strflags</code> 确定了该命令的行为模式，其值的列表如下，如要传递多个 flags，则以空格隔开.</p><ul><li><code>write</code>: The command may modify the data set(it may also read from it)</li><li><code>readonly</code>: The command returns data from keys but never writes</li><li><code>admin</code>: The command is an administrative command (may change replication or perform similar tasks).</li><li><code>deny-oom</code>: The command may use additional memory and should be denied during out of memory conditions.</li><li><code>deny-script</code>: Don't allow this command in Lua scripts.</li><li><code>allow-loading</code>: Allow this command while the server is loading data. Only commands not interacting with the data set should be allowed to run in this mode. If not sure don't use this flag.</li><li><code>pubsub</code>: The command publishes things on Pub/Sub channels.</li><li><code>random</code>: The command may have different outputs even starting from the same input arguments and key values.</li><li><code>allow-stale</code>: The command is allowed to run on slaves that don't serve stale data. Don't use if you don't know what this means.</li><li><code>no-monitor</code>: Don't propagate the command on monitor. Use this if the command has sensible data among the arguments.</li><li><code>no-slowlog</code>: Don't log this command in the slowlog. Use this if the command has sensible data among the arguments.</li><li><code>fast</code>: The command time complexity is not greater than O(log(N)) where N is the size of the collection or anything else representing the normal scalability issue with the command.</li><li><code>getkeys-api</code>: The command implements the interface to return the arguments that are keys. Used when start/stop/step is not enough because of the command syntax.</li><li><code>no-cluster</code>: The command should not register in Redis Cluster since is not designed to work with it because, for example, is unable to report the position of the keys, programmatically creates key names, or any other reason.</li><li><code>no-auth</code>: This command can be run by an un-authenticated client. Normally this is used by a command that is used to authenticate a client.</li></ul><p><code>firstkey</code> 表明在执行该注册的命令之时，需要读取的首个 key，其值为 0 则视为无需读取 key，<code>lastkey</code> 亦是如此。</p><h3 id="其他">其他</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lookup the requested module API and store the function pointer</span></span><br><span class="line"><span class="comment"> * into the target pointer. The function returns REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if there is no such named API, otherwise REDISMODULE_OK.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is not meant to be used by modules developer, it is only</span></span><br><span class="line"><span class="comment"> * used implicitly by including redismodule.h. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetApi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *funcname, <span class="keyword">void</span> **targetPtrPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command, that was declared with the</span></span><br><span class="line"><span class="comment"> * flag &quot;getkeys-api&quot;, is called in a special way to get the keys</span></span><br><span class="line"><span class="comment"> * position and not to get executed. Otherwise zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsKeysPositionRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uses this function to report keys.</span></span><br><span class="line"><span class="comment"> * example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     if (RedisModule_IsKeysPositionRequest(ctx)) &#123;</span></span><br><span class="line"><span class="comment"> *         RedisModule_KeyAtPos(ctx,1);</span></span><br><span class="line"><span class="comment"> *         RedisModule_KeyAtPos(ctx,2);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_KeyAtPos</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called by RM_Init() to setup the ctx-&gt;module structure */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetModuleAttribs</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> ver, <span class="keyword">int</span> apiver)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if the module name is busy. Otherwise zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsModuleNameBusy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current UNIX time in milliseconds. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_Milliseconds</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set flags defining capabilities or behavior bit flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i.e. REDISMODULE_OPTIONS_HANDLE_IO_ERRORS:</span></span><br><span class="line"><span class="comment"> * Generally, modules don&#x27;t need to bother with this, as the process will just</span></span><br><span class="line"><span class="comment"> * terminate if a read error happens, however, setting this flag would allow</span></span><br><span class="line"><span class="comment"> * repl-diskless-load to work if enabled.</span></span><br><span class="line"><span class="comment"> * The module should use RedisModule_IsIOError after reads, before using the</span></span><br><span class="line"><span class="comment"> * data that was read, and in case of error, propagate it upwards, and also be</span></span><br><span class="line"><span class="comment"> * able to release the partially populated value and all it&#x27;s allocations. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetModuleOptions</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Signals that the key is modified from user&#x27;s perspective</span></span><br><span class="line"><span class="comment"> * i.e. invalidate WATCH and client side caching. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SignalModifiedKey</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="redismodulestring-objects-apis">RedisModuleString objects APIs</h2><h3 id="create">Create</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new module string object by copying the len bytes starting ar ptr.</span></span><br><span class="line"><span class="comment"> * No reference is retained to the passed buffer. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string object from a printf format and arguments.</span></span><br><span class="line"><span class="comment"> * The string is created using the sds formatter function sdscatvprintf(). */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringPrintf</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a long long integer */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromLongLong</span><span class="params">(RedisModuleCtx *ctx</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a double */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromDouble</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from a long double */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromLongDouble</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> <span class="keyword">double</span> ld, <span class="keyword">int</span> humanfriendly)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new module string from another RedisModuleString */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在未启用自动内存管理功能时，上述接口所返回的对象必须调用 <code>RedisModule_FreeString()</code> 进行释放</li><li>当你想在上下文范围之外创建一个 <code>RedisModuleString</code> 对象时，<code>ctx</code> 可设置为 <code>NULL</code>，此时，自动内存管理功能不可用，你必须手动进行释放操作</li></ul><h3 id="free">Free</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a module string object obtained with one of the</span></span><br><span class="line"><span class="comment"> * Redis Module API calls that return new string objects. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在启用自动内存管理的情况下，我们仍然可以调用该函数，会立即释放传入的 <code>RedisModuleString</code>，并从字符串待释放列表中移除该对象</li><li>如果在创建 <code>RedisModuleString</code> 时上下文为 <code>NULL</code>，则在释放时上下文也可为 <code>NULL</code>，不过此时上下文不为 <code>NULL</code> 也没啥问题。但如果创建时上下文不为空，则在释放时也不可为空。</li></ul><h3 id="retain">Retain</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_RetainString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>通常而言，只有在以下条件都满足时，才会调用这个函数：</p><ul><li>You have automatic memory management enabled</li><li>You want to create string objects</li><li>Those string objects you create need to live after the callback function creating them returns</li></ul></li><li><p>每次调用该函数，必须额外调用一次 <code>RedisModule_FreeString()</code> 以真正释放内存。</p></li><li><p>在该函数中，上下文也可以为空。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_HoldString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在 <code>RedisModule_RetainString()</code> 中只有在无法从字符串待释放列表中移除该字符串时，才会增加引用次数；而调用 <code>RedisModule_HoldString()</code> 总是会成功达到目的。</li><li>调用该函数时，在传入字符串的引用次数达到上限 <code>INT_MAX - 1</code> 时，调用 <code>RedisModule_CreateStringFromString()</code> 复制，返回副本的指针；否则，增加引用次数，返回传入字符串指针。所以该函数比 <code>RedisModule_CreateStringFromString()</code> 效率更高。</li><li>在未开启自动内存管理时，需要手动调用 <code>RedisModule_FreeString()</code>。</li><li>在该函数中，上下文也可以为空。</li></ul><h3 id="convert">Convert</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the string pointer and length of the given module string.</span></span><br><span class="line"><span class="comment"> * Return value should only be used for read only access and never modified. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_StringPtrLen</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a long long integer, storing it at *ll.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success. if the string can&#x27;t be parsed as a valid,</span></span><br><span class="line"><span class="comment"> * strict long long(no sapces before/after), REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToLongLong</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">long</span> <span class="keyword">long</span> *ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a double, storing it at *d.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success or REDISMODULE_ERR</span></span><br><span class="line"><span class="comment"> * if the string is not a valid string representation of a double value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToDouble</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">double</span> *d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the string into a long double, storing it at *ld.</span></span><br><span class="line"><span class="comment"> * Return REDISMODULE_OK on success or REDISMODULE_ERR if the</span></span><br><span class="line"><span class="comment"> * string is not a valid string representation of a long double value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringToLongDouble</span><span class="params">(<span class="keyword">const</span> RedisModuleString *str, <span class="keyword">long</span> <span class="keyword">double</span> *ld)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="operators">Operators</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare two string objects, returning -1, 0 or 1 respectively if a &lt; b,</span></span><br><span class="line"><span class="comment"> * a == b or a &gt; b. String are compared byte by byte as two binary blobs</span></span><br><span class="line"><span class="comment"> * without any encoding care/collation attempt. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringCompare</span><span class="params">(RedisModuleString *a, RedisModuleString *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Append the specified buffer to the string str. The string must be</span></span><br><span class="line"><span class="comment"> * a string created by the user that is referenced only a single time,</span></span><br><span class="line"><span class="comment"> * otherwise REDISMOUDLE_ERR is returned and the operation is not performed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringAppendBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *str,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="reply-apis">Reply APIs</h2><h3 id="reply-with-numeral">Reply with numeral</h3><p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send an integer reply to the client, with the specified long long value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithLongLong</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a string reply obtained converting the double &#x27;d&#x27; into a bulk string.</span></span><br><span class="line"><span class="comment"> * This function is basically equivalent to converting a double into a string</span></span><br><span class="line"><span class="comment"> * into a C buffer, and then calling the function</span></span><br><span class="line"><span class="comment"> * RedisModule_ReplyWithStringBuffer() with the buffer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithDouble</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a string reply obtained converting the long double &#x27;ld&#x27; into a bulk</span></span><br><span class="line"><span class="comment"> * string. This function is basically equivalent to converting a long double</span></span><br><span class="line"><span class="comment"> * into a string into a C buffer, and then calling the function</span></span><br><span class="line"><span class="comment"> * RedisModule_ReplyWithStringBuffer() with the buffer and length.</span></span><br><span class="line"><span class="comment"> * The double string uses human readable formatting</span></span><br><span class="line"><span class="comment"> * (see addReplyHumanLongDouble in networking.c). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithLongDouble</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> <span class="keyword">double</span> ld)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="reply-with-string">Reply with string</h3><p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reply with a simple string(+...\r\n in RESP protocol). This replies are</span></span><br><span class="line"><span class="comment"> * suitable only when sending a small non-binary string with small overhead,</span></span><br><span class="line"><span class="comment"> * like &quot;OK&quot; or similar replies. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithSimpleString</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a C buffer pointer</span></span><br><span class="line"><span class="comment"> * that is assumed to be null-terminated. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithCString</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a C buffer pointer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithStringBuffer</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a bulk string, taking in input a RedisModuleString object. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with an empty string */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithEmptyString</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a binary safe string, which should not be escaped or filtered</span></span><br><span class="line"><span class="comment"> * taking in input a C buffer pointer and length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithVerbatimString</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="reply-with-array">Reply with array</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reply with an array type of &#x27;len&#x27; elements.</span></span><br><span class="line"><span class="comment"> * However &#x27;len&#x27; other calls to ReplyWith* style functions must follow in order to</span></span><br><span class="line"><span class="comment"> * emit the elements of the array. The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithArray</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When RedisModule_ReplyWithArray() is used with the argument</span></span><br><span class="line"><span class="comment"> * REDISMODULE_POSTPONED_ARRAY_LEN, because we don&#x27;t know beforehand the number</span></span><br><span class="line"><span class="comment"> * of items we are going to output as elements of the array, this function will</span></span><br><span class="line"><span class="comment"> * take care to set the array length.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since it is possible to have multiple array replies pending with unknown</span></span><br><span class="line"><span class="comment"> * length, this function guarantees to always set the latest array length</span></span><br><span class="line"><span class="comment"> * that was created in a postponed way. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ReplySetArrayLength</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to the client with a null array, simple null in RESP3</span></span><br><span class="line"><span class="comment"> * null array in RESP2. The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithNullArray</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to client with an empty array.</span></span><br><span class="line"><span class="comment"> * The function always returns REDISMODULE_OK. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithEmptyArray</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="others">Others</h3><p>以下函数返回值固定为 <code>REDISMODULE_OK</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send an error about the number of arguments given to the command,</span></span><br><span class="line"><span class="comment"> * citing the command name in the error message. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_WrongArity</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply to client with a NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithNull</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with the error &#x27;err&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that &#x27;err&#x27; must contain all the error, including</span></span><br><span class="line"><span class="comment"> * the initial error code. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithError</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply exactly what a Redis command returned us with RedisModule_Call().</span></span><br><span class="line"><span class="comment"> * This function is useful when we use RedisModule_Call() in order to execute</span></span><br><span class="line"><span class="comment"> * some command, as we want to reply to the client exactly the same reply</span></span><br><span class="line"><span class="comment"> * we obtained by the command. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithCallReply</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RedisModuleCallReply *reply)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="commands-replication-apis">Commands replication APIs</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replicate the specified command and arguments to slaves and AOF, as effect</span></span><br><span class="line"><span class="comment"> * of execution of the calling command implementation. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Replicate</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>复制的命令在 <code>MULTI/EXEC</code> 块中，其包含在该 module command 执行期间调用的所有命令，在 <code>MULTI/EXEC</code> 块中，通过 <code>RedisModule_Call()</code> 复制的命令在前，<code>RedisModule_Replicate</code> 复制的命令在后。Modules 应该只使用两个接口其中一个。</li><li>该函数的接口和 <code>RedisModule_Call()</code> 相同，可查看 <code>RedisModule_Call()</code> 了解详情</li><li>格式说明符非法或不存在该 <code>cmdname</code> 时，函数返回 <code>REDISMODULE_ERR</code></li></ul><blockquote><p>Note about calling this function from a thread safe context: Normally when you call this function from the callback implementing a module command, or any other callback provided by the Redis Module API, Redis will accumulate all the calls to this function in the context of the callback, and will propagate all the commands wrapped in a MULTI/EXEC transaction. However when calling this function from a threaded safe context that can live an undefined amount of time, and can be locked/unlocked in at will, the behavior is different: MULTI/EXEC wrapper is not emitted and the command specified is inserted in the AOF and replication stream immediately.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replicate the command exactly as it was invoked by the client. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplicateVerbatim</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>复制的命令不会包含在 <code>MULTI/EXEC</code> 块中，所以不要和其他命令复制的接口混用</li><li>常用于想将客户端请求的命令直接复制转发至 <code>slave</code> 或 <code>AOF</code> 的场景</li><li>返回值固定为 <code>REDISMODULE_OK</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if some client sent the CLIENT PAUSE command to the server or</span></span><br><span class="line"><span class="comment"> * if Redis Cluster is doing a manual failover, and paused tue clients.</span></span><br><span class="line"><span class="comment"> * This is needed when we have a master with replicas, and want to write,</span></span><br><span class="line"><span class="comment"> * without adding further data to the replication channel, that the replicas</span></span><br><span class="line"><span class="comment"> * replication offset, match the one of the master. When this happens, it is</span></span><br><span class="line"><span class="comment"> * safe to failover the master without data loss.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However modules may generate traffic by calling RedisModule_Call() with</span></span><br><span class="line"><span class="comment"> * the &quot;!&quot; flag, or by calling RedisModule_Replicate(), in a context outside</span></span><br><span class="line"><span class="comment"> * commands execution, for instance in timeout callbacks, threads safe</span></span><br><span class="line"><span class="comment"> * contexts, and so forth. When modules will generate too much traffic, it</span></span><br><span class="line"><span class="comment"> * will be hard for the master and replicas offset to match, because there</span></span><br><span class="line"><span class="comment"> * is more data to send in the replication channel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So modules may want to try to avoid very heavy background work that has</span></span><br><span class="line"><span class="comment"> * the effect of creating data to the replication channel, when this function</span></span><br><span class="line"><span class="comment"> * returns true. This is mostly useful for modules that have background</span></span><br><span class="line"><span class="comment"> * garbage collection tasks, or that do writes and replicate such writes</span></span><br><span class="line"><span class="comment"> * periodically in timer callbacks or other periodic callbacks. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AvoidReplicaTraffic</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="db-and-key-apis----generic-apis">DB and Key APIs -- Generic APIs</h2><p><strong>GetClientId</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return th ID of the current client calling the currently active module cmd. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_GetClientId</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>每个客户端 ID 是唯一的，单调递增的，取值范围为 <span class="math inline">\([1, 2^{64} - 1]\)</span></li><li>返回 0 则意味着在当前上下文中无法获取客户端 ID</li><li>获取客户端 ID 后，可通过调用 <code>RedisModule_IsAOFClient(id)</code> 等判断当前客户端是否为指定类型</li></ul><p><strong>GetClientInfoById</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return information about the client with the specified ID. If the client</span></span><br><span class="line"><span class="comment"> * exists, REDISMODULE_OK is returned, otherwise REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetClientInfoById</span><span class="params">(<span class="keyword">void</span> *ci, <span class="keyword">uint64_t</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>当对应的客户端存在且传入的 <code>ci</code> 指向一个 <code>RedisModuleClientInfo</code> 结构体时，会使用客户端信息填充该结构体，其包含以下成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> flags;     <span class="comment">// REDISMODULE_CLIENTINFO_FLAG_*</span></span><br><span class="line"><span class="keyword">uint64_t</span> id;        <span class="comment">// Client ID</span></span><br><span class="line"><span class="keyword">char</span> addr[<span class="number">46</span>];      <span class="comment">// IPv4 or IPv6 address</span></span><br><span class="line"><span class="keyword">uint16_t</span> port;      <span class="comment">// TCP port</span></span><br><span class="line"><span class="keyword">uint16_t</span> db;        <span class="comment">// Selected DB</span></span><br></pre></td></tr></table></figure><p>该结构体可被 <code>REDISMODULE_CLIENTINFO_INITIALIZER</code> 初始化，其中 <code>flags</code> 的种类如下：</p><table><thead><tr class="header"><th style="text-align: left;">flag</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_SSL</td><td style="text-align: left;">Client using SSL connection.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_PUBSUB</td><td style="text-align: left;">Client in Pub/Sub mode.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_BLOCKED</td><td style="text-align: left;">Client blocked in command.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_TRACKING</td><td style="text-align: left;">Client with keys tracking on.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET</td><td style="text-align: left;">Client using unix domain socket.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_CLIENTINFO_FLAG_MULTI</td><td style="text-align: left;">Client in MULTI state.</td></tr></tbody></table><p>当传入的 <code>ci</code> 为 <code>NULL</code> 时，会直接返回 <code>REDISMODULE_OK</code> 或 <code>REDISMODULE_ERR</code> 表明对应的客户端存在/不存在。</p><p><strong>PublishMessage</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Publish a message to subscribers (see PUBLISH command). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_PublishMessage</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *channel, RedisModuleString *message)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>GetSelectedDb</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the currently selected DB. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetSelectedDb</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>SelectDb</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Change the currently selected DB. Returns an error if the id is out of range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SelectDb</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">int</span> newid)</span></span>;</span><br></pre></td></tr></table></figure><p>若调用该函数，直接返回响应后，客户端会一直保留该函数执行后所选择的 <code>DB</code>。因此，如想切换回之前的 <code>DB</code>，可调用 <code>RedisModule_GetSelectedDb()</code> 保存之前的 <code>DB</code>，并在返回响应前，切换回原先的 <code>DB</code>。</p><p><strong>DbSize</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the number of keys in the current db. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_DbSize</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>ResetDataset</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ResetDataset</span><span class="params">(<span class="keyword">int</span> restart_aof, <span class="keyword">int</span> async)</span></span></span><br></pre></td></tr></table></figure><ul><li>执行与 <code>FLUSHALL</code> 类似的操作</li><li>在启用 <code>AOF</code> 的情况下，如果 <code>restart_aof</code> 为 <code>true</code>，则会启动一个新的 <code>AOF</code> 文件，必须确保该命令不会传播到新的 <code>AOF</code> 文件</li><li>如果 <code>async</code> 设置为 <code>true</code>，则释放数据占用内存的操作会在后台线程中执行</li></ul><p><strong>GetContextFlags</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the current context&#x27;s flags. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetContextFlags</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>上下文标志会包含当前请求信息和实例信息</li><li>也可以对 <code>NULL</code> 上下文调用该函数</li></ul><p>其中 <code>flags</code> 的种类如下：</p><table><colgroup><col style="width: 55%"><col style="width: 45%"></colgroup><thead><tr class="header"><th style="text-align: left;">flag</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_LUA</td><td style="text-align: left;">The command is running in a Lua script</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_MULTI</td><td style="text-align: left;">The command is running inside a transaction</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_REPLICATED</td><td style="text-align: left;">The command was sent over the replication link by the MASTER</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_MASTER</td><td style="text-align: left;">The Redis instance is a master</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_SLAVE</td><td style="text-align: left;">The Redis instance is a slave</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_READONLY</td><td style="text-align: left;">The Redis instance is read-only</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_CLUSTER</td><td style="text-align: left;">The Redis instance is in cluster mode</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_AOF</td><td style="text-align: left;">The Redis instance has AOF enabled</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_RDB</td><td style="text-align: left;">The instance has RDB enabled</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_MAXMEMORY</td><td style="text-align: left;">The instance has Maxmemory set</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_EVICT</td><td style="text-align: left;">Maxmemory is set and has an eviction policy that may delete keys</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_OOM</td><td style="text-align: left;">Redis is out of memory according to the maxmemory setting.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_OOM_WARNING</td><td style="text-align: left;">Less than 25% of memory remains before reaching the maxmemory level.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_LOADING</td><td style="text-align: left;">Server is loading RDB/AOF</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_STALE</td><td style="text-align: left;">No active link with the master.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_CONNECTING</td><td style="text-align: left;">The replica is trying to connect with the master.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_TRANSFERRING</td><td style="text-align: left;">Master -&gt; Replica RDB transfer is in progress.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULECTXFLAGS_REPLICA_IS_ONLINE</td><td style="text-align: left;">The replica has an active link with its master. This is the contrary of STALE state.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULECTXFLAGS_ACTIVE_CHILD</td><td style="text-align: left;">There is currently some background process active (RDB, AUX or module).</td></tr></tbody></table><h2 id="low-level-key-apis">Low level Key APIs</h2><h3 id="base">Base</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return an handle representing a Redis key, so that it is possible to call</span></span><br><span class="line"><span class="comment"> * other APIs with the key handle as argument to perform operations on the key. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_OpenKey</span><span class="params">(RedisModuleCtx *ctx, robj *keyname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 <code>RedisModule_OpenKey()</code> 返回的 <code>RedisModuleKey</code>，在对其访问结束之前，必须调用 <code>RedisModule_CloseKey()</code> 以释放句柄。</p><p>调用 <code>RedisModule_OpenKey()</code> 传入的 key 不存在时：</p><ul><li>如果是 <code>REDISMODULE_WRITE</code> 模式，仍会返回句柄</li><li>如果仅是 <code>REDISMODULE_READ</code> 模式，则会返回 <code>NULL</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Close a key handle. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_CloseKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the type of the key. If the key pointer is NULL then</span></span><br><span class="line"><span class="comment"> * REDISMODULE_KEYTYPE_EMPTY is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_KeyType</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure><p>调用 <code>RedisModule_CloseKey()</code> 或 <code>RedisModule_KeyType()</code> 时，传入的实参可以为 <code>NULL</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the length of the value associated with the key.</span></span><br><span class="line"><span class="comment"> * For strings this is the length of the string. For all the other types</span></span><br><span class="line"><span class="comment"> * is the number of elements (just counting keys for hashes).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key pointer is NULL or the key is empty, zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">RedisModule_ValueLength</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the key is open for writing, remove it, and setup the key to</span></span><br><span class="line"><span class="comment"> * accept new writes as an empty key (that will be created on demand).</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DeleteKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the key is open for writing, unlink it (that is delete it in a</span></span><br><span class="line"><span class="comment"> * non-blocking way, not reclaiming memory immediately) and setup the key to</span></span><br><span class="line"><span class="comment"> * accept new writes as an empty key (that will be created on demand).</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnlinkKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the key expire value, as milliseconds of remaining TTL.</span></span><br><span class="line"><span class="comment"> * If no TTL is associated with the key or if the key is empty,</span></span><br><span class="line"><span class="comment"> * REDISMODULE_NO_EXPIRE is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">mstime_t</span> <span class="title">RedisModule_GetExpire</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a new expire for the key. If the special expire</span></span><br><span class="line"><span class="comment"> * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was</span></span><br><span class="line"><span class="comment"> * one (the same as the PERSIST command).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the expire must be provided as a positive integer representing</span></span><br><span class="line"><span class="comment"> * the number of milliseconds of TTL the key should have.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if</span></span><br><span class="line"><span class="comment"> * the key was not open for writing or is an empty key. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetExpire</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> expire)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a name of a random key, or NULL if current db is empty. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_RandomKey</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="string-type">String type</h3><p><strong>Set</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the key is open for writing, set the specified string &#x27;str&#x27; as the</span></span><br><span class="line"><span class="comment"> * value of the key, deleting the old value if any.</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for</span></span><br><span class="line"><span class="comment"> * writing or there is an active iterator, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringSet</span><span class="params">(RedisModuleKey *key, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>DMA access</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare the key associated string value for DMA access, and returns</span></span><br><span class="line"><span class="comment"> * a pointer and size (by reference), that the user can use to read or</span></span><br><span class="line"><span class="comment"> * modify the string in-place accessing it directly via pointer. */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_StringDMA</span><span class="params">(RedisModuleKey *key, <span class="keyword">size_t</span> *len, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>key</code> 所关联的对象不是 <code>String</code> 类型，则会返回 <code>NULL</code></li><li>如果 <code>mode</code> 仅为可读，则不可修改返回值</li><li>DMA access rules:<ul><li>因为是就地访问，所以应避免并发问题。对于同一个 key，只存在一写或多读的情况。</li><li>每次调用 <code>RedisModule_StringTruncate()</code> 之后, 需重新调用 <code>RedisModule_StringDMA()</code> 以获取新的字符串指针和长度</li><li>若获取的指针不为 <code>NULL</code>，但长度为 0 时 (key 为空或字符串为空)，可使用 <code>RedisModule_StringTruncate()</code> 调整字符串大小后再次调用 <code>RedisModule_StringDMA()</code>。</li></ul></li></ul><p><strong>Truncate</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the string is open for writing and is of string type, resize it, padding</span></span><br><span class="line"><span class="comment"> * with zero bytes if the new length is greater than the old one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After this call, RedisModule_StringDMA() must be called again to continue</span></span><br><span class="line"><span class="comment"> * DMA access with the new pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on</span></span><br><span class="line"><span class="comment"> * error, that is, the key is not open for writing, is not a string</span></span><br><span class="line"><span class="comment"> * or resizing for more than 512 MB is requested.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is empty, a string key is created with the new string value</span></span><br><span class="line"><span class="comment"> * unless the new length value requested is zero. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringTruncate</span><span class="params">(RedisModuleKey *key, <span class="keyword">size_t</span> newlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="list-type">List type</h3><p><strong>Push</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Push an element into a list, on head or tail depending on &#x27;where&#x27; argument. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ListPush</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> where, RedisModuleString *ele)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>如果传入的 <code>key</code> 为空，模式为写模式的话，则会创建新 <code>key</code></li><li>只读模式或类型错误时，返回 <code>REDISMODULE_ERR</code>，否则返回 <code>REDISMODULE_OK</code></li></ul><p><strong>Pop</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pop an element from list, from head or tail depending on &#x27;where&#x27; argument. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ListPop</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> where)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在未启用自动内存管理的情况下，返回值必须调用 <code>RedisModule_FreeString()</code> 进行释放</li><li>返回值为 <code>NULL</code> 时，可能由以下原因造成：<ul><li>列表为空</li><li>只读模式</li><li>类型错误</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tail and head */</span></span><br><span class="line">REDISMODULE_LIST_HEAD</span><br><span class="line">REDISMODULE_LIST_TAIL</span><br></pre></td></tr></table></figure><h3 id="sorted-set-type">Sorted Set type</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conversion from/to public flags of the Modules API and our private flags,</span></span><br><span class="line"><span class="comment"> * so that we have everything decoupled. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAddFlagsToCoreFlags</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAddFlagsFromCoreFlags</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>ZADD</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new element into a sorted set, with the specified &#x27;score&#x27;.</span></span><br><span class="line"><span class="comment"> * If the element already exists, the score is updated. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> score,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *ele,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *flagsptr)</span></span>;</span><br></pre></td></tr></table></figure><p>在写模式下，如果 <code>key</code> 为空，则会新建一个 <code>ZSET</code>。</p><p>可以注意到，此处 flags 按指针传递，其用途有二：</p><ul><li>作为 <code>input flags</code>， 决定 <code>RedisModule_ZsetAdd()</code> 的行为模式</li><li>作为 <code>output flags</code>，返回 <code>RedisModule_ZsetAdd()</code> 的执行结果</li></ul><p>其中，<code>input flags</code> 可以为</p><ul><li><code>REDISMODULE_ZADD_XX</code>: Element must already exist. Do nothing otherwise.</li><li><code>REDISMODULE_ZADD_NX</code>: Element must not exist. Do nothing otherwise.</li></ul><p><code>output flags</code> 可以为：</p><ul><li><code>REDISMODULE_ZADD_ADDED</code>: The new element was added to the sorted set.</li><li><code>REDISMODULE_ZADD_UPDATED</code>: The score of the element was updated.</li><li><code>REDISMODULE_ZADD_NOP</code>: No operation was performed because XX or NX flags.</li></ul><p>当然，<code>flagsptr</code> 也可为 <code>NULL</code>。</p><p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p><ul><li>只读模式</li><li>类型错误</li><li>传入的 <code>score</code> 不是数值类型</li></ul><p><strong>ZINCRBY</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Increase the score of the existing element, of if the element does not</span></span><br><span class="line"><span class="comment"> * already exist, it is added assuming the old score was zero. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetIncrby</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> score,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *ele,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *flagsptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> *newscore)</span></span>;</span><br></pre></td></tr></table></figure><p><code>inpout/output flags</code> 和返回值和 <code>RedisModule_ZsetAdd()</code> 一样，唯一的区别是，当 <code>score</code> 不是数值类型时，该函数除了返回 <code>REDISMODULE_ERR</code> 之外，还会使得现有 <code>element</code> 的 <code>socre</code> 变成非数值类型。</p><p>传入的 <code>newscore</code> 实参不为 <code>NULL</code> 时，会在函数执行完毕之后使用 <code>element</code> 新的 <code>score</code> 进行填充，在无错误的情况下，会被返回。</p><p><strong>ZREM</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified element from the sorted set. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRem</span><span class="params">(RedisModuleKey *key, RedisModuleString *ele, <span class="keyword">int</span> *deleted)</span></span>;</span><br></pre></td></tr></table></figure><p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p><ul><li>只读模式</li><li>类型错误</li></ul><p>通过返回值不能确定该 <code>element</code> 是否真的被移除，如果想知道 <code>element</code> 是否被移除的话，则需要传入非空的 <code>deleted</code> 指针，其在返回时会根据函数执行情况填充 0 或 1</p><p><strong>ZSCORE</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retrieve the double score associated at the sorted set element &#x27;ele&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetScore</span><span class="params">(RedisModuleKey *key, RedisModuleString *ele, <span class="keyword">double</span> *score)</span></span>;</span><br></pre></td></tr></table></figure><p>函数执行成功时返回 <code>REDISMODULE_OK</code>，但遇到以下错误时会返回 <code>REDISMODULE_ERR</code>:</p><ul><li>该 <code>ZSET</code> 中不存在该 <code>element</code></li><li><code>key</code> 为空</li><li>类型错误</li></ul><p><strong>Sorted Set iterator</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Stop a sorted set iteration. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ZsetRangeStop</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the &quot;End of range&quot; flag value to signal the end of the iteration. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangeEndReached</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current sorted set element of an active sorted set iterator or</span></span><br><span class="line"><span class="comment"> * NULL if the range specified in the iterator does not include any element. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ZsetRangeCurrentElement</span><span class="params">(RedisModuleKey *key, <span class="keyword">double</span> *score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Go to the next element of the sorted set iterator.</span></span><br><span class="line"><span class="comment"> * Returns 1 if there was a next element, 0 if we are already</span></span><br><span class="line"><span class="comment"> * at the latest element or the range does not include any item at all. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangeNext</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Go to the previous element of the sorted set iterator.</span></span><br><span class="line"><span class="comment"> * Returns 1 if there was a previous element, 0 if we are already</span></span><br><span class="line"><span class="comment"> * at the first element or the range does not include any item at all. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetRangePrev</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup a sorted set iterator seeking the first element in the specified range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetFirstInScoreRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> min, <span class="keyword">double</span> max,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> minex, <span class="keyword">int</span> maxex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of</span></span><br><span class="line"><span class="comment"> * the range is selected for the start of the iteration instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetLastInScoreRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> min, <span class="keyword">double</span> max,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> minex, <span class="keyword">int</span> maxex)</span></span>;</span><br></pre></td></tr></table></figure><p>上述两函数在迭代器被正确初始化时，返回 <code>REDISMODULE_OK</code>；在 <code>key</code> 为空或对应的数据类型不是 <code>ZSET</code> 时，返回 <code>REDISMODULE_ERR</code>。</p><p>迭代区间由 <code>min</code> 和 <code>max</code> 控制，当 <code>minex</code>(<code>maxex</code>) 设置为 <code>true</code> 时，区间不包含 <code>min</code>(<code>max</code>)。可以使用以下宏赋值给 <code>min</code> 或 <code>max</code>:</p><ul><li><code>REDISMODULE_POSITIVE_INFINITE</code>: positive infinite value</li><li><code>REDISMODULE_NEGATIVE_INFINITE</code>: negative infinite value</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup a sorted set iterator seeking the first element in the</span></span><br><span class="line"><span class="comment"> * specified lexicographical range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetFirstInLexRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *min, RedisModuleString *max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element</span></span><br><span class="line"><span class="comment"> * of the range is selected for the start of the iteration instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ZsetLastInLexRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString *min, RedisModuleString *max)</span></span>;</span><br></pre></td></tr></table></figure><p>上述两函数在迭代器被正确初始化时，返回 <code>REDISMODULE_OK</code>，在以下情况下返回 <code>REDISMODULE_ERR</code>:</p><ul><li><code>key</code> 对应的数据类型不为 <code>ZSET</code></li><li><code>key</code> 为空</li><li>确定字典范围的 <code>min</code> 和 <code>max</code> 格式错误</li></ul><p>传入的 <code>min</code> 和 <code>max</code> 格式和 <code>ZRANGEBYLEX</code> 命令参数的格式相同。<code>min</code> 和 <code>max</code> 对象可在迭代器被正确赋值之后立即释放。</p><h3 id="hash-type">Hash type</h3><p><strong>HashSet</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the field of the specified hash field to the specified value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_HashSet</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> flags, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>如果 <code>key</code> 为空且处于写模式，则会新建一个 <code>Hash</code>。</p><p>控制函数行为模式的 <code>flags</code> 列表如下：</p><table><colgroup><col style="width: 32%"><col style="width: 67%"></colgroup><thead><tr class="header"><th style="text-align: left;">flags</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULE_HASH_NONE</td><td style="text-align: left;">No special behavior is needed.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_HASH_NX</td><td style="text-align: left;">The operation is performed only if the field was not already existing in the hash.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_HASH_XX</td><td style="text-align: left;">The operation is performed only if the field was already existing, so that a new value could be associated to an existing filed, but no new fields are created.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_HASH_CFIELDS</td><td style="text-align: left;">The field names passed are null terminated C strings instead of RedisModuleString objects.</td></tr></tbody></table><p>可变参数列表由 <code>flied/value-ptr pairs</code> 和 <code>NULL</code> 组成：</p><ul><li><code>flied/value-ptr pairs</code> 中传入的数据类型为 <code>RedisModuleString*</code> (flags 不为 CFIELDS)</li><li><code>NULL</code> 为最后一个实参的标识</li><li>当 <code>value == REDISMODULE_HASH_DELETE</code> 时，意为删除对应的 <code>field</code></li></ul><p>该函数的返回值为更新的 <code>field</code> 个数，故 <code>key</code> 为只读模式或对应的数据类型不为 <code>Hash</code> 时，返回值一直为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Example to set the hash argv[1] to the value argv[2]: */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of delete fileds */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],REDISMODULE_HASH_DELETE,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_CFIELDS */</span></span><br><span class="line">RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,<span class="string">&quot;foo&quot;</span>,REDISMODULE_HASH_DELETE,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><strong>HashGet</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get fields value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_HashGet</span><span class="params">(RedisModuleKey *key, <span class="keyword">int</span> flags, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>控制函数行为模式的 <code>flags</code> 列表如下：</p><table><colgroup><col style="width: 30%"><col style="width: 69%"></colgroup><thead><tr class="header"><th style="text-align: left;">flags</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULE_HASH_NONE</td><td style="text-align: left;">No special behavior is needed.</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_HASH_CFIELD</td><td style="text-align: left;">field names as null terminated C strings.</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_HASH_EXISTS</td><td style="text-align: left;">instead of setting the value of the field expecting a RedisModuleString pointer to pointer, the function just reports if the field exists or not and expects an integer pointer as the second element of each pair.</td></tr></tbody></table><p>可变参数列表由 <code>flied/value-ptr pairs</code> 和 <code>NULL</code> 组成：</p><ul><li><code>flied/value-ptr pairs</code> 中传入的数据类型为 <code>RedisModuleString*</code> (flags 不为 CFIELDS)</li><li><code>NULL</code> 为最后一个实参的标识</li><li>返回时，<code>value</code> 指针为空表示对应的 <code>field</code> 不存在</li><li>不要忘记释放 <code>RedisModuleString</code> 对象</li></ul><p>在函数执行成功时返回 <code>REDISMODULE_OK</code>，如 <code>key</code> 对应的数据类型不为 <code>Hash</code>，则返回 <code>REDISMODULE_ERR</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An example usage. */</span></span><br><span class="line">RedisModuleString *first, *second;</span><br><span class="line">RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[<span class="number">1</span>],&amp;first,argv[<span class="number">2</span>],&amp;second,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_CFIELD */</span></span><br><span class="line">RedisModuleString *username, *hashedpass;</span><br><span class="line">RedisModule_HashGet(mykey,<span class="string">&quot;username&quot;</span>,&amp;username,<span class="string">&quot;hp&quot;</span>,&amp;hashedpass, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example of REDISMODULE_HASH_EXISTS */</span></span><br><span class="line"><span class="keyword">int</span> exists;</span><br><span class="line">RedisModule_HashGet(mykey,argv[<span class="number">1</span>],&amp;exists,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="high-level-key-apis----call">High level Key APIs -- Call</h2><p><strong>Call</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exported API to call any Redis command from modules. */</span></span><br><span class="line"><span class="function">RedisModuleCallReply *<span class="title">RedisModule_Call</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>格式说明符列表如下：</p><ul><li><code>c</code> -- Null terminated C string pointer</li><li><code>b</code> -- C buffer, two arguments needed: C string pointer and <code>size_t</code> length</li><li><code>s</code> -- RedisModuleString as received in <code>argv</code> or by other Redis module APIs returning a RedisModuleString object</li><li><code>l</code> -- Long long integer</li><li><code>v</code> -- Array of RedisModuleString objects</li><li><code>!</code> -- This modifier just tells the function to replicate the command to replicas and AOF. it is ignored from the point of view of arguments parsing</li><li><code>A</code> -- This modifier, when <code>!</code> is given, tells to suppress AOF propagation: the command will propagated only to replicas</li><li><code>R</code> -- This modifier, when <code>!</code> is given, tells to suppress replicas propagation: the command will be propagated only to the AOF if enabled</li></ul><p>函数执行成功时返回 <code>RedisModuleCallReply</code> 对象，失败时返回 <code>NULL</code> 并将 <code>errno</code> 设置为以下值：</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th style="text-align: left;">errno</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">EBADF</td><td style="text-align: left;">wrong format specifier.</td></tr><tr class="even"><td style="text-align: left;">EINVAL</td><td style="text-align: left;">wrong command arity.</td></tr><tr class="odd"><td style="text-align: left;">ENOENT</td><td style="text-align: left;">command does not exist.</td></tr><tr class="even"><td style="text-align: left;">EPERM</td><td style="text-align: left;">operation in Cluster instance with key in non local slot.</td></tr><tr class="odd"><td style="text-align: left;">EROFS</td><td style="text-align: left;">operation in Cluster instance when a write command is sent in a readonly state. ENETDOWN</td></tr></tbody></table><p><strong>Access CallReply</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the reply type. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CallReplyType</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the reply type length, where applicable. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">RedisModule_CallReplyLength</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the &#x27;idx&#x27;-th nested call reply element of an array reply,</span></span><br><span class="line"><span class="comment"> * or NULL if the reply type is wrong or the index is out of range. */</span></span><br><span class="line"><span class="function">RedisModuleCallReply *<span class="title">RedisModule_CallReplyArrayElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCallReply *reply, <span class="keyword">size_t</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the long long of an integer reply. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_CallReplyInteger</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer and length of a string or error reply. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_CallReplyStringPtr</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a new string object from a call reply of type string,</span></span><br><span class="line"><span class="comment"> * error or integer. Otherwise (wrong reply type) return NULL. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateStringFromCallReply</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer, and a length, to the protocol</span></span><br><span class="line"><span class="comment"> * returned by the command that returned the reply object. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_CallReplyProto</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">size_t</span> *len)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Free CallReply</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a Call reply and all the nested replies it contains if it&#x27;s an array. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeCallReply_Rec</span><span class="params">(RedisModuleCallReply *reply, <span class="keyword">int</span> freenested)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper for the recursive free reply function.</span></span><br><span class="line"><span class="comment"> * This is needed in order to have the first level function to return</span></span><br><span class="line"><span class="comment"> * on nested replies, but only if called by the module API. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeCallReply</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="自定义数据类型">自定义数据类型</h2><h3 id="create-data-type">Create Data Type</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Register a new data type exported by the module. */</span></span><br><span class="line"><span class="function">moduleType *<span class="title">RedisModule_CreateDataType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> encver,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *typemethods_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>在 <code>name</code> 已存在，<code>name</code> 或 <code>encver</code> 非法的情况下，该函数返回 <code>NULL</code>。</p><p>各个参数说明如下：</p><ul><li><p><code>name</code>: 类型名，由 9 个字符组成，可用字符集合为 <code>&#123;A-Z, a-z, 0-9, -, _&#125;</code> &gt;"AAAAAAAAA" is reserved and produces an error</p></li><li><p><code>encver</code>: 序列化数据的 Encoding version，用于向前兼容，取值范围为 <span class="math inline">\([0, 1023]\)</span></p></li><li><p><code>typemethods_ptr</code>: 指向 <code>RedisModuleTypeMethods</code> 结构体的指针，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleTypeMethods tm =</span><br><span class="line">&#123;</span><br><span class="line">    .version = REDISMODULE_TYPE_METHOD_VERSION,</span><br><span class="line">    .rdb_load = myType_RDBLoadCallBack,</span><br><span class="line">    .rdb_save = myType_RDBSaveCallBack,</span><br><span class="line">    .aof_rewrite = myType_AOFRewriteCallBack,</span><br><span class="line">    .<span class="built_in">free</span> = myType_FreeCallBack,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional fields */</span></span><br><span class="line">    .digest = myType_DigestCallBack,</span><br><span class="line">    .mem_usage = myType_MemUsageCallBack,</span><br><span class="line">    .aux_save = myType_AuxRDBSaveCallBack,</span><br><span class="line">    .aux_load = myType_AuxRDBLoadCallBack,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体成员说明如下：</p><ul><li><code>rdb_load</code>: A callback function pointer that loads data from RDB files.</li><li><code>rdb_save</code>: A callback function pointer that saves data to RDB files.</li><li><code>aof_rewrite</code>: A callback function pointer that rewrites data as commands.</li><li><code>free</code>: A callback function pointer that can free a type value.</li><li><code>digest</code>: A callback function pointer that is used for <code>DEBUG DIGEST</code>.</li><li><code>mem_usage</code>: A callback function pointer that is used for <code>MEMORY</code></li><li><code>aux_save</code>: A callback function pointer that saves out of keyspace data to RDB files. <code>when</code> argument is either <code>REDISMODULE_AUX_BEFORE_RDB</code> or <code>REDISMODULE_AUX_AFTER_RDB</code>.</li><li><code>aux_load</code>: A callback function pointer that loads out of keyspace data from RDB files. Similar to <code>aux_save</code>, returns <code>REDISMODULE_OK</code> on success, and <code>REDISMODULE_ERR</code> otherwise.</li></ul><blockquote><p>The <code>digest</code> and <code>mem_usage</code> methods should currently be omitted since they are not yet implemented inside the Redis modules core.</p></blockquote></li></ul><h3 id="access-to-moduletype">Access to moduleType</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the key is open for writing, set the specified module type object</span></span><br><span class="line"><span class="comment"> * as the value of the key, deleting the old value if any.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success REDISMODULE_OK is returned. If the key is not open for writing</span></span><br><span class="line"><span class="comment"> * or there is an active iterator, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ModuleTypeSetValue</span><span class="params">(RedisModuleKey *key, moduleType *mt, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Replace the value assigned to a module type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The key must be open for writing, have an existing value, and have a moduleType</span></span><br><span class="line"><span class="comment"> * that matches the one specified by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlike RM_ModuleTypeSetValue() which will free the old value, this function</span></span><br><span class="line"><span class="comment"> * simply swaps the old value with the new value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK on success, REDISMODULE_ERR on errors</span></span><br><span class="line"><span class="comment"> * such as:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Key is not opened for writing.</span></span><br><span class="line"><span class="comment"> * 2. Key is not a module data type key.</span></span><br><span class="line"><span class="comment"> * 3. Key is a module datatype other than &#x27;mt&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If old_value is non-NULL, the old value is returned by reference. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ModuleTypeReplaceValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleKey *key, moduleType *mt, <span class="keyword">void</span> *new_value, <span class="keyword">void</span> **old_value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on</span></span><br><span class="line"><span class="comment"> * the key, returns the module type pointer of the value stored at key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is NULL, is not associated with a module type, or is empty,</span></span><br><span class="line"><span class="comment"> * then NULL is returned instead. */</span></span><br><span class="line"><span class="function">moduleType *<span class="title">RedisModule_ModuleTypeGetType</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on</span></span><br><span class="line"><span class="comment"> * the key, returns the module type low-level value stored at key, as</span></span><br><span class="line"><span class="comment"> * it was set by the user via RedisModule_ModuleTypeSetValue().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the key is NULL, is not associated with a module type, or is empty,</span></span><br><span class="line"><span class="comment"> * then NULL is returned instead. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_ModuleTypeGetValue</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="rdb-loading-and-saving-functions">RDB loading and saving functions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if any previous IO API failed.</span></span><br><span class="line"><span class="comment"> * for Load* APIs the REDISMODULE_OPTIONS_HANDLE_IO_ERRORS flag must be set with</span></span><br><span class="line"><span class="comment"> * RediModule_SetModuleOptions first. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsIOError</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save an unsigned 64 bit value into the RDB file. This function should only</span></span><br><span class="line"><span class="comment"> * be called in the context of the rdb_save method of modules implementing new</span></span><br><span class="line"><span class="comment"> * data types. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveUnsigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">uint64_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load an unsigned 64 bit value from the RDB file. This function should only</span></span><br><span class="line"><span class="comment"> * be called in the context of the rdb_load method of modules implementing</span></span><br><span class="line"><span class="comment"> * new data types. */</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">RedisModule_LoadUnsigned</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveSigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">int64_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">RedisModule_LoadSigned</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module type, saves a</span></span><br><span class="line"><span class="comment"> * string into the RDB file taking as input a RedisModuleString.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string can be later loaded with RedisModule_LoadString() or</span></span><br><span class="line"><span class="comment"> * other Load family functions expecting a serialized string inside</span></span><br><span class="line"><span class="comment"> * the RDB file. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveString</span><span class="params">(RedisModuleIO *io, RedisModuleString *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_load method of a module data type, loads a string</span></span><br><span class="line"><span class="comment"> * from the RDB file, that was previously saved with RedisModule_SaveString()</span></span><br><span class="line"><span class="comment"> * functions family.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned string is a newly allocated RedisModuleString object, and</span></span><br><span class="line"><span class="comment"> * the user should at some point free it with a call to RedisModule_FreeString().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the data structure does not store strings as RedisModuleString objects,</span></span><br><span class="line"><span class="comment"> * the similar function RedisModule_LoadStringBuffer() could be used instead. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_LoadString</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_SaveString() but takes a raw C pointer and length as input. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveStringBuffer</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_LoadString() but returns an heap allocated string that</span></span><br><span class="line"><span class="comment"> * was allocated with RedisModule_Alloc(), and can be resized or freed with</span></span><br><span class="line"><span class="comment"> * RedisModule_Realloc() or RedisModule_Free().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size of the string is stored at &#x27;*lenptr&#x27; if not NULL.</span></span><br><span class="line"><span class="comment"> * The returned string is not automatically NULL terminated, it is loaded</span></span><br><span class="line"><span class="comment"> * exactly as it was stored inisde the RDB file. */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_LoadStringBuffer</span><span class="params">(RedisModuleIO *io, <span class="keyword">size_t</span> *lenptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a double</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The double can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveDouble</span><span class="params">(RedisModuleIO *io, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * double value saved by RedisModule_SaveDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RedisModule_LoadDouble</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a float</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The float can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadFloat(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveFloat</span><span class="params">(RedisModuleIO *io, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * float value saved by RedisModule_SaveFloat(). */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RedisModule_LoadFloat</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, saves a long double</span></span><br><span class="line"><span class="comment"> * value to the RDB file. The double can be a valid number, a NaN or infinity.</span></span><br><span class="line"><span class="comment"> * It is possible to load back the value with RedisModule_LoadLongDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveLongDouble</span><span class="params">(RedisModuleIO *io, <span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the context of the rdb_save method of a module data type, loads back the</span></span><br><span class="line"><span class="comment"> * long double value saved by RedisModule_SaveLongDouble(). */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">RedisModule_LoadLongDouble</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="key-digest-api">Key digest API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new element to the digest. This function can be called multiple times</span></span><br><span class="line"><span class="comment"> * one element after the other, for all the elements that constitute a given</span></span><br><span class="line"><span class="comment"> * data structure. The function call must be followed by the call to</span></span><br><span class="line"><span class="comment"> * `RedisModule_DigestEndSequence` eventually, when all the elements that are</span></span><br><span class="line"><span class="comment"> * always in a given order are added. See the Redis Modules data types</span></span><br><span class="line"><span class="comment"> * documentation for more info. However this is a quick example that uses Redis</span></span><br><span class="line"><span class="comment"> * data types as an example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To add a sequence of unordered elements (for example in the case of a Redis</span></span><br><span class="line"><span class="comment"> * Set), the pattern to use is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach element &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(element);</span></span><br><span class="line"><span class="comment"> *         EndSequence();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because Sets are not ordered, so every element added has a position that</span></span><br><span class="line"><span class="comment"> * does not depend from the other. However if instead our elements are</span></span><br><span class="line"><span class="comment"> * ordered in pairs, like field-value pairs of an Hash, then one should</span></span><br><span class="line"><span class="comment"> * use:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach key,value &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(key);</span></span><br><span class="line"><span class="comment"> *         AddElement(value);</span></span><br><span class="line"><span class="comment"> *         EndSquence();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because the key and value will be always in the above order, while instead</span></span><br><span class="line"><span class="comment"> * the single key-value pairs, can appear in any position into a Redis hash.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A list of ordered elements would be implemented with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     foreach element &#123;</span></span><br><span class="line"><span class="comment"> *         AddElement(element);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *     EndSequence();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestAddStringBuffer</span><span class="params">(RedisModuleDigest *md,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input</span></span><br><span class="line"><span class="comment"> * that gets converted into a string before adding it to the digest. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestAddLongLong</span><span class="params">(RedisModuleDigest *md, <span class="keyword">long</span> <span class="keyword">long</span> ll)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DigestEndSequence</span><span class="params">(RedisModuleDigest *md)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode a serialized representation of a module data type &#x27;mt&#x27; from string</span></span><br><span class="line"><span class="comment"> * &#x27;str&#x27; and return a newly allocated value, or NULL if decoding failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call basically reuses the &#x27;rdb_load&#x27; callback which module data types</span></span><br><span class="line"><span class="comment"> * implement in order to allow a module to arbitrarily serialize/de-serialize</span></span><br><span class="line"><span class="comment"> * keys, similar to how the Redis &#x27;DUMP&#x27; and &#x27;RESTORE&#x27; commands are implemented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Modules should generally use the REDISMODULE_OPTIONS_HANDLE_IO_ERRORS flag and</span></span><br><span class="line"><span class="comment"> * make sure the de-serialization code properly checks and handles IO errors</span></span><br><span class="line"><span class="comment"> * (freeing allocated buffers and returning a NULL).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this is NOT done, Redis will handle corrupted (or just truncated) serialized</span></span><br><span class="line"><span class="comment"> * data by producing an error message and terminating the process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_LoadDataTypeFromString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> RedisModuleString *str, <span class="keyword">const</span> moduleType *mt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode a module data type &#x27;mt&#x27; value &#x27;data&#x27; into serialized form, and return it</span></span><br><span class="line"><span class="comment"> * as a newly allocated RedisModuleString.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call basically reuses the &#x27;rdb_save&#x27; callback which module data types</span></span><br><span class="line"><span class="comment"> * implement in order to allow a module to arbitrarily serialize/de-serialize</span></span><br><span class="line"><span class="comment"> * keys, similar to how the Redis &#x27;DUMP&#x27; and &#x27;RESTORE&#x27; commands are implemented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_SaveDataTypeToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, <span class="keyword">void</span> *data, <span class="keyword">const</span> moduleType *md)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="aof-api-for-modules-data-types">AOF API for modules data types</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Emits a command into the AOF during the AOF rewriting process. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_EmitAOF</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数只在 <code>aof_rewrite</code> 函数中调用</li><li>执行模式和 <code>RedisModule_Call()</code> 相同，但是无返回值，异常情况由 Redis 自身处理</li></ul><h3 id="io-context-handling">IO context handling</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleCtx *<span class="title">RedisModule_GetContextFromIO</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a RedisModuleString with the name of the key currently saving or</span></span><br><span class="line"><span class="comment"> * loading, when an IO data type callback is called.  There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the key name is always available, so this may return NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_GetKeyNameFromIO</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a RedisModuleString with the name of the key from RedisModuleKey */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_GetKeyNameFromModuleKey</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="输出日志">输出日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Produces a log message to the standard Redis log, the format accepts</span></span><br><span class="line"><span class="comment"> * printf-alike specifiers. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Log</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">char</span> *levelstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><p><code>levelstr</code> 描述了指定的日志级别，日志级别可为以下四种之一:</p><ul><li><code>debug</code></li><li><code>verbose</code></li><li><code>notice</code></li><li><code>warning</code></li></ul><p>当传入的 <code>levelstr</code> 内容不为以上四种之一时，日志级别默认设置为 <code>verbose</code>。传入的上下文指针可以为 <code>NULL</code>，此时在日志输出时，会以 <code>module</code> 代替 module name。 &gt;日志长度有上限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Log errors from RDB / AOF serialization callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used when a callback is returning a critical</span></span><br><span class="line"><span class="comment"> * error to the caller since cannot load or save the data for some</span></span><br><span class="line"><span class="comment"> * critical reason. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_LogIOError</span><span class="params">(RedisModuleIO *io,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span> *levelstr, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Redis-like assert function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A failed assertion will shut down the server and produce logging information</span></span><br><span class="line"><span class="comment"> * that looks identical to information generated by Redis itself. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule__Assert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *estr, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allows adding event to the latency monitor to be observed by the LATENCY</span></span><br><span class="line"><span class="comment"> * command. The call is skipped if the latency is smaller than the configured</span></span><br><span class="line"><span class="comment"> * latency-monitor-threshold. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_LatencyAddSample</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *event, <span class="keyword">mstime_t</span> latency)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="blocking-clients-from-modules">Blocking clients from modules</h2><h3 id="block-client">Block Client</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Block a client in the context of a blocking command. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_BlockClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc reply_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc timeout_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*free_privdata)(RedisModuleCtx*,<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> <span class="keyword">long</span> timeout_ms)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>reply_callback</code>: called after a successful <code>RedisModule_UnblockClient()</code> call in order to reply to the client and unblock it.</li><li><code>timeout_callback</code>: called when the timeout is reached in order to send an error to the client.</li><li><code>free_privdata</code>: called in order to free the private data that is passed by <code>RedisModule_UnblockClient()</code> call.</li><li><code>timeout_ms</code>: a timeout after which the client is unblocked.</li></ul><p>在以下情况下不该调用该函数，如在这些情况下，调用该函数并不会阻塞客户端，会返回错误回复。</p><ul><li>If the client is a Lua script.</li><li>If the client is executing a <code>MULTI</code> block.</li></ul><p>函数执行成功会会返回 <code>RedisModuleBlockedClient</code> 对象，用于之后调用 <code>RedisModule_UnblockClient()</code> 以解除对客户端的阻塞及释放该对象占用的内存。因此，无论该客户端被 killed, time-out 或 disconnected，都应该调用 <code>RedisModule_UnblockClient()</code>，否则会有内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unblock a client blocked by `RedisModule_BlockedClient`. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnblockClient</span><span class="params">(RedisModuleBlockedClient *bc, <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>调用该函数，会触发 <code>reply_callback</code>，按需将数据通过 <code>privdata</code> 指针传递至 <code>reply_callback</code>。</li><li>可在模块派生出的线程中调用此函数</li><li>当对 <code>RedisModule_BlockClientOnKeys</code> 的返回值调用该函数时，<code>privdata</code> 指针无用，客户端被视为超时，触发 <code>timeout_callback</code>。</li></ul><h3 id="block-client-on-keys">Block Client On Keys</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This call is similar to RedisModule_BlockClient(), however in this case we</span></span><br><span class="line"><span class="comment"> * don&#x27;t just block the client, but also ask Redis to unblock it automatically</span></span><br><span class="line"><span class="comment"> * once certain keys become &quot;ready&quot;, that is, contain more data. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_BlockClientOnKeys</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc reply_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc timeout_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*free_privdata)(RedisModuleCtx*,<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> <span class="keyword">long</span> timeout_ms,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleString **keys,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> numkeys,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的运行模式和 <a href="https://redis.io/commands/blpop">BLPOP</a> 或 <a href="https://redis.io/commands/bzpopmax">BZPOPMAX</a> 等可阻塞客户端的命令类似 —— 当不能立马获取数据时，客户端阻塞，随后当数据可获取时，客户端解除阻塞并返回数据。调用该函数后，解除阻塞条件分为两种：</p><ol type="1"><li>If you block on a key of a type that has blocking operations associated, like a list, a sorted set, a stream, and so forth, the client may be unblocked once the relevant key is targeted by an operation that normally unblocks the native blocking operations for that type. So if we block on a list key, an <code>RPUSH</code> command may unblock our client and so forth.</li><li>If you are implementing your native data type, or if you want to add new unblocking conditions in addition to <code>1</code>, you can call the modules API <code>RedisModule_SignalKeyAsReady()</code>.</li></ol><p>我们不能在收到 key 已准备好的信号后，立马解除对客户端的阻塞，因为在此期间 key 可能又被修改。因此在调用 <code>RedisModule_BlockClientOnKeys()</code> 时，<code>reply_callback</code> 并不是在调用 <code>RedisModule_UnblockClient()</code> 之后调用，而是在每次收到 key 已准备好的信号后调用：如果此时 <code>reply_callback</code> 可以返回客户端期待的数据时，其返回 <code>REDISMODULE_OK</code> 并解除对客户端的阻塞；否则其返回 <code>REDISMODULE_ERR</code> 并在之后重试。<code>reply_callback</code> 可以在收到 <code>key</code> 已准备的信号后，通过调用 <code>RedisModule_GetBlockedClientReadyKey()</code> 访问该 <code>key</code>。</p><p>在 <code>RedisModule_BlockClient()</code> 中，<code>prvidata</code> 由 <code>RedisModule_UnblockClient()</code> 提供，由于 <code>RedisModule_BlockClientOnKeys()</code> 中解除阻塞无须调用 <code>RedisModule_UnblockClient()</code>，所以我们直接传递了 <code>prvidata</code> 指针，供 <code>reply_callback</code>/<code>timeout_callback</code> 访问。</p><p>在 Block client on keys 的情况下，通常无需调用 <code>RedisModule_UnblockClient()</code>，若因某些原因而调用 <code>RedisModule_UnblockClient()</code> 时，此时客户端视为超时，因此此时必须实现 <code>timeout_callback</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is used in order to potentially unblock a client blocked</span></span><br><span class="line"><span class="comment"> * on keys with RedisModule_BlockClientOnKeys(). When this function is called,</span></span><br><span class="line"><span class="comment"> * all the clients blocked for this key will get their reply callback called,</span></span><br><span class="line"><span class="comment"> * and if the callback returns REDISMODULE_OK the client will be unblocked. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SignalKeyAsReady</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the key that is ready when the reply callback is called in the context</span></span><br><span class="line"><span class="comment"> * of a client blocked by RedisModule_BlockClientOnKeys(). */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_GetBlockedClientReadyKey</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="utils">Utils</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Abort a blocked client blocking operation: the client will be unblocked</span></span><br><span class="line"><span class="comment"> * without firing any callback. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AbortBlock</span><span class="params">(RedisModuleBlockedClient *bc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a callback that will be called if a blocked client disconnects</span></span><br><span class="line"><span class="comment"> * before the module has a chance to call RedisModule_UnblockClient()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usually what you want to do there, is to cleanup your module state</span></span><br><span class="line"><span class="comment"> * so that you can call RedisModule_UnblockClient() safely, otherwise</span></span><br><span class="line"><span class="comment"> * the client will remain blocked forever if the timeout is large.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. It is not safe to call Reply* family functions here, it is also</span></span><br><span class="line"><span class="comment"> *    useless since the client is gone.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. This callback is not called if the client disconnects because of</span></span><br><span class="line"><span class="comment"> *    a timeout. In such a case, the client is unblocked automatically</span></span><br><span class="line"><span class="comment"> *    and the timeout callback is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetDisconnectCallback</span><span class="params">(RedisModuleBlockedClient *bc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       RedisModuleDisconnectFunc callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command was called in order to fill the</span></span><br><span class="line"><span class="comment"> * reply for a blocked client. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedReplyRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return non-zero if a module command was called in order to fill the</span></span><br><span class="line"><span class="comment"> * reply for a blocked client that timed out. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedTimeoutRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the private data set by RedisModule_UnblockClient() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_GetBlockedClientPrivateData</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the blocked client associated with a given context.</span></span><br><span class="line"><span class="comment"> * This is useful in the reply and timeout callbacks of blocked clients,</span></span><br><span class="line"><span class="comment"> * before sometimes the module has the blocked client handle references</span></span><br><span class="line"><span class="comment"> * around, and wants to cleanup it. */</span></span><br><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_GetBlockedClientHandle</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if when the free callback of a blocked client is called,</span></span><br><span class="line"><span class="comment"> * the reason for the client to be unblocked is that it disconnected</span></span><br><span class="line"><span class="comment"> * while it was blocked. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_BlockedClientDisconnected</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="thread-safe-contexts">Thread Safe Contexts</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return a context which can be used inside threads to make Redis context</span></span><br><span class="line"><span class="comment"> * calls with certain modules APIs. If &#x27;bc&#x27; is not NULL then the module will</span></span><br><span class="line"><span class="comment"> * be bound to a blocked client, and it will be possible to use the</span></span><br><span class="line"><span class="comment"> * `RedisModule_Reply*` family of functions to accumulate a reply for when the</span></span><br><span class="line"><span class="comment"> * client will be unblocked. Otherwise the thread safe context will be</span></span><br><span class="line"><span class="comment"> * detached by a specific client.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To call non-reply APIs, the thread safe context must be prepared with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *     ... make your call here ...</span></span><br><span class="line"><span class="comment"> *     RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is not needed when using `RedisModule_Reply*` functions, assuming</span></span><br><span class="line"><span class="comment"> * that a blocked client was used when the context was created, otherwise</span></span><br><span class="line"><span class="comment"> * no RedisModule_Reply* call should be made at all.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> thread safe contexts do not inherit the blocked client</span></span><br><span class="line"><span class="comment"> * selected database. */</span></span><br><span class="line"><span class="function">RedisModuleCtx *<span class="title">RedisModule_GetThreadSafeContext</span><span class="params">(RedisModuleBlockedClient *bc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release a thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeThreadSafeContext</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acquire the server lock before executing a thread safe API call.</span></span><br><span class="line"><span class="comment"> * This is not needed for `RedisModule_Reply*` calls when there is</span></span><br><span class="line"><span class="comment"> * a blocked client connected to the thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ThreadSafeContextLock</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the server lock after a thread safe API call was executed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ThreadSafeContextUnlock</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="module-keyspace-notifications-api">Module Keyspace Notifications API</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Subscribe to keyspace notifications. This is a low-level version of the</span></span><br><span class="line"><span class="comment"> * keyspace-notifications API. A module can register callbacks to be notified</span></span><br><span class="line"><span class="comment"> * when keyspce events occur. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SubscribeToKeyspaceEvents</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> types, RedisModuleNotificationFunc callback)</span></span>;</span><br></pre></td></tr></table></figure><p><code>types</code> 表示我们想订阅的 events 类型，其种类如下：</p><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr class="header"><th style="text-align: left;">types</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_GENERIC</td><td style="text-align: left;">Generic commands like DEL, EXPIRE, RENAME</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_STRING</td><td style="text-align: left;">String events</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_LIST</td><td style="text-align: left;">List events</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_SET</td><td style="text-align: left;">Set events</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_HASH</td><td style="text-align: left;">Hash events</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_ZSET</td><td style="text-align: left;">Sorted Set events</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_EXPIRED</td><td style="text-align: left;">Expiration events</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_EVICTED</td><td style="text-align: left;">Eviction events</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_STREAM</td><td style="text-align: left;">Stream events</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_KEYMISS</td><td style="text-align: left;">Key-miss events</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_NOTIFY_ALL</td><td style="text-align: left;">All events (Excluding REDISMODULE_NOTIFY_KEYMISS)</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_NOTIFY_LOADED</td><td style="text-align: left;">A special notification available only for modules, indicates that the key was loaded from persistence. Notice, when this event fires, the given key can not be retained, use RM_CreateStringFromString instead.</td></tr></tbody></table><p>回调函数 <code>RedisModuleNotificationFunc</code> 的 <code>signature</code> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx,</span><br><span class="line">                                    <span class="keyword">int</span> type,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">char</span> *event,</span><br><span class="line">                                    RedisModuleString *key);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>type</code> 必须和注册时相同</li><li><code>event</code> 指的是正在执行的 command</li><li><code>key</code> 为相关的 redis key</li></ul><p>需要注意以下几点：</p><ul><li>不可再 <code>RedisModuleNotificationFunc</code> 中向客户端发送信息</li><li>为了使 module notifications 工作无需在 <code>redis.conf</code> 中启用 <code>notifications</code></li><li>由于 <code>RedisModuleNotificationFunc</code> 是同步运行的，因此要保证该函数的运行够快</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get the configured bitmap of notify-keyspace-events (Could be used</span></span><br><span class="line"><span class="comment"> * for additional filtering in RedisModuleNotificationFunc) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetNotifyKeyspaceEvents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expose notifyKeyspaceEvent to modules */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_NotifyKeyspaceEvent</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">char</span> *event, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-cluster-api">Modules Cluster API</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a callback receiver for cluster messages of type &#x27;type&#x27;. If there</span></span><br><span class="line"><span class="comment"> * was already a registered callback, this will replace the callback function</span></span><br><span class="line"><span class="comment"> * with the one provided, otherwise if the callback is set to NULL and there</span></span><br><span class="line"><span class="comment"> * is already a callback for this function, the callback is unregistered</span></span><br><span class="line"><span class="comment"> * (so this API call is also used in order to delete the receiver). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_RegisterClusterMessageReceiver</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint8_t</span> type, RedisModuleClusterMessageReceiver callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a message to all the nodes in the cluster if `target` is NULL, otherwise</span></span><br><span class="line"><span class="comment"> * at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as</span></span><br><span class="line"><span class="comment"> * returned by the receiver callback or by the nodes iteration functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK if the message was successfully sent,</span></span><br><span class="line"><span class="comment"> * otherwise if the node is not connected or such node ID does not map to any</span></span><br><span class="line"><span class="comment"> * known cluster node, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SendClusterMessage</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> *target_id, <span class="keyword">uint8_t</span> type, <span class="keyword">unsigned</span> <span class="keyword">char</span> *msg, <span class="keyword">uint32_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return an array of string pointers, each string pointer points to a cluster</span></span><br><span class="line"><span class="comment"> * node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).</span></span><br><span class="line"><span class="comment"> * The number of returned node IDs is stored into `*numnodes`.</span></span><br><span class="line"><span class="comment"> * However if this function is called by a module not running an a Redis</span></span><br><span class="line"><span class="comment"> * instance with Redis Cluster enabled, NULL is returned instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order</span></span><br><span class="line"><span class="comment"> * to get more information about single nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The array returned by this function must be freed using the function</span></span><br><span class="line"><span class="comment"> * RedisModule_FreeClusterNodesList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     size_t count, j;</span></span><br><span class="line"><span class="comment"> *     char **ids = RedisModule_GetClusterNodesList(ctx,&amp;count);</span></span><br><span class="line"><span class="comment"> *     for (j = 0; j &lt; count; j++) &#123;</span></span><br><span class="line"><span class="comment"> *         RedisModule_Log(&quot;notice&quot;,&quot;Node %.*s&quot;,</span></span><br><span class="line"><span class="comment"> *             REDISMODULE_NODE_ID_LEN,ids[j]);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *     RedisModule_FreeClusterNodesList(ids);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">RedisModule_GetClusterNodesList</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">size_t</span> *numnodes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the node list obtained with RedisModule_GetClusterNodesList. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeClusterNodesList</span><span class="params">(<span class="keyword">char</span> **ids)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster</span></span><br><span class="line"><span class="comment"> * is disabled. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_GetMyClusterID</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of nodes in the cluster, regardless of their state</span></span><br><span class="line"><span class="comment"> * (handshake, noaddress, ...) so that the number of active nodes may actually</span></span><br><span class="line"><span class="comment"> * be smaller, but not greater than this number. If the instance is not in</span></span><br><span class="line"><span class="comment"> * cluster mode, zero is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">RedisModule_GetClusterSize</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate the specified info for the node having as ID the specified &#x27;id&#x27;,</span></span><br><span class="line"><span class="comment"> * then returns REDISMODULE_OK. Otherwise if the node ID does not exist from</span></span><br><span class="line"><span class="comment"> * the POV of this local node, REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The arguments ip, master_id, port and flags can be NULL in case we don&#x27;t</span></span><br><span class="line"><span class="comment"> * need to populate back certain info. If an ip and master_id (only populated</span></span><br><span class="line"><span class="comment"> * if the instance is a slave) are specified, they point to buffers holding</span></span><br><span class="line"><span class="comment"> * at least REDISMODULE_NODE_ID_LEN bytes. The strings written back as ip</span></span><br><span class="line"><span class="comment"> * and master_id are not null terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The list of flags reported is the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_MYSELF        This node</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_MASTER        The node is a master</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_SLAVE         The node is a replica</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_PFAIL         We see the node as failing</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_FAIL          The cluster agrees the node is failing</span></span><br><span class="line"><span class="comment"> * * REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetClusterNodeInfo</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">char</span> *ip, <span class="keyword">char</span> *master_id, <span class="keyword">int</span> *port, <span class="keyword">int</span> *flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set Redis Cluster flags in order to change the normal behavior of</span></span><br><span class="line"><span class="comment"> * Redis Cluster, especially with the goal of disabling certain functions.</span></span><br><span class="line"><span class="comment"> * This is useful for modules that use the Cluster API in order to create</span></span><br><span class="line"><span class="comment"> * a different distributed system, but still want to use the Redis Cluster</span></span><br><span class="line"><span class="comment"> * message bus. Flags that can be set:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  CLUSTER_MODULE_FLAG_NO_FAILOVER</span></span><br><span class="line"><span class="comment"> *  CLUSTER_MODULE_FLAG_NO_REDIRECTION</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * With the following effects:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  NO_FAILOVER: prevent Redis Cluster slaves to failover a failing master.</span></span><br><span class="line"><span class="comment"> *               Also disables the replica migration feature.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  NO_REDIRECTION: Every node will accept any key, without trying to perform</span></span><br><span class="line"><span class="comment"> *                  partitioning according to the user Redis Cluster algorithm.</span></span><br><span class="line"><span class="comment"> *                  Slots informations will still be propagated across the</span></span><br><span class="line"><span class="comment"> *                  cluster, but without effects. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SetClusterFlags</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">uint64_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-timers-api">Modules Timers API</h2><p>Module timers are an high precision "green timers" abstraction where every module can register even millions of timers without problems, even if the actual event loop will just have a single timer that is used to awake the module timers subsystem in order to process the next event.</p><p>All the timers are stored into a radix tree, ordered by expire time, when the main Redis event loop timer callback is called, we try to process all the timers already expired one after the other. Then we re-enter the event loop registering a timer that will expire when the next to process module timer will expire.</p><p>Every time the list of active timers drops to zero, we unregister the main event loop timer, so that there is no overhead when such feature is not used.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new timer that will fire after `period` milliseconds, and will call</span></span><br><span class="line"><span class="comment"> * the specified function using `data` as argument. The returned timer ID can be</span></span><br><span class="line"><span class="comment"> * used to get information from the timer or to stop it before it fires. */</span></span><br><span class="line"><span class="function">RedisModuleTimerID <span class="title">RedisModule_CreateTimer</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">mstime_t</span> period, RedisModuleTimerProc callback, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the</span></span><br><span class="line"><span class="comment"> * calling module, and was stopped, otherwise REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> * If not NULL, the data pointer is set to the value of the data argument when</span></span><br><span class="line"><span class="comment"> * the timer was created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StopTimer</span><span class="params">(RedisModuleCtx *ctx, RedisModuleTimerID id, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Obtain information about a timer: its remaining time before firing</span></span><br><span class="line"><span class="comment"> * (in milliseconds), and the private data pointer associated with the timer.</span></span><br><span class="line"><span class="comment"> * If the timer specified does not exist or belongs to a different module</span></span><br><span class="line"><span class="comment"> * no information is returned and the function returns REDISMODULE_ERR, otherwise</span></span><br><span class="line"><span class="comment"> * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if</span></span><br><span class="line"><span class="comment"> * the caller does not need certain information. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetTimerInfo</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleTimerID id, <span class="keyword">uint64_t</span> *remaining, <span class="keyword">void</span> **data)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-acl-api">Modules ACL API</h2><p>Implements a hook into the authentication and authorization within Redis.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Creates a Redis ACL user that the module can use to authenticate a client.</span></span><br><span class="line"><span class="comment"> * After obtaining the user, the module should set what such user can do</span></span><br><span class="line"><span class="comment"> * using the RM_SetUserACL() function. Once configured, the user</span></span><br><span class="line"><span class="comment"> * can be used in order to authenticate a connection, with the specified</span></span><br><span class="line"><span class="comment"> * ACL rules, using the RedisModule_AuthClientWithUser() function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Users created here are not listed by the ACL command.</span></span><br><span class="line"><span class="comment"> * * Users created here are not checked for duplicated name, so it&#x27;s up to</span></span><br><span class="line"><span class="comment"> *   the module calling this function to take care of not creating users</span></span><br><span class="line"><span class="comment"> *   with the same name.</span></span><br><span class="line"><span class="comment"> * * The created user can be used to authenticate multiple Redis connections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller can later free the user using the function</span></span><br><span class="line"><span class="comment"> * RM_FreeModuleUser(). When this function is called, if there are</span></span><br><span class="line"><span class="comment"> * still clients authenticated with this user, they are disconnected.</span></span><br><span class="line"><span class="comment"> * The function to free the user should only be used when the caller really</span></span><br><span class="line"><span class="comment"> * wants to invalidate the user to define a new one with different</span></span><br><span class="line"><span class="comment"> * capabilities. */</span></span><br><span class="line"><span class="function">RedisModuleUser *<span class="title">RedisModule_CreateModuleUser</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Frees a given user and disconnects all of the clients that have been</span></span><br><span class="line"><span class="comment"> * authenticated with it. See RM_CreateModuleUser for detailed usage.*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_FreeModuleUser</span><span class="params">(RedisModuleUser *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets the permissions of a user created through the redis module</span></span><br><span class="line"><span class="comment"> * interface. The syntax is the same as ACL SETUSER, so refer to the</span></span><br><span class="line"><span class="comment"> * documentation in acl.c for more information. See RM_CreateModuleUser</span></span><br><span class="line"><span class="comment"> * for detailed usage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_OK on success and REDISMODULE_ERR on failure</span></span><br><span class="line"><span class="comment"> * and will set an errno describing why the operation failed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetModuleUserACL</span><span class="params">(RedisModuleUser *user, <span class="keyword">const</span> <span class="keyword">char</span>* acl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Authenticate the current context&#x27;s user with the provided redis acl user.</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_ERR if the user is disabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See authenticateClientWithUser for information about callback, client_id,</span></span><br><span class="line"><span class="comment"> * and general usage for authentication. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AuthenticateClientWithUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUser *module_user,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUserChangedFunc callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *privdata,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> *client_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Authenticate the current context&#x27;s user with the provided redis acl user.</span></span><br><span class="line"><span class="comment"> * Returns REDISMODULE_ERR if the user is disabled or the user does not exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See authenticateClientWithUser for information about callback, client_id,</span></span><br><span class="line"><span class="comment"> * and general usage for authentication. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AuthenticateClientWithACLUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleUserChangedFunc callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *privdata,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> *client_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deauthenticate and close the client. The client resources will not be</span></span><br><span class="line"><span class="comment"> * be immediately freed, but will be cleaned up in a background job. This is</span></span><br><span class="line"><span class="comment"> * the recommended way to deauthenicate a client since most clients can&#x27;t</span></span><br><span class="line"><span class="comment"> * handle users becomming deauthenticated. Returns REDISMODULE_ERR when the</span></span><br><span class="line"><span class="comment"> * client doesn&#x27;t exist and REDISMODULE_OK when the operation was successful.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The client ID is returned from the RM_AuthenticateClientWithUser and</span></span><br><span class="line"><span class="comment"> * RM_AuthenticateClientWithACLUser APIs, but can be obtained through</span></span><br><span class="line"><span class="comment"> * the CLIENT api or through server events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is not thread safe, and must be executed within the context</span></span><br><span class="line"><span class="comment"> * of a command or thread safe context. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DeauthenticateAndCloseClient</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">uint64_t</span> client_id)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-dictionary-api">Modules Dictionary API</h2><p>Implements a sorted dictionary (actually backed by a radix tree) with the usual get / set / del / num-items API, together with an iterator capable of going back and forth.</p><h3 id="base-1">Base</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new dictionary. */</span></span><br><span class="line"><span class="function">RedisModuleDict *<span class="title">RedisModule_CreateDict</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>新建一个 Dictionary，传入的 <code>ctx</code> 可以为 <code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a dictionary created with RM_CreateDict(). You need to pass the</span></span><br><span class="line"><span class="comment"> * context pointer &#x27;ctx&#x27; only if the dictionary was created using the</span></span><br><span class="line"><span class="comment"> * context instead of passing NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeDict</span><span class="params">(RedisModuleCtx *ctx, RedisModuleDict *d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the size of the dictionary (number of keys). */</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">RedisModule_DictSize</span><span class="params">(RedisModuleDict *d)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="setgetdel">Set/Get/Del</h3><p><strong>Take key as a cstring</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the specified key into the dictionary, setting its value to the</span></span><br><span class="line"><span class="comment"> * pointer &#x27;ptr&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictSetC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>当 <code>key</code> 已存在时，返回 <code>REDISMODULE_ERR</code>，否则返回 <code>REDISMODULE_OK</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Like RedisModule_DictSetC() but will replace the key with the new</span></span><br><span class="line"><span class="comment"> * value if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictReplaceC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value stored at the specified key. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictGetC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> *nokey)</span></span>;</span><br></pre></td></tr></table></figure><p><code>RedisModule_DictGetC</code> 在 <code>key</code> 不存在或 <code>key</code> 对应的 <code>value</code> 为 <code>NULL</code> 时，返回 <code>NULL</code>。因此，若想确定 <code>key</code> 是否存在时，可传入非空的 <code>nokey</code>，当 <code>key</code> 不存在时，其会被设置为 1，否则为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified key from the dictionary. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictDelC</span><span class="params">(RedisModuleDict *d, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">void</span> *oldval)</span></span>;</span><br></pre></td></tr></table></figure><p>当 <code>key</code> 存在并被删除时，返回 <code>REDISMODULE_OK</code>，若 <code>key</code> 不存在时，返回 <code>REDISMODULE_ERR</code>。返回 <code>REDISMODULE_OK</code> 时，若传入的 <code>oldval</code> 不为空，其会保存 <code>key</code> 被删除前对应的 <code>value</code>。</p><p><strong>Take key as a RedisModuleString</strong></p><p><code>key</code> 的数据类型为 <code>RedisModuleString</code>，功能和上述四个接口相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictSet</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictReplace</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictGet</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">int</span> *nokey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictDel</span><span class="params">(RedisModuleDict *d, RedisModuleString *key, <span class="keyword">void</span> *oldval)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="iterator">Iterator</h3><p><strong>Take key as a cstring</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleDictIter *<span class="title">RedisModule_DictIteratorStartC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDict *d, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure><p>基于传入的 <code>key</code> 和 <code>op</code>，返回 Dictionary 的迭代器，其中 <code>op</code> 的种类如下:</p><ul><li><code>^</code> -- Seek the first (lexicographically smaller) key.</li><li><code>$</code> -- Seek the last (lexicographically biffer) key.</li><li><code>&gt;</code> -- Seek the first element greter than the specified key.</li><li><code>&gt;=</code> -- Seek the first element greater or equal than the specified key.</li><li><code>&lt;</code> -- Seek the first element smaller than the specified key.</li><li><code>&lt;=</code> -- Seek the first element smaller or equal than the specified key.</li><li><code>==</code> -- Seek the first element matching exactly the specified key.</li></ul><p>当 <code>op</code> 为 <code>^</code> 或 <code>$</code> 时，传入的 <code>key</code> 不会被使用，此时传入 <code>key</code> 可为 <code>NULL</code>，<code>keylen</code> 为 0.</p><p>如果根据 <code>key</code> 和 <code>op</code> 无法获取迭代器，那么初次调用 <code>RedisModule_DictNextC() / PrevC()</code> 时会返回 <code>REDISMODULE_ERR</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictIteratorReseekC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在调用 <code>RedisModule_DictIteratorStartC()</code> 获得迭代器之后，可以通过调用该函数改变迭代器当前所指向的元素</li><li><code>op</code> 和 <code>key</code> 的含义和 <code>RedisModule_DictIteratorStartC()</code> 相同</li><li>查找到指定的元素后，返回 <code>REDISMODULE_OK</code>，无法查找指定的元素时，返回 <code>REDISMODULE_ERR</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the current item of the dictionary iterator &#x27;di&#x27; and steps to the</span></span><br><span class="line"><span class="comment"> * next element. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictNextC</span><span class="params">(RedisModuleDictIter *di, <span class="keyword">size_t</span> *keylen, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is exactly like RedisModule_DictNext() but after returning</span></span><br><span class="line"><span class="comment"> * the currently selected element in the iterator, it selects the previous</span></span><br><span class="line"><span class="comment"> * element (laxicographically smaller) instead of the next one. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_DictPrevC</span><span class="params">(RedisModuleDictIter *di, <span class="keyword">size_t</span> *keylen, <span class="keyword">void</span> **dataptr)</span></span>;</span><br></pre></td></tr></table></figure><p>这两函数执行模式类似，下述仅提及 <code>RedisModule_DictNextC()</code>。</p><p>如果迭代器已指向最后一个元素，返回 <code>NULL</code>，否则返回指向 <code>key</code> 的指针，此时：</p><ul><li>若 <code>keylen</code> 不为 <code>NULL</code>，则会被赋值为 <code>key</code> 的长度</li><li>若 <code>*dataptr</code> 不为 <code>NULL</code>，则会被赋值为指向 <code>value</code> 的指针</li></ul><p>由于返回的值都是指针，因此返回值仅在 <code>di</code> 未被释放且未调用 <code>RedisModule_DictNextC()</code> 或 <code>RedisModule_DictPrevC()</code> 之前有效。</p><p>使用示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... create the iteator here ... */</span></span><br><span class="line"><span class="keyword">char</span> *key;</span><br><span class="line"><span class="keyword">size_t</span> keylen;</span><br><span class="line"><span class="keyword">void</span> *data;</span><br><span class="line"><span class="keyword">while</span>((key = RedisModule_DictNextC(iter, &amp;keylen, &amp;data)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.*s %p\n&quot;</span>, (<span class="keyword">int</span>)keylen, key, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare the element currently pointed by the iterator to the specified</span></span><br><span class="line"><span class="comment"> * element given by key/keylen, according to the operator &#x27;op&#x27; (the set of</span></span><br><span class="line"><span class="comment"> * valid operators are the same valid for RedisModule_DictIteratorStart).</span></span><br><span class="line"><span class="comment"> * If the comparision is successful the command returns REDISMODULE_OK</span></span><br><span class="line"><span class="comment"> * otherwise REDISMODULE_ERR is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is useful when we want to just emit a lexicographical range, so</span></span><br><span class="line"><span class="comment"> * in the loop, as we iterate elements, we can also check if we are still</span></span><br><span class="line"><span class="comment"> * on range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returne REDISMODULE_ERR if the iterator reached the</span></span><br><span class="line"><span class="comment"> * end of elements condition as well. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictCompareC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">void</span> *key, <span class="keyword">size_t</span> keylen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Take key as a RedisModuleString</strong></p><p><code>key</code> 的数据类型为 <code>RedisModuleString</code>，功能和上述五个接口相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleDictIter *<span class="title">RedisModule_DictIteratorStart</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDict *d, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictIteratorReseek</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_DictNext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleDictIter *di, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_DictPrev</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleDictIter *di, <span class="keyword">void</span> **dataptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_DictCompare</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleDictIter *di, <span class="keyword">const</span> <span class="keyword">char</span> *op, RedisModuleString *key)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Stop</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Release the iterator created with RedisModule_DictIteratorStart(). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_DictIteratorStop</span><span class="params">(RedisModuleDictIter *di)</span></span>;</span><br></pre></td></tr></table></figure><p>必须调用该函数以释放 <code>RedisModuleDictIter</code> 对象。</p><h2 id="modules-info-fields">Modules Info fields</h2><p>可以使用以下接口在 <code>INFO</code> 命令中显示我们想展示的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used to start a new section, before adding any fields. the section name will</span></span><br><span class="line"><span class="comment"> * be prefixed by &quot;&lt;modulename&gt;_&quot; and must only include A-Z,a-z,0-9.</span></span><br><span class="line"><span class="comment"> * NULL or empty string indicates the default section (only &lt;modulename&gt;) is used.</span></span><br><span class="line"><span class="comment"> * When return value is REDISMODULE_ERR, the section should and will be skipped. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddSection</span><span class="params">(RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Starts a dict field, similar to the ones in INFO KEYSPACE. Use normal</span></span><br><span class="line"><span class="comment"> * RedisModule_InfoAddField* functions to add the items to this field, and</span></span><br><span class="line"><span class="comment"> * terminate with RedisModule_InfoEndDictField. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoBeginDictField</span><span class="params">(RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ends a dict field, see RedisModule_InfoBeginDictField */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoEndDictField</span><span class="params">(RedisModuleInfoCtx *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by RedisModuleInfoFunc to add info fields.</span></span><br><span class="line"><span class="comment"> * Each field will be automatically prefixed by &quot;&lt;modulename&gt;_&quot;.</span></span><br><span class="line"><span class="comment"> * Field names or values must not include \r\n of &quot;:&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, RedisModuleString *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldCString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldLongLong</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_InfoAddFieldULongLong</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleInfoCtx *ctx, <span class="keyword">char</span> *field, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_RegisterInfoFunc</span><span class="params">(RedisModuleCtx *ctx, RedisModuleInfoFunc cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get information about the server similar to the one that returns from the</span></span><br><span class="line"><span class="comment"> * INFO command. This function takes an optional &#x27;section&#x27; argument that may</span></span><br><span class="line"><span class="comment"> * be NULL. The return value holds the output and can be used with</span></span><br><span class="line"><span class="comment"> * RedisModule_ServerInfoGetField and alike to get the individual fields.</span></span><br><span class="line"><span class="comment"> * When done, it needs to be freed with RedisModule_FreeServerInfo or with the</span></span><br><span class="line"><span class="comment"> * automatic memory management mechanism if enabled. */</span></span><br><span class="line"><span class="function">RedisModuleServerInfoData *<span class="title">RedisModule_GetServerInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *section)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free data created with RM_GetServerInfo(). You need to pass the</span></span><br><span class="line"><span class="comment"> * context pointer &#x27;ctx&#x27; only if the dictionary was created using the</span></span><br><span class="line"><span class="comment"> * context instead of passing NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeServerInfo</span><span class="params">(RedisModuleCtx *ctx, RedisModuleServerInfoData *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). You</span></span><br><span class="line"><span class="comment"> * need to pass the context pointer &#x27;ctx&#x27; only if you want to use auto memory</span></span><br><span class="line"><span class="comment"> * mechanism to release the returned string. Return value will be NULL if the</span></span><br><span class="line"><span class="comment"> * field was not found. */</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_ServerInfoGetField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Similar to RM_ServerInfoGetField, but returns a char* which should not be </span></span><br><span class="line"><span class="comment"> * freed but the caller. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_ServerInfoGetFieldC</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not numerical or out of range, return value will be</span></span><br><span class="line"><span class="comment"> * 0, and the optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_ServerInfoGetFieldSigned</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not numerical or out of range, return value will be</span></span><br><span class="line"><span class="comment"> * 0, and the optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">RedisModule_ServerInfoGetFieldUnsigned</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the value of a field from data collected with RM_GetServerInfo(). If the</span></span><br><span class="line"><span class="comment"> * field is not found, or is not a double, return value will be 0, and the</span></span><br><span class="line"><span class="comment"> * optional out_err argument will be set to REDISMODULE_ERR. */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RedisModule_ServerInfoGetFieldDouble</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleServerInfoData *data, <span class="keyword">const</span> <span class="keyword">char</span>* field, <span class="keyword">int</span> *out_err)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-utility-apis">Modules utility APIs</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return random bytes using SHA1 in counter mode with a /dev/urandom</span></span><br><span class="line"><span class="comment"> * initialized seed. This function is fast so can be used to generate</span></span><br><span class="line"><span class="comment"> * many bytes without any effect on the operating system entropy pool.</span></span><br><span class="line"><span class="comment"> * Currently this function is not thread safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_GetRandomBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like RedisModule_GetRandomBytes() but instead of setting the string to</span></span><br><span class="line"><span class="comment"> * random bytes the string is set to random characters in the in the</span></span><br><span class="line"><span class="comment"> * hex charset [0-9a-f]. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_GetRandomHexChars</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-api-exporting-importing">Modules API exporting / importing</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called by a module in order to export some API with a</span></span><br><span class="line"><span class="comment"> * given name. Other modules will be able to use this API by calling the</span></span><br><span class="line"><span class="comment"> * symmetrical function RM_GetSharedAPI() and casting the return value to</span></span><br><span class="line"><span class="comment"> * the right function pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return REDISMODULE_OK if the name is not already taken,</span></span><br><span class="line"><span class="comment"> * otherwise REDISMODULE_ERR will be returned and no operation will be</span></span><br><span class="line"><span class="comment"> * performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMPORTANT: the apiname argument should be a string literal with static</span></span><br><span class="line"><span class="comment"> * lifetime. The API relies on the fact that it will always be valid in</span></span><br><span class="line"><span class="comment"> * the future. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ExportSharedAPI</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *apiname, <span class="keyword">void</span> *func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Request an exported API pointer. The return value is just a void pointer</span></span><br><span class="line"><span class="comment"> * that the caller of this function will be required to cast to the right</span></span><br><span class="line"><span class="comment"> * function pointer, so this is a private contract between modules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the requested API is not available then NULL is returned. Because</span></span><br><span class="line"><span class="comment"> * modules can be loaded at different times with different order, this</span></span><br><span class="line"><span class="comment"> * function calls should be put inside some module generic API registering</span></span><br><span class="line"><span class="comment"> * step, that is called every time a module attempts to execute a</span></span><br><span class="line"><span class="comment"> * command that requires external APIs: if some API cannot be resolved, the</span></span><br><span class="line"><span class="comment"> * command should return an error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here is an exmaple:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int ... myCommandImplementation() &#123;</span></span><br><span class="line"><span class="comment"> *        if (getExternalAPIs() == 0) &#123;</span></span><br><span class="line"><span class="comment"> *             reply with an error here if we cannot have the APIs</span></span><br><span class="line"><span class="comment"> *        &#125;</span></span><br><span class="line"><span class="comment"> *        // Use the API:</span></span><br><span class="line"><span class="comment"> *        myFunctionPointer(foo);</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And the function registerAPI() is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     int getExternalAPIs(void) &#123;</span></span><br><span class="line"><span class="comment"> *         static int api_loaded = 0;</span></span><br><span class="line"><span class="comment"> *         if (api_loaded != 0) return 1; // APIs already resolved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         myFunctionPointer = RedisModule_GetOtherModuleAPI(&quot;...&quot;);</span></span><br><span class="line"><span class="comment"> *         if (myFunctionPointer == NULL) return 0;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         return 1;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_GetSharedAPI</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *apiname)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="module-command-filter-api">Module Command Filter API</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register a new command filter function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Command filtering makes it possible for modules to extend Redis by plugging</span></span><br><span class="line"><span class="comment"> * into the execution flow of all commands.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A registered filter gets called before Redis executes *any* command.  This</span></span><br><span class="line"><span class="comment"> * includes both core Redis commands and commands registered by any module.  The</span></span><br><span class="line"><span class="comment"> * filter applies in all execution paths including:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Invocation by a client.</span></span><br><span class="line"><span class="comment"> * 2. Invocation through `RedisModule_Call()` by any module.</span></span><br><span class="line"><span class="comment"> * 3. Invocation through Lua &#x27;redis.call()`.</span></span><br><span class="line"><span class="comment"> * 4. Replication of a command from a master.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The filter executes in a special filter context, which is different and more</span></span><br><span class="line"><span class="comment"> * limited than a RedisModuleCtx.  Because the filter affects any command, it</span></span><br><span class="line"><span class="comment"> * must be implemented in a very efficient way to reduce the performance impact</span></span><br><span class="line"><span class="comment"> * on Redis.  All Redis Module API calls that require a valid context (such as</span></span><br><span class="line"><span class="comment"> * `RedisModule_Call()`, `RedisModule_OpenKey()`, etc.) are not supported in a</span></span><br><span class="line"><span class="comment"> * filter context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The `RedisModuleCommandFilterCtx` can be used to inspect or modify the</span></span><br><span class="line"><span class="comment"> * executed command and its arguments.  As the filter executes before Redis</span></span><br><span class="line"><span class="comment"> * begins processing the command, any change will affect the way the command is</span></span><br><span class="line"><span class="comment"> * processed.  For example, a module can override Redis commands this way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Register a `MODULE.SET` command which implements an extended version of</span></span><br><span class="line"><span class="comment"> *    the Redis `SET` command.</span></span><br><span class="line"><span class="comment"> * 2. Register a command filter which detects invocation of `SET` on a specific</span></span><br><span class="line"><span class="comment"> *    pattern of keys.  Once detected, the filter will replace the first</span></span><br><span class="line"><span class="comment"> *    argument from `SET` to `MODULE.SET`.</span></span><br><span class="line"><span class="comment"> * 3. When filter execution is complete, Redis considers the new command name</span></span><br><span class="line"><span class="comment"> *    and therefore executes the module&#x27;s own command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that in the above use case, if `MODULE.SET` itself uses</span></span><br><span class="line"><span class="comment"> * `RedisModule_Call()` the filter will be applied on that call as well.  If</span></span><br><span class="line"><span class="comment"> * that is not desired, the `REDISMODULE_CMDFILTER_NOSELF` flag can be set when</span></span><br><span class="line"><span class="comment"> * registering the filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The `REDISMODULE_CMDFILTER_NOSELF` flag prevents execution flows that</span></span><br><span class="line"><span class="comment"> * originate from the module&#x27;s own `RM_Call()` from reaching the filter.  This</span></span><br><span class="line"><span class="comment"> * flag is effective for all execution flows, including nested ones, as long as</span></span><br><span class="line"><span class="comment"> * the execution begins from the module&#x27;s command context or a thread-safe</span></span><br><span class="line"><span class="comment"> * context that is associated with a blocking command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detached thread-safe contexts are *not* associated with the module and cannot</span></span><br><span class="line"><span class="comment"> * be protected by this flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If multiple filters are registered (by the same or different modules), they</span></span><br><span class="line"><span class="comment"> * are executed in the order of registration. */</span></span><br><span class="line"><span class="function">RedisModuleCommandFilter *<span class="title">RedisModule_RegisterCommandFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unregister a command filter. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnregisterCommandFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx, RedisModuleCommandFilter *filter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of arguments a filtered command has.  The number of</span></span><br><span class="line"><span class="comment"> * arguments include the command itself. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgsCount</span><span class="params">(RedisModuleCommandFilterCtx *fctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the specified command argument.  The first argument (position 0) is</span></span><br><span class="line"><span class="comment"> * the command itself, and the rest are user-provided args. */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> RedisModuleString *<span class="title">RedisModule_CommandFilterArgGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by inserting a new argument at the specified</span></span><br><span class="line"><span class="comment"> * position.  The specified RedisModuleString argument may be used by Redis</span></span><br><span class="line"><span class="comment"> * after the filter context is destroyed, so it must not be auto-memory</span></span><br><span class="line"><span class="comment"> * allocated, freed or used elsewhere. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgInsert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos, RedisModuleString *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by replacing an existing argument with a new one.</span></span><br><span class="line"><span class="comment"> * The specified RedisModuleString argument may be used by Redis after the</span></span><br><span class="line"><span class="comment"> * filter context is destroyed, so it must not be auto-memory allocated, freed</span></span><br><span class="line"><span class="comment"> * or used elsewhere. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgReplace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos, RedisModuleString *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modify the filtered command by deleting an argument at the specified position. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_CommandFilterArgDelete</span><span class="params">(RedisModuleCommandFilterCtx *fctx, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="scanning-keyspace-and-hashes">Scanning keyspace and hashes</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new cursor to be used with RedisModule_Scan */</span></span><br><span class="line"><span class="function">RedisModuleScanCursor *<span class="title">RedisModule_ScanCursorCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restart an existing cursor. The keys will be rescanned. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ScanCursorRestart</span><span class="params">(RedisModuleScanCursor *cursor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy the cursor struct. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_ScanCursorDestroy</span><span class="params">(RedisModuleScanCursor *cursor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scan API that allows a module to scan all the keys and value in</span></span><br><span class="line"><span class="comment"> * the selected db.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callback for scan implementation.</span></span><br><span class="line"><span class="comment"> * void scan_callback(RedisModuleCtx *ctx, RedisModuleString *keyname,</span></span><br><span class="line"><span class="comment"> *                    RedisModuleKey *key, void *privdata);</span></span><br><span class="line"><span class="comment"> * ctx - the redis module context provided to for the scan.</span></span><br><span class="line"><span class="comment"> * keyname - owned by the caller and need to be retained if used after this</span></span><br><span class="line"><span class="comment"> * function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key - holds info on the key and value, it is provided as best effort, in</span></span><br><span class="line"><span class="comment"> * some cases it might be NULL, in which case the user should (can) use</span></span><br><span class="line"><span class="comment"> * RedisModule_OpenKey (and CloseKey too).</span></span><br><span class="line"><span class="comment"> * when it is provided, it is owned by the caller and will be free when the</span></span><br><span class="line"><span class="comment"> * callback returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * privdata - the user data provided to RedisModule_Scan.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way it should be used:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_Scan(ctx, c, callback, privateData));</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to use this API from another thread while the lock</span></span><br><span class="line"><span class="comment"> * is acquired durring the actuall call to RM_Scan:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_Scan(ctx, c, callback, privateData))&#123;</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *          // do some background job</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return 1 if there are more elements to scan and</span></span><br><span class="line"><span class="comment"> * 0 otherwise, possibly setting errno if the call failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to restart an existing cursor using RM_ScanCursorRestart.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMPORTANT: This API is very similar to the Redis SCAN command from the</span></span><br><span class="line"><span class="comment"> * point of view of the guarantees it provides. This means that the API</span></span><br><span class="line"><span class="comment"> * may report duplicated keys, but guarantees to report at least one time</span></span><br><span class="line"><span class="comment"> * every key that was there from the start to the end of the scanning process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> If you do database changes within the callback, you should be aware</span></span><br><span class="line"><span class="comment"> * that the internal state of the database may change. For instance it is safe</span></span><br><span class="line"><span class="comment"> * to delete or modify the current key, but may not be safe to delete any</span></span><br><span class="line"><span class="comment"> * other key.</span></span><br><span class="line"><span class="comment"> * Moreover playing with the Redis keyspace while iterating may have the</span></span><br><span class="line"><span class="comment"> * effect of returning more duplicates. A safe pattern is to store the keys</span></span><br><span class="line"><span class="comment"> * names you want to modify elsewhere, and perform the actions on the keys</span></span><br><span class="line"><span class="comment"> * later when the iteration is complete. Howerver this can cost a lot of</span></span><br><span class="line"><span class="comment"> * memory, so it may make sense to just operate on the current key when</span></span><br><span class="line"><span class="comment"> * possible during the iteration, given that this is safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Scan</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleScanCursor *cursor, RedisModuleScanCB fn, <span class="keyword">void</span> *privdata)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scan api that allows a module to scan the elements in a hash, set or sorted set key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callback for scan implementation.</span></span><br><span class="line"><span class="comment"> * void scan_callback(RedisModuleKey *key, RedisModuleString* field,</span></span><br><span class="line"><span class="comment"> *                    RedisModuleString* value, void *privdata);</span></span><br><span class="line"><span class="comment"> * - key - the redis key context provided to for the scan.</span></span><br><span class="line"><span class="comment"> * - field - field name, owned by the caller and need to be retained if used</span></span><br><span class="line"><span class="comment"> *   after this function.</span></span><br><span class="line"><span class="comment"> * - value - value string or NULL for set type, owned by the caller and need to</span></span><br><span class="line"><span class="comment"> *   be retained if used after this function.</span></span><br><span class="line"><span class="comment"> * - privdata - the user data provided to RedisModule_ScanKey.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way it should be used:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_ScanKey(key, c, callback, privateData));</span></span><br><span class="line"><span class="comment"> *      RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is also possible to use this API from another thread while the lock is acquired</span></span><br><span class="line"><span class="comment"> * during the actuall call to RM_ScanKey, and re-opening the key each time:</span></span><br><span class="line"><span class="comment"> *      RedisModuleCursor *c = RedisModule_ScanCursorCreate();</span></span><br><span class="line"><span class="comment"> *      RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *      RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      while(RedisModule_ScanKey(ctx, c, callback, privateData))&#123;</span></span><br><span class="line"><span class="comment"> *          RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextUnlock(ctx);</span></span><br><span class="line"><span class="comment"> *          // do some background job</span></span><br><span class="line"><span class="comment"> *          RedisModule_ThreadSafeContextLock(ctx);</span></span><br><span class="line"><span class="comment"> *          RedisModuleKey *key = RedisModule_OpenKey(...)</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      RedisModule_CloseKey(key);</span></span><br><span class="line"><span class="comment"> *      RedisModule_ScanCursorDestroy(c);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function will return 1 if there are more elements to scan and 0 otherwise,</span></span><br><span class="line"><span class="comment"> * possibly setting errno if the call failed.</span></span><br><span class="line"><span class="comment"> * It is also possible to restart an existing cursor using RM_ScanCursorRestart.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Certain operations are unsafe while iterating the object. For instance</span></span><br><span class="line"><span class="comment"> * while the API guarantees to return at least one time all the elements that</span></span><br><span class="line"><span class="comment"> * are present in the data structure consistently from the start to the end</span></span><br><span class="line"><span class="comment"> * of the iteration (see HSCAN and similar commands documentation), the more</span></span><br><span class="line"><span class="comment"> * you play with the elements, the more duplicates you may get. In general</span></span><br><span class="line"><span class="comment"> * deleting the current element of the data structure is safe, while removing</span></span><br><span class="line"><span class="comment"> * the key you are iterating is not safe. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ScanKey</span><span class="params">(RedisModuleKey *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="module-fork-api">Module fork API</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a background child process with the current frozen snaphost of the</span></span><br><span class="line"><span class="comment"> * main process where you can do some processing in the background without</span></span><br><span class="line"><span class="comment"> * affecting / freezing the traffic and no need for threads and GIL locking.</span></span><br><span class="line"><span class="comment"> * Note that Redis allows for only one concurrent fork.</span></span><br><span class="line"><span class="comment"> * When the child wants to exit, it should call RedisModule_ExitFromChild.</span></span><br><span class="line"><span class="comment"> * If the parent wants to kill the child it should call RedisModule_KillForkChild</span></span><br><span class="line"><span class="comment"> * The done handler callback will be executed on the parent process when the</span></span><br><span class="line"><span class="comment"> * child existed (but not when killed)</span></span><br><span class="line"><span class="comment"> * Return: -1 on failure, on success the parent process will get a positive PID</span></span><br><span class="line"><span class="comment"> * of the child, and the child process will get 0. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_Fork</span><span class="params">(RedisModuleForkDoneHandler cb, <span class="keyword">void</span> *user_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call from the child process when you want to terminate it.</span></span><br><span class="line"><span class="comment"> * retcode will be provided to the done handler executed on the parent process. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ExitFromChild</span><span class="params">(<span class="keyword">int</span> retcode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can be used to kill the forked child process from the parent process.</span></span><br><span class="line"><span class="comment"> * child_pid whould be the return value of RedisModule_Fork. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_KillForkChild</span><span class="params">(<span class="keyword">int</span> child_pid)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="server-hooks-implementation">Server hooks implementation</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register to be notified, via a callback, when the specified server event</span></span><br><span class="line"><span class="comment"> * happens. The callback is called with the event as argument, and an additional</span></span><br><span class="line"><span class="comment"> * argument which is a void pointer and should be cased to a specific type</span></span><br><span class="line"><span class="comment"> * that is event-specific (but many events will just use NULL since they do not</span></span><br><span class="line"><span class="comment"> * have additional information to pass to the callback).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the callback is NULL and there was a previous subscription, the module</span></span><br><span class="line"><span class="comment"> * will be unsubscribed. If there was a previous subscription and the callback</span></span><br><span class="line"><span class="comment"> * is not null, the old callback will be replaced with the new one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The callback must be of this type:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  int (*RedisModuleEventCallback)(RedisModuleCtx *ctx,</span></span><br><span class="line"><span class="comment"> *                                  RedisModuleEvent eid,</span></span><br><span class="line"><span class="comment"> *                                  uint64_t subevent,</span></span><br><span class="line"><span class="comment"> *                                  void *data);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &#x27;ctx&#x27; is a normal Redis module context that the callback can use in</span></span><br><span class="line"><span class="comment"> * order to call other modules APIs. The &#x27;eid&#x27; is the event itself, this</span></span><br><span class="line"><span class="comment"> * is only useful in the case the module subscribed to multiple events: using</span></span><br><span class="line"><span class="comment"> * the &#x27;id&#x27; field of this structure it is possible to check if the event</span></span><br><span class="line"><span class="comment"> * is one of the events we registered with this callback. The &#x27;subevent&#x27; field</span></span><br><span class="line"><span class="comment"> * depends on the event that fired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally the &#x27;data&#x27; pointer may be populated, only for certain events, with</span></span><br><span class="line"><span class="comment"> * more relevant data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here is a list of events you can use as &#x27;eid&#x27; and related sub events:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_ReplicationRoleChanged</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when the instance switches from master</span></span><br><span class="line"><span class="comment"> *          to replica or the other way around, however the event is</span></span><br><span class="line"><span class="comment"> *          also called when the replica remains a replica but starts to</span></span><br><span class="line"><span class="comment"> *          replicate with a different master.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_MASTER</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The &#x27;data&#x27; field can be casted by the callback to a</span></span><br><span class="line"><span class="comment"> *          RedisModuleReplicationInfo structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int master; // true if master, false if replica</span></span><br><span class="line"><span class="comment"> *              char *masterhost; // master instance hostname for NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *              int masterport; // master instance port for NOW_REPLICA</span></span><br><span class="line"><span class="comment"> *              char *replid1; // Main replication ID</span></span><br><span class="line"><span class="comment"> *              char *replid2; // Secondary replication ID</span></span><br><span class="line"><span class="comment"> *              uint64_t repl1_offset; // Main replication offset</span></span><br><span class="line"><span class="comment"> *              uint64_t repl2_offset; // Offset of replid2 validity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Persistence</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when RDB saving or AOF rewriting starts</span></span><br><span class="line"><span class="comment"> *          and ends. The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_ENDED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_PERSISTENCE_FAILED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The above events are triggered not just when the user calls the</span></span><br><span class="line"><span class="comment"> *          relevant commands like BGSAVE, but also when a saving operation</span></span><br><span class="line"><span class="comment"> *          or AOF rewriting occurs because of internal server triggers.</span></span><br><span class="line"><span class="comment"> *          The SYNC_RDB_START sub events are happening in the forground due to</span></span><br><span class="line"><span class="comment"> *          SAVE command, FLUSHALL, or server shutdown, and the other RDB and</span></span><br><span class="line"><span class="comment"> *          AOF sub events are executed in a background fork child, so any</span></span><br><span class="line"><span class="comment"> *          action the module takes can only affect the generated AOF or RDB,</span></span><br><span class="line"><span class="comment"> *          but will not be reflected in the parent process and affect connected</span></span><br><span class="line"><span class="comment"> *          clients and commands. Also note that the AOF_START sub event may end</span></span><br><span class="line"><span class="comment"> *          up saving RDB content in case of an AOF with rdb-preamble.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_FlushDB</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The FLUSHALL, FLUSHDB or an internal flush (for instance</span></span><br><span class="line"><span class="comment"> *          because of replication, after the replica synchronization)</span></span><br><span class="line"><span class="comment"> *          happened. The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_FLUSHDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_FLUSHDB_END</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleFlushInfo</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t async;  // True if the flush is done in a thread.</span></span><br><span class="line"><span class="comment"> *                                 See for instance FLUSHALL ASYNC.</span></span><br><span class="line"><span class="comment"> *                                 In this case the END callback is invoked</span></span><br><span class="line"><span class="comment"> *                                 immediately after the database is put</span></span><br><span class="line"><span class="comment"> *                                 in the free list of the thread.</span></span><br><span class="line"><span class="comment"> *              int32_t dbnum;  // Flushed database number, -1 for all the DBs</span></span><br><span class="line"><span class="comment"> *                                 in the case of the FLUSHALL operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The start event is called *before* the operation is initated, thus</span></span><br><span class="line"><span class="comment"> *          allowing the callback to call DBSIZE or other operation on the</span></span><br><span class="line"><span class="comment"> *          yet-to-free keyspace.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Loading</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Called on loading operations: at startup when the server is</span></span><br><span class="line"><span class="comment"> *          started, but also after a first synchronization when the</span></span><br><span class="line"><span class="comment"> *          replica is loading the RDB file from the master.</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_RDB_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_AOF_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_REPL_START</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_ENDED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_FAILED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Note that AOF loading may start with an RDB data in case of</span></span><br><span class="line"><span class="comment"> *          rdb-preamble, in which case you&#x27;ll only recieve an AOF_START event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_ClientChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          Called when a client connects or disconnects.</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleClientInfo</span></span><br><span class="line"><span class="comment"> *          structure, documented in RedisModule_GetClientInfoById().</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      RedisModuleEvent_Shutdown</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The server is shutting down. No subevents are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_ReplicaChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when the instance (that can be both a</span></span><br><span class="line"><span class="comment"> *          master or a replica) get a new online replica, or lose a</span></span><br><span class="line"><span class="comment"> *          replica since it gets disconnected.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          No additional information is available so far: future versions</span></span><br><span class="line"><span class="comment"> *          of Redis will have an API in order to enumerate the replicas</span></span><br><span class="line"><span class="comment"> *          connected and their state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_CronLoop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called every time Redis calls the serverCron()</span></span><br><span class="line"><span class="comment"> *          function in order to do certain bookkeeping. Modules that are</span></span><br><span class="line"><span class="comment"> *          required to do operations from time to time may use this callback.</span></span><br><span class="line"><span class="comment"> *          Normally Redis calls this function 10 times per second, but</span></span><br><span class="line"><span class="comment"> *          this changes depending on the &quot;hz&quot; configuration.</span></span><br><span class="line"><span class="comment"> *          No sub events are available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleCronLoop</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t hz;  // Approximate number of events per second.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_MasterLinkChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This is called for replicas in order to notify when the</span></span><br><span class="line"><span class="comment"> *          replication link becomes functional (up) with our master,</span></span><br><span class="line"><span class="comment"> *          or when it goes down. Note that the link is not considered</span></span><br><span class="line"><span class="comment"> *          up when we just connected to the master, but only if the</span></span><br><span class="line"><span class="comment"> *          replication is happening correctly.</span></span><br><span class="line"><span class="comment"> *          The following sub events are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MASTER_LINK_UP</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_ModuleChange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called when a new module is loaded or one is unloaded.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MODULE_LOADED</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_MODULE_UNLOADED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleModuleChange</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              const char* module_name;  // Name of module loaded or unloaded.</span></span><br><span class="line"><span class="comment"> *              int32_t module_version;  // Module version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  RedisModuleEvent_LoadingProgress</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          This event is called repeatedly called while an RDB or AOF file</span></span><br><span class="line"><span class="comment"> *          is being loaded.</span></span><br><span class="line"><span class="comment"> *          The following sub events are availble:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB</span></span><br><span class="line"><span class="comment"> *              REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          The data pointer can be casted to a RedisModuleLoadingProgress</span></span><br><span class="line"><span class="comment"> *          structure with the following fields:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              int32_t hz;  // Approximate number of events per second.</span></span><br><span class="line"><span class="comment"> *              int32_t progress;  // Approximate progress between 0 and 1024,</span></span><br><span class="line"><span class="comment"> *                                    or -1 if unknown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns REDISMODULE_OK if the module was successfully subscrived</span></span><br><span class="line"><span class="comment"> * for the specified event. If the API is called from a wrong context then</span></span><br><span class="line"><span class="comment"> * REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SubscribeToServerEvent</span><span class="params">(RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleEvent event, RedisModuleEventCallback callback)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="modules-api-internals">Modules API internals</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the key last access time for LRU based eviction. not relevent if the</span></span><br><span class="line"><span class="comment"> * servers&#x27;s maxmemory policy is LFU based. Value is idle time in milliseconds.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if the LRU was updated, REDISMODULE_ERR otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetLRU</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> lru_idle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gets the key last access time.</span></span><br><span class="line"><span class="comment"> * Value is idletime in milliseconds or -1 if the server&#x27;s eviction policy is</span></span><br><span class="line"><span class="comment"> * LFU based.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if when key is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetLRU</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> *lru_idle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the key access frequency. only relevant if the server&#x27;s maxmemory policy</span></span><br><span class="line"><span class="comment"> * is LFU based.</span></span><br><span class="line"><span class="comment"> * The frequency is a logarithmic counter that provides an indication of</span></span><br><span class="line"><span class="comment"> * the access frequencyonly (must be &lt;= 255).</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if the LFU was updated, REDISMODULE_ERR otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetLFU</span><span class="params">(RedisModuleKey *key, <span class="keyword">long</span> <span class="keyword">long</span> lfu_freq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gets the key access frequency or -1 if the server&#x27;s eviction policy is not</span></span><br><span class="line"><span class="comment"> * LFU based.</span></span><br><span class="line"><span class="comment"> * returns REDISMODULE_OK if when key is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_GetLFU</span><span class="params">(RedisModuleKey *key, <span class="keyword">long</span> <span class="keyword">long</span> *lfu_freq)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Modules APIs 介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NVM-notes</title>
    <link href="https://yz1509.github.io//posts/3ac765ba/"/>
    <id>https://yz1509.github.io//posts/3ac765ba/</id>
    <published>2020-08-26T12:38:59.000Z</published>
    <updated>2020-09-04T10:31:25.709Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>NVM 相关笔记。</p><a id="more"></a><hr><h2 id="intel-optane-dc-persistent-memory-overview">Intel Optane DC Persistent Memory Overview</h2><p><a href="https://software.intel.com/content/www/us/en/develop/videos/overview-of-the-new-intel-optane-dc-memory.html">原文地址</a></p><p>Intel Optane DC Persistent Memory has two main properties:</p><ul><li>It is <strong>persistent</strong>. Data is maintained even when the system power is off.</li><li>This memory is <strong>byte-addressable</strong>. Like in regular DRAM, programs can access data structures in place at cache line granularity, avoiding the need to access data in large blocks as it currently happens in traditional I/O.</li></ul><p>Persistent memory available modes:</p><ul><li><p>Memory Mode</p><figure><img src="/posts/3ac765ba/memory_mode.png" alt><figcaption>memory_mode</figcaption></figure></li><li><p>Application Direct (App-Direct) Mode</p><figure><img src="/posts/3ac765ba/app_direct_mode.png" alt><figcaption>app_direct_mode</figcaption></figure></li><li><p>Mixed Mode (combination of the two)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NVM 相关笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://yz1509.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="NVM" scheme="https://yz1509.github.io/tags/NVM/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Redis modules</title>
    <link href="https://yz1509.github.io//posts/a216612a/"/>
    <id>https://yz1509.github.io//posts/a216612a/</id>
    <published>2020-08-19T08:52:01.000Z</published>
    <updated>2020-08-29T08:07:34.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Redis Modules 入门。</p><a id="more"></a><hr><h2 id="introduction-to-redis-modules">Introduction to Redis modules</h2><p><a href="https://redis.io/topics/modules-intro">原文地址</a></p><h3 id="加载卸载和查看-modules">加载、卸载和查看 Modules</h3><p><strong>加载</strong></p><p>Modules 有两种加载方式：</p><ul><li>在 <code>redis.conf</code> 中设置：<code>loadmodule /path/to/mymodule.so</code></li><li>通过 redis command 实时加载：<code>MODULE LOAD /path/to/mymodule.so</code></li></ul><p>也可在加载模块时传递参数，如: <code>loadmodule(MODULE LOAD) /path/to/mymodule.so 765 PRO FIGHT</code></p><p><strong>卸载</strong></p><p>卸载 Modules：<code>MODULE UNLOAD mymodule</code>，如果需要在卸载模块之前进行内存清理之类的操作，可以通过实现 <code>RedisModule_OnUnload</code> 函数来完成，此函数接口为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_OnUnload</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>也可以通过在 <code>RedisModule_OnUnload</code> 中直接返回 <code>REDISMODULE_ERR</code> 禁止模块被卸载。</p><p><strong>查看</strong></p><p>列出已加载的 Modules: <code>MODULE LIST</code></p><h3 id="模块示例">模块示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;redismodule.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The function that implements the command must have the following prototype:</span></span><br><span class="line"><span class="comment"> * int mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HelloworldRand_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModule_ReplyWithLongLong(ctx, rand());</span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_OnLoad</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* It should be the first function called by the module OnLoad function.</span></span><br><span class="line"><span class="comment">     * Init function prototype:</span></span><br><span class="line"><span class="comment">     * @return int</span></span><br><span class="line"><span class="comment">     * @param1: RedisModuleCtx *ctx</span></span><br><span class="line"><span class="comment">     * @param2: const char *modeulename</span></span><br><span class="line"><span class="comment">     * @param3: int module_version (reported by MODULE LIST)</span></span><br><span class="line"><span class="comment">     * @param4: int api_version</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (RedisModule_Init(ctx, <span class="string">&quot;helloworld&quot;</span>, <span class="number">1</span>, REDISMODULE_APIVER_1) == REDISMODULE_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> REDISMODULE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It used in order to register commands into the Redis core.</span></span><br><span class="line"><span class="comment">     * CreateCommand function prototype:</span></span><br><span class="line"><span class="comment">     * @return int</span></span><br><span class="line"><span class="comment">     * @param1: RedisModuleCtx *ctx</span></span><br><span class="line"><span class="comment">     * @param2: const char *name</span></span><br><span class="line"><span class="comment">     * @param3: RedisModuleCmdFunc cmdfunc</span></span><br><span class="line"><span class="comment">     * @param4: const char *strflags</span></span><br><span class="line"><span class="comment">     * @param5: int firstkey</span></span><br><span class="line"><span class="comment">     * @param6: int lastkey</span></span><br><span class="line"><span class="comment">     * @param7: int keystep</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (RedisModule_CreateCommand(ctx, <span class="string">&quot;helloworld.rand&quot;</span>, HelloworldRand_RedisCommand,</span><br><span class="line">                                  <span class="string">&quot;fast random&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) == REDISMODULE_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> REDISMODULE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redismodulestring">RedisModuleString</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// accesss a string</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">RedisModule_StringPtrLen</span><span class="params">(RedisModuleString *<span class="built_in">string</span>, <span class="keyword">size_t</span> *len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create new string</span></span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_CreateString</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create string from number</span></span><br><span class="line">RedisModuleString *mystr = RedisModule_CreateStringFromLongLong(ctx, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse string as number</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> myval;</span><br><span class="line"><span class="keyword">if</span> (RedisModule_StringToLongLong(ctx, argv[<span class="number">1</span>], &amp;myval) == REDISMODULE_OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Do something with myval*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free a string which created by RedisModule_CreateString</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeString</span><span class="params">(RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>如果不想手动 free 的话，可以开启自动内存管理</li><li>通过 <code>argv</code> 数组传递的参数不要 free</li></ul><h3 id="返回响应">返回响应</h3><p>在模块中实现的命令可以通过 <code>RedisModule_ReplyWith&lt;something&gt;</code> 接口返回响应至客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return an error */</span></span><br><span class="line">RedisModule_ReplyWithError(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *err);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relpy with a long long */</span></span><br><span class="line">RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, <span class="keyword">long</span> <span class="keyword">long</span> res);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with a simple string, that can&#x27;t contain binary values or newlines */</span></span><br><span class="line">RedisModule_ReplyWithSimpleString(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *res);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with bulk strings that are binary safe */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithStringBuffer</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_ReplyWithString</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reply with an array, you just need to use a function to</span></span><br><span class="line"><span class="comment"> * emit the array length, followed by as many calls to the</span></span><br><span class="line"><span class="comment"> * above functions as the number of elements of array are. */</span></span><br><span class="line">RedisModule_ReplyWithArray(ctx, <span class="number">2</span>);</span><br><span class="line">RedisModule_ReplyWithStringBuffer(ctx, <span class="string">&quot;age&quot;</span>, <span class="number">3</span>);</span><br><span class="line">RedisModule_ReplyWithLongLong(ctx, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returning arrays with dynamic length,</span></span><br><span class="line"><span class="comment"> * It is possible to have multiple nested arrays with postponed reply.</span></span><br><span class="line"><span class="comment"> * Each call to ReplySetArrayLength() will set the length of the latest</span></span><br><span class="line"><span class="comment"> * corresponding call to to ReplyWithArray() */</span></span><br><span class="line">RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);</span><br><span class="line">... generate <span class="number">100</span> elements ...</span><br><span class="line">RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);</span><br><span class="line">... generate <span class="number">10</span> elements ...</span><br><span class="line">RedisModule_ReplySetArrayLength(ctx, <span class="number">10</span>);</span><br><span class="line">RedisModuel_ReplySetArrayLength(ctx, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="请求有效性检测">请求有效性检测</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check the number of arguments */</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisModule_WrongArity(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the type of key */</span></span><br><span class="line">RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[<span class="number">1</span>],</span><br><span class="line">    REDISMODULE_READ|REDISMODULE_WRITE);</span><br><span class="line"><span class="keyword">int</span> key_type = RedisModule_KeyType(key);</span><br><span class="line"><span class="keyword">if</span> (key_type != REDISMODULE_KEYTYPE_STRING &amp;&amp; key_type != REDISMODULE_KEYTYPE_EMPTY)</span><br><span class="line">&#123;</span><br><span class="line">    RedisModule_CloseKey(key);</span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="low-level-access-to-keys">Low level access to keys</h3><p>访问 Redis 数据库有两种 APIs:</p><ul><li>low level APIs: 可直接操作 Redis 数据结构，速度快</li><li>high level APIs：使用 <code>RedisModule_Call()</code> 函数 call Redis commands</li></ul><p>在请求有效性检测中，我们已经看过了 low level 操作的简单示例，这些 APIs 为了保证运行速度，并未做很多 run-time checks，因此需要遵守下述规则：</p><ul><li>同时 Open 相同的 key，并且其中有写操作的话，会产生未定义行为或 crashes</li><li>当一个 key 被 Open 时，应该只使用 low level APIs 访问，不可同时和 <code>RedisModule_Call()</code> 混用</li></ul><p><strong>Open a key for access</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleKey *key;</span><br><span class="line"><span class="comment">/* Prototype: void* RedisModule_OpenKey(RedisModuleCtx *ctx,</span></span><br><span class="line"><span class="comment"> *                                      RedisModuleString *keyname, int mode);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">RedisModule_OpenKey(ctx, argv[<span class="number">1</span>], REDISMODULE_READ;</span><br></pre></td></tr></table></figure><ul><li><code>mode</code> 可以是 <code>REDISMODULE_READ</code> 或 <code>REDISMODULE_WRITE</code></li><li>打开一个不存在的 key 时<ul><li><p><code>REDISMODULE_WRITE</code>：创造新 key，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleKey *key;</span><br><span class="line">key = RedisModule_OpenKey(ctx, argv[<span class="number">1</span>], REDISMODULE_WRITE);</span><br><span class="line"><span class="keyword">if</span> (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY)</span><br><span class="line">&#123;</span><br><span class="line">    RedisModule_StringSet(key, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>REDISMODULE_READ</code>: 返回 <code>NULL</code></p></li></ul></li></ul><p><strong>Getting the key type</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key_type = RedisModule_KeyType(key);</span><br></pre></td></tr></table></figure><p>返回值种类：</p><ul><li><code>REDISMODULE_KEYTYPE_EMPTY</code></li><li><code>REDISMODULE_KEYTYPE_STRING</code></li><li><code>REDISMODULE_KEYTYPE_LIST</code></li><li><code>REDISMODULE_KEYTYPE_SET</code></li><li><code>REDISMODULE_KEYTYPE_ZSET</code></li><li><code>REDISMODULE_KEYTYPE_HASH</code></li><li><code>REDISMODULE_KEYTYPE_MODULE</code></li><li><code>REDISMODULE_KEYTYPE_STREAM</code></li></ul><p><strong>Managing key expires(TTLs)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Query the current expire of an open key. Return the time to live of the key</span></span><br><span class="line"><span class="comment"> * in milliseconds, or REDISMODULE_NO_EXPIRE as a special value to signal the</span></span><br><span class="line"><span class="comment"> * key has no associated or does not exist at all. */</span></span><br><span class="line"><span class="function"><span class="keyword">mstime_t</span> <span class="title">RedisModule_GetExpire</span><span class="params">(RedisModuleKey *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Change the expire of a key</span></span><br><span class="line"><span class="comment"> * When called on a non existing key, REDISMODULE_ERR is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_SetExpire</span><span class="params">(RedisModuleKey *key, <span class="keyword">mstime_t</span> expire)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Deleting keys</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return REDISMODULE_ERR if the key is not open for writing */</span></span><br><span class="line">RedisModule_DeleteKey(key);</span><br></pre></td></tr></table></figure><p><strong>Close a key</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisModule_CloseKey(key);</span><br></pre></td></tr></table></figure><p>当自动内存管理功能开启时，也可以不用 close keys。</p><p><strong>Obtaining the length of values</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return the length of values associated to an open key</span></span><br><span class="line"><span class="keyword">size_t</span> len = RedisModule_ValueLength(key);</span><br></pre></td></tr></table></figure><ul><li><code>string</code>: 返回的是字符串长度</li><li><code>list</code>, <code>set</code>, <code>zset</code> 和 <code>hash</code>：返回的是元素个数</li><li>key 不存在时返回 0</li></ul><p><strong>String type API</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setting a new string value, this function works exactly like SET cmd */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_StringSet</span><span class="params">(RedisModuleKey *key, RedisModuleString *str)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 DMA(direct memory access) 访问字符串类型效率更高，DMA 方位期间该 key 不可有其他操作，否则 DMA 指针非法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len, j;</span><br><span class="line"><span class="keyword">char</span> *myptr = RedisModule_StringDMA(key, &amp;len, REDISMODULE_WRITE);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">    myptr[j] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过以下接口改变字符串长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisModule_StringTruncate(mykey, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><ul><li>如果该 key 操作之前不存在，则会创造新 key</li><li>字符串长度扩展时，会填充 zero bytes</li></ul><p>更多数据类型的 APIs 可见 Modules API reference。</p><h3 id="high-level-access-to-keys----calling-redis-commands">High level access to keys -- Calling Redis commands</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleCallReply *reply;</span><br><span class="line"><span class="comment">/* @return: RedisModuleCallReply on sucess, NUll on error</span></span><br><span class="line"><span class="comment"> * @param1: context</span></span><br><span class="line"><span class="comment"> * @param2: a null terminated C string with the command name</span></span><br><span class="line"><span class="comment"> * @param3: the format specifier where each character corresponds to</span></span><br><span class="line"><span class="comment"> *          the type of the arguments that will follow  */</span></span><br><span class="line">reply = RedisModule_Call(ctx, <span class="string">&quot;INCRBY&quot;</span>, <span class="string">&quot;sc&quot;</span>, argv[<span class="number">1</span>], <span class="string">&quot;10&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accesss a RedisModuleCallReply object */</span></span><br><span class="line"><span class="keyword">if</span> (RedisModule_CallReplyType(reply) == REDISMODULE_REPLY_INTEGER)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> myval = RedisModule_CallReplyInteger(reply);</span><br><span class="line">    <span class="comment">/* Do something with myval */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>格式说明符</strong></p><ul><li><code>c</code> -- Null terminated C string pointer</li><li><code>b</code> -- C buffer, two arguments needed: C string pointer and <code>size_t</code> length</li><li><code>s</code> -- RedisModuleString as received in <code>argv</code> or by other Redis module APIs returning a RedisModuleString object</li><li><code>l</code> -- Long long integer</li><li><code>v</code> -- Array of RedisModuleString objects</li><li><code>!</code> -- This modifier just tells the function to replicate the command to replicas and AOF. it is ignored from the point of view of arguments parsing</li><li><code>A</code> -- This modifier, when <code>!</code> is given, tells to suppress AOF propagation: the command will propagated only to replicas</li><li><code>R</code> -- This modifier, when <code>!</code> is given, tells to suppress replicas propagation: the command will be propagated only to the AOF if enabled</li></ul><p><strong>返回值</strong></p><p>函数执行成功时返回 <code>RedisModuleCallReply</code> 对象，失败时返回 <code>NULL</code> 并将 <code>errno</code> 设置为以下值：</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th style="text-align: left;">errno</th><th style="text-align: left;">meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">EBADF</td><td style="text-align: left;">wrong format specifier.</td></tr><tr class="even"><td style="text-align: left;">EINVAL</td><td style="text-align: left;">wrong command arity.</td></tr><tr class="odd"><td style="text-align: left;">ENOENT</td><td style="text-align: left;">command does not exist.</td></tr><tr class="even"><td style="text-align: left;">EPERM</td><td style="text-align: left;">operation in Cluster instance with key in non local slot.</td></tr><tr class="odd"><td style="text-align: left;">EROFS</td><td style="text-align: left;">operation in Cluster instance when a write command is sent in a readonly state. ENETDOWN</td></tr></tbody></table><p><strong>RedisModuleCallReply</strong></p><table><thead><tr class="header"><th style="text-align: left;">Reply type</th><th style="text-align: left;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">REDISMODULE_REPLY_STRING</td><td style="text-align: left;">Bulk string or status replies</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_REPLY_ERROR</td><td style="text-align: left;">Errors</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_REPLY_INTEGER</td><td style="text-align: left;">Signed 64-bit integers</td></tr><tr class="even"><td style="text-align: left;">REDISMODULE_REPLY_ARRAY</td><td style="text-align: left;">Array of replies</td></tr><tr class="odd"><td style="text-align: left;">REDISMODULE_REPLY_NULL</td><td style="text-align: left;">NULL reply</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Strings, errors and arrays hava an associated length.</span></span><br><span class="line"><span class="comment"> * To obtain the reply length: */</span></span><br><span class="line"><span class="keyword">size_t</span> reply_len = RedisModule_CallReplyLength(reply);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accesss strings or errors */</span></span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> *ptr = RedisModule_CallReplyStringPtr(reply, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Accesss sub elements of array */</span></span><br><span class="line">RedisModuleCallReply *sub_reply;</span><br><span class="line">sub_reply = RedisModule_CallReplyArrayElement(reply, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Obtain the value of an integer reply */</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> reply_integer_val = RedisModule_CallReplyInteger(reply);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RedisModuleCallReply are not the same as RedisModuleString type</span></span><br><span class="line"><span class="comment"> * create a new string object from a call reply of type string, error or integer</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">RedisModuleString *mystr = RedisModule_CreateStringFromCallReply(reply);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free a reply object</span></span><br><span class="line"><span class="comment"> * For arrays, you need to free only the top level reply, not the nested replies.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_FreeCallReply</span><span class="params">(RedisModuleCallReply *reply)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="replicating-commands">Replicating commands</h3><p>当使用 high level APIs 访问 key，通过加 <code>!</code> 格式说明符，命令自动被复制，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reply = RedisModule_Call(ctx, <span class="string">&quot;INCRBY&quot;</span>, <span class="string">&quot;!sc&quot;</span>, argv[<span class="number">1</span>], <span class="string">&quot;10&quot;</span>);</span><br></pre></td></tr></table></figure><p>当使用 low level APIs 时，可通过以下俩个接口复制命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When you use the follow API, you should not use any other replication</span></span><br><span class="line"><span class="comment"> * function since they are not guaranteed to mix well. */</span></span><br><span class="line">RedisModule_ReplicateVerbatim(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exactly tell Redis what commands to replicate as the effect of the command</span></span><br><span class="line"><span class="comment"> * execution. It&#x27;s possible to call RedisModule_Replicate multiple times,</span></span><br><span class="line"><span class="comment"> * and each will emit a command. All the sequence emitted is wrapped between</span></span><br><span class="line"><span class="comment"> * a MULTI/EXEC transaction, so that the AOF and replication effects are</span></span><br><span class="line"><span class="comment"> * the same as executing a single command. */</span></span><br><span class="line">RedisModule_Replicate(ctx, <span class="string">&quot;INCRBY&quot;</span>, <span class="string">&quot;cl&quot;</span>, <span class="string">&quot;foo&quot;</span>, my_increment);</span><br></pre></td></tr></table></figure><h3 id="automatic-memory-management">Automatic memory management</h3><p>启用自动内存管理，只需在命令实现函数的开头加上 <code>RedisModule_AutoMemory(ctx);</code> 即可，虽然会有些性能损耗，但是你可以不再需要手动 <code>close open keys</code>, <code>free replies</code> 和 <code>free RedisModuleString objects</code>。</p><h3 id="allocating-memory-into-modules">Allocating memory into modules</h3><p>虽然在模块中可以调用 <code>malloc()</code> 和 <code>free()</code> 函数，但是通过 <code>malloc()</code> 分配的内存并不会被计算到 <code>used_memory</code> 信息中去，也不会受到 <code>maxmemory</code> 限制，所以应首先考虑使用 Redis Modules 提供的 APIs。而且，使用 APIs 分配内存实现的自定义数据结构也可以被 RDB 加载函数正确地反序列化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_Alloc</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">RedisModule_Realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_Calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_Strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pool allocator</span></span><br><span class="line"><span class="comment"> * the memory allocated is automatically released when the command returns. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RedisModule_PoolAlloc</span><span class="params">(RedisModuleCtx *ctx, <span class="keyword">size_t</span> bytes)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="implementing-native-data-types">Implementing native data types</h2><p><a href="https://redis.io/topics/modules-native-types">原文地址</a></p><p>在模块中实现类似 Redis 原生的数据类型需要满足以下几点：</p><ul><li>The implementation of some kind of new data structure and of commands operating on the new data structure.</li><li>A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the DEBUG DIGEST command.</li><li>A 9 characters name that is unique to each module native data type.</li><li>An encoding version, used to persist into RDB files a module-specific data version, so that a module will be able to load older representations from RDB files.</li></ul><h3 id="registering-a-new-data-types">Registering a new data types</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Declare a global variable that will hold a reference to the data type */</span></span><br><span class="line"><span class="keyword">static</span> RedisModuleType *MyType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTYPE_ENCODING_VERSION 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_OnLoad</span><span class="params">(RedisModuleCtx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* The follow set of methods must be passed.</span></span><br><span class="line"><span class="comment">     * while .digest and .mem_usage are optinal */</span></span><br><span class="line">    RedisModuleTypeMethods tm =</span><br><span class="line">    &#123;</span><br><span class="line">        .version = REDISMODULE_TYPE_METHOD_VERSION,</span><br><span class="line">        .rdb_load = MyTypeRDBLoad,</span><br><span class="line">        .rdb_save = MyTypeRDBSave,</span><br><span class="line">        .aof_rewrite = MyTypeAOFRewrite,</span><br><span class="line">        .<span class="built_in">free</span> = MyTypeFree</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 9 character name, character set &#123;A-Z, a-z, 0-9, _, -&#125;*/</span></span><br><span class="line">    MyType = RedisModule_CreateDataType(ctx, <span class="string">&quot;MyType-AZ&quot;</span>,</span><br><span class="line">                                        MYTYPE_ENCODING_VERSION, &amp;tm);</span><br><span class="line">    <span class="keyword">if</span> (MyType == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> REDISMODULE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Prototypes of type methods</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mandatory */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, <span class="keyword">int</span> encver);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*RedisModuleTypeSaveFunc)</span><span class="params">(RedisModuleIO *rdb, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*RedisModuleTypeRewriteFunc)</span><span class="params">(RedisModuleIO *aof,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           RedisModuleString *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*RedisModuleTypeFreeFunc)</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* optinal */</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">size_t</span> <span class="params">(*RedisModuleTypeMemUsageFunc)</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*RedisModuleTypeDigestFunc)</span><span class="params">(RedisModuleDigest *digest, <span class="keyword">void</span> *value)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>rdb_load</code> is called when loading data from the RDB file. It loads data in the same format as rdb_save produces.</li><li><code>rdb_save</code> is called when saving data to the RDB file.</li><li><code>aof_rewrite</code> is called is called when the AOF is being rewritten, and the module needs to tell Redis what is the sequence of commands to recreate the content of a given key.</li><li><code>free</code> is called when a key with the module native type is deleted via DEL or in any other mean, in order to let the module reclaim the memory associated with such a value.</li><li><code>digest</code> is called when DEBUG DIGEST is executed and a key holding this module type is found. Currently this is not yet implemented so the function can be left empty.</li><li><code>mem_usage</code> is called when the MEMORY command asks for the total memory consumed by a specific key, and is used in order to get the amount of bytes used by the module value.</li></ul><p><strong>为什么名字要 9 个字符？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now RDB files are sequences of key-value pairs like the following: */</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">| <span class="number">1</span> byte type | key | a type specific value |</span><br><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in module data, prefix a type specific value with 64-bit integer</span></span><br><span class="line"><span class="comment"> * 64 = 9 * 6 + 10, 9 characters of 6 bits, 10 bits are used in oreder</span></span><br><span class="line"><span class="comment"> * to store the encoding version of the type */</span></span><br><span class="line">------------------------------------------</span><br><span class="line">| <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">6</span> | <span class="number">10</span> |</span><br><span class="line">------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="seting-and-getting-keys">Seting and getting keys</h3><p>使用 low level APIs 去操作自定义的数据结构，例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[<span class="number">1</span>],</span><br><span class="line">                                          REDISMODULE_READ|REDISMODULE_WRITE);</span><br><span class="line"><span class="keyword">int</span> type = RedisModule_KeyType(key);</span><br><span class="line"><span class="comment">/* Check the key */</span></span><br><span class="line"><span class="keyword">if</span> (type != REDISMODULE_KEYTYPE_EMPTY &amp;&amp;</span><br><span class="line">    RedisModule_ModuleTypeGetType(key) != MyType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">some_private_struct</span> *<span class="title">data</span>;</span></span><br><span class="line"><span class="keyword">if</span> (type == REDISMODULE_KEYTYPE_EMPTY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create an empty value object if the key is currently empty. */</span></span><br><span class="line">    data = createMyDataStructure();</span><br><span class="line">    RedisModule_ModuleTypeSetValue(key, MyType, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Retrieve the private data from a key */</span></span><br><span class="line">    data = RedisModule_ModuleTypeGetValue(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do something with data */</span></span><br></pre></td></tr></table></figure><h3 id="free-method">Free method</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a simple impl of the free method */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTypeFreeCallback</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModule_Free(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rdb-load-and-save-methods">RDB load and save methods</h3><p>当调用 RDB saving 或 loading 时，我们需要给出自定义数据类型在磁盘上的排布方式，Redis 提供了在 RDB 文件中存储以下数据类型的 high level APIs：</p><ul><li>Unsigned 64-bit integers</li><li>Signed 64-bit integers</li><li>Doubles</li><li>Strings</li></ul><p>APIs 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveUnsigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">uint64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">RedisModule_LoadUnsigned</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveSigned</span><span class="params">(RedisModuleIO *io, <span class="keyword">int64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">RedisModule_LoadSigned</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveDouble</span><span class="params">(RedisModuleIO *io, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RedisModule_LoadDouble</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveString</span><span class="params">(RedisModuleIO *io, RedisModuleString *s)</span></span>;</span><br><span class="line"><span class="function">RedisModuleString *<span class="title">RedisModule_LoadString</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_SaveStringBuffer</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">RedisModule_LoadStringBuffer</span><span class="params">(RedisModuleIO *io)</span></span>;</span><br></pre></td></tr></table></figure><p>一个简单的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">double_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">double</span> *values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rdb_save */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleArrayRDBSave</span><span class="params">(RedisModuleIO *io, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">double_array</span> *<span class="title">da</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    RedisModule_SaveUnsigned(io, da-&gt;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; da-&gt;count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        RedisModule_SaveDouble(io, da-&gt;values[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rdb_load */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">DoubleArrayRDBLoad</span><span class="params">(RedisModuleIO *io, <span class="keyword">int</span> encver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (encver != DOUBLE_ARRAY_ENC_VER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We should actually log an error here, or try to implement the ability</span></span><br><span class="line"><span class="comment">         * to load older versions of our data structure */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">double_array</span> *<span class="title">da</span>;</span></span><br><span class="line">    da = RedisModule_Alloc(<span class="keyword">sizeof</span>(*da));</span><br><span class="line">    da-&gt;count = RedisModule_LoadUnsigned(io);</span><br><span class="line">    da-&gt;values = RedisModule_Alloc(da-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; da-&gt;count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        da-&gt;values[j] = RedisModule_LoadDouble(io);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> da;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aof-rewriting">AOF rewriting</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedisModule_EmitAOF</span><span class="params">(RedisModuleIO *io, <span class="keyword">const</span> <span class="keyword">char</span> *cmdname, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="handling-multiple-encodings">Handling multiple encodings</h3><p>TODO</p><h3 id="allocating-memory">Allocating memory</h3><p>自定义数据结构的内存管理建议使用 Redis Module 提供的 APIs：</p><ul><li>自定义数据结构使用的内存会被计算在 <code>used_memory</code> 内，方便 Redis 进行内存管理</li><li>Redis 使用的是 <code>jemalloc</code> 分配器，可以降低内存碎片率</li><li>与 Redis 内存分配器相同时，从 RDB loading 函数中返回的值无需再次拷贝，可直接访问使用</li></ul><h2 id="blocking-operations-with-modules">Blocking operations with modules</h2><p><a href="https://redis.io/topics/modules-blocking-ops">原文地址</a></p><h3 id="how-blocking-and-resuming-works">How blocking and resuming works</h3><p>可使用以下接口让客户端进入 <strong>blocked state</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RedisModuleBlockedClient *<span class="title">RedisModule_BlockClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCtx *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc reply_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisModuleCmdFunc timeout_callback,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*free_private)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> <span class="keyword">long</span> timeout_ms)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数返回的 <code>RedisModuleBlockedClient</code> 对象，用于之后 unblock 该客户端</li><li><code>ctx</code> is the command execution context as usually in the rest of the API</li><li><code>reply_callback</code> is the callback, having the same prototype of a normal command function, that is called when the client is unblokced in order to return a reply to the client</li><li><code>timeout_callback</code> is the callback, having the same prototype of a normal command function that is called when the client reached the <code>timeout_ms</code> timeout.</li><li><code>free_private</code> is the callback that is called in order to free the private data. Private data is a pointer to some data that is passed between the API used to unblock the client, to the callback that will send the reply to the client.</li><li><code>timeout_ms</code> is the timeout in milliseconds. When the timeout is reached, the timeout callback is called and the client is automatically aborted.</li></ul><p>可使用以下接口 <strong>unblock</strong> 客户端:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is thread safe */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_UnblockClient</span><span class="params">(RedisModuleBlokcedClient *bc, <span class="keyword">void</span> *privdata)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在客户端解除阻塞之前，会立即调用在客户端被阻塞时指定的 <code>reply_callback</code> 函数：该函数将有权访问此处使用的 <code>privdata</code> 指针。</li><li>在客户端解除阻塞之后，会自动调用在客户端被阻塞时指定的 <code>free_private</code> 函数释放 <code>privdata</code> 占用的空间</li></ul><p><strong>一个简单示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reply_func</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithSimpleString(ctx, <span class="string">&quot;765PRO! FIGHT!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout_func</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithNull(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlockedClient *bc = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait one second and unblock,</span></span><br><span class="line"><span class="comment">     * You can think at it as an actually expansive operation of some kind */</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    RedisModule_UnblockClient(bc, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Example_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlockedClient *bc =</span><br><span class="line">        RedisModule_BlockClient(ctx, reply_func, timeout_func, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, threadmian, bc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="passing-reply-data-when-unblocking">Passing reply data when unblocking</h3><p>一般而言阻塞客户端的目的是为了等待某些计算的结果，并将结果回复给客户端，该结果往往是在 unblocked 时传递给 <code>reply_callback</code> 的，我们将上述示例进行简单修改，以演示传递 <code>reply</code> 的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reply_func</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Obtain the private data */</span></span><br><span class="line">    <span class="keyword">long</span> *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);</span><br><span class="line">    <span class="comment">/* Don&#x27;t free mynumber here, but in the free private data callback */</span></span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithLongLong(ctx, mynumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout_func</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisModule_ReplyWithNull(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_privdata</span><span class="params">(<span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModule_Free(privdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlokcedClient *bc = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait one second and unblock,</span></span><br><span class="line"><span class="comment">     * You can think at it as an actually expansive operation of some kind */</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> *mynumber = RedisModule_Alloc(<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    *mynumber = rand();</span><br><span class="line">    RedisModule_UnblockClient(bc, mynumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Example_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlockedClient *bc =</span><br><span class="line">        RedisModule_BlockClient(ctx, reply_func, timeout_func, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, threadmian, bc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>privdata</code> 的释放必须放置在 <code>free_privdata</code> callback 中，因为 <code>reply_callback</code> 可能因为客户端连接超时或断开导致无法被调用</li><li>在 <code>timeout_callback</code> 中，也可通过 <code>GetBlockedClientPrivateData()</code> 访问 <code>privdata</code></li></ul><h3 id="aborting-the-blocking-of-a-client">Aborting the blocking of a client</h3><p>当实现 Redis Command 的函数中，当申请资源发生错误时，我们既不想 block 客户端，也不想触发 <code>reply_callback</code>，此时我们最好的选择可能是使用以下接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_AbortBlock</span><span class="params">(RedisModuleBlockedClient *bc)</span></span>;</span><br></pre></td></tr></table></figure><p>这时，我们可以将上一小节的 <code>Example_RedisCommand</code> 函数改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Example_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlockedClient *bc =</span><br><span class="line">        RedisModule_BlockClient(ctx, reply_func, timeout_func, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, threadmain, bc) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RedisModule_AbortBlock(bc);</span><br><span class="line">        RedisModule_ReplyWithError(ctx, <span class="string">&quot;Sorry can&#x27;t create a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="implementing-the-command-reply-and-timeout-callback-using-a-single-function">Implementing the command, reply and timeout callback using a single function</h3><p>有人可能喜欢将所有实现放在一个函数中，通过使用以下 API 可达到此目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedReplyRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RedisModule_IsBlockedTimeoutRequest</span><span class="params">(RedisModuleCtx *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>比如可将之前的示例改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadmain</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedisModuleBlokcedClient *bc = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait one second and unblock,</span></span><br><span class="line"><span class="comment">     * You can think at it as an actually expansive operation of some kind */</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> *mynumber = RedisModule_Alloc(<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    *mynumber = rand();</span><br><span class="line">    RedisModule_UnblockClient(bc, mynumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Example_RedisCommand</span><span class="params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="keyword">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RedisModule_IsBlockedReplyRequest(ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);</span><br><span class="line">        <span class="keyword">return</span> RedisModule_ReplyWithLongLong(ctx, mynumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (RedisModule_IsBlockedTimeoutRequest(ctx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisModule_ReplyWithNull(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RedisModuleBlockedClient *bc =</span><br><span class="line">        RedisModule_BlockClient(ctx, reply_func, timeout_func, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, threadmain, bc) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RedisModule_AbortBlock(bc);</span><br><span class="line">        RedisModule_ReplyWithError(ctx, <span class="string">&quot;Sorry can&#x27;t create a thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Modules 入门。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统相关笔记</title>
    <link href="https://yz1509.github.io//posts/ad92b110/"/>
    <id>https://yz1509.github.io//posts/ad92b110/</id>
    <published>2020-08-17T12:08:58.000Z</published>
    <updated>2020-08-27T03:01:21.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>分布式系统相关资源汇总及简要笔记。</p><a id="more"></a><hr><h2 id="基础概念">基础概念</h2><h3 id="一致性相关">一致性相关</h3><h4 id="strong-consistency-models">Strong consistency models</h4><p><a href="https://zhuanlan.zhihu.com/p/48782892">中文版</a> <a href="https://aphyr.com/posts/313-strong-consistency-models">英文版</a></p><p><strong>正确性 (Correctness)</strong></p><ul><li>我们说一个<code>系统</code>是由<code>状态</code>和一些导致状态转移的<code>操作</code>组成的</li><li>系统的<code>正确性</code>：给定一些涉及状态与操作的<code>规则</code>，随着操作的演进，系统将一直遵循这些规则。我们把这样的规则成为<code>一致性模型</code></li><li>更加正式地说，一致性模型是所有被允许的操作记录的集合。如果任意可能执行的操作都在这个被允许的操作集合内，那么系统就满足一致性模型</li></ul><p><strong>光锥 (Light cones)</strong></p><ul><li>读写不是一个瞬时的过程，而是一个类似 光传播(调用) -&gt; 反射面(执行) -&gt; 反向传播(完成) 的过程</li><li>因此，调用的先后顺序并不等于操作真实执行的先后顺序</li></ul><p><strong>线性一致性 (Linearizability)</strong></p><p>每个操作会在它调用和完成之间的某个时间点原子地生效.</p><ul><li>对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进</li><li>所有的读总能返回最近写操作的值</li></ul><p><strong>顺序一致性 (Sequential consistency)</strong></p><p>如果我们允许进程在时间维度发生偏移，从而它们的操作可能会在调用之前或是完成之后生效，但仍然保证一个约束 —— 任意进程中的操作必须按照进程中定义的顺序 (即编程的定义的逻辑顺序) 发生。这样我们就得到了一个稍弱的一致性模型：顺序一致性。</p><ul><li>不要求操作按照真实的时间顺序发生 (可能读到过期数据)</li><li>不同进程间的操作执行先后顺序没有强制要求，但必须是原子的</li><li>单个进程内的操作顺序必须和编码时的顺序一致</li></ul><p><strong>因果一致性 (Casual consistency)</strong></p><p>不对一个进程中的每个操作都施加顺序约束。只有因果相关的操作必须按顺序发生。</p><p><strong>串行一致性 (Serializable consistency)</strong></p><p>串行一致性是事务的隔离属性，每个事务可以读写多个对象 (行，文档，记录)。它确保事务的行为，与它们按照某种顺序依次执行的结果相同 (每个事务在下一个事务开始之前运行完成)。这种执行顺序可以与事务实际执行的顺序不同，和调用时间与完成时间无关。</p><ul><li>串行一致性是对多操作，多对象的保证，对总体的操作顺序无要求</li><li>线性一致性是对单操作，单对象的保证，所有操作遵循真实时间序</li></ul><h3 id="cap-定理相关">CAP 定理相关</h3><p><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 定理</a>指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性 (Consistency): Every read receives the most recent write or an error</li><li>可用性 (Availability): Every request receives a (non-error) response, without the guarantee that it contains the most recent write</li><li>分区容错性 (Partition tolerance): The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes</li></ul><h4 id="cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the "Rules" Have Changed</h4><p><a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">中文版</a> <a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/">英文版</a></p><ul><li>三选二具有误导性</li><li>ACID、BASE、CAP 的关系<ul><li><code>BASE</code>: Basically Available, Soft state, Eventually consistent</li></ul></li><li>CAP 与延迟的联系</li><li>管理分区<ol type="1"><li>检测分区开始</li><li>明确进入分区模式，两种可行的策略<ul><li>限制部分触犯不变性约束的操作，因此会削弱可用性</li><li>额外记录一些有利于分区恢复的操作信息，如版本向量等</li></ul></li><li>分区恢复，修复分区期间造成的错误</li></ol></li></ul><h4 id="please-stop-calling-databases-cp-or-ap">Please stop calling databases CP or AP</h4><p><a href="https://zhuanlan.zhihu.com/p/55053121">中文版</a> <a href="http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">英文版</a></p><ul><li>CAP 定义非常狭隘<ul><li>一致性在 CAP 中其实是指线性一致性 (linearizability)</li><li>可用性要求<strong>任何</strong>非故障节点都能够处理请求</li><li>分区容错性基本上意味着你的通信建立在可能会延迟或丢包的异步通信网络上. 互联网和我们的数据中心都有这个属性, 所以在这个问题上其实没有任何选择.</li><li>CAP 系统模型是一个单一读写寄存器 (single, read-write register)，没有涉及多个对象的事务</li><li>CAP 定理只考虑了网络分区 (network partition) 这一故障场景</li><li>CAP 定理没考虑到延迟 (latency)</li></ul></li><li>多数系统既不线性可用 (linearizable) 也不 CAP 可用 (CAP-available)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式系统相关资源汇总及简要笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://yz1509.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式系统" scheme="https://yz1509.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="一致性" scheme="https://yz1509.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Specification and Complexity of Collaborative Text Editing</title>
    <link href="https://yz1509.github.io//posts/a8337500/"/>
    <id>https://yz1509.github.io//posts/a8337500/</id>
    <published>2020-06-17T09:53:02.000Z</published>
    <updated>2020-09-07T04:04:35.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Specification and Complexity of Collaborative Text Editing 阅读笔记。</p><a id="more"></a><hr><p><a href="https://dl.acm.org/doi/pdf/10.1145/2933057.2933090">论文地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Specification and Complexity of Collaborative Text Editing 阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过四级没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E5%9B%9B%E7%BA%A7%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="最终一致性" scheme="https://yz1509.github.io/tags/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="协同编辑" scheme="https://yz1509.github.io/tags/%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>CRDTs in Redis</title>
    <link href="https://yz1509.github.io//posts/8e7f36d6/"/>
    <id>https://yz1509.github.io//posts/8e7f36d6/</id>
    <published>2020-06-17T03:15:10.000Z</published>
    <updated>2020-09-04T02:39:08.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Redis 全球多活调研笔记。</p><a id="more"></a><hr><h2 id="crdt-简单介绍">CRDT 简单介绍</h2><p>在 <a href="https://hal.inria.fr/inria-00609399v2/document">Conflict-free Replicated Data Types</a> 一文中，作者依据传递消息内容的区别，提出了两种 CRDT：</p><ul><li>CvRDT(State-based Convergent Replicated Data Type): 基于<strong>状态</strong>的<strong>聚合</strong>复制数据类型<ul><li>条件：<ul><li>状态满足单调性，消息最终可达</li><li>状态更改操作为 Merge 需满足交换律，结合律，幂等</li></ul></li><li>优点：对通信协议要求不高</li><li>缺点：消息传递的内容是状态，消息体大</li></ul></li><li>CmRDT(Op-based Commutative Replicated Data Type)：基于<strong>操作</strong>的<strong>交换</strong>复制数据类型<ul><li>条件：<ul><li>Update 操作要么可确定明确的因果顺序，要么满足可交换</li><li>消息传输提供 <code>exactly once</code> 的保证</li></ul></li><li>优点：消息传递的内容是操作，消息体小</li><li>缺点：对通信协议要求高</li></ul></li></ul><h2 id="redislabs-crdb-相关">RedisLabs CRDB 相关</h2><p><strong>参考资料</strong></p><ul><li><a href="https://redislabs.com/redis-enterprise/technology/active-active-geo-distribution/">Active-Active Geo-Distribution (CRDT-Based)</a></li><li><a href="https://www.slideshare.net/RedisLabs/redisconf18-crdts-and-redis-from-sequential-to-concurrent-executions">RedisConf18 - CRDTs and Redis - From sequential to concurrent executions</a></li><li><a href="https://docs.redislabs.com/latest/rs/developing/crdbs/">Developing Applications with Geo-Distributed CRDBs on Redis Enterprise Software (RS)</a></li></ul><p><strong>目前 CRDB 支持的数据类型</strong></p><table><thead><tr class="header"><th style="text-align: left;">Data Type</th><th style="text-align: left;">Support Level</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Float Counters</td><td style="text-align: left;">Supported</td></tr><tr class="even"><td style="text-align: left;">Geospatial</td><td style="text-align: left;">Supported</td></tr><tr class="odd"><td style="text-align: left;">Hashes</td><td style="text-align: left;">Supported; Hash fields are treated as strings or counters</td></tr><tr class="even"><td style="text-align: left;">Integer Counters</td><td style="text-align: left;">Supported</td></tr><tr class="odd"><td style="text-align: left;">Lists</td><td style="text-align: left;">Supported</td></tr><tr class="even"><td style="text-align: left;">Sets</td><td style="text-align: left;">Supported</td></tr><tr class="odd"><td style="text-align: left;">Strings</td><td style="text-align: left;">Supported</td></tr><tr class="even"><td style="text-align: left;">Sorted Sets</td><td style="text-align: left;">Supported</td></tr><tr class="odd"><td style="text-align: left;">HyperLogLog</td><td style="text-align: left;">Supported</td></tr><tr class="even"><td style="text-align: left;">Streams</td><td style="text-align: left;">Supported</td></tr><tr class="odd"><td style="text-align: left;">Bitsets</td><td style="text-align: left;">Not currently supported</td></tr></tbody></table><p>目前可查询到有关 CRDB 实现的情报如下所述。</p><h3 id="string">String</h3><p>在 CRDB 中，String 分为 Counter 和 Pure String 两种类型，这两种类型之间<strong>不可动态转换</strong>。下表给出了其各自支持的操作，可以看到 Counter 和 Pure String 都不支持位操作。</p><table><colgroup><col style="width: 44%"><col style="width: 55%"></colgroup><thead><tr class="header"><th style="text-align: left;">Type</th><th style="text-align: left;">Support Methods</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Counter</td><td style="text-align: left;">INCR, DECR, INCRBY, DECRBY, GET</td></tr><tr class="even"><td style="text-align: left;">Pure String</td><td style="text-align: left;">APPEND, GET, GETRANGE, GETSET, MGET, MSET, MSETNX, PSETEX, SET, SETEX, SETNX, SETRANGE, STRLEN</td></tr></tbody></table><ul><li>Counter：参考 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#PN-Counter_(Positive-Negative_Counter)">PN-Counter</a> 实现</li><li>Pure String：采用 wall-clock timestamp 和 Last Write Wins (LWW)</li></ul><h3 id="set">Set</h3><p>参考 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#OR-Set_(Observed-Remove_Set)">OR-Set</a> 实现</p><h3 id="hash">Hash</h3><ul><li>在 Key 维度参考 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#OR-Set_(Observed-Remove_Set)">OR-Set</a> 实现</li><li>在 Field 维度实现同 String 类型，分为 Counter 和 Pure String</li></ul><h3 id="sorted-set">Sorted Set</h3><ul><li>在 Key 维度参考 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#OR-Set_(Observed-Remove_Set)">OR-Set</a> 实现</li><li>在 Member 维度参考 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#PN-Counter_(Positive-Negative_Counter)">PN-Counter</a> 实现</li></ul><h3 id="list">List</h3><p>尚未发现确切的情报，可能有参考 <a href="https://dl.acm.org/doi/pdf/10.1145/2933057.2933090">Specification and Complexity of Collaborative Text Editing</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 全球多活调研笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="最终一致性" scheme="https://yz1509.github.io/tags/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="CRDT" scheme="https://yz1509.github.io/tags/CRDT/"/>
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Conflict free replicated data types</title>
    <link href="https://yz1509.github.io//posts/fa8423b1/"/>
    <id>https://yz1509.github.io//posts/fa8423b1/</id>
    <published>2020-04-22T10:09:55.000Z</published>
    <updated>2020-09-07T04:04:11.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Conflict free replicated data types 阅读笔记。</p><a id="more"></a><hr><p><a href="https://hal.inria.fr/inria-00609399v2/document">论文地址</a></p><h2 id="最终一致性">最终一致性</h2><h3 id="eventual-consistency"><a href="https://en.wikipedia.org/wiki/Eventual_consistency">Eventual Consistency</a></h3><p>一个分布式系统是最终一致的，需满足以下条件：</p><ul><li><strong>Eventual delivery</strong>: 在健康节点上执行的更新操作最终会被传递至所有健康节点，也就是说 <span class="math inline">\(f \in c_i \Rightarrow \lozenge f \in c_j, \forall i, j \in [1, \dots, n]\)</span>，其中 <span class="math inline">\(c_i\)</span> 是节点 <span class="math inline">\(p_i\)</span> 的 causal history</li><li><strong>Convergence</strong>: 执行相同操作集合的健康节点<strong>最终</strong>会收敛至相同的状态，也就是说 <span class="math inline">\(\square c_i = c_j \Rightarrow \lozenge \square s_i \equiv s_j, \forall i, j \in [1, \dots, n]\)</span></li><li><strong>Termination</strong>: 所有操作会终止</li></ul><p>在上述说明中，<span class="math inline">\(\lozenge\)</span> 表示可能性，<span class="math inline">\(\square\)</span> 表示必然性，详见 <a href="https://en.wikipedia.org/wiki/Modal_logic">Modal logic</a> 和 <a href="https://en.wikipedia.org/wiki/S5_(modal_logic)">S5 modal logic</a>。至于 causal history，可以简单理解为操作的集合。</p><h3 id="strong-eventual-consistency">Strong Eventual Consistency</h3><p>一个分布式系统是强最终一致的，需在满足最终一致的条件下，额外满足以下约束：</p><ul><li><strong>Strong Convergence</strong>: 执行相同操作集合的健康节点具有相同的状态，也就是说 <span class="math inline">\(c_i = c_j \Rightarrow s_i \equiv s_j, \forall i, j \in [1, \dots, n]\)</span></li></ul><h2 id="系统模型">系统模型</h2><h3 id="符号说明">符号说明</h3><table><thead><tr class="header"><th style="text-align: left;">符号</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="math inline">\(p_i\)</span></td><td style="text-align: left;">process <span class="math inline">\(i\)</span></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(s_i\)</span></td><td style="text-align: left;">process <span class="math inline">\(p_i\)</span> has state <span class="math inline">\(s_i \in \mathcal{S}\)</span>, called its <em>payload</em></td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(s^0\)</span></td><td style="text-align: left;">初始状态</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(q\)</span></td><td style="text-align: left;">query</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(t\)</span></td><td style="text-align: left;">prepare-update</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(u\)</span></td><td style="text-align: left;">update</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(m\)</span></td><td style="text-align: left;">merge</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\mathcal{P}\)</span></td><td style="text-align: left;">communication protocol</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(f_i^k(a)\)</span></td><td style="text-align: left;">在节点 <span class="math inline">\(p_i\)</span> 上执行的 <span class="math inline">\(k^{th}\)</span> 操作, <span class="math inline">\(f\)</span> 是 <span class="math inline">\(q\)</span>, <span class="math inline">\(u\)</span> 或 <span class="math inline">\(m\)</span>, <span class="math inline">\(a\)</span> 是参数</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(K_i(f)\)</span></td><td style="text-align: left;">在节点 <span class="math inline">\(p_i\)</span> 上操作 <span class="math inline">\(f\)</span> 执行的序数</td></tr></tbody></table><h3 id="state-based-convergent-replicated-data-typecvrdt">State-based Convergent Replicated Data Type(CvRDT)</h3><p><strong>Causal History</strong></p><p>我们定义一个对象的 <em>causal hisatory(stated-based)</em> 为 <span class="math inline">\(\mathcal{C} = [c_1, \dots, c_n]\)</span>，其中 <span class="math inline">\(c_i\)</span> 经历了一系列中间态 <span class="math inline">\(c_i^0, \dots, c_i^k, \dots\)</span>。初始时，<span class="math inline">\(c_i^0 = \emptyset, \forall i \in [1, \dots, n]\)</span>，在节点 <span class="math inline">\(p_i\)</span> 上执行的 <span class="math inline">\(k^{th}\)</span> 操作分为以下三种情况：</p><p><span class="math display">\[c_i^k = \begin{cases}  c_i^{k-1} &amp; f = q \\c_i^{k-1} \cup \{u_i^k(a)\} &amp; f = u_i^k(a) \\c_i^{k-1} \cup c_{i&#39;}^{k&#39;} &amp; f = m_i^k(s_{i&#39;}^{k&#39;})\end{cases}\]</span></p><p><strong>Monotonic semilattice object</strong></p><p>我们用 <span class="math inline">\((\mathcal{S}, \le, s^0, q, u, m)\)</span> 表示基于状态的对象，其中 <span class="math inline">\(\le\)</span> 表示 <em>partial order</em>。若其满足以下约束，我们称其为 <em>monotonic semilattice object</em>:</p><ol type="1"><li><a href="https://en.wikipedia.org/wiki/Partially_ordered_set">Poset</a> <span class="math inline">\((\mathcal{S}, \le)\)</span> 构成一个 Join-semilattice</li><li>Merge 操作满足: <span class="math inline">\(s \cdot m(s&#39;) = s \vee s&#39;\)</span></li><li>在更新操作下状态 <span class="math inline">\(s\)</span> 满足单调性，即 <span class="math inline">\(s \le s \cdot u\)</span></li></ol><p>回顾<a href="http://k-on.me/posts/cce5fbef/#more">之前的知识</a>，可以知道第 1 条约束的意思是集合 <span class="math inline">\(\mathcal{S}\)</span> 中任意非空子集都有 <code>join</code>，第 2 条约束说明 merge 即为 <code>join</code>。</p><p><strong>CvRDT</strong></p><p>Assuming eventual delivery and termination, any state-based object that satisfies the monotonic semilattice property is SEC.</p><blockquote><p>CvRDT 使用 <span class="math inline">\((\mathcal{S}, \le, s^0, q, u, m)\)</span> 表示。</p></blockquote><p>从上可以看出，在 <code>CvRDT</code> 中， 需要满足以下条件：</p><ul><li>状态满足单调性，消息最终可达</li><li>状态更改操作为 Merge 需满足交换律，结合律，幂等</li></ul><h3 id="op-based-commutative-replicated-data-typecmrdt">Op-based Commutative Replicated Data Type(CmRDT)</h3><p><strong>Causal History</strong></p><p>我们定义一个对象的 <em>causal hisatory(op-based)</em> 为 <span class="math inline">\(\mathcal{C} = [c_1, \dots, c_n]\)</span>，其中 <span class="math inline">\(c_i\)</span> 经历了一系列中间态 <span class="math inline">\(c_i^0, \dots, c_i^k, \dots\)</span>。初始时，<span class="math inline">\(c_i^0 = \emptyset, \forall i \in [1, \dots, n]\)</span>，在节点 <span class="math inline">\(p_i\)</span> 上执行的 <span class="math inline">\(k^{th}\)</span> 操作分为以下两种情况：</p><p><span class="math display">\[c_i^k = \begin{cases}  c_i^{k-1} &amp; f = q, t \\c_i^{k-1} \cup \{u_i^k(a)\} &amp; f = u_i^k(a)\end{cases}\]</span></p><p><strong>Happened-before</strong></p><p>Update <span class="math inline">\((t, u)\)</span> happended-before <span class="math inline">\((t&#39;, u&#39;)\)</span> iff the former is delivered when the latter executes: <span class="math inline">\((t, u) \rightarrow (t&#39;, u&#39;) \Leftrightarrow u \in c_j^{k-1}\)</span>, where <span class="math inline">\(t&#39;\)</span> executeds at <span class="math inline">\(p_j\)</span> and <span class="math inline">\(k = K_j(t&#39;)\)</span>.</p><p><strong>Commutativity</strong></p><p>Updates <span class="math inline">\((t, u)\)</span> and <span class="math inline">\((t&#39;, u&#39;)\)</span> commute, iff for any reachable replica state <span class="math inline">\(s\)</span> where both <span class="math inline">\(u\)</span> and <span class="math inline">\(u&#39;\)</span> are enabled, <span class="math inline">\(u\)</span> (resp. <span class="math inline">\(u&#39;\)</span>) remains enabled in state <span class="math inline">\(s \cdot u&#39;\)</span>(resp. <span class="math inline">\(s \cdot u\)</span>), and <span class="math inline">\(s \cdot u \cdot u&#39; \equiv s \cdot u&#39; \cdot u\)</span>.</p><p><strong>CmRDT</strong></p><p>Assuming causal delivery of updates and method termination, any op-based object that satisfies the commutativity property for all concurrent updates, and whose delivery precondition is satisfied by causal delivery, is SEC.</p><blockquote><p>CmRDT 使用 <span class="math inline">\((\mathcal{S}, s^0, q, t, u, \mathcal{P})\)</span> 表示。</p></blockquote><p>从上可以看出，在 <code>CmRDT</code> 中， 需要满足以下条件：</p><ul><li>Update 操作要么可确定明确的因果顺序，要么满足可交换</li><li>消息传输提供 <code>exactly once</code> 的保证</li></ul><h2 id="一些结论">一些结论</h2><ul><li>CvRDTs and CmRDTs are equivalent</li><li>SEC is incomparable to sequential consistency</li></ul><h2 id="crdt-示例">CRDT 示例</h2><h3 id="counters">Counters</h3><p>我们使用 CvRDT 的框架来构造一个分布式计数器 <span class="math inline">\((\mathcal{S}, \le^n, s^0, value, inc, max^n)\)</span>:</p><table><colgroup><col style="width: 30%"><col style="width: 69%"></colgroup><thead><tr class="header"><th style="text-align: left;">符号</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><span class="math inline">\(\mathcal{S}\)</span></td><td style="text-align: left;">状态集合，其中 <span class="math inline">\(s = \vec{v} = [v_1, \dots, v_n]\)</span> 表示计数器的状态</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\le^n\)</span></td><td style="text-align: left;"><span class="math inline">\(\vec{v} \le^n \vec{v&#39;} \Leftrightarrow v_i \le v&#39;_i, \forall i \in [1, \dots, n]\)</span></td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(s^0\)</span></td><td style="text-align: left;"><span class="math inline">\([0, \dots, 0]\)</span></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(value\)</span></td><td style="text-align: left;"><span class="math inline">\(value(\vec{v}) = \sum_{i}v_i\)</span></td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(inc\)</span></td><td style="text-align: left;">在节点 <span class="math inline">\(p_i\)</span> 上 <span class="math inline">\(inc(\vec{v}) = \vec{v&#39;}\)</span>，其中 <span class="math inline">\(v&#39;_i = v_i + 1 \cdot \mathbb{I}_{\{j\}}(i), \forall i \in [1, \dots, n]\)</span></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(max^n\)</span></td><td style="text-align: left;"><span class="math inline">\(s \cdot max^n(s&#39;) = [max(v_1, v&#39;_1), \dots, max(v_n, v&#39;_n)]\)</span></td></tr></tbody></table><p>可以发现上述定义的是一个只增计数器，如果想可增可减的话，可以使用两个只增计数器构成。</p><h3 id="set">Set</h3><p>一个 add-only 的集合可以构造为 <span class="math inline">\((\mathcal{S}, \subseteq, \emptyset, value, add(e), \cup)\)</span>，其中 <span class="math inline">\(s \cdot add(e) = s \cup \{e\}\)</span>，很明显这也是一个 CRDT。</p><p>在 <a href="https://hal.inria.fr/inria-00555588/document">A comprehensive study of Convergent and Commutative Replicated Data Types</a> 中作者定义了可增可减的两种 Set，但是也有较强的 assumption...</p><ul><li>2P-Set：维护两个集合：add-only 和 remove-only。只能适用于集合中的元素只会被 add/remove 一次的情况</li><li>U-Set: 维护一个支持 add/remove 的集合。需要满足两个条件:<ul><li>remove 过的元素不会再 add</li><li>add 操作确保在 remove 前</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Conflict free replicated data types 阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过四级没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E5%9B%9B%E7%BA%A7%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="最终一致性" scheme="https://yz1509.github.io/tags/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="CRDT" scheme="https://yz1509.github.io/tags/CRDT/"/>
    
  </entry>
  
  <entry>
    <title>CRDT-notes</title>
    <link href="https://yz1509.github.io//posts/cce5fbef/"/>
    <id>https://yz1509.github.io//posts/cce5fbef/</id>
    <published>2020-04-21T03:02:30.000Z</published>
    <updated>2020-09-04T10:31:10.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>CRDT 学习笔记。</p><a id="more"></a><hr><h2 id="crdt-相关资源">CRDT 相关资源</h2><ul><li><a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDT wiki</a></li><li><a href="https://github.com/ept/crdt-website">CRDT Website</a></li><li><a href="https://github.com/ipfs/notes/tree/master/CRDT">CRDT Research</a></li><li><a href="https://github.com/alangibson/awesome-crdt">Awesome CRDT</a></li></ul><h2 id="背景知识">背景知识</h2><h3 id="a-crdt-primer-part-i-defanging-order-theory"><a href="http://jtfmumm.com/blog/2015/11/17/crdt-primer-1-defanging-order-theory/">A CRDT Primer Part I: Defanging Order Theory</a></h3><h4 id="order">Order</h4><p><strong>Definition</strong></p><p>An <strong>Order</strong> set is a binary relation <span class="math inline">\(\le\)</span> on a set <span class="math inline">\(\mathcal{S}\)</span>, written <span class="math inline">\((\mathcal{S},\le)\)</span>.</p><p><strong>Core concepts</strong></p><ul><li>If we can say that <span class="math inline">\(a \le b\)</span> or <span class="math inline">\(b \le a\)</span>, then we know that <span class="math inline">\(a\)</span> is <strong>comparable</strong> to <span class="math inline">\(b\)</span>.</li><li>In order theory, if <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are <strong>incomparable</strong>, we write <span class="math inline">\(a \parallel b\)</span>.</li><li>A <strong>join</strong> between two elements, written <span class="math inline">\(a \vee b\)</span>.</li></ul><p><strong>Type of order</strong></p><ul><li><p>An order is <strong>total</strong> if for any <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in the set, either <span class="math inline">\(a \le b\)</span> or <span class="math inline">\(b \le a\)</span>.</p><blockquote><p>例: 集合是自然数，二元关系为小于等于</p></blockquote></li><li><p>A <a href="https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition">partial order</a> is weaker than a total. It does not require that every pair <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in a set can be compared.</p><blockquote><p>例: 集合是地理位置，二元关系为"位于"</p></blockquote></li></ul><h4 id="join">Join</h4><p><strong>Upper bound</strong></p><p>For a set <span class="math inline">\(\mathcal{S}\)</span>, an order <span class="math inline">\((\mathcal{S},\le)\)</span>, and <span class="math inline">\(\mathcal{A} \subseteq \mathcal{S}\)</span> is an aibitrary subset, then an element <span class="math inline">\(u \in \mathcal{S}\)</span> is said to be an <strong>upper bound</strong> of <span class="math inline">\(\mathcal{A}\)</span> if <span class="math inline">\(a \le u, \forall a \in \mathcal{A}\)</span>.</p><p><strong>Definition</strong></p><p>For a set <span class="math inline">\(\mathcal{S}\)</span>, an order <span class="math inline">\((\mathcal{S},\le)\)</span>, and two elements <span class="math inline">\(a,b \in \mathcal{S}\)</span>, then <strong>join</strong> of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> (written <span class="math inline">\(a \vee b\)</span>) is a least upper bound of <span class="math inline">\(\{a, b\}\)</span> according to our order <span class="math inline">\((\mathcal{S},\le)\)</span>.</p><blockquote><p>In total order, a join of two elelments is always equals to one of those two elements. However, if we're talking about partial orders, this is not guaranteed.</p></blockquote><p><strong>Properties</strong></p><ol type="1"><li>Commutativity: <span class="math inline">\(a \vee b = b \vee a\)</span></li><li>Associativity: <span class="math inline">\((a \vee b) \vee c = a \vee (b \vee c)\)</span></li><li>Idempotence: <span class="math inline">\(a \vee a = a\)</span></li></ol><p><strong>Join-semilattice</strong></p><p>A <a href="https://en.wikipedia.org/wiki/Semilattice">join-semilattice</a> is a order set <span class="math inline">\((\mathcal{S},\le)\)</span> that has a join(a least upper bound) for any nonempty finite subset.</p><blockquote><p>Dually, a meet-semilattice (or lower semilattice) is a ordered set which has a meet (or greatest lower bound) for any nonempty finite subset.</p></blockquote><h3 id="扩展阅读">扩展阅读</h3><ul><li><a href="https://en.wikipedia.org/wiki/Order_theory">Order theory</a></li><li><a href="http://www.tac.mta.ca/tac/reprints/articles/22/tr22abs.html">Category Theory for Computing Science</a></li></ul><h2 id="crdt-相关论文">CRDT 相关论文</h2><h3 id="conflict-free-replicated-data-types"><a href="https://hal.inria.fr/inria-00609399v2/document">Conflict-free Replicated Data Types</a></h3><p>在这篇文章中，作者主要提出了两种本质上等价的 CRDT：CvRDT 和 CmRDT。为了保证强最终一致性，作者表示在 CvRDT 中需定义合适的操作，使得状态集合在给定的偏序关系下构成 Join-semilattice；而在 CmRDT 中，操作需满足要么可比较，不可比的便可交换的条件，除此之外，还需要消息传输提供 <code>exactly once</code> 的保证。详细内容<a href="http://k-on.me/posts/fa8423b1/#more">请点击</a>。</p><h3 id="a-comprehensive-study-of-convergent-and-commutative-replicated-data-types"><a href="https://hal.inria.fr/inria-00555588/document">A comprehensive study of Convergent and Commutative Replicated Data Types</a></h3><p>理论内容和上一篇相比几乎相同，新增了一些 CRDT 数据结构示例、垃圾回收和简单应用的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CRDT 学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="最终一致性" scheme="https://yz1509.github.io/tags/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="CRDT" scheme="https://yz1509.github.io/tags/CRDT/"/>
    
  </entry>
  
  <entry>
    <title>初试性能调优</title>
    <link href="https://yz1509.github.io//posts/7cfaf8f6/"/>
    <id>https://yz1509.github.io//posts/7cfaf8f6/</id>
    <published>2020-01-22T02:36:38.000Z</published>
    <updated>2020-04-23T11:35:27.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用 <a href="https://github.com/torvalds/linux/tree/master/tools/perf">perf</a> + <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 进行性能调优。</p><a id="more"></a><hr><p>简单使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// perf</span></span><br><span class="line"><span class="meta"># perf record -F 99 -p pid --call-graph dwarf sleep 60</span></span><br><span class="line"><span class="meta"># perf script &gt; out.perf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FlameGraph</span></span><br><span class="line"># ./stackcollapse-perf.pl out.perf &gt; out.folded</span><br><span class="line"># ./flamegraph.pl out.folded &gt; flameGraph.svg</span><br></pre></td></tr></table></figure><p><a href="http://www.brendangregg.com/perf.html">Perf 命令示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用 &lt;a href=&quot;https://github.com/torvalds/linux/tree/master/tools/perf&quot;&gt;perf&lt;/a&gt; + &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt; 进行性能调优。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yz1509.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://yz1509.github.io/tags/Linux/"/>
    
      <category term="Perf" scheme="https://yz1509.github.io/tags/Perf/"/>
    
      <category term="FlameGraph" scheme="https://yz1509.github.io/tags/FlameGraph/"/>
    
  </entry>
  
  <entry>
    <title>钓鱼实战技巧</title>
    <link href="https://yz1509.github.io//posts/ed043c3e/"/>
    <id>https://yz1509.github.io//posts/ed043c3e/</id>
    <published>2019-12-23T11:59:24.000Z</published>
    <updated>2020-04-23T11:22:12.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我再也不想当空军了.jpg</p><a id="more"></a><hr><h2 id="黑坑鲫鱼实战技巧">黑坑(鲫鱼)实战技巧</h2><h3 id="线组">线组</h3><p>黑坑鲫鱼口小，所以需采用较为精细的线组。例如 2.0 的主线搭配 0.6 的子线，浮漂选择细长浮力小的。</p><ul><li>实操经验：可使用 1.0 的主线，若使用 0.4 的子线需要选购质量过关 &amp; 拉杆不可过猛。稳妥起见，建议入门使用 0.6 的子线。</li></ul><p>淘宝店推荐: TODO</p><h3 id="鱼饵">鱼饵</h3><p>需要用拉饵(可淘宝)，直接把钩按在饵料上，拉起来就可以扔池塘，大约半分钟一换。如不使用打窝料，可采用<a href="https://baike.baidu.com/item/%E6%95%A3%E7%82%AE">散炮</a>技术。</p><p>淘宝店推荐: TODO</p><h3 id="调漂">调漂</h3><p>详见<a href="https://baike.baidu.com/item/%E5%8D%8A%E6%B0%B4%E8%B0%83%E6%BC%82">半水调漂</a>和<a href="https://baike.baidu.com/item/%E8%B0%83%E5%9B%9B%E9%92%93%E4%BA%8C/9322113">调四钓二</a>。</p><h3 id="拉杆时机">拉杆时机</h3><p>垂钓时基本一有动静马上就要拉起来，鲫鱼最大的动静就是浮漂上浮或者下沉一目。另外，还需不时抖动下鱼竿，这样可使鲫鱼以为你的饵料是活的，更有诱惑性。</p><h2 id="淡水野钓实战技巧">淡水野钓实战技巧</h2><p>TODO</p><h2 id="海钓实战技巧">海钓实战技巧</h2><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我再也不想当空军了.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="生活小常识" scheme="https://yz1509.github.io/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="钓鱼" scheme="https://yz1509.github.io/tags/%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>CCIA-线程间同步</title>
    <link href="https://yz1509.github.io//posts/48b6c0a1/"/>
    <id>https://yz1509.github.io//posts/48b6c0a1/</id>
    <published>2019-12-11T11:45:55.000Z</published>
    <updated>2019-12-16T04:34:18.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《C++ Concurrentcy in Action 2nd》 第四章阅读笔记。</p><a id="more"></a><hr><p>在多线程编程中，不仅需要知道处理数据的一致性问题，还需要熟悉线程之间的同步机制。</p><h1 id="等待某个事件条件">等待某个事件/条件</h1><p>当一个线程需要等待其他线程完成某些任务时，可以使用 C++ 提供的条件变量 (condition variable)。</p><h2 id="使用条件变量">使用条件变量</h2><p>C++ 在 <code>condition_variable</code> 库中实现了两种条件变量：</p><ul><li><code>std::condition_variable</code>： 仅限于和 <code>std::mutex</code> 一起使用，性能比 <code>std::condition_variable_any</code> 好</li><li><code>std::condition_variable_any</code>：可以和与 <code>std::mutex</code> 类似的对象一起使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 4.1 Waiting for data to process with std::condition_variable</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;  <span class="comment">// phase 1</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (more_data_to_prepare())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data = prepare_data();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.push(data);  <span class="comment">// phase 2</span></span><br><span class="line">    data_cond.notify_one(); <span class="comment">// phase 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; <span class="comment">// phase 4</span></span><br><span class="line">    data_cond.wait(lk, []&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);  <span class="comment">// phase 5</span></span><br><span class="line">    data_chunk data = data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    lk.unlock();  <span class="comment">// phase 6</span></span><br><span class="line">    process(data);</span><br><span class="line">    <span class="keyword">if</span> (is_last_chunk(data))  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先分析 <code>data_preparation_thread()</code>，如果 <code>data</code> 准备完成，则会对 <code>mut</code> 上锁，然后 <code>data</code> 压入队列 (phase 2)，随后调用条件变量实例 <code>data_cond</code> 的成员函数 <code>notify_one()</code> 通知等待该条件变量的线程，这里我们使用了 <code>std::lock_guard</code>，保证在通知等待线程后便释放互斥锁，可以避免在等待线程被唤醒后还需等待互斥锁的性能损失。</p><p>在 <code>data_processing_thread()</code> 中，在 phase 4 使用 <code>std::unique_lock</code> 而不使用 <code>std::lock_guard</code> 是因为我们可能需要在 phase 5 执行 <code>unlock</code> 和 <code>lock</code> 操作，可以从 <code>wait()</code> 的一个简单实现(如下)看出这点，当然还有一个好处是，我们可以在对数据进行处理前主动释放锁 (phase 6)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minimal_wait</span><span class="params">(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lk, Predicate pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!pred()) &#123;</span><br><span class="line">    lk.unlock();</span><br><span class="line">    lk.lock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面 <code>wait()</code> 的简单实现没有考虑与 <code>notify_one()</code> 和 <code>notify_all()</code> 的协作，仅为示意用。</p><h2 id="带有条件变量的线程安全队列">带有条件变量的线程安全队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 4.2 std::unique interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="keyword">const</span> Container&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">explicit</span> <span class="title">queue</span>(<span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">queue</span>(<span class="title">const</span> <span class="title">Container</span>&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">queue</span>(<span class="title">Container</span>&amp;&amp; <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">queue</span>(<span class="title">queue</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">queue</span>&amp; q)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 4.3 The interface of your threadsafe_queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue();</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Concurrentcy in Action 2nd》 第四章阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://yz1509.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="多线程" scheme="https://yz1509.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://yz1509.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>GO 进程资源占用分析</title>
    <link href="https://yz1509.github.io//posts/b0dfeba6/"/>
    <id>https://yz1509.github.io//posts/b0dfeba6/</id>
    <published>2019-11-22T10:47:27.000Z</published>
    <updated>2019-11-22T13:00:34.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用 pprof 和 graphviz 分析进程内存分配，CPU 耗时等信息。</p><a id="more"></a><hr><p>当我们想分析自己写的代码中内存分配主要发生在哪或者哪些语句比较耗时时，可以使用 <a href="https://golang.org/pkg/net/http/pprof/">pprof</a> 帮我们记录这些信息。只需要在代码中嵌入一个 goroutine 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ol type="1"><li><p>可以通过浏览器打开 http://localhost:6060/debug/pprof/ 即可查看相关信息</p><ul><li><code>allocs</code>: A sampling of all past memory allocations</li><li><code>block</code>: Stack traces that led to blocking on synchronization primitives</li><li><code>cmdline</code>: The command line invocation of the current program</li><li><code>goroutine</code>: Stack traces of all current goroutines</li><li><code>heap</code>: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.</li><li><code>mutex</code>: Stack traces of holders of contended mutexes</li><li><code>profile</code>: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.</li><li><code>threadcreate</code>: Stack traces that led to the creation of new OS threads</li><li><code>trace</code>: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.</li></ul></li><li><p>也可通过命令行查看</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看堆内内存分配情况</span><br><span class="line">go tool pprof http:&#x2F;&#x2F;localhost:6060&#x2F;debug&#x2F;pprof&#x2F;heap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看 30 秒内 CPU 耗时信息</span><br><span class="line">go tool pprof http:&#x2F;&#x2F;localhost:6060&#x2F;debug&#x2F;pprof&#x2F;profile?seconds&#x3D;30</span><br></pre></td></tr></table></figure></p></li><li><p>在命令行中也可使用 <a href="http://www.graphviz.org/">graphviz</a> 将获得的信息以图的形式展现 <code>png &gt; filename.png</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 pprof 和 graphviz 分析进程内存分配，CPU 耗时等信息。&lt;/p&gt;
    
    </summary>
    
      <category term="生活小常识" scheme="https://yz1509.github.io/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E5%B8%B8%E8%AF%86/"/>
    
    
      <category term="GO" scheme="https://yz1509.github.io/tags/GO/"/>
    
      <category term="pprof" scheme="https://yz1509.github.io/tags/pprof/"/>
    
      <category term="graphviz" scheme="https://yz1509.github.io/tags/graphviz/"/>
    
  </entry>
  
  <entry>
    <title>CCIA-线程间共享数据</title>
    <link href="https://yz1509.github.io//posts/d1f906e1/"/>
    <id>https://yz1509.github.io//posts/d1f906e1/</id>
    <published>2019-11-15T09:15:13.000Z</published>
    <updated>2019-12-11T11:57:16.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《C++ Concurrentcy in Action 2nd》 第三章阅读笔记。</p><a id="more"></a><hr><h1 id="使用互斥锁保护共享数据">使用互斥锁保护共享数据</h1><h2 id="在-c-中使用互斥锁">在 C++ 中使用互斥锁</h2><p>构造一个 <code>std::mutex</code> 的实例即可创建一个互斥锁，使用成员函数 <code>lock()</code> 和 <code>unlock()</code> 可分别执行加锁和释放锁的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.1. Protecting a list with a mutex</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;   <span class="comment">// global variable</span></span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>; <span class="comment">// RAII idiom for a mutex</span></span><br><span class="line">  some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::find(some_list.begin(), some_list.end(), value_to_find) != some_list.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++17 中，由于添加了类模板中的模板参数自动推导，故可将 <code>std::lock_guard&lt;std::mutex&gt; guard(some_mutex)</code> 简化为 <code>std::lock_guard guard(some_mutex)</code>。</p><h2 id="利用-oop-的思想保护共享数据">利用 OOP 的思想保护共享数据</h2><p>在使用互斥锁保护共享数据时，特别要注意关于临界资源的指针和引用，其可能会在临界区外修改临界资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.2 Accidentally passing out a reference to protected data</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    func(data); <span class="comment">// Pass &quot;protected&quot; data to user-supplied function</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected = &amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.process_data(malicious_function); <span class="comment">// Pass in a malicious function</span></span><br><span class="line">  unprotected-&gt;do_something(); <span class="comment">// Unprotected access to protected data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于共享数据，无论是作为函数的返回值，还是函数的实参，都不要传递其指针或引用至临界区外。</p><h2 id="发现接口固有的竞争情况">发现接口固有的竞争情况</h2><p>例如在双向链表中，如果想删除某个节点，仅仅对该节点上锁是不可行的。假设一个 stack 容器定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.3 The interface to the std::stack container adapter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">explicit</span> <span class="title">stack</span>(<span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">const</span> <span class="title">Container</span>&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">Container</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt; <span class="title">stack</span>(<span class="title">stack</span>&amp;&amp;, <span class="title">const</span> <span class="title">Alloc</span>&amp;);</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">stack</span>&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在多线程环境下，上述定义中 <code>empty()</code> 和 <code>size()</code> 接口得到的值不保证可用性。例如在下述代码中，在 phase 1 和 phase 2 之间可能有另外一个线程清空该 stack 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (!s.empty()) <span class="comment">// phase 1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> value = s.top(); <span class="comment">// phase 2</span></span><br><span class="line">  s.pop();  <span class="comment">// phase 3</span></span><br><span class="line">  do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有一种很常见的情况发生：</p><table><thead><tr class="header"><th style="text-align: left;">Thread A</th><th style="text-align: left;">Thread B</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>if(!s.empty())</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">.</td><td style="text-align: left;"><code>if(!s.empty())</code></td></tr><tr class="odd"><td style="text-align: left;"><code>int const value = s.top()</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">.</td><td style="text-align: left;"><code>int const value = s.top()</code></td></tr><tr class="odd"><td style="text-align: left;"><code>s.pop()</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>do_something(value)</code></td><td style="text-align: left;"><code>s.pop()</code></td></tr><tr class="odd"><td style="text-align: left;">.</td><td style="text-align: left;"><code>do_something(value)</code></td></tr></tbody></table><p>在上述表格的执行顺序下，我们会 pop 出两个元素，但 <code>do_something()</code> 只处理了其中一个元素，而且我们还很难发现这个 bug 。但是如果将 <code>top()</code> 和 <code>pop()</code> 两个接口合并的话，也会有新的问题：拷贝操作可能抛出异常(比如内存分配失败等)，从而导致 stack 发生了修改，但我们没得到栈顶的元素。我们可以从几个方面试着解决这个问题：</p><ol type="1"><li><p>Pass in a reference</p><p>我们可以选择给 <code>pop()</code> 函数传递一个变量的引用以避免内存分配时可能抛出的异常。该方法有两个前提条件：</p><ul><li>需要提前构造栈元素的实例</li><li>需要栈元素支持赋值操作</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">void</span> pop(T&amp; value);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">some_stack.pop(result);</span><br></pre></td></tr></table></figure></p></li><li><p>Require a no-throw copy constructor or move constructor</p><p>有些类型的拷贝构造函数或者移动构造函数并不会抛出异常，所以对它们而言并不存在该异常安全问题。</p></li><li><p>Return a pointer to the popped value</p><p>返回指针虽然可以避免拷贝操作，但是需要注意内存泄露问题，可使用智能指针进行内存管理。</p></li><li><p>Provide both option 1 and either option 2 or 3</p><p>下面是线程安全的 <code>threadsafe_stack</code> 类型定义。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.4 An outline class definition for a thread-safe satck</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // For std::shared_ptr&lt;T&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack();</span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp;);</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// option 3</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>; <span class="comment">// option 1</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Listing 3.5 A fleshed-out class definition for a thread-safe satck</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">  <span class="comment">/* Mutable is used to specify that the member does not affect the externally </span></span><br><span class="line"><span class="comment">    visible state of the class. */</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack()&#123;&#125;</span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data = other.data; <span class="comment">// Copy performed in constructor body</span></span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.push(<span class="built_in">std</span>::move(new_value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// Check for empty before trying to pop value</span></span><br><span class="line">    <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    <span class="comment">// Allocate return value before modifying stack</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::shard_ptr&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">    data.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">    value = data.pop();</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>; <span class="comment">// require m mutable here</span></span><br><span class="line">    <span class="keyword">return</span> data.empty();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><em>Tips:</em> <a href="https://stackoverflow.com/questions/12833241/difference-between-c03-throw-specifier-c11-noexcept">Difference between C++03 throw() specifier C++11 noexcept.</a></p></li></ol><h2 id="死锁">死锁</h2><p>当一个操作中含有两个或多个互斥锁时，死锁就有可能会发生。如果可以同时加锁的话，此时可避免死锁的情况，针对于此，STL 的 <code>std::lock</code> 函数可同时对多个互斥锁进行加锁操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.6 Using std::lock() and std::lock_guard in a swap operation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs, some_big_object&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object <span class="keyword">const</span>&amp; sd) : some_detail(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::lock(lhs.m, rhs.m);  <span class="comment">// phase 1</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, <span class="built_in">std</span>::adopt_lock)</span></span>; <span class="comment">// phase 2</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, <span class="built_in">std</span>::adopt_lock)</span></span>; <span class="comment">// phase 3</span></span><br><span class="line">    swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>phase 2 和 phase 3 中的 <code>std::adopt_lock</code> 表示 <code>lock_guard</code> 构造函数仅会取得互斥锁 <span class="math inline">\(m\)</span> 的所有权，不会对其进行加锁操作。C++ 17 提供了 和 <code>lock_guard</code> 功能类似但是支持可变模板参数的 <code>scoped_lock</code>，C++ 17 中可将 <code>swap</code> 函数改写成如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(lhs.m, rhs.m);</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::scoped_lock <span class="title">guard</span><span class="params">(lhs.m, rhs,m)</span></span>;</span><br><span class="line">  swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于可以同时加锁的情况，避免死锁比较容易做到，但是在其他情况下，如果有效避免死锁的发生是相当困难的。</p><h2 id="避免死锁的几点建议">避免死锁的几点建议</h2><p>死锁不仅仅是伴随着互斥锁而出现，例如，在两个线程互相等待对方结束的情况下，也会发生死锁。</p><ol type="1"><li><p>Don't acquire a lock if you already hold one. 使用场景受限，而且不能避免循环等待。</p></li><li><p>Avoid calling user-supplied code while holding a lock.</p></li><li><p>如果必须要获得多个锁时，建议按固定顺序进行加锁操作，例如在双向链表中，加锁时只能以从头至尾的顺序。</p></li><li><p>Use a lock hierarchy</p><p>给互斥锁附加一个 <code>hierarchy_value</code> 字段，当线程持有互斥锁时，只能对 <code>hierarchy_value</code> 比当前锁更小的 mutex 加锁。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.7 Using a lock hierarchy to prevent deadlock</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> do_low_level_stuff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierachical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>;</span><br><span class="line">  high_level_stuff(low_level_func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  high_level_func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  high_level_func();</span><br><span class="line">  do_other_stuff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;hierachical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span></span><br><span class="line"><span class="function">  <span class="title">other_stuff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述示例中，thread_a() 遵守规则，运行良好；而 thread_b() 违反规则，故运行失败。下面是 <code>hierarchical_mutex</code> 的一个简单实现。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.8 A simple hierachical mutex</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex internal_mutex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;mutex hierarchy violated.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pervious_hierarchy_value = this_thread_hierarchy_value;</span><br><span class="line">    this_thread_hierarchy_value = hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line">    hierarchy_value(value),</span><br><span class="line">    previous_hierarchy_value(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    internal_mutex.lock();</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value != hierarchy_value)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;mutex hierarchy violated.&quot;</span>);</span><br><span class="line">    this_thread_hierarchy_value = previous_hierarchy_value;</span><br><span class="line">    internal_mutex.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    <span class="keyword">if</span> (!internal_mutex.try_lock())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> </span><br><span class="line">  hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);</span><br></pre></td></tr></table></figure></p><p><em>Tips:</em> <a href="https://en.cppreference.com/w/cpp/language/storage_duration">thread_local</a></p></li></ol><h2 id="stdunique_lock"><code>std::unique_lock</code></h2><p>使用 <code>std::unique_lock</code> 可以将 Listing 3.6 改写为如下形式。其中 <code>std::defer_lock</code> 表示在构造 <code>std::unqiue_lock</code> 实例时，会让传入的 <code>std::mutex</code> 保持 unlocked。</p><p><code>std::unique_lock</code> 的优缺点：</p><ul><li>优点：<code>std::unique_lock</code> 并不会总是持有 <code>std::mutex</code> 的所有权，使用更加灵活</li><li>缺点：为了实现上面的优点，需要花费额外的空间和时间以存储更新相关状态数据，所以 <code>std::unqiue_lock</code> 比 <code>std::lock_guard</code> 慢且更占存储空间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.9 Using std::lock() and std::unique_lock() in a swap operation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs, some_big_object&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// std::defer_lock leaves mutexes unlocked.</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// Mutexes are locked here</span></span><br><span class="line">    <span class="comment">// std::unique_lock objects could be passed to std::lock()</span></span><br><span class="line">    <span class="built_in">std</span>::lock(lock_a, lock_b);  </span><br><span class="line">    swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上例中，我们发现 <code>std::unique_lock</code> 对象可以传入 <code>std::lock()</code> 函数，这是因为 <code>std::unique_lock</code> 实现了 <code>lock()</code>、<code>try_lock()</code> 和 <code>unlock()</code> 成员函数。除此之外，还可以通过调用 <code>owns_lock()</code> 函数查看 <code>std::unique_lock</code> 当前是否拥有 <code>std::mutex</code>。</p><p><code>std::unique_lock</code> 类型不支持 copy，但支持 move，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  prepare_data();</span><br><span class="line">  <span class="keyword">return</span> lk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">  do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合理设置互斥锁的粒度">合理设置互斥锁的粒度</h2><p>通常说到粒度，大家都会想到数据大小相关的粒度的概念；除此之外，占有锁的时间的粒度大小也需要多加注意。比如，有时不必全程持有互斥锁，只在对共享数据进行操作时才上锁，操作完毕后及时释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_add_process_data</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">  some_class data_to_process = get_next_data_chunk();</span><br><span class="line">  <span class="comment">// Don&#x27;t need mutex locked across call to process()</span></span><br><span class="line">  my_lock.unlock();</span><br><span class="line">  result_type result = process(data_to_process);</span><br><span class="line">  <span class="comment">// Relock mutex to write result</span></span><br><span class="line">  my_lock.lock();</span><br><span class="line">  write_result(data_to_process, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们需要尽可能地减少占有锁的时间。比如，如果对数据的副本进行操作也可以得到想要的结果，而且拷贝操作耗时很小时，我们可以选择操作副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.10 Locking one mutex at a time in a comparison operator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> some_detail;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> some_detail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Y(<span class="keyword">int</span> sd):some_detail(sd) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== (Y <span class="keyword">const</span>&amp; lhs, Y <span class="keyword">const</span>&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> lhs_value = lhs.get_detail(); <span class="comment">// phase 1</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> rhs_value = rhs.get_detail(); <span class="comment">// phase 2</span></span><br><span class="line">    <span class="keyword">return</span> lhs_value == rhs_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中需要注意的是，在 phase 1 和 phase 2 之间，可能 <code>lhs</code> 的值发生了改变，所以返回的结果的有效性有一定损失。</p><h1 id="保护共享数据的其他场景方法">保护共享数据的其他场景/方法</h1><p>互斥锁的确很通用，但在特定的场合下选择更适合的保护机制也是很有必要的。</p><h2 id="仅在初始化阶段需要保护的共享数据">仅在初始化阶段需要保护的共享数据</h2><p>假设你需要对某个对象使用 <strong>Lazy initialization</strong> 机制，在单线程下很容易实现，仅需要在使用之前检查是否已初始化即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource); </span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程的场景下，初始化的操作需要进行保护，一个简单的实现如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.11 Thread-safe lazy initialization using a mutex</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// All threads are serialized here</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>; </span><br><span class="line">  <span class="keyword">if</span> (!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Only the initialization needs protection</span></span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">  &#125;</span><br><span class="line">  lk.unlock();</span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现中，增加了不必要的加锁、释放锁的操作，而我们所需要保护的仅仅是初始化操作而已。为了解决这个问题，可能有人会想到 double-checked locking 模式，写出如下所示的代码，但是这不仅不会解决我们得问题，还会额外引发其他问题：线程在 phase 1 可随意访问共享对象，其与 phase 3 并不处于同步状态，很有可能在 phase 1 阶段发现指针非空便直接到了 phase 4 阶段，而此时对象 <code>some_resource</code> 可能还未构造完毕，从而造成未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// infamous double-checked locking pattern</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!resource_ptr)  <span class="comment">// phase 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!resource_ptr)  <span class="comment">// phase 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      resource_ptr.reset(<span class="keyword">new</span> some_resource);  <span class="comment">// phase 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;do_something(); <span class="comment">// phase 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 C++ 提供的 <code>std::once_flag</code> 和 <code>std::call_once</code> 便可写出满足要求的代码，每个 <code>std::once_flag</code> 实例对应于不同的初始化过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::once_flag resourceZ_flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initalization is called exactly once.</span></span><br><span class="line">  <span class="built_in">std</span>::call_once(resource_flag, init_resource);</span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的成员函数使用 <code>std::call_once()</code> 时需要传入 <code>this</code> 指针，就像 <code>std::thread</code> 的构造函数或 <code>std::bind()</code> 一样，如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.12 Thread-safe lazy initialization of a class member using std::call_once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line">  <span class="built_in">std</span>::once_flag  connection_init_flag;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    connection = connection_manager.open(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(connection_info <span class="keyword">const</span>&amp; connection_details_) : </span><br><span class="line">        connection_details(connection_details_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);  </span><br><span class="line">    connection.send_data(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> connection.receive_data();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++11 之前，静态变量也有潜在的竞态情况，但在 C++11 之中这一点被修复了，静态局部变量的初始化仅会在一个线程中执行，所以在 C++11 之中，声明变量为 <code>static</code> 也可以起到和 <code>std::call_once()</code> 类似的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span>;</span></span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialization guaranteed to be thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> my_class instance;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保护极少更新的共享数据">保护极少更新的共享数据</h2><p>对于这种情况，我们可以立马想到使用读写锁，C++17 提供两种读写锁：<code>std::shared_mutex</code> 和 <code>std::shared_timed_mutex</code>；C++14 仅提供 <code>std::shared_time_mutex</code>；而对于 C++11，如果想使用读写锁，就需要依赖 Boost library 提供的实现。</p><p>对于 <code>std::shared_mutex</code>(<code>std::mutex_time_mutex</code>同样)，在使用 RAII 机制时：</p><ul><li>写锁：<code>std::lock_guard&lt;std::shared_mutex&gt;</code> 或 <code>std::unique_lock&lt;std::shared_mutex&gt;</code></li><li>读锁：<code>std::shared_lock&lt;std::shared_mutex&gt;</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 3.13 Protecting a data structure with std::shared_mutex</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, dns_entry&gt; entries;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex entry_mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, dns_entry&gt;::const_iterator <span class="keyword">const</span> it = entries.find(domain);</span><br><span class="line">    <span class="keyword">return</span> (it == entries.end()) ? dns_entry() : it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain, dns_entry <span class="keyword">const</span>&amp; dns_details)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line">    entries[domain] = dns_details;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归锁">递归锁</h2><p>虽然一般不推荐使用递归锁，但是想使用的话，C++ 提供了递归锁的实现：<code>std::recursive_mutex</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Concurrentcy in Action 2nd》 第三章阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://yz1509.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="多线程" scheme="https://yz1509.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://yz1509.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CCIA-线程管理</title>
    <link href="https://yz1509.github.io//posts/ef64709b/"/>
    <id>https://yz1509.github.io//posts/ef64709b/</id>
    <published>2019-11-14T06:20:01.000Z</published>
    <updated>2019-12-11T11:57:36.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《C++ Concurrentcy in Action 2nd》 第二章阅读笔记。</p><a id="more"></a><hr><h1 id="基础线程管理">基础线程管理</h1><h2 id="启动线程">启动线程</h2><p>使用 C++ 线程库启动线程，可以归结为构造 <code>std::thread</code> 对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        do_something();</span><br><span class="line">        do_something_else();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">background_task f;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure><p>注意在上述 case 2 中，如果你传入一个临时变量时，编译器可能会将其<a href="https://en.wikipedia.org/wiki/Most_vexing_parse">误解为函数声明</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>; <span class="comment">// 可能会误解为函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除歧义的方法</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">( (background_task()) )</span></span>; </span><br><span class="line"><span class="built_in">std</span>::thread my_thread&#123;background_task()&#125;;</span><br></pre></td></tr></table></figure><p>也可使用 lambda 表达式改写 case 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    do_something();</span></span></span><br><span class="line"><span class="function"><span class="params">    do_something_else();</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="等待线程完成">等待线程完成</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_thread.join();</span><br></pre></td></tr></table></figure><p>因为 <code>join()</code> 函数还会清除与线程相关的存储区，因此一个 <code>std::thread</code> 对象只能调用一次 <code>join()</code>，一旦调用了 <code>join()</code>，调用 <code>joinable()</code> 会返回 <code>false</code>。</p><p>如果在线程启动和调用 <code>join()</code> 之间出现异常，我们该如何保证调用 <code>join()</code> 的执行呢？</p><ol type="1"><li><p>使用 <code>try/catch</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.2. Waiting for a thread to finish</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i_) : i(i_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            do_something(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        do_something_in_current_thread();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>使用 <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 机制</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.3. Using RAII to wait for a thread to complete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(<span class="built_in">std</span>::thread&amp; t_)</span> : <span class="title">t</span><span class="params">(t_)</span> </span>&#123;&#125;</span><br><span class="line">    ~thread_guard()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.joinable())</span><br><span class="line">        &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_guard(thread_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// See Listing 2.2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="分离线程">分离线程</h2><p>通过调用 <code>detach()</code> 可让线程在后台运行。可以通过调用 <code>joinable()</code> 判断线程是否可以分离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.4. Detaching a thread to handle other documents</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    open_document_and_display_gui(filename);</span><br><span class="line">    <span class="keyword">while</span> (!done_editing())</span><br><span class="line">    &#123;</span><br><span class="line">        user_command cmd = get_user_input();</span><br><span class="line">        <span class="keyword">if</span> (cmd.type == open_new_document)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span> new_name = get_filename_from_user();</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(edit_document, new_name)</span></span>;</span><br><span class="line">            t.detach();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            process_user_input(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传递参数">传递参数</h1><p>向可调用对象或函数传递参数很简单，只需要将这些参数作为 <code>std::thread</code> 构造函数的附加参数即可。但需要注意的是，在默认情况下，这些参数会被拷贝至新线程的独立内存空间中，以供新线程访问，并如同临时变量一样作为右值传递给可调用对象或函数。即使函数中的参数是引用的形式，拷贝操作也会执行。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;heoolo&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>代码创建了一个调用 <code>f(3, "hello")</code> 的线程。注意，函数 <code>f</code> 需要一个 <code>std::string</code> 对象作为第二个参数，但这里使用的是字符串的字面值，也就是 <code>char const *</code> 类型。之后，在线程的上下文中完成字面值向 <code>std::string</code> 对象的转化。</p><h2 id="提防隐式转换">提防隐式转换</h2><p>特别需要注意的是，当指向动态变量的指针作为参数传递给线程的情况，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>]; </span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>, some_param);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, buffer)</span></span>; </span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<code>buffer</code> 是一个指针变量，指向局部变量，然后此局部变量通过 <code>buffer</code> 传递到新线程中。此时，函数 <code>oops</code> 很有可能会在 <code>buffer</code> 转换成 <code>std::string</code> 对象之前结束，从而导致一些未定义的行为。因为此时无法保证隐式转换的操作和 <code>std::thread</code> 构造函数的拷贝操作按顺序进行，有可能 <code>std::thread</code> 的构造函数拷贝的是转换前的变量 (<code>buffer</code> 指针)，而非字符串。解决方案就是在传递到 <code>std::thread</code> 构造函数之前就将字符数组转化为 <code>std::string</code> 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">    <span class="comment">// Using std::string avoids dangling pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(buffer))</span></span>; </span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递引用">传递引用</h2><p>当你尝试使用线程更新一个引用传递的数据结构时也会出现问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w, widget_data&amp; data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget, w, data)</span></span>;</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，虽然 <code>update_data_for_widget</code> 的第二个参数期待传入一个引用，但是 <code>std::thread</code> 的构造函数并不知晓；其无视 <code>update_data_for_widget</code> 期待的参数类型，并盲目地拷贝提供的变量。内部代码会将拷贝的参数以右值的方式进行传递，这是为了照顾到那些只能进行移动的类型，而后会尝试以右值为实参调用 <code>update_data_for_widget</code>。但因为函数期望的是一个非常量引用作为参数，而非右值，所以会在编译时出错。对于熟悉 <code>std::bind</code> 的开发者来说，问题的解决办法是显而易见的：可以使用 <code>std::ref</code> 将参数转换成引用的形式，因此可将线程的调用改为以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget, w, <span class="built_in">std</span>::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><p>从而，<code>update_data_for_widget</code> 就会接收到一个 <code>data</code> 变量的引用，而非 <code>data</code> 变量的拷贝副本，这样代码就能顺利的通过编译。</p><h2 id="传递成员函数指针">传递成员函数指针</h2><p>你也可以向线程传递一个成员函数指针，并提供一个合适的对象指针作为函数第一个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x)</span></span>;</span><br></pre></td></tr></table></figure><p>在这段代码中，新线程将会调用 <code>my_x.do_lengthy_work()</code>，其中 <code>my_x</code> 的地址作为对象指针提供给函数。你也可以为成员函数提供参数：<code>std::thread</code> 构造函数的第三个参数就是成员函数的第一个参数。</p><h2 id="传递仅支持-move-的参数">传递仅支持 <code>move</code> 的参数</h2><p>当原对象是一个临时变量时，自动进行 <code>move</code> 操作，但当原对象是一个命名变量，那么传递的时候就需要使用 <code>std::move()</code> 进行显示 <code>move</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;prepare_data(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(process_big_object, <span class="built_in">std</span>::move(p))</span></span>;</span><br></pre></td></tr></table></figure><p><code>std::thread</code> 对象其实和 <code>std::unique</code> 类似，也是仅支持 <code>move</code>，不支持 <code>copy</code> 的类型。这说明了在同一时刻，至多仅有一个 <code>std::thread</code> 实例与一个执行中的线程关联，而且允许在不同的实例之间转移线程的所有权。</p><h1 id="转移线程所有权">转移线程所有权</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; <span class="comment">// some_function - t1</span></span><br><span class="line"><span class="built_in">std</span>::thread t2 = <span class="built_in">std</span>::move(t1); <span class="comment">// some_function - t2</span></span><br><span class="line">t1 = <span class="built_in">std</span>::thread(some_other_function); <span class="comment">// some_other_function - t1</span></span><br><span class="line"><span class="built_in">std</span>::thread t3;</span><br><span class="line">t3 = <span class="built_in">std</span>::move(t2); <span class="comment">// some_function - t3</span></span><br><span class="line">t1 = <span class="built_in">std</span>::move(t3); <span class="comment">// This assignment will terminate the program</span></span><br></pre></td></tr></table></figure><p><code>std::thread</code> 对象支持 <code>move</code> 操作，意味着其可以作为函数的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.5. Returning a std::thread from a function</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::thread(some_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_other_function, <span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>std::thread</code> 类型也可以作为函数的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::thread t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    f(<span class="built_in">std</span>::thread(some_function));</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">    f(<span class="built_in">std</span>::move(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用 <code>move</code> 实现功能类似 <code>thread_guard</code> 的类，与 Listing 2.3 中的 <code>thread_guard</code> 不同的是，<code>scoped_thread</code> 直接转移线程的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.6. scoped_thread and example usage</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">scoped_thread</span><span class="params">(<span class="built_in">std</span><span class="string">&quot;&quot;</span>thread t_)</span> : <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(t_))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t.joinable())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~scoped_thread()</span><br><span class="line">    &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    scoped_thread(scoped_thread <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>= (scoped_thread <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// See Listing 2.2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_locate_state;</span><br><span class="line">    scoped_thread t&#123;<span class="built_in">std</span>::thread(func(some_local_state))&#125;;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果保存 <code>std::thread</code> 对象的容器是 move-aware 的，则其也支持 <code>move</code> 语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.8. Spawns some threads and waits for them to finsh</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads.emplace_back(do_work, i);   <span class="comment">// Spawns threads</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry: threads)</span><br><span class="line">        entry.join();   <span class="comment">// Calls join() on each thread in turn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Tips:</em> 此处使用的 <code>emplace_back</code> 比 <code>push_back</code> 更高效，它仅需要传入对象构造函数所需的参数。 <a href="https://devdocs.io/cpp/container/vector/emplace_back">接口定义</a> &amp;&amp; <a href="https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back">两者对比</a></p><h1 id="选择所需线程的数量">选择所需线程的数量</h1><p>函数 <code>std::thread::hardware_concurrency()</code> 返回当前可真正并行运行的线程数（不过需要确定当前运行环境是否支持该命令）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 2.9. A naive parallel version of std::accumulate</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Iterator first, Iterator last, T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = <span class="built_in">std</span>::accumulate(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads = </span><br><span class="line">            <span class="built_in">std</span>::min(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size = length / num_threads;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        <span class="built_in">std</span>::advance(block_end, block_size);</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(</span><br><span class="line">            accumulate_block&lt;Iterator, T&gt;(),</span><br><span class="line">            block_start, block_end, <span class="built_in">std</span>::ref(results[i]) );</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// current thread process the final block</span></span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;() (block_start, last, results[num_threads - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry: threads)</span><br><span class="line">        entry.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(results.begin(), results.end(), init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程标识">线程标识</h1><p>线程标识的类型是 <code>std::thread::id</code>，可通过种方式获取：</p><ul><li>调用 <code>std::thread</code> 对象的成员函数 <code>get_id()</code></li><li>调用 <code>std::this_thread::get_id()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::id master_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::this_thread::get_id == master_thread)</span><br><span class="line">    &#123;</span><br><span class="line">        do_master_thread_work();</span><br><span class="line">    &#125;</span><br><span class="line">    do_common_work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Concurrentcy in Action 2nd》 第二章阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://yz1509.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="多线程" scheme="https://yz1509.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://yz1509.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis Streams</title>
    <link href="https://yz1509.github.io//posts/76da14fe/"/>
    <id>https://yz1509.github.io//posts/76da14fe/</id>
    <published>2019-10-16T09:50:09.000Z</published>
    <updated>2019-10-30T10:10:21.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>主要介绍 Redis Streams 数据结构及部分操作，并不涉及源码部分。</p><a id="more"></a><hr><p>整理自 <a href="http://antirez.com/news/114">Streams: a new general purpose data structure in Redis</a>、<a href="http://antirez.com/news/116">An update on Redis Streams development</a>、<a href="http://antirez.com/news/128">Redis streams as a pure data structure</a> 和 <a href="https://redis.io/topics/streams-intro">Introduction to Redis Streams</a> 。</p><h1 id="什么是-redis-streams">什么是 Redis Streams</h1><p>本质上是一个抽象日志：</p><ul><li>日志中的每条记录是结构化、可扩展的 <code>&lt;field, value&gt;</code> 对</li><li>支持范围查询和指定读取</li><li>每条记录在日志中有唯一标识，标识中包含了单调递增的时间戳信息</li><li>日志可以根据需要自动清理历史记录</li><li>日志保存在内存中，但是也支持持久化</li></ul><p>和其他可模拟消息队列的数据类型 (List, Pub/Sub, Zset) 对比：</p><table><colgroup><col style="width: 60%"><col style="width: 39%"></colgroup><thead><tr class="header"><th>List, Pub/Sub, Zset</th><th>Redis Streams</th></tr></thead><tbody><tr class="odd"><td>List 不能从中间获取成员，<span class="math inline">\(O(N)\)</span></td><td>可以从中间获取成员，<span class="math inline">\(O(logN)\)</span></td></tr><tr class="even"><td>no fan-out is possible, blocking operations on list serve a single element to a single client</td><td>可以多个 clients 使用 XREAD blocking for new message</td></tr><tr class="odd"><td>List 中没有标识符的概念</td><td>每条 msg 都有一个唯一的 id</td></tr><tr class="even"><td>Pub/Sub 无法保留历史消息，只能获取连接之后的消息，不支持范围查询</td><td>可以保存在 AOF 和 RDB 中</td></tr><tr class="odd"><td>Pub/Sub 没有 consumer group 的概念</td><td>有 consumer group，更贴近真实的业务场景</td></tr><tr class="even"><td>Pub/Sub 的性能和订阅某个频道的 client 数量正相关</td><td>不存在</td></tr><tr class="odd"><td>Zset 不允许添加重复成员，不支持成员淘汰和 block 新消息操作，内存开销大</td><td>允许，支持按时间线来淘汰历史数据，支持 block 操作，基于 redix tree 和 listpack，内存开销低</td></tr><tr class="even"><td>Zset 支持删除任意元素</td><td>不支持从中间删除元素 (log属性)，more compact and memory efficient</td></tr></tbody></table><h1 id="redis-streams-结构">Redis Streams 结构</h1><figure class="highlight plain"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">| key | Entry1 |--| Entry2 |--| ...... |--| EntryN |</span><br><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">      :        :       </span><br><span class="line">+-----+        +-------------------------------------------+</span><br><span class="line">|                                                          |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| ID | field1 | value1 | field2 | value3 | ...... | ...... |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">:    : </span><br><span class="line">|    +-------------------------------+ </span><br><span class="line">|                                    |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| millisecond time | sequence number |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure><ul><li>在每个 streams 中含有多个 entry(message)</li><li>每个 entry 有一唯一的 ID，并且可包含多个 <code>&lt;filed, value&gt;</code> 对<ul><li>添加连续的 entry，如果使用相同的 field name 可以节省内存</li></ul></li><li>ID 由 millisecond time(64bit) 和 sequence number(64bit) 两部分组成<ul><li>其中，millisecond time 取当前时间戳和上一条插入 streams 的 entry 的时间戳之间的较大值，保证单调性</li></ul></li></ul><h1 id="redis-streams-api">Redis Streams API</h1><h2 id="xadd">XADD</h2><p><code>XADD key [MAXLEN [~] number] ID field string [field string ...]</code></p><p>Appends a new entry into the specified streams.</p><ul><li>ID 为 <code>*</code> 表示让 Redis 自动生成 ID</li><li>如果指定消息 ID，为了维持单调递增性，后面指令的 ID 必须大于之前指令的 ID</li><li>可以指定 streams 的 <code>MAXLEN</code>，此时 streams 类似于一个固定大小的队列</li><li>添加 <code>~</code> 表示并不严格要求 <code>MAXLEN=number</code></li></ul><h2 id="xrange-xrevrange">XRANGE / XREVRANGE</h2><p><code>XRANGE key start end [COUNT count]</code></p><ul><li>返回结果包含 start ID 和 end ID，即闭区间</li><li><code>-</code> 和 <code>+</code> 分别表示最小和最大 ID</li><li>start ID 和 end ID 可以省略 sequenceNumber 部分，此时 start ID 默认 sequenceNumber = 0，而 end ID 默认 sequenceNumber 为最大值</li><li>可以添加 <code>COUNT</code> 参数，实现类似 <code>scan</code> 操作</li></ul><p><code>XREVRANGE key end start [COUNT count]</code></p><ul><li>逆序返回结果，使用方法类似 <code>XRANGE</code></li></ul><h2 id="xread-blocking-for-new-data">XREAD: blocking for new data</h2><p><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></p><ul><li>ID为 <code>$</code> 表示指定 ID 为流中目前已存的最大 ID</li><li>BLOCK 超时时间单位为 ms，超时时间为 0 时表示不会超时</li><li>当有多个 client BLOCK 等待新 msg 时，排队方式为 FIFO</li></ul><h2 id="xlen">XLEN</h2><p><code>XLEN key</code></p><p>查看指定流中的 entry 个数，one ID one entry.</p><h1 id="consumer-groups">Consumer groups</h1><p>一个 consumer group 就像一个 pseudo consumer 一样从 streams 中获取数据，它有如下特点：</p><ul><li>同一消息不可能传递给多个 consumer</li><li>在 consumer group 中由 consumer(client) 自身提供 name 来进行区分</li><li>每个 consumer group 保存了目前尚未分发的第一条消息的 ID (即，偏移量)，据此，当 consumer 请求消费时， consumer group 保证不会将先前已分发的消息发送给该 consumer</li><li>消费消息需要显式地 ACK 机制，只有当该消息确认被处理，才会从 consumer group 的消息队列中删除</li><li>Consumer group 记录当前所有的未决消息的信息，因此保证了 consumer 在中断重连后只能重新获取之前自身未 ACK 的消息</li></ul><p>一个 consumer group 状态的示例如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| consumer_group_name: mygroup             |</span><br><span class="line">| consumer_group_stream: somekey           |</span><br><span class="line">| last_delivered_id: <span class="number">1292309234234</span><span class="number">-92</span>      |     </span><br><span class="line">|                                          |                                   </span><br><span class="line">| consumers:                               |</span><br><span class="line">|     <span class="string">&quot;consumer-1&quot;</span> <span class="keyword">with</span> pending messages   |</span><br><span class="line">|        <span class="number">1292309234234</span><span class="number">-4</span>                   |</span><br><span class="line">|        <span class="number">1292309234232</span><span class="number">-8</span>                   | </span><br><span class="line">|     <span class="string">&quot;consumer-42&quot;</span> <span class="keyword">with</span> pending messages  |</span><br><span class="line">|       ... (<span class="keyword">and</span> so forth)                 |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="xgroup">XGROUP</h2><p>创建、销毁和管理 consumer group</p><ul><li><code>XGROUP CREATE key groupname id-or-$</code><ul><li>目前尚不支持从一个未存在的 streams 上创建 consumer group</li></ul></li><li><code>XGROUP SETID key groupname id-or-$</code></li><li><code>XGROUP DESTROY key groupname</code></li><li><code>XGROUP DELCONSUMER key groupname consumername</code></li></ul><h2 id="xreadgroup">XREADGROUP</h2><p>通过 consumer group 的方式从 streams 中读取数据</p><p><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code> * 首次出现的 consumer 将自动加入 consumer group，无需显式声明 * ID 为 <code>&gt;</code> 表示请求尚未分发给其他 consumer 的新消息 * ID 为其他有效的数字 ID 表示请求自身尚未 ACK 的 pending messages</p><h2 id="xack">XACK</h2><p>将一个未决消息标记为已处理</p><p><code>XACK key group ID [ID ...]</code></p><h2 id="xpending">XPENDING</h2><p>返回 consumer group 中的 pending messages 相关信息</p><p><code>XPENDING key group [start end count] [consumer]</code></p><h2 id="xclaim">XCLAIM</h2><p>将满足条件的 pending messages 重分配</p><p><code>XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]</code></p><p>全部 consumer group 命令可查看<a href="https://redis.io/commands/xack">相关页面</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 Redis Streams 数据结构及部分操作，并不涉及源码部分。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Chord</title>
    <link href="https://yz1509.github.io//posts/33be3840/"/>
    <id>https://yz1509.github.io//posts/33be3840/</id>
    <published>2019-10-15T06:45:23.000Z</published>
    <updated>2020-09-07T04:05:00.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>还没开始看。</p><a id="more"></a><hr><p><a href="http://www.falleneth.com/cmuj/papers/chord.pdf">论文地址</a></p><h1 id="whydunit">Whydunit</h1><h1 id="whodunit">Whodunit</h1><h1 id="howdunit">Howdunit</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还没开始看。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过四级没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E5%9B%9B%E7%BA%A7%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="分布式" scheme="https://yz1509.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Consistent Hashing</title>
    <link href="https://yz1509.github.io//posts/affa099c/"/>
    <id>https://yz1509.github.io//posts/affa099c/</id>
    <published>2019-10-12T13:26:09.000Z</published>
    <updated>2020-09-07T04:04:49.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一致性哈希的 first paper (maybe) 阅读笔记。</p><a id="more"></a><hr><p><a href="http://david.choffnes.com/classes/cs4700sp14/papers/akamai.pdf">论文地址</a></p><h1 id="whydunit">Whydunit</h1><p>当大量的客户端同时对单个服务器发起请求时，可能会使该服务器(Hot spots) "swamped" （无法使用）。除此之外，还可能会阻塞该服务附近的网络通信。所以我们需要一个负载均衡算法来有效地避免 Hot spots 的出现。</p><h1 id="whodunit">Whodunit</h1><h2 id="proxy-cache">Proxy cache</h2><p>使用 proxy 缓存经常被请求的数据，多个客户端共享一个 proxy cache。</p><ol type="1"><li>所有用户的请求都发往 proxy</li><li>未命中时，proxy 会把该请求转发至 home server。</li></ol><p><strong>缺点</strong>：proxy 本身可能会 swamped</p><h2 id="a-group-of-caches-functions-as-one">A group of caches functions as one</h2><ol type="1"><li>用户的请求发往任意一个 cache</li><li>未命中时，使用 IP Multicast 将该请求转发至所有其他的 cache</li><li>未命中时，将该请求转发至 heme server</li></ol><p><strong>缺点</strong>：cache 之间的通信消息数量不可控</p><h2 id="harvest-cache">Harvest Cache</h2><p>使用树型结构的 cache，root 为 home server</p><ol type="1"><li>用户的请求发往邻近的叶节点</li><li>未命中时，将该请求转发至兄弟节点(siblings)</li><li>未命中时，将该请求转发至父节点(parent)</li></ol><p><strong>优点</strong>：保证了请求只会来自于子节点或兄弟节点</p><p><strong>缺点</strong>：当所有不同请求同时到来时，至少会有一个请求会到达 root，因此这只是一个缩放的结构，root 无法避免 swamped 的命运</p><h2 id="using-randomization-and-hashing">Using randomization and hashing</h2><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.877&amp;rep=rep1&amp;type=pdf">Plaxton and Rajaraman</a></p><p>新增一组 virtual cache 集合层，通过 random hash function 在现有的 Caches 和 virtual cache 集合之间建立映射，用户的请求发往任一 virtual cache 集合。如果 virtual cache 集合的负载超过阈值，则创建一个更大的 virtual cache 集合。</p><p><strong>优点</strong>：请求响应快，因为每个 cache 的负载都在可控范围；负载均衡。</p><p><strong>缺点</strong>：由于用户的请求发往任一 virtual cache 集合，故小规模的 virtual cache 集合可能会 swamped。</p><h2 id="random-cache-trees">Random cache trees</h2><p>下次一定看！</p><h2 id="consistent-hashing">Consistent hashing</h2><p>传统 hashing 的局限： * 假定节点数是固定的 * 每个节点需要知道全局信息，使用消息进行同步时，由于延时的存在，节点所保存的全局信息正确性无法保证</p><p>Consistent hashing 如何解决这两个问题，将于下文详述。</p><h1 id="howdunit">Howdunit</h1><h2 id="符号说明">符号说明</h2><ul><li><span class="math inline">\(\mathcal{I}\)</span>: set of items，数据</li><li><span class="math inline">\(i\)</span>: is an item</li><li><span class="math inline">\(\mathcal{B}\)</span>: set of buckets，类似于 proxy chche</li><li><span class="math inline">\(b\)</span>: is a bucket</li><li><em>view</em>: any subset of the buckets <span class="math inline">\(\mathcal{B}\)</span>，模拟节点的增加与删除</li><li><em>ranged hash function</em> <span class="math inline">\(f\)</span>: <span class="math inline">\(2^{\mathcal{B}} \times \mathcal{I} \rightarrowtail \mathcal{B}\)</span><ul><li><span class="math inline">\(f(\mathcal{V}, i)\)</span> or <span class="math inline">\(f_{\mathcal{V}}(i)\)</span> is the bucket to which item <span class="math inline">\(i\)</span> is assigned in view <span class="math inline">\(\mathcal{V}\)</span></li><li>Require: <span class="math inline">\(f_{\mathcal{V}}(\mathcal{I}) \subseteq \mathcal{V}\)</span> for every view <span class="math inline">\(\mathcal{V}\)</span></li></ul></li><li><em>ranged hash family</em> <span class="math inline">\(\mathcal{F}\)</span>: is a family of ranged hash functions</li><li><em>random ranged hash function</em>: is a function drawn at random from a particular ranged hash family</li></ul><h2 id="一致性哈希函数应满足的性质介绍">一致性哈希函数应满足的性质介绍</h2><ol type="1"><li><p>Balance</p><p>A ranged hash family is <em>balanced</em> if, given a particular view <span class="math inline">\(\mathcal{V}\)</span>, a set of items,and a randomly chosen function selected from the hash family, with high probability the fraction of items mapped to each bucket is <span class="math inline">\(O(1/|V|)\)</span>.</p></li><li><p>Monotonicity</p><ul><li>A ranged hash function <span class="math inline">\(f\)</span> is <em>monotone</em> if for all views <span class="math inline">\(\mathcal{V}_1 \subseteq \mathcal{V}_2 \subseteq \mathcal{B}, f_{\mathcal{V}_2}(i) \in \mathcal{V}_1\)</span> implies <span class="math inline">\(f_{\mathcal{V}_1}(i) = f_{\mathcal{V}_2}(i)\)</span>.</li><li>A ranged hash family is <em>monotone</em> if every ranged hash function in it is.</li></ul><p>单调性保证了：如果新增了一个节点，只会有将之前的数据迁移到新节点的操作，而不会有旧节点之间互相迁移的操作。</p></li><li><p>Spread</p><p>Let <span class="math inline">\(\mathcal{V}_1 \dots \mathcal{V}_{|V|}\)</span> be a set of views, altogether containing <span class="math inline">\(C\)</span> distinct buckets and each individually containing at least <span class="math inline">\(C/t\)</span> buckets.</p><ul><li>For a ranged hash function and a particular item <span class="math inline">\(i\)</span>, the <em>spread</em> <span class="math inline">\(\sigma(i)\)</span> = <span class="math inline">\(|\{f_{\mathcal{V}_j}(i)\}^{|V|}_{j=1}|\)</span>.</li><li>The <em>spread</em> of a hash function <span class="math inline">\(\sigma(f)\)</span> is the maximum spread of an item.</li><li>The <em>spread</em> of a hash family is <span class="math inline">\(\sigma\)</span> if with high probability, the spread of a random hash function from the family is <span class="math inline">\(\sigma\)</span>.</li></ul><p>Spread 大致意思是指，一个 item 在不同的 view 下会被分配到的 bucket 所组成集合的大小，其越小说明在节点数量发生变化时，需要做的数据迁移操作越少。</p></li><li><p>Load</p><p>Define a set of <span class="math inline">\(|V|\)</span> views as before.</p><ul><li>For a ranged hash function <span class="math inline">\(f\)</span> and bucket <span class="math inline">\(b\)</span>, the <em>load</em> <span class="math inline">\(\lambda(b) = |\cup_{\mathcal{V}}f^{-1}_{\mathcal{V}}(b)|\)</span>. (Note that <span class="math inline">\(f^{-1}_{\mathcal{V}}(b)\)</span>) is the set of items assigned to bucket <span class="math inline">\(b\)</span> in view <span class="math inline">\(\mathcal{V}\)</span>)</li><li>The <em>load</em> of a hash function <span class="math inline">\(\lambda(f)\)</span> is the maximum load of a bucket.</li><li>The <em>load</em> of a hash family is <span class="math inline">\(\lambda\)</span> if with high probability, a randomly chosen hash function has load <span class="math inline">\(\lambda\)</span>.</li></ul><p>Load 大致意思是指， 一个 bucket 在不同的 view 下所包含的 items 集合的并集的大小，其具有上界保证了在不同的节点总数情况下，不会出现单个节点需要储存过多的数据的现象。</p></li></ol><h2 id="构造一致性哈希函数">构造一致性哈希函数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希的 first paper (maybe) 阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过四级没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E5%9B%9B%E7%BA%A7%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="一致性哈希" scheme="https://yz1509.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码之 sds</title>
    <link href="https://yz1509.github.io//posts/18e84d53/"/>
    <id>https://yz1509.github.io//posts/18e84d53/</id>
    <published>2019-10-12T12:10:31.000Z</published>
    <updated>2020-03-09T08:28:46.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Redis 简单字符串的源码读后感 (超500字)。</p><a id="more"></a><hr><p>源码文件 <code>/src/sds.h</code> &amp; <code>sdsalloc.h</code> &amp; <code>/src/sds.c</code></p><h1 id="sds-数据结构">sds 数据结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------- sds 的头部结构 -------------------------------</span></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出来，sds 本质还是 C 风格字符串，但是由于不需用 <code>\0</code> 作为结尾标志，所以 sds 是二进制安全的，但是为了兼容 C 风格字符串， sds 也以终止字符 <code>\0</code> 结尾，所以 sds 可以直接重用一部分 C 字符串函数库里面的函数。关于 sds 的头部结构，作者定义了四种不同类型的 sdshdr 供程序使用，区别只是存储 <code>len</code> 和 <code>alloc</code> 使用的整型长度不同，目的应该为了<a href="https://github.com/antirez/redis/pull/2509">节省内存</a>。</p><p><code>sdshdr5</code> 会在 <code>key</code> 的长度小于 32 时使用，详细可了解 <a href="https://github.com/antirez/redis/blob/7ca81170c7e98a4f70f203dd1afe027efe3aed89/src/db.c"><code>dbAdd</code></a> -&gt; <code>sdsdup</code> -&gt; <code>sdsnewlen</code> 的代码。</p><p>四种不同类型(除 <code>sdshdr5</code>)的 sdshdr 结构一致，主要包括以下几个部分：</p><ul><li><code>len</code>：存储 <code>buf</code> 数组的长度，不包括终止字符 <code>\0</code></li><li><code>alloc</code>：<code>buf</code> 数组的容量大小</li><li><code>flags</code>：sdshdr 的类型</li></ul><p><em>Tips:</em> <code>__attribute__ ((__packed__))</code> 的作用就是告诉编译器取消结构体在编译过程中的优化对齐，以紧凑模式来分配内存。按照实际占用字节数进行对齐，是 GCC 特有的语法。这个功能是跟操作系统没关系，跟编译器有关。</p><p><em>Tips:</em> 在上述结构体定义中，字符数组 <code>buf</code> 的长度为 0，不占用额外的内存空间，<code>buf</code> 实际指向的是结构体之后的内存空间，如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个 <code>buf</code> 的内容，也可用此类特性实现 C 语言变长数组。</p><h1 id="辅助函数">辅助函数</h1><p>重申：长度 ≠ 容量</p><h2 id="获取字符数组-buf-的长度-len">获取字符数组 <code>buf</code> 的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同 sdshdr 的类型码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="comment">// 用于 sdshdr 的位运算常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="comment">// 得到 sdshdr 的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 flags 的值</span></span><br><span class="line">    <span class="comment">// 由于结构体定义使用紧凑模式，所以 s 所指的地址紧接在存储 flags 的地址之后</span></span><br><span class="line">    <span class="comment">// 从而 s[-1] 的内容即为 flags，注意不要和 Python 中的 -1 混淆</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Tips:</em> 宏定义中的 <code>##</code> 为符号连接操作符。</p><h2 id="获取-buf-数组中的剩余可用空间大小">获取 <code>buf</code> 数组中的剩余可用空间大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用 <code>SDS_HDR_VAR</code> 而不使用 <code>return SDS_HDR(T,s)-&gt;alloc - SDS_HDR(T,s)-&gt;len;</code> 的原因可能如下：</p><ul><li>为了代码好看</li><li>可以少计算一次</li></ul><p>而 <code>SDS_HDR_VAR</code> 的宏定义最后的分号其实可以去掉，<a href="https://wiki.sei.cmu.edu/confluence/display/c/PRE11-C.+Do+not+conclude+macro+definitions+with+a+semicolon">详情请见</a></p><h2 id="设置-buf-数组的长度-len">设置 <code>buf</code> 数组的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取存储 flags 的地址</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 低 3 位存 type，高 5 位存长度</span></span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加-buf-数组的长度-len">增加 <code>buf</code> 数组的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newlen = len + inc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, <span class="keyword">size_t</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> newlen = SDS_TYPE_5_LEN(flags)+inc;</span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有获取/设置 <code>buf</code> 数组的容量 <code>alloc</code> 的函数，函数逻辑一致便不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="comment">// 设置 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span>;</span><br></pre></td></tr></table></figure><p><em>Tips</em> 关于 <code>static inline</code></p><ul><li><code>inline</code> 的作用仅仅是建议编译器做内联开展处理，而不是强制。内联函数（inline）可以减少 CPU 的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数。通常，程序执行时，处理器从内存中读取代码执行。当程序中调用一个函数时，程序跳到存储器中保存函数的位置，开始读取代码执行，执行完后再返回。为了提高速度，C 语言定义了 <code>inline</code> 函数，告诉编译器把函数代码在编译时直接拷贝到程序中，这样就不用执行时另外读取函数代码。</li><li><code>static</code> 告诉编译器其他文件看不到这个函数，因此该函数只能在当前文件中被调用。</li></ul><h1 id="sds-基本操作">sds 基本操作</h1><h2 id="构造函数">构造函数</h2><ol type="1"><li><p><code>sdsnewlen</code></p><p>根据指针 <code>init</code> 和长度 <code>initlen</code> 构造一个 sds。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;   <span class="comment">// 头部指针</span></span><br><span class="line">    sds s;      <span class="comment">// 存储返回值</span></span><br><span class="line">    <span class="comment">/* static inline char sdsReqType(size_t string_size)</span></span><br><span class="line"><span class="comment">    * 根据字符串长度选择合适的 sdshdr 类型 */</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">    * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">/* static inline int sdsHdrSize(char type)</span></span><br><span class="line"><span class="comment">    * 根据 type 返回 sdshdr 的存储空间大小 */</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* #define s_malloc zmalloc</span></span><br><span class="line"><span class="comment">    * + 1 是为了存储 \0 */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* const char *SDS_NOINIT = &quot;SDS_NOINIT&quot;;</span></span><br><span class="line"><span class="comment">    * If SDS_NOINIT is used, the buffer is left uninitialized; */</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 填充 sdshdr 中的 len、alloc、flags</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);   <span class="comment">// 填充 buf 字符数组的内容</span></span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 填充终止字符 \0</span></span><br><span class="line">    <span class="keyword">return</span> s;   <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现生成的 sds 中有：<span class="math inline">\(len = alloc = initlen\)</span></p></li><li><p><code>sdsempty</code></p><p>构造一个空的 sds，可以看出 <code>buf</code> 数组长度即使为 0，该 sds 也包含 <code>\0</code>。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsnew</code></p><p>根据一个 C 风格字符串构造一个 sds 。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsdup</code></p><p>复制一个 sds 。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfromlonglong</code></p><p>将一个 <code>long long</code> 类型转换为 sds，该操作比直接调用 <code>sdscatprintf(sdsempty(),"%lld\n", value);</code> 高效得多。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// #define SDS_LLSTR_SIZE 21</span></span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">    <span class="comment">/* int sdsll2str(char *s, long long value)</span></span><br><span class="line"><span class="comment">    * The function returns the length of the null-terminated string </span></span><br><span class="line"><span class="comment">            representation stored at &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment">    * &#x27;s&#x27; must point to a string with room for at least </span></span><br><span class="line"><span class="comment">            SDS_LLSTR_SIZE bytes. */</span></span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="析构函数请不要沉迷-c">析构函数（请不要沉迷 C++</h2><ol type="1"><li><p><code>sdsclear</code> —— 虚假的析构函数</p><p>将 <code>buf</code> 数组长度设置为 0，但是可以发现并未调用 <code>free</code>，而是将其设置为空闲空间。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfree</code> —— 真实的析构函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* #define s_free zfree</span></span><br><span class="line"><span class="comment">    * (char*)s-sdsHdrSize(s[-1]) —— sds 头部的起始地址 */</span></span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>])); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="动态调整函数">动态调整函数</h2><ol type="1"><li><p><code>sdsMakeRoomFor</code> —— 扩容</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;   <span class="comment">// 旧、新的头指针</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 剩余可用空间大小</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen; </span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen; <span class="comment">// 存储新的头部长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);    <span class="comment">// buf 数组目前长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">// 旧的头指针</span></span><br><span class="line">    newlen = (len+addlen);  <span class="comment">// buf 数组将来长度</span></span><br><span class="line">    <span class="comment">/* #define SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class="line"><span class="comment">    * 扩容策略：如果 buf 数组将来长度小于 1 M，按两倍给你扩容，大气</span></span><br><span class="line"><span class="comment">    *          如果 buf 数组将来长度不小于 1 M，比要求多给你扩 1 M，精打细算 */</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newtype (NT 新人类，大雾)</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">    * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">    * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);  <span class="comment">// 新的头部长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;    <span class="comment">// 不需要更改头部的 len 和 flags，直接扩充 buf 数组的容量</span></span><br><span class="line">        <span class="comment">// #define s_realloc zrealloc</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">        * and can&#x27;t use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 申请新的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// len + 1，\0 也被复制</span></span><br><span class="line">        s_free(sh); <span class="comment">// 释放旧空间</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;    <span class="comment">// 更新 buf 数组首地址</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;   <span class="comment">// 更新 flags</span></span><br><span class="line">        sdssetlen(s, len);  <span class="comment">// 设置 len，大小没变</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen); <span class="comment">// 更新 alloc</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现该函数仅在当前剩余可用空间不足时进行扩容，采取的扩容策略类似 <code>vector</code>，可以在尽可能不浪费内存空间的基础上减少扩容操作的次数。当然扩容并不会改变 <code>buf</code> 数组的长度 <code>len</code>。</p></li><li><p><code>sdsRemoveFreeSpace</code> —— 回收空闲空间</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">    * fit this string. */</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">    * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">    * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">    * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的基本流程和扩容操作类似，可以看出仅仅在旧的头部结构不为 <code>sdshdr8</code> 且新的头部结构为 <code>sdshdr8</code> 时，才会重新申请新的内存空间，不然只是在旧的 sds 基础上调用 <code>zrealloc</code> 调整 <code>buf</code> 数组的容量，使得 <span class="math inline">\(alloc = len\)</span> 成立。</p><p>注意调用 <code>sdsRemoveFreeSpace</code> 成功返回后，原指针可能会失效，请使用返回的新指针。</p></li><li><p><code>sdsIncrLen</code> —— 调整长度</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span> </span>&#123;  <span class="comment">// typedef long long ssize_t</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">// fp 指向存储 flags 的地址</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> oldlen = SDS_TYPE_5_LEN(flags);</span><br><span class="line">            <span class="comment">/* 增长时需确保剩余可用空间大小充足</span></span><br><span class="line"><span class="comment">            * 缩短时需确保减少量不得超过现有长度 */</span></span><br><span class="line">            assert((incr &gt; <span class="number">0</span> &amp;&amp; oldlen+incr &lt; <span class="number">32</span>) || (incr &lt; <span class="number">0</span> &amp;&amp; oldlen &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            *fp = SDS_TYPE_5 | ((oldlen+incr) &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            len = oldlen+incr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: len = <span class="number">0</span>; <span class="comment">/* Just to avoid compilation warnings. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 设置终止字符 &#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，变量 <code>incr</code> 可正可负，所以在满足条件的基础上长度可增可减。</p></li></ol><h2 id="append-操作">Append 操作</h2><ol type="1"><li><p><code>sdsgrowzero</code></p><p>将 <code>buf</code> 的数组长度增长到给定的 <code>len</code>，如果 <span class="math inline">\(len &lt; currentLen\)</span>，则什么都不做。新增的字节部分，每一位都置为 0。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn&#x27;t contain garbage */</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatlen</code></p><p>将二进制安全的字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><ul><li><code>t</code>：附加字符串首位地址</li><li><code>len</code>：附加字符串长度</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscat</code></p><p>将 C 风格字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatsds</code></p><p>拼接两个 sds，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatvprintf</code></p><p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>], *buf = staticbuf, *t;</span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try to start using a static buffer for speed.</span></span><br><span class="line"><span class="comment">    * If not possible we revert to heap allocation. */</span></span><br><span class="line">    <span class="keyword">if</span> (buflen &gt; <span class="keyword">sizeof</span>(staticbuf)) &#123;</span><br><span class="line">        buf = s_malloc(buflen);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try with buffers two times bigger every time we fail to</span></span><br><span class="line"><span class="comment">    * fit the string in the current buffer size. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置哨兵，测试格式化字符串是否已全部写入 buf 中</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">/* void va_copy(va_list dest, va_list src);</span></span><br><span class="line"><span class="comment">        * The va_copy macro copies src to dest. */</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">/* int vsnprintf( char *restrict buffer, size_t bufsz, </span></span><br><span class="line"><span class="comment">                const char *restrict format, va_list vlist );</span></span><br><span class="line"><span class="comment">        * writes the results to a character string buffer. At most buflen - 1 </span></span><br><span class="line"><span class="comment">                characters are written </span></span><br><span class="line"><span class="comment">        * The resulting character string will be terminated with a </span></span><br><span class="line"><span class="comment">                null character, unless buflen is zero. */</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">/* void va_end(va_list ap);</span></span><br><span class="line"><span class="comment">        * The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy */</span></span><br><span class="line">        va_end(cpy);</span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;    <span class="comment">// 当前 buf 不够长！</span></span><br><span class="line">            <span class="keyword">if</span> (buf != staticbuf) s_free(buf);  </span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            buf = s_malloc(buflen);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 格式化字符串已全部写入 buf</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally concat the obtained string to the SDS string and return it. */</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    <span class="keyword">if</span> (buf != staticbuf) s_free(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于不知晓格式化字符串的长度，所以我们需要使用一个 <code>while</code> 循环来测试当前分配的 <code>buf</code> 字符数组的容量是否可以容纳该格式化字符串，每次失败时，我们将 <code>buf</code> 的容量翻倍。</p></li><li><p><code>sdscatprintf</code></p><p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    <span class="comment">/* void va_start(va_list ap, parmN);</span></span><br><span class="line"><span class="comment">    * The va_start macro enables access to the variable arguments following </span></span><br><span class="line"><span class="comment">            the named argument parmN. */</span></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatfmt</code></p><p>将格式化字符串拼接到 sds 之后，但是比 <code>sdscatprintf</code> 更快，但是其支持以下几种格式化字符串：</p><ul><li><code>%s</code> - C String</li><li><code>%S</code> - SDS string</li><li><code>%i</code> - signed int</li><li><code>%I</code> - 64 bit signed integer (long long, int64_t)</li><li><code>%u</code> - unsigned int</li><li><code>%U</code> - 64 bit unsigned integer (unsigned long long, uint64_t)</li><li><code>%%</code> - Verbatim "%" character.</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatrepr</code></p><p>将无法打印显式字符的字符数组的转义形式 (eg, "..." or "&lt;hex-number&gt;") 拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="拷贝操作">拷贝操作</h2><ol type="1"><li><p><code>sdscpylen</code></p><p>丢弃 sds 字符数组中的原内容，将长为 <code>len</code> 的字符串拷贝至 sds 的 <code>buf</code> 中。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdsalloc(s) &lt; len) &#123;    <span class="comment">// 容量不足，扩容</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sdslen(s));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscpy</code></p><p>丢弃 sds 字符数组中的原内容，将 C 风格字符串拷贝至 sds 的 <code>buf</code> 中。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="修剪操作">修剪操作</h2><ol type="1"><li><p><code>sdstrim</code></p><p>从 sds 两端开始遍历，出现在 C 风格字符串 cset 中的字符将会被删除。注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;     <span class="comment">// 指向第一个字符</span></span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;   <span class="comment">// 指向终止字符 `\0` 前一字符</span></span><br><span class="line">    <span class="comment">/* char *strchr(const char *str, int ch);</span></span><br><span class="line"><span class="comment">    * Finds the first occurrence of ch (after conversion to char as if </span></span><br><span class="line"><span class="comment">        by (char)ch) in the null-terminated byte string pointed to by str </span></span><br><span class="line"><span class="comment">        (each character interpreted as unsigned char). </span></span><br><span class="line"><span class="comment">    * 从前往后遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 +1 */</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="comment">/* 前一步遍历的终止条件不是越界时有 ep &gt; sp</span></span><br><span class="line"><span class="comment">    * 从后往前遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 -1 */</span></span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    <span class="comment">// 计算修剪后的字符串长度</span></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* void* memmove( void* dest, const void* src, size_t count );</span></span><br><span class="line"><span class="comment">    * Copies count characters from the object pointed to by src to the object </span></span><br><span class="line"><span class="comment">        pointed to by dest*/</span></span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p><p>虽然作者提示原指针可能会失效，但是在函数中可以发现返回的就是原指针值，表示疑惑。</p></li><li><p><code>sdsrange</code></p><p>依据起始和结束索引下标修剪 sds 字符串，注意：</p><ul><li><code>start</code> 和 <code>end</code> 可以为负数，类似数组的下标索引</li><li>结果子串的范围为闭区间 <span class="math inline">\([start, end]\)</span></li><li>该操作是就地进行的</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引下标</span></span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;   <span class="comment">// 绝对值大于字符串长度的负数索引值置为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算子串长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">ssize_t</span>)len) &#123;    <span class="comment">// 起始索引值大于等于字符串长度，子串为空</span></span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">ssize_t</span>)len) &#123; <span class="comment">// 结束索引值大于等于字符串长度，置为 len-1</span></span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 因 end 更改，故更新子串长度</span></span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(s, s+start, newlen);</span><br><span class="line">    s[newlen] = <span class="number">0</span>;  <span class="comment">// 等价于 s[newlen] = &#x27;\0&#x27;;</span></span><br><span class="line">    sdssetlen(s,newlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同上，可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p></li></ol><h2 id="split-操作">split 操作</h2><ol type="1"><li><p><code>sdssplitlen</code></p><p>使用长为 <code>seplen</code> 的二进制安全字符串 <code>sep</code> 作为分隔符，将长为 <code>len</code> 的二进制安全字符串 <code>s</code> 分割成 <code>count</code> 个 sds 字符串。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* elements 存放当前 sds 字符串的个数</span></span><br><span class="line"><span class="comment">    * slots 存放当前已分配内存的 sds 指针数组 tokens 的大小 */</span></span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">0</span>, j;</span><br><span class="line">    sds *tokens;    <span class="comment">// sds 指针数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tokens = s_malloc(<span class="keyword">sizeof</span>(sds)*slots);   <span class="comment">// 先搞五个试试</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符串匹配过程</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;     <span class="comment">// 扩容采取倍增策略</span></span><br><span class="line">            newtokens = s_realloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator </span></span><br><span class="line"><span class="comment">        * int memcmp( const void* lhs, const void* rhs, size_t count );</span></span><br><span class="line"><span class="comment">        * Compares the first count characters of the objects pointed to by lhs and rhs*/</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        s_free(tokens);</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfreesplitres</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the result returned by sdssplitlen(), or do nothing if &#x27;tokens&#x27; is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    s_free(tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsplitargs</code></p><ul><li>Split a line into arguments, where every argument can be in the following programming-language REPL-alike form: <code>foo bar "newline are supported\n" and "\xff\x00otherstuff"</code></li><li>The number of arguments is stored into *argc, and an array of sds is returned.</li><li>The caller should free the resulting array of sds strings with sdsfreesplitres().</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span></span><br></pre></td></tr></table></figure></p><p>偷个懒，用到时再看hhhhh</p></li></ol><h2 id="其他函数">其他函数</h2><ol type="1"><li><p><code>sdsupdatelen</code></p><p>更新 sds 的长度 <code>len</code>，由于是调用 <code>strlen</code>，故只统计到终止字符 <code>\0</code>（不包括 <code>\0</code>）</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsAllocSize</code></p><p>返回分配内存空间的大小，包括：</p><ul><li>头部结构体的大小 <code>sdsHdrSize</code></li><li><code>buf</code> 数组容量 <code>alloc</code></li><li>终止字符 <code>\0</code> 的长度 1</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsAllocSize</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> alloc = sdsalloc(s);</span><br><span class="line">    <span class="keyword">return</span> sdsHdrSize(s[<span class="number">-1</span>])+alloc+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsAllocPtr</code></p><p>返回 sds 头部起始地址。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) (s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdstolower</code></p><p>转换为小写</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdstoupper</code></p><p>转换为大写</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscmp</code></p><p>使用 <code>memcmp</code> 实现两个 sds 的比较操作</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1&gt;l2? <span class="number">1</span>: (l1&lt;l2? <span class="number">-1</span>: <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsmapchars</code></p><p>遍历 sds 字符串，将在字符串 <code>from</code> 中出现的字符替换成 <code>to</code> 中对应位置的字符，<code>setlen</code> 为字符串 <code>from</code> 和 <code>to</code> 的长度。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> j, i, l = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setlen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == from[i]) &#123;</span><br><span class="line">                s[j] = to[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsjoin</code></p><p>使用 C 风格字符串 <code>sep</code> 作为分隔符，将 C 风格字符串数组拼接为一个 sds。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsjoinsds</code></p><p>类似于 <code>sdsjoin</code>，将 sds 字符串数组拼接为一个 sds。值得注意的是，使用的字符串分隔符是二进制安全的，而不是 C 风格字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscatsds(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscatlen(join,sep,seplen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 简单字符串的源码读后感 (超500字)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码之 adlist</title>
    <link href="https://yz1509.github.io//posts/28a59907/"/>
    <id>https://yz1509.github.io//posts/28a59907/</id>
    <published>2019-10-12T12:08:45.000Z</published>
    <updated>2019-10-31T02:13:03.133Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Redis 底层链表结构相关源码阅读笔记。</p><a id="more"></a><hr><p>源码文件 <code>/src/adlist.h</code> &amp; <code>/src/adlist.c</code></p><h1 id="adlist-数据结构">adlist 数据结构</h1><p>adlist 其实是一个双向链表，我们首先介绍其链表节点、链表迭代器和链表的数据结构。</p><h2 id="链表节点">链表节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向前一节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向后一节点</span></span><br><span class="line">    <span class="keyword">void</span> *value;            <span class="comment">// 指向当前节点的值</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><h2 id="链表迭代器">链表迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;     <span class="comment">// 迭代器当前所指节点，为什么不叫 now ？       </span></span><br><span class="line">    <span class="keyword">int</span> direction;      <span class="comment">// 迭代访问的方向    </span></span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0     <span class="comment">// 从首到尾</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1     <span class="comment">// 从尾到首</span></span></span><br></pre></td></tr></table></figure><h2 id="链表">链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;     <span class="comment">// 首节点</span></span><br><span class="line">    listNode *tail;     <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 用户可自定义的节点值匹配函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;  <span class="comment">// 记录链表长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h1 id="辅助函数">辅助函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><h1 id="adlist-基本操作">adlist 基本操作</h1><h2 id="构造函数">构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span>  <span class="comment">// 指向一个链表的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 首尾节点默认为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值： * 分配内存执行失败时，返回 <code>NULL</code> * 执行成功时返回指向已构造的空链表的指针。</p><h2 id="析构函数">析构函数</h2><ol type="1"><li><p><code>lsitEpmty</code> —— 不健全的析构函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;   <span class="comment">// 保存下一节点的指针</span></span><br><span class="line">        <span class="comment">// 如果 list 中的 free 函数已设置，调用其，释放节点值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        <span class="comment">// 释放当前节点的指针</span></span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 将首尾节点置为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，<code>listEmpty</code> 函数释放了链表中的每个节点，但是并未释放指向该链表的指针本身。</p></li><li><p><code>listRelease</code> —— 析构函数完全体</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);    <span class="comment">// 释放指向该链表的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="添加">添加</h2><ol type="1"><li><p><code>listAddNodeHead</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;  <span class="comment">// 首节点的 prev 指针指向 NULL</span></span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，该函数的作用是，根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的首部，其返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul></li><li><p><code>listAddNodeTail</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 尾节点的 next 指针指向 NULL</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的尾部，其返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul></li><li><p><code>listInsertNode</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;    <span class="comment">// atfer 非 0，新节点插入在指定节点之后</span></span><br><span class="line">        node-&gt;prev = old_node;  </span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123; <span class="comment">// 指定节点为尾节点     </span></span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;        <span class="comment">// 更新链表的尾节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// after 为 0，新节点插入在指定节点之前</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;  <span class="comment">// 指定节点为首节点</span></span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;         <span class="comment">// 更新链表的首节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;    <span class="comment">// 更新插入节点的前一节点的 next 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;    <span class="comment">// 更新插入节点的后一节点的 prev 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，随后将该节点插入到链表的指定位置：</p><ul><li><span class="math inline">\(after \ne 0\)</span>，插入到 <code>old_node</code> 之后</li><li><span class="math inline">\(after = 0\)</span>，插入到 <code>old_node</code> 之前</li></ul><p>函数的返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul><p><em>Tips:</em> 插入节点时，可以先更新插入节点的指针，然后再更新插入节点相邻节点的指针。</p></li></ol><h2 id="删除">删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;  </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;    <span class="comment">// 删除节点为首节点，更新链表首节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;    <span class="comment">// 删除节点为尾节点，更新链表尾节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);    <span class="comment">// 释放该节点所占内存空间</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：删除给定节点，并释放其所占内存空间。</p><h2 id="迭代器相关">迭代器相关</h2><ol type="1"><li><p><code>listGetIterator</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD) </span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;    <span class="comment">// 从首到尾      </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;    <span class="comment">// 从尾到首</span></span><br><span class="line">    iter-&gt;direction = direction;    <span class="comment">// 存储遍历方向</span></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的返回值：</p><ul><li>申请内存失败时，返回 <code>NULL</code></li><li>申请内存成功时，根据方向参数初始化迭代器，并返回其指针 <code>iter</code></li><li><code>direction == AL_START_HEAD</code> 时，返回正序迭代器</li><li><code>direction == AL_START_TAIL</code> 时，返回逆序迭代器</li></ul></li><li><p><code>listReleaseIterator</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：释放迭代器所占内存。</p></li><li><p><code>listRewind</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：将给定迭代器重置为正序迭代器。</p></li><li><p><code>listRewindTail</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：将给定迭代器重置为逆序迭代器。</p></li><li><p><code>listNext</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next; <span class="comment">// 迭代器当前所指节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：如果迭代器当前所指节点非空，则根据方向参数更新迭代器的 <code>next</code> 指针，最后返回迭代器当前所指节点。</p></li></ol><h2 id="复制">复制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)  <span class="comment">// 构造一个空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;      <span class="comment">// 复制自定义值复制函数</span></span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;    <span class="comment">// 复制自定义值释放函数</span></span><br><span class="line">    copy-&gt;match = orig-&gt;match;  <span class="comment">// 复制自定义值匹配函数</span></span><br><span class="line">    listRewind(orig, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;   <span class="comment">// 遍历原链表</span></span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;    <span class="comment">// 值复制函数已给定</span></span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;    <span class="comment">// 值复制失败</span></span><br><span class="line">                listRelease(copy);  <span class="comment">// 释放复制链表</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>      <span class="comment">// 未给定值复制函数</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123; <span class="comment">// 添加新节点到尾部</span></span><br><span class="line">            listRelease(copy);  <span class="comment">// 添加节点失败，释放链表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用为：完全复制给定的链表 <code>orig</code>，函数的返回值为： * 执行失败时，返回 <code>NULL</code> * 执行成功时，返回复制链表指针 <code>copy</code></p><p><strong>注意</strong>：不论该函数是否执行成功，原链表都不会被修改。</p><h2 id="查找">查找</h2><ol type="1"><li><p><code>listSearchKey</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;  <span class="comment">// 值匹配函数已指定</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定值匹配函数</span></span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 未找到，返回 NUll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针，寻找值相等的链表节点，该函数的返回值为：</p><ul><li>成功找到时，返回第一个值相等的链表节点指针（正序）</li><li>未找到时，返回 <code>NULL</code></li></ul></li><li><p><code>listIndex</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的索引值，返回相应的链表节点</p><ul><li>从 0 开始计算索引</li><li>支持负数索引</li><li>当索引值 <code>index</code> <span class="math inline">\(\notin[-len, len - 1]\)</span> 时，返回 <code>NULL</code></li></ul></li></ol><h2 id="旋转">旋转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev; </span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：删除链表原尾节点，将原尾节点插入到首部，作为新的首节点。</p><h2 id="拼接">拼接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head)    <span class="comment">// 链表 o 不为空</span></span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail)    <span class="comment">// 链表 l 不为空</span></span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail;</span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. */</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：将链表 <code>o</code> 拼接到链表 <code>l</code> 之后，随后将链表 <code>o</code> 置为空链表，并未释放链表指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 底层链表结构相关源码阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
