<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HTT</title>
  
  <subtitle>ふわふわ時間</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yz1509.github.io/"/>
  <updated>2019-10-30T10:10:21.763Z</updated>
  <id>https://yz1509.github.io/</id>
  
  <author>
    <name>KyoAni</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis Streams</title>
    <link href="https://yz1509.github.io//posts/76da14fe/"/>
    <id>https://yz1509.github.io//posts/76da14fe/</id>
    <published>2019-10-16T09:50:09.000Z</published>
    <updated>2019-10-30T10:10:21.763Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 Redis Streams 数据结构及部分操作，并不涉及源码部分。</p><a id="more"></a><hr><p>整理自 <a href="http://antirez.com/news/114" target="_blank" rel="noopener">Streams: a new general purpose data structure in Redis</a>、<a href="http://antirez.com/news/116" target="_blank" rel="noopener">An update on Redis Streams development</a>、<a href="http://antirez.com/news/128" target="_blank" rel="noopener">Redis streams as a pure data structure</a> 和 <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">Introduction to Redis Streams</a> 。</p><h1 id="什么是-redis-streams">什么是 Redis Streams</h1><p>本质上是一个抽象日志：</p><ul><li>日志中的每条记录是结构化、可扩展的 <code>&lt;field, value&gt;</code> 对</li><li>支持范围查询和指定读取</li><li>每条记录在日志中有唯一标识，标识中包含了单调递增的时间戳信息</li><li>日志可以根据需要自动清理历史记录</li><li>日志保存在内存中，但是也支持持久化</li></ul><p>和其他可模拟消息队列的数据类型 (List, Pub/Sub, Zset) 对比：</p><table><colgroup><col style="width: 60%"><col style="width: 39%"></colgroup><thead><tr class="header"><th>List, Pub/Sub, Zset</th><th>Redis Streams</th></tr></thead><tbody><tr class="odd"><td>List 不能从中间获取成员，<span class="math inline">\(O(N)\)</span></td><td>可以从中间获取成员，<span class="math inline">\(O(logN)\)</span></td></tr><tr class="even"><td>no fan-out is possible, blocking operations on list serve a single element to a single client</td><td>可以多个 clients 使用 XREAD blocking for new message</td></tr><tr class="odd"><td>List 中没有标识符的概念</td><td>每条 msg 都有一个唯一的 id</td></tr><tr class="even"><td>Pub/Sub 无法保留历史消息，只能获取连接之后的消息，不支持范围查询</td><td>可以保存在 AOF 和 RDB 中</td></tr><tr class="odd"><td>Pub/Sub 没有 consumer group 的概念</td><td>有 consumer group，更贴近真实的业务场景</td></tr><tr class="even"><td>Pub/Sub 的性能和订阅某个频道的 client 数量正相关</td><td>不存在</td></tr><tr class="odd"><td>Zset 不允许添加重复成员，不支持成员淘汰和 block 新消息操作，内存开销大</td><td>允许，支持按时间线来淘汰历史数据，支持 block 操作，基于 redix tree 和 listpack，内存开销低</td></tr><tr class="even"><td>Zset 支持删除任意元素</td><td>不支持从中间删除元素 (log属性)，more compact and memory efficient</td></tr></tbody></table><h1 id="redis-streams-结构">Redis Streams 结构</h1><figure class="highlight plain"><figcaption><span>&#123;cmd</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">| key | Entry1 |--| Entry2 |--| ...... |--| EntryN |</span><br><span class="line">+-----+--------+  +--------+  +--------+  +--------+</span><br><span class="line">      :        :       </span><br><span class="line">+-----+        +-------------------------------------------+</span><br><span class="line">|                                                          |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| ID | field1 | value1 | field2 | value3 | ...... | ...... |</span><br><span class="line">+----+--------+--------+--------+--------+--------+--------+</span><br><span class="line">:    : </span><br><span class="line">|    +-------------------------------+ </span><br><span class="line">|                                    |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| millisecond time | sequence number |</span><br><span class="line">+------------------+-----------------+</span><br></pre></td></tr></table></figure><ul><li>在每个 streams 中含有多个 entry(message)</li><li>每个 entry 有一唯一的 ID，并且可包含多个 <code>&lt;filed, value&gt;</code> 对<ul><li>添加连续的 entry，如果使用相同的 field name 可以节省内存</li></ul></li><li>ID 由 millisecond time(64bit) 和 sequence number(64bit) 两部分组成<ul><li>其中，millisecond time 取当前时间戳和上一条插入 streams 的 entry 的时间戳之间的较大值，保证单调性</li></ul></li></ul><h1 id="redis-streams-api">Redis Streams API</h1><h2 id="xadd">XADD</h2><p><code>XADD key [MAXLEN [~] number] ID field string [field string ...]</code></p><p>Appends a new entry into the specified streams.</p><ul><li>ID 为 <code>*</code> 表示让 Redis 自动生成 ID</li><li>如果指定消息 ID，为了维持单调递增性，后面指令的 ID 必须大于之前指令的 ID</li><li>可以指定 streams 的 <code>MAXLEN</code>，此时 streams 类似于一个固定大小的队列</li><li>添加 <code>~</code> 表示并不严格要求 <code>MAXLEN=number</code></li></ul><h2 id="xrange-xrevrange">XRANGE / XREVRANGE</h2><p><code>XRANGE key start end [COUNT count]</code></p><ul><li>返回结果包含 start ID 和 end ID，即闭区间</li><li><code>-</code> 和 <code>+</code> 分别表示最小和最大 ID</li><li>start ID 和 end ID 可以省略 sequenceNumber 部分，此时 start ID 默认 sequenceNumber = 0，而 end ID 默认 sequenceNumber 为最大值</li><li>可以添加 <code>COUNT</code> 参数，实现类似 <code>scan</code> 操作</li></ul><p><code>XREVRANGE key end start [COUNT count]</code></p><ul><li>逆序返回结果，使用方法类似 <code>XRANGE</code></li></ul><h2 id="xread-blocking-for-new-data">XREAD: blocking for new data</h2><p><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></p><ul><li>ID为 <code>$</code> 表示指定 ID 为流中目前已存的最大 ID</li><li>BLOCK 超时时间单位为 ms，超时时间为 0 时表示不会超时</li><li>当有多个 client BLOCK 等待新 msg 时，排队方式为 FIFO</li></ul><h2 id="xlen">XLEN</h2><p><code>XLEN key</code></p><p>查看指定流中的 entry 个数，one ID one entry.</p><h1 id="consumer-groups">Consumer groups</h1><p>一个 consumer group 就像一个 pseudo consumer 一样从 streams 中获取数据，它有如下特点：</p><ul><li>同一消息不可能传递给多个 consumer</li><li>在 consumer group 中由 consumer(client) 自身提供 name 来进行区分</li><li>每个 consumer group 保存了目前尚未分发的第一条消息的 ID (即，偏移量)，据此，当 consumer 请求消费时， consumer group 保证不会将先前已分发的消息发送给该 consumer</li><li>消费消息需要显式地 ACK 机制，只有当该消息确认被处理，才会从 consumer group 的消息队列中删除</li><li>Consumer group 记录当前所有的未决消息的信息，因此保证了 consumer 在中断重连后只能重新获取之前自身未 ACK 的消息</li></ul><p>一个 consumer group 状态的示例如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">| consumer_group_name: mygroup             |</span><br><span class="line">| consumer_group_stream: somekey           |</span><br><span class="line">| last_delivered_id: <span class="number">1292309234234</span><span class="number">-92</span>      |     </span><br><span class="line">|                                          |                                   </span><br><span class="line">| consumers:                               |</span><br><span class="line">|     <span class="string">"consumer-1"</span> <span class="keyword">with</span> pending messages   |</span><br><span class="line">|        <span class="number">1292309234234</span><span class="number">-4</span>                   |</span><br><span class="line">|        <span class="number">1292309234232</span><span class="number">-8</span>                   | </span><br><span class="line">|     <span class="string">"consumer-42"</span> <span class="keyword">with</span> pending messages  |</span><br><span class="line">|       ... (<span class="keyword">and</span> so forth)                 |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="xgroup">XGROUP</h2><p>创建、销毁和管理 consumer group</p><ul><li><code>XGROUP CREATE key groupname id-or-$</code><ul><li>目前尚不支持从一个未存在的 streams 上创建 consumer group</li></ul></li><li><code>XGROUP SETID key groupname id-or-$</code></li><li><code>XGROUP DESTROY key groupname</code></li><li><code>XGROUP DELCONSUMER key groupname consumername</code></li></ul><h2 id="xreadgroup">XREADGROUP</h2><p>通过 consumer group 的方式从 streams 中读取数据</p><p><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code> * 首次出现的 consumer 将自动加入 consumer group，无需显式声明 * ID 为 <code>&gt;</code> 表示请求尚未分发给其他 consumer 的新消息 * ID 为其他有效的数字 ID 表示请求自身尚未 ACK 的 pending messages</p><h2 id="xack">XACK</h2><p>将一个未决消息标记为已处理</p><p><code>XACK key group ID [ID ...]</code></p><h2 id="xpending">XPENDING</h2><p>返回 consumer group 中的 pending messages 相关信息</p><p><code>XPENDING key group [start end count] [consumer]</code></p><h2 id="xclaim">XCLAIM</h2><p>将满足条件的 pending messages 重分配</p><p><code>XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]</code></p><p>全部 consumer group 命令可查看<a href="https://redis.io/commands/xack" target="_blank" rel="noopener">相关页面</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 Redis Streams 数据结构及部分操作，并不涉及源码部分。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Chord</title>
    <link href="https://yz1509.github.io//posts/33be3840/"/>
    <id>https://yz1509.github.io//posts/33be3840/</id>
    <published>2019-10-15T06:45:23.000Z</published>
    <updated>2019-10-30T10:00:56.760Z</updated>
    
    <content type="html"><![CDATA[<p>还没开始看。</p><a id="more"></a><p><a href="http://www.falleneth.com/cmuj/papers/chord.pdf" target="_blank" rel="noopener">论文地址</a></p><h1 id="whydunit">Whydunit</h1><h1 id="whodunit">Whodunit</h1><h1 id="howdunit">Howdunit</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还没开始看。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过托福没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E6%89%98%E7%A6%8F%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="分布式" scheme="https://yz1509.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Consistent Hashing</title>
    <link href="https://yz1509.github.io//posts/affa099c/"/>
    <id>https://yz1509.github.io//posts/affa099c/</id>
    <published>2019-10-12T13:26:09.000Z</published>
    <updated>2019-10-30T10:01:42.204Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希的 first paper (maybe) 阅读笔记。</p><a id="more"></a><p><a href="http://david.choffnes.com/classes/cs4700sp14/papers/akamai.pdf" target="_blank" rel="noopener">论文地址</a></p><h1 id="whydunit">Whydunit</h1><p>当大量的客户端同时对单个服务器发起请求时，可能会使该服务器(Hot spots) "swamped" （无法使用）。除此之外，还可能会阻塞该服务附近的网络通信。所以我们需要一个负载均衡算法来有效地避免 Hot spots 的出现。</p><h1 id="whodunit">Whodunit</h1><h2 id="proxy-cache">Proxy cache</h2><p>使用 proxy 缓存经常被请求的数据，多个客户端共享一个 proxy cache。</p><ol type="1"><li>所有用户的请求都发往 proxy</li><li>未命中时，proxy 会把该请求转发至 home server。</li></ol><p><strong>缺点</strong>：proxy 本身可能会 swamped</p><h2 id="a-group-of-caches-functions-as-one">A group of caches functions as one</h2><ol type="1"><li>用户的请求发往任意一个 cache</li><li>未命中时，使用 IP Multicast 将该请求转发至所有其他的 cache</li><li>未命中时，将该请求转发至 heme server</li></ol><p><strong>缺点</strong>：cache 之间的通信消息数量不可控</p><h2 id="harvest-cache">Harvest Cache</h2><p>使用树型结构的 cache，root 为 home server</p><ol type="1"><li>用户的请求发往邻近的叶节点</li><li>未命中时，将该请求转发至兄弟节点(siblings)</li><li>未命中时，将该请求转发至父节点(parent)</li></ol><p><strong>优点</strong>：保证了请求只会来自于子节点或兄弟节点</p><p><strong>缺点</strong>：当所有不同请求同时到来时，至少会有一个请求会到达 root，因此这只是一个缩放的结构，root 无法避免 swamped 的命运</p><h2 id="using-randomization-and-hashing">Using randomization and hashing</h2><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.877&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Plaxton and Rajaraman</a></p><p>新增一组 virtual cache 集合层，通过 random hash function 在现有的 Caches 和 virtual cache 集合之间建立映射，用户的请求发往任一 virtual cache 集合。如果 virtual cache 集合的负载超过阈值，则创建一个更大的 virtual cache 集合。</p><p><strong>优点</strong>：请求响应快，因为每个 cache 的负载都在可控范围；负载均衡。</p><p><strong>缺点</strong>：由于用户的请求发往任一 virtual cache 集合，故小规模的 virtual cache 集合可能会 swamped。</p><h2 id="random-cache-trees">Random cache trees</h2><p>下次一定看！</p><h2 id="consistent-hashing">Consistent hashing</h2><p>传统 hashing 的局限： * 假定节点数是固定的 * 每个节点需要知道全局信息，使用消息进行同步时，由于延时的存在，节点所保存的全局信息正确性无法保证</p><p>Consistent hashing 如何解决这两个问题，将于下文详述。</p><h1 id="howdunit">Howdunit</h1><h2 id="符号说明">符号说明</h2><ul><li><span class="math inline">\(\mathcal{I}\)</span>: set of items，数据</li><li><span class="math inline">\(i\)</span>: is an item</li><li><span class="math inline">\(\mathcal{B}\)</span>: set of buckets，类似于 proxy chche</li><li><span class="math inline">\(b\)</span>: is a bucket</li><li><em>view</em>: any subset of the buckets <span class="math inline">\(\mathcal{B}\)</span>，模拟节点的增加与删除</li><li><em>ranged hash function</em> <span class="math inline">\(f\)</span>: <span class="math inline">\(2^{\mathcal{B}} \times \mathcal{I} \rightarrowtail \mathcal{B}\)</span><ul><li><span class="math inline">\(f(\mathcal{V}, i)\)</span> or <span class="math inline">\(f_{\mathcal{V}}(i)\)</span> is the bucket to which item <span class="math inline">\(i\)</span> is assigned in view <span class="math inline">\(\mathcal{V}\)</span></li><li>Require: <span class="math inline">\(f_{\mathcal{V}}(\mathcal{I}) \subseteq \mathcal{V}\)</span> for every view <span class="math inline">\(\mathcal{V}\)</span></li></ul></li><li><em>ranged hash family</em> <span class="math inline">\(\mathcal{F}\)</span>: is a family of ranged hash functions</li><li><em>random ranged hash function</em>: is a function drawn at random from a particular ranged hash family</li></ul><h2 id="一致性哈希函数应满足的性质介绍">一致性哈希函数应满足的性质介绍</h2><ol type="1"><li><p>Balance</p><p>A ranged hash family is <em>balanced</em> if, given a particular view <span class="math inline">\(\mathcal{V}\)</span>, a set of items,and a randomly chosen function selected from the hash family, with high probability the fraction of items mapped to each bucket is <span class="math inline">\(O(1/|V|)\)</span>.</p></li><li><p>Monotonicity</p><ul><li>A ranged hash function <span class="math inline">\(f\)</span> is <em>monotone</em> if for all views <span class="math inline">\(\mathcal{V}_1 \subseteq \mathcal{V}_2 \subseteq \mathcal{B}, f_{\mathcal{V}_2}(i) \in \mathcal{V}_1\)</span> implies <span class="math inline">\(f_{\mathcal{V}_1}(i) = f_{\mathcal{V}_2}(i)\)</span>.</li><li>A ranged hash family is <em>monotone</em> if every ranged hash function in it is.</li></ul><p>单调性保证了：如果新增了一个节点，只会有将之前的数据迁移到新节点的操作，而不会有旧节点之间互相迁移的操作。</p></li><li><p>Spread</p><p>Let <span class="math inline">\(\mathcal{V}_1 \dots \mathcal{V}_{|V|}\)</span> be a set of views, altogether containing <span class="math inline">\(C\)</span> distinct buckets and each individually containing at least <span class="math inline">\(C/t\)</span> buckets.</p><ul><li>For a ranged hash function and a particular item <span class="math inline">\(i\)</span>, the <em>spread</em> <span class="math inline">\(\sigma(i)\)</span> = <span class="math inline">\(|\{f_{\mathcal{V}_j}(i)\}^{|V|}_{j=1}|\)</span>.</li><li>The <em>spread</em> of a hash function <span class="math inline">\(\sigma(f)\)</span> is the maximum spread of an item.</li><li>The <em>spread</em> of a hash family is <span class="math inline">\(\sigma\)</span> if with high probability, the spread of a random hash function from the family is <span class="math inline">\(\sigma\)</span>.</li></ul><p>Spread 大致意思是指，一个 item 在不同的 view 下会被分配到的 bucket 所组成集合的大小，其越小说明在节点数量发生变化时，需要做的数据迁移操作越少。</p></li><li><p>Load</p><p>Define a set of <span class="math inline">\(|V|\)</span> views as before.</p><ul><li>For a ranged hash function <span class="math inline">\(f\)</span> and bucket <span class="math inline">\(b\)</span>, the <em>load</em> <span class="math inline">\(\lambda(b) = |\cup_{\mathcal{V}}f^{-1}_{\mathcal{V}}(b)|\)</span>. (Note that <span class="math inline">\(f^{-1}_{\mathcal{V}}(b)\)</span>) is the set of items assigned to bucket <span class="math inline">\(b\)</span> in view <span class="math inline">\(\mathcal{V}\)</span>)</li><li>The <em>load</em> of a hash function <span class="math inline">\(\lambda(f)\)</span> is the maximum load of a bucket.</li><li>The <em>load</em> of a hash family is <span class="math inline">\(\lambda\)</span> if with high probability, a randomly chosen hash function has load <span class="math inline">\(\lambda\)</span>.</li></ul><p>Load 大致意思是指， 一个 bucket 在不同的 view 下所包含的 items 集合的并集的大小，其具有上界保证了在不同的节点总数情况下，不会出现单个节点需要储存过多的数据的现象。</p></li></ol><h2 id="构造一致性哈希函数">构造一致性哈希函数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希的 first paper (maybe) 阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="现在英语怎么样 过托福没 可以看论文吗" scheme="https://yz1509.github.io/categories/%E7%8E%B0%E5%9C%A8%E8%8B%B1%E8%AF%AD%E6%80%8E%E4%B9%88%E6%A0%B7-%E8%BF%87%E6%89%98%E7%A6%8F%E6%B2%A1-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%AE%BA%E6%96%87%E5%90%97/"/>
    
    
      <category term="一致性哈希" scheme="https://yz1509.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码之 sds</title>
    <link href="https://yz1509.github.io//posts/18e84d53/"/>
    <id>https://yz1509.github.io//posts/18e84d53/</id>
    <published>2019-10-12T12:10:31.000Z</published>
    <updated>2019-10-30T09:50:07.468Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 简单字符串的源码读后感 (超500字)。</p><a id="more"></a><p>源码文件 <code>/src/sds.h</code> &amp; <code>sdsalloc.h</code> &amp; <code>/src/sds.c</code></p><h1 id="sds-数据结构">sds 数据结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------- sds 的头部结构 -------------------------------</span></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出来，sds 本质还是 C 风格字符串，但是由于不需用 <code>\0</code> 作为结尾标志，所以 sds 是二进制安全的，但是为了兼容 C 风格字符串， sds 也以终止字符 <code>\0</code> 结尾，所以 sds 可以直接重用一部分 C 字符串函数库里面的函数。关于 sds 的头部结构，作者定义了四种不同类型的 sdshdr 供程序使用，区别只是存储 <code>len</code> 和 <code>alloc</code> 使用的整型长度不同，目的应该是为了节省内存。</p><p>四种不同类型的 sdshdr 结构一致，主要包括以下几个部分：</p><ul><li><code>len</code>：存储 <code>buf</code> 数组的长度，不包括终止字符 <code>\0</code></li><li><code>alloc</code>：<code>buf</code> 数组的容量大小</li><li><code>flags</code>：sdshdr 的类型</li></ul><p><em>Tips:</em> <code>__attribute__ ((__packed__))</code> 的作用就是告诉编译器取消结构体在编译过程中的优化对齐，以紧凑模式来分配内存。按照实际占用字节数进行对齐，是 GCC 特有的语法。这个功能是跟操作系统没关系，跟编译器有关。</p><p><em>Tips:</em> 在上述结构体定义中，字符数组 <code>buf</code> 的长度为 0，不占用额外的内存空间，<code>buf</code> 实际指向的是结构体之后的内存空间，如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个 <code>buf</code> 的内容，也可用此类特性实现 C 语言变长数组。</p><h1 id="辅助函数">辅助函数</h1><p>重申：长度 ≠ 容量</p><h2 id="获取字符数组-buf-的长度-len">获取字符数组 <code>buf</code> 的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同 sdshdr 的类型码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="comment">// 用于 sdshdr 的位运算常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="comment">// 得到 sdshdr 的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 flags 的值</span></span><br><span class="line">    <span class="comment">// 由于结构体定义使用紧凑模式，所以 s 所指的地址紧接在存储 flags 的地址之后</span></span><br><span class="line">    <span class="comment">// 从而 s[-1] 的内容即为 flags，注意不要和 Python 中的 -1 混淆</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Tips:</em> 宏定义中的 <code>##</code> 为符号连接操作符。</p><h2 id="获取-buf-数组中的剩余可用空间大小">获取 <code>buf</code> 数组中的剩余可用空间大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据指向 buf 的指针，获取 sdshdr 的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用 <code>SDS_HDR_VAR</code> 而不使用 <code>return SDS_HDR(T,s)-&gt;alloc - SDS_HDR(T,s)-&gt;len;</code> 的原因可能如下：</p><ul><li>为了代码好看</li><li>可以少计算一次</li></ul><p>而 <code>SDS_HDR_VAR</code> 的宏定义最后的分号其实可以去掉，<a href="https://wiki.sei.cmu.edu/confluence/display/c/PRE11-C.+Do+not+conclude+macro+definitions+with+a+semicolon" target="_blank" rel="noopener">详情请见</a></p><h2 id="设置-buf-数组的长度-len">设置 <code>buf</code> 数组的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取存储 flags 的地址</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 低 3 位存 type，高 5 位存长度</span></span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加-buf-数组的长度-len">增加 <code>buf</code> 数组的长度 <code>len</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newlen = len + inc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, <span class="keyword">size_t</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> newlen = SDS_TYPE_5_LEN(flags)+inc;</span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有获取/设置 <code>buf</code> 数组的容量 <code>alloc</code> 的函数，函数逻辑一致便不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="comment">// 设置 `buf` 数组的容量 `alloc`</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span>;</span><br></pre></td></tr></table></figure><p><em>Tips</em> 关于 <code>static inline</code></p><ul><li><code>inline</code> 的作用仅仅是建议编译器做内联开展处理，而不是强制。内联函数（inline）可以减少 CPU 的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数。通常，程序执行时，处理器从内存中读取代码执行。当程序中调用一个函数时，程序跳到存储器中保存函数的位置，开始读取代码执行，执行完后再返回。为了提高速度，C 语言定义了 <code>inline</code> 函数，告诉编译器把函数代码在编译时直接拷贝到程序中，这样就不用执行时另外读取函数代码。</li><li><code>static</code> 告诉编译器其他文件看不到这个函数，因此该函数只能在当前文件中被调用。</li></ul><h1 id="sds-基本操作">sds 基本操作</h1><h2 id="构造函数">构造函数</h2><ol type="1"><li><p><code>sdsnewlen</code></p><p>根据指针 <code>init</code> 和长度 <code>initlen</code> 构造一个 sds。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;   <span class="comment">// 头部指针</span></span><br><span class="line">    sds s;      <span class="comment">// 存储返回值</span></span><br><span class="line">    <span class="comment">/* static inline char sdsReqType(size_t string_size)</span></span><br><span class="line"><span class="comment">    * 根据字符串长度选择合适的 sdshdr 类型 */</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">    * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">/* static inline int sdsHdrSize(char type)</span></span><br><span class="line"><span class="comment">    * 根据 type 返回 sdshdr 的存储空间大小 */</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* #define s_malloc zmalloc</span></span><br><span class="line"><span class="comment">    * + 1 是为了存储 \0 */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* const char *SDS_NOINIT = "SDS_NOINIT";</span></span><br><span class="line"><span class="comment">    * If SDS_NOINIT is used, the buffer is left uninitialized; */</span></span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 填充 sdshdr 中的 len、alloc、flags</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);   <span class="comment">// 填充 buf 字符数组的内容</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;  <span class="comment">// 填充终止字符 \0</span></span><br><span class="line">    <span class="keyword">return</span> s;   <span class="comment">// s 指向 buf 数组首地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现生成的 sds 中有：<span class="math inline">\(len = alloc = initlen\)</span></p></li><li><p><code>sdsempty</code></p><p>构造一个空的 sds，可以看出 <code>buf</code> 数组长度即使为 0，该 sds 也包含 <code>\0</code>。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsnew</code></p><p>根据一个 C 风格字符串构造一个 sds 。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsdup</code></p><p>复制一个 sds 。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfromlonglong</code></p><p>将一个 <code>long long</code> 类型转换为 sds，该操作比直接调用 <code>sdscatprintf(sdsempty(),"%lld\n", value);</code> 高效得多。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// #define SDS_LLSTR_SIZE 21</span></span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">    <span class="comment">/* int sdsll2str(char *s, long long value)</span></span><br><span class="line"><span class="comment">    * The function returns the length of the null-terminated string </span></span><br><span class="line"><span class="comment">            representation stored at 's'.</span></span><br><span class="line"><span class="comment">    * 's' must point to a string with room for at least </span></span><br><span class="line"><span class="comment">            SDS_LLSTR_SIZE bytes. */</span></span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="析构函数请不要沉迷-c">析构函数（请不要沉迷 C++</h2><ol type="1"><li><p><code>sdsclear</code> —— 虚假的析构函数</p><p>将 <code>buf</code> 数组长度设置为 0，但是可以发现并未调用 <code>free</code>，而是将其设置为空闲空间。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfree</code> —— 真实的析构函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* #define s_free zfree</span></span><br><span class="line"><span class="comment">    * (char*)s-sdsHdrSize(s[-1]) —— sds 头部的起始地址 */</span></span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>])); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="动态调整函数">动态调整函数</h2><ol type="1"><li><p><code>sdsMakeRoomFor</code> —— 扩容</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;   <span class="comment">// 旧、新的头指针</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 剩余可用空间大小</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen; </span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen; <span class="comment">// 存储新的头部长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);    <span class="comment">// buf 数组目前长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">// 旧的头指针</span></span><br><span class="line">    newlen = (len+addlen);  <span class="comment">// buf 数组将来长度</span></span><br><span class="line">    <span class="comment">/* #define SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class="line"><span class="comment">    * 扩容策略：如果 buf 数组将来长度小于 1 M，按两倍给你扩容，大气</span></span><br><span class="line"><span class="comment">    *          如果 buf 数组将来长度不小于 1 M，比要求多给你扩 1 M，精打细算 */</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newtype (NT 新人类，大雾)</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">    * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">    * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);  <span class="comment">// 新的头部长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;    <span class="comment">// 不需要更改头部的 len 和 flags，直接扩充 buf 数组的容量</span></span><br><span class="line">        <span class="comment">// #define s_realloc zrealloc</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">        * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 申请新的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// len + 1，\0 也被复制</span></span><br><span class="line">        s_free(sh); <span class="comment">// 释放旧空间</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;    <span class="comment">// 更新 buf 数组首地址</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;   <span class="comment">// 更新 flags</span></span><br><span class="line">        sdssetlen(s, len);  <span class="comment">// 设置 len，大小没变</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen); <span class="comment">// 更新 alloc</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现该函数仅在当前剩余可用空间不足时进行扩容，采取的扩容策略类似 <code>vector</code>，可以在尽可能不浪费内存空间的基础上减少扩容操作的次数。当然扩容并不会改变 <code>buf</code> 数组的长度 <code>len</code>。</p></li><li><p><code>sdsRemoveFreeSpace</code> —— 回收空闲空间</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s);</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-oldhdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">    * fit this string. */</span></span><br><span class="line">    type = sdsReqType(len);</span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">    * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">    * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">    * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;</span><br><span class="line">        newsh = s_realloc(sh, oldhdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的基本流程和扩容操作类似，可以看出仅仅在旧的头部结构不为 <code>sdshdr8</code> 且新的头部结构为 <code>sdshdr8</code> 时，才会重新申请新的内存空间，不然只是在旧的 sds 基础上调用 <code>zrealloc</code> 调整 <code>buf</code> 数组的容量，使得 <span class="math inline">\(alloc = len\)</span> 成立。</p><p>注意调用 <code>sdsRemoveFreeSpace</code> 成功返回后，原指针可能会失效，请使用返回的新指针。</p></li><li><p><code>sdsIncrLen</code> —— 调整长度</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span> </span>&#123;  <span class="comment">// typedef long long ssize_t</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">// fp 指向存储 flags 的地址</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> oldlen = SDS_TYPE_5_LEN(flags);</span><br><span class="line">            <span class="comment">/* 增长时需确保剩余可用空间大小充足</span></span><br><span class="line"><span class="comment">            * 缩短时需确保减少量不得超过现有长度 */</span></span><br><span class="line">            assert((incr &gt; <span class="number">0</span> &amp;&amp; oldlen+incr &lt; <span class="number">32</span>) || (incr &lt; <span class="number">0</span> &amp;&amp; oldlen &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            *fp = SDS_TYPE_5 | ((oldlen+incr) &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            len = oldlen+incr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            assert((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (<span class="keyword">uint64_t</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: len = <span class="number">0</span>; <span class="comment">/* Just to avoid compilation warnings. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;  <span class="comment">// 设置终止字符 '\0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，变量 <code>incr</code> 可正可负，所以在满足条件的基础上长度可增可减。</p></li></ol><h2 id="append-操作">Append 操作</h2><ol type="1"><li><p><code>sdsgrowzero</code></p><p>将 <code>buf</code> 的数组长度增长到给定的 <code>len</code>，如果 <span class="math inline">\(len &lt; currentLen\)</span>，则什么都不做。新增的字节部分，每一位都置为 0。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatlen</code></p><p>将二进制安全的字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><ul><li><code>t</code>：附加字符串首位地址</li><li><code>len</code>：附加字符串长度</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscat</code></p><p>将 C 风格字符串附加到现有的 <code>buf</code> 数组之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatsds</code></p><p>拼接两个 sds，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatvprintf</code></p><p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>], *buf = staticbuf, *t;</span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try to start using a static buffer for speed.</span></span><br><span class="line"><span class="comment">    * If not possible we revert to heap allocation. */</span></span><br><span class="line">    <span class="keyword">if</span> (buflen &gt; <span class="keyword">sizeof</span>(staticbuf)) &#123;</span><br><span class="line">        buf = s_malloc(buflen);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try with buffers two times bigger every time we fail to</span></span><br><span class="line"><span class="comment">    * fit the string in the current buffer size. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置哨兵，测试格式化字符串是否已全部写入 buf 中</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">/* void va_copy(va_list dest, va_list src);</span></span><br><span class="line"><span class="comment">        * The va_copy macro copies src to dest. */</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">/* int vsnprintf( char *restrict buffer, size_t bufsz, </span></span><br><span class="line"><span class="comment">                const char *restrict format, va_list vlist );</span></span><br><span class="line"><span class="comment">        * writes the results to a character string buffer. At most buflen - 1 </span></span><br><span class="line"><span class="comment">                characters are written </span></span><br><span class="line"><span class="comment">        * The resulting character string will be terminated with a </span></span><br><span class="line"><span class="comment">                null character, unless buflen is zero. */</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">/* void va_end(va_list ap);</span></span><br><span class="line"><span class="comment">        * The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy */</span></span><br><span class="line">        va_end(cpy);</span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;    <span class="comment">// 当前 buf 不够长！</span></span><br><span class="line">            <span class="keyword">if</span> (buf != staticbuf) s_free(buf);  </span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            buf = s_malloc(buflen);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 格式化字符串已全部写入 buf</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally concat the obtained string to the SDS string and return it. */</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    <span class="keyword">if</span> (buf != staticbuf) s_free(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于不知晓格式化字符串的长度，所以我们需要使用一个 <code>while</code> 循环来测试当前分配的 <code>buf</code> 字符数组的容量是否可以容纳该格式化字符串，每次失败时，我们将 <code>buf</code> 的容量翻倍。</p></li><li><p><code>sdscatprintf</code></p><p>将格式化字符串拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    <span class="comment">/* void va_start(va_list ap, parmN);</span></span><br><span class="line"><span class="comment">    * The va_start macro enables access to the variable arguments following </span></span><br><span class="line"><span class="comment">            the named argument parmN. */</span></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatfmt</code></p><p>将格式化字符串拼接到 sds 之后，但是比 <code>sdscatprintf</code> 更快，但是其支持以下几种格式化字符串：</p><ul><li><code>%s</code> - C String</li><li><code>%S</code> - SDS string</li><li><code>%i</code> - signed int</li><li><code>%I</code> - 64 bit signed integer (long long, int64_t)</li><li><code>%u</code> - unsigned int</li><li><code>%U</code> - 64 bit unsigned integer (unsigned long long, uint64_t)</li><li><code>%%</code> - Verbatim "%" character.</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscatrepr</code></p><p>将无法打印显式字符的字符数组的转义形式 (eg, "..." or "&lt;hex-number&gt;") 拼接到 sds 之后，注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="拷贝操作">拷贝操作</h2><ol type="1"><li><p><code>sdscpylen</code></p><p>丢弃 sds 字符数组中的原内容，将长为 <code>len</code> 的字符串拷贝至 sds 的 <code>buf</code> 中。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdsalloc(s) &lt; len) &#123;    <span class="comment">// 容量不足，扩容</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sdslen(s));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscpy</code></p><p>丢弃 sds 字符数组中的原内容，将 C 风格字符串拷贝至 sds 的 <code>buf</code> 中。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="修剪操作">修剪操作</h2><ol type="1"><li><p><code>sdstrim</code></p><p>从 sds 两端开始遍历，出现在 C 风格字符串 cset 中的字符将会被删除。注意该函数调用成功后，原指针可能会失效，请使用返回的新指针。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;     <span class="comment">// 指向第一个字符</span></span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;   <span class="comment">// 指向终止字符 `\0` 前一字符</span></span><br><span class="line">    <span class="comment">/* char *strchr(const char *str, int ch);</span></span><br><span class="line"><span class="comment">    * Finds the first occurrence of ch (after conversion to char as if </span></span><br><span class="line"><span class="comment">        by (char)ch) in the null-terminated byte string pointed to by str </span></span><br><span class="line"><span class="comment">        (each character interpreted as unsigned char). </span></span><br><span class="line"><span class="comment">    * 从前往后遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 +1 */</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="comment">/* 前一步遍历的终止条件不是越界时有 ep &gt; sp</span></span><br><span class="line"><span class="comment">    * 从后往前遍历 sds，如果当前指针所指字符出现在 cset 所指字符串中，则指针 -1 */</span></span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    <span class="comment">// 计算修剪后的字符串长度</span></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* void* memmove( void* dest, const void* src, size_t count );</span></span><br><span class="line"><span class="comment">    * Copies count characters from the object pointed to by src to the object </span></span><br><span class="line"><span class="comment">        pointed to by dest*/</span></span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p><p>虽然作者提示原指针可能会失效，但是在函数中可以发现返回的就是原指针值，表示疑惑。</p></li><li><p><code>sdsrange</code></p><p>依据起始和结束索引下标修剪 sds 字符串，注意：</p><ul><li><code>start</code> 和 <code>end</code> 可以为负数，类似数组的下标索引</li><li>结果子串的范围为闭区间 <span class="math inline">\([start, end]\)</span></li><li>该操作是就地进行的</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引下标</span></span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;   <span class="comment">// 绝对值大于字符串长度的负数索引值置为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算子串长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">ssize_t</span>)len) &#123;    <span class="comment">// 起始索引值大于等于字符串长度，子串为空</span></span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">ssize_t</span>)len) &#123; <span class="comment">// 结束索引值大于等于字符串长度，置为 len-1</span></span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 因 end 更改，故更新子串长度</span></span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(s, s+start, newlen);</span><br><span class="line">    s[newlen] = <span class="number">0</span>;  <span class="comment">// 等价于 s[newlen] = '\0';</span></span><br><span class="line">    sdssetlen(s,newlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同上，可以发现函数在执行过程中并未调用 <code>free</code>，是否存在内存泄漏的风险？具体需要观察后续对该函数的调用场景进行分析，暂时 MARK。</p></li></ol><h2 id="split-操作">split 操作</h2><ol type="1"><li><p><code>sdssplitlen</code></p><p>使用长为 <code>seplen</code> 的二进制安全字符串 <code>sep</code> 作为分隔符，将长为 <code>len</code> 的二进制安全字符串 <code>s</code> 分割成 <code>count</code> 个 sds 字符串。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* elements 存放当前 sds 字符串的个数</span></span><br><span class="line"><span class="comment">    * slots 存放当前已分配内存的 sds 指针数组 tokens 的大小 */</span></span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">0</span>, j;</span><br><span class="line">    sds *tokens;    <span class="comment">// sds 指针数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tokens = s_malloc(<span class="keyword">sizeof</span>(sds)*slots);   <span class="comment">// 先搞五个试试</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符串匹配过程</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;     <span class="comment">// 扩容采取倍增策略</span></span><br><span class="line">            newtokens = s_realloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator </span></span><br><span class="line"><span class="comment">        * int memcmp( const void* lhs, const void* rhs, size_t count );</span></span><br><span class="line"><span class="comment">        * Compares the first count characters of the objects pointed to by lhs and rhs*/</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        s_free(tokens);</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsfreesplitres</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    s_free(tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsplitargs</code></p><ul><li>Split a line into arguments, where every argument can be in the following programming-language REPL-alike form: <code>foo bar "newline are supported\n" and "\xff\x00otherstuff"</code></li><li>The number of arguments is stored into *argc, and an array of sds is returned.</li><li>The caller should free the resulting array of sds strings with sdsfreesplitres().</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span></span><br></pre></td></tr></table></figure></p><p>偷个懒，用到时再看hhhhh</p></li></ol><h2 id="其他函数">其他函数</h2><ol type="1"><li><p><code>sdsupdatelen</code></p><p>更新 sds 的长度 <code>len</code>，由于是调用 <code>strlen</code>，故只统计到终止字符 <code>\0</code>（不包括 <code>\0</code>）</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    sdssetlen(s, reallen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsAllocSize</code></p><p>返回分配内存空间的大小，包括：</p><ul><li>头部结构体的大小 <code>sdsHdrSize</code></li><li><code>buf</code> 数组容量 <code>alloc</code></li><li>终止字符 <code>\0</code> 的长度 1</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> alloc = sdsalloc(s);</span><br><span class="line">    <span class="keyword">return</span> sdsHdrSize(s[<span class="number">-1</span>])+alloc+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsAllocPtr</code></p><p>返回 sds 头部起始地址。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) (s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdstolower</code></p><p>转换为小写</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdstoupper</code></p><p>转换为大写</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdscmp</code></p><p>使用 <code>memcmp</code> 实现两个 sds 的比较操作</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1&gt;l2? <span class="number">1</span>: (l1&lt;l2? <span class="number">-1</span>: <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsmapchars</code></p><p>遍历 sds 字符串，将在字符串 <code>from</code> 中出现的字符替换成 <code>to</code> 中对应位置的字符，<code>setlen</code> 为字符串 <code>from</code> 和 <code>to</code> 的长度。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> j, i, l = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setlen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == from[i]) &#123;</span><br><span class="line">                s[j] = to[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsjoin</code></p><p>使用 C 风格字符串 <code>sep</code> 作为分隔符，将 C 风格字符串数组拼接为一个 sds。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>sdsjoinsds</code></p><p>类似于 <code>sdsjoin</code>，将 sds 字符串数组拼接为一个 sds。值得注意的是，使用的字符串分隔符是二进制安全的，而不是 C 风格字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscatsds(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscatlen(join,sep,seplen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 简单字符串的源码读后感 (超500字)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码之 adlist</title>
    <link href="https://yz1509.github.io//posts/28a59907/"/>
    <id>https://yz1509.github.io//posts/28a59907/</id>
    <published>2019-10-12T12:08:45.000Z</published>
    <updated>2019-10-30T09:52:40.033Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 底层链表结构相关源码阅读笔记。</p><a id="more"></a><p>源码文件 <code>/src/adlist.h</code> &amp; <code>/src/adlist.c</code></p><h1 id="adlist-数据结构">adlist 数据结构</h1><p>adlist 其实是一个双向链表，我们首先介绍其链表节点、链表迭代器和链表的数据结构。</p><h2 id="链表节点">链表节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向前一节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向后一节点</span></span><br><span class="line">    <span class="keyword">void</span> *value;            <span class="comment">// 指向当前节点的值</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><h2 id="链表迭代器">链表迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;     <span class="comment">// 迭代器当前所指节点，为什么不叫 now ？       </span></span><br><span class="line">    <span class="keyword">int</span> direction;      <span class="comment">// 迭代访问的方向    </span></span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0     <span class="comment">// 从首到尾</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1     <span class="comment">// 从尾到首</span></span></span><br></pre></td></tr></table></figure><h2 id="链表">链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;     <span class="comment">// 首节点</span></span><br><span class="line">    listNode *tail;     <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);    <span class="comment">// 用户可自定义的节点值释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 用户可自定义的节点值匹配函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;  <span class="comment">// 记录链表长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h1 id="辅助函数">辅助函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><h1 id="adlist-基本操作">adlist 基本操作</h1><h2 id="构造函数">构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span>  <span class="comment">// 指向一个链表的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 首尾节点默认为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值： * 分配内存执行失败时，返回 <code>NULL</code> * 执行成功时返回指向已构造的空链表的指针。</p><h2 id="析构函数">析构函数</h2><ol type="1"><li><p><code>lsitEpmty</code> —— 不健全的析构函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;   <span class="comment">// 保存下一节点的指针</span></span><br><span class="line">        <span class="comment">// 如果 list 中的 free 函数已设置，调用其，释放节点值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        <span class="comment">// 释放当前节点的指针</span></span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 将首尾节点置为 NULL</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，<code>listEmpty</code> 函数释放了链表中的每个节点，但是并未释放指向该链表的指针本身。</p></li><li><p><code>listRelease</code> —— 析构函数完全体</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);    <span class="comment">// 释放指向该链表的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="添加">添加</h2><ol type="1"><li><p><code>listAddNodeHead</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;  <span class="comment">// 首节点的 prev 指针指向 NULL</span></span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，该函数的作用是，根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的首部，其返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul></li><li><p><code>listAddNodeTail</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 尾节点的 next 指针指向 NULL</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，并将该节点插入到给定链表 <code>list</code> 的尾部，其返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul></li><li><p><code>listInsertNode</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;    <span class="comment">// atfer 非 0，新节点插入在指定节点之后</span></span><br><span class="line">        node-&gt;prev = old_node;  </span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123; <span class="comment">// 指定节点为尾节点     </span></span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;        <span class="comment">// 更新链表的尾节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// after 为 0，新节点插入在指定节点之前</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;  <span class="comment">// 指定节点为首节点</span></span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;         <span class="comment">// 更新链表的首节点指针为新插入节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;    <span class="comment">// 更新插入节点的前一节点的 next 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;    <span class="comment">// 更新插入节点的后一节点的 prev 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针 <code>value</code>，构造一个新的 <code>listnode</code>，随后将该节点插入到链表的指定位置：</p><ul><li><span class="math inline">\(after \ne 0\)</span>，插入到 <code>old_node</code> 之后</li><li><span class="math inline">\(after = 0\)</span>，插入到 <code>old_node</code> 之前</li></ul><p>函数的返回值为：</p><ul><li>为新增节点申请内存失败时，返回 <code>NULL</code>，不改变原链表</li><li>申请内存成功时，返回修改好的链表指针 <code>list</code></li></ul><p><em>Tips:</em> 插入节点时，可以先更新插入节点的指针，然后再更新插入节点相邻节点的指针。</p></li></ol><h2 id="删除">删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;  </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;    <span class="comment">// 删除节点为首节点，更新链表首节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;    <span class="comment">// 删除节点为尾节点，更新链表尾节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);    <span class="comment">// 释放该节点所占内存空间</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：删除给定节点，并释放其所占内存空间。</p><h2 id="迭代器相关">迭代器相关</h2><ol type="1"><li><p><code>listGetIterator</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD) </span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;    <span class="comment">// 从首到尾      </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;    <span class="comment">// 从尾到首</span></span><br><span class="line">    iter-&gt;direction = direction;    <span class="comment">// 存储遍历方向</span></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数的返回值：</p><ul><li>申请内存失败时，返回 <code>NULL</code></li><li>申请内存成功时，根据方向参数初始化迭代器，并返回其指针 <code>iter</code></li><li><code>direction == AL_START_HEAD</code> 时，返回正序迭代器</li><li><code>direction == AL_START_TAIL</code> 时，返回逆序迭代器</li></ul></li><li><p><code>listReleaseIterator</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：释放迭代器所占内存。</p></li><li><p><code>listRewind</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：将给定迭代器重置为正序迭代器。</p></li><li><p><code>listRewindTail</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：将给定迭代器重置为逆序迭代器。</p></li><li><p><code>listNext</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next; <span class="comment">// 迭代器当前所指节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：如果迭代器当前所指节点非空，则根据方向参数更新迭代器的 <code>next</code> 指针，最后返回迭代器当前所指节点。</p></li></ol><h2 id="复制">复制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)  <span class="comment">// 构造一个空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;      <span class="comment">// 复制自定义值复制函数</span></span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;    <span class="comment">// 复制自定义值释放函数</span></span><br><span class="line">    copy-&gt;match = orig-&gt;match;  <span class="comment">// 复制自定义值匹配函数</span></span><br><span class="line">    listRewind(orig, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;   <span class="comment">// 遍历原链表</span></span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;    <span class="comment">// 值复制函数已给定</span></span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;    <span class="comment">// 值复制失败</span></span><br><span class="line">                listRelease(copy);  <span class="comment">// 释放复制链表</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>      <span class="comment">// 未给定值复制函数</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123; <span class="comment">// 添加新节点到尾部</span></span><br><span class="line">            listRelease(copy);  <span class="comment">// 添加节点失败，释放链表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用为：完全复制给定的链表 <code>orig</code>，函数的返回值为： * 执行失败时，返回 <code>NULL</code> * 执行成功时，返回复制链表指针 <code>copy</code></p><p><strong>注意</strong>：不论该函数是否执行成功，原链表都不会被修改。</p><h2 id="查找">查找</h2><ol type="1"><li><p><code>listSearchKey</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter);    <span class="comment">// iter 重置为正序迭代器</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;  <span class="comment">// 值匹配函数已指定</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定值匹配函数</span></span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;  <span class="comment">// 返回第一个匹配成功的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 未找到，返回 NUll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的值指针，寻找值相等的链表节点，该函数的返回值为：</p><ul><li>成功找到时，返回第一个值相等的链表节点指针（正序）</li><li>未找到时，返回 <code>NULL</code></li></ul></li><li><p><code>listIndex</code></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;    <span class="comment">// 支持负数索引</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是：根据给定的索引值，返回相应的链表节点</p><ul><li>从 0 开始计算索引</li><li>支持负数索引</li><li>当索引值 <code>index</code> <span class="math inline">\(\notin[-len, len - 1]\)</span> 时，返回 <code>NULL</code></li></ul></li></ol><h2 id="旋转">旋转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev; </span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：删除链表原尾节点，将原尾节点插入到首部，作为新的首节点。</p><h2 id="拼接">拼接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head)    <span class="comment">// 链表 o 不为空</span></span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail)    <span class="comment">// 链表 l 不为空</span></span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail;</span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. */</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：将链表 <code>o</code> 拼接到链表 <code>l</code> 之后，随后将链表 <code>o</code> 置为空链表，并未释放链表指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 底层链表结构相关源码阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码之 zmalloc</title>
    <link href="https://yz1509.github.io//posts/ab216dfd/"/>
    <id>https://yz1509.github.io//posts/ab216dfd/</id>
    <published>2019-10-12T12:07:44.000Z</published>
    <updated>2019-10-30T09:51:21.948Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 内存分配及释放相关源码阅读笔记。</p><a id="more"></a><p>源码文件 <code>/src/zmalloc.h</code> &amp; <code>/src/zmalloc.c</code></p><h1 id="分配内存">分配内存</h1><h2 id="zmalloc">zmalloc</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 malloc 分配内存</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="comment">// HAVE_MALLOC_SIZE 为 1 时，PREFIX_SIZE 为 0，直接返回 ptr</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 保存数据所需分配内存的实际大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// PREFIX_SIZE 中存储了 malloc size</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>zmalloc_size</p><p>使用 <code>tcmalloc 1.6+</code> 或 <code>jemalloc 2.1+</code> 或 <code>malloc</code>，则 <code>HAVE_MALLOC_SIZE</code> 为 1 。至于不同内存分配函数的区别，可以参考<a href="https://cyningsun.github.io/07-07-2018/memory-allocator-contrasts.html" target="_blank" rel="noopener">这篇博客</a>。</p><p>自身定义的 <code>zmalloc_size</code> 函数如下：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Provide zmalloc_size() for systems where this function is not provided by</span></span><br><span class="line"><span class="comment">* malloc itself, given that in that case we store a header with this</span></span><br><span class="line"><span class="comment">* information as the first bytes of every allocation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></span><br><span class="line"><span class="comment">    * the underlying allocator. */</span></span><br><span class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_usable(<span class="keyword">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_size(ptr)-PREFIX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li><li><p>update_zmalloc_stat_alloc</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \    </span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="comment">// atomicIncr(var,count) </span></span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>根据 <a href="https://github.com/antirez/redis/pull/4770" target="_blank" rel="noopener">redis #4770</a>，第 2、3 两行可以删除，由于并未计算内存补齐的原因，全局变量 <code>used_memory</code> 一般小于实际分配内存大小。</p><p><em>Tips:</em> <a href="http://www.spongeliu.com/415.html" target="_blank" rel="noopener"><code>do {} while(0)</code> 的作用</a>：</p><ul><li>辅助定义复杂的宏，避免引用的时候出错</li><li>避免使用 <code>goto</code> 对程序流进行统一的控制，例如：使用 <code>break</code> 来代替 <code>goto</code>，后续的处理工作在 <code>while</code> 之后，就能够达到同样的效果</li><li>避免空宏引起的 <code>warning</code></li><li>定义一个单独的函数块来实现复杂的操作</li></ul><p><em>Tips:</em> 将 <span class="math inline">\(a\)</span> 调整为 <span class="math inline">\(b = 2^n\)</span> 的整数倍</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &amp; (b<span class="number">-1</span>))</span><br><span class="line">    a += b - (a &amp; (b<span class="number">-1</span>));</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="zcalloc">zcalloc</h2><p>源码逻辑和 <code>zmalloc</code> 一样，此处主要介绍 <code>malloc</code> 和 <code>calloc</code> 的区别：</p><table><thead><tr class="header"><th>区别</th><th><code>malloc</code></th><th><code>calloc</code></th></tr></thead><tbody><tr class="odd"><td>定义</td><td><code>void* malloc(size_t size);</code></td><td><code>void* calloc(size_t num, size_t size);</code></td></tr><tr class="even"><td>作用</td><td>分配 <code>size</code> 字节未初始化的内存空间</td><td>为 <code>num</code> 个大小为 <code>size</code> 的对象分配内存空间，并且初始化每一 <code>bit</code> 为 0</td></tr></tbody></table><p>两个函数都是线程安全的，并且都自带满足内存对齐，当分配成功时，返回指向初始位置的指针，该指针需要调用 <code>free()</code> 或 <code>realloc()</code> 释放，当分配失败时，返回空指针。</p><h2 id="zrealloc">zrealloc</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配的内存的大小为 0</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原内存指针为空，无需释放</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size); </span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="comment">// HAVE_MALLOC_SIZE 为 1 时，PREFIX_SIZE 为 0，直接返回 newptr</span></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">// 对应 *((size_t*)ptr) = size;</span></span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// PREFIX_SIZE 中存储了 malloc size</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>update_zmalloc_stat_free</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="comment">// atomicDecr(var,count)</span></span><br><span class="line">    atomicDecr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>同上，根据 <a href="https://github.com/antirez/redis/pull/4770" target="_blank" rel="noopener">redis #4770</a>，第 2、3 两行可以删除，由于并未计算内存补齐的原因，全局变量 <code>used_memory</code> 一般小于实际分配内存大小。</p></li><li><p>疑问：变量定义语句置于判断返回语句前是否浪费了为变量分配存储空间的时间？变量定义是否应该离使用变量语句近一些更好？</p></li></ol><h1 id="释放内存">释放内存</h1><h2 id="zfree">zfree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 指针为空时无需调用 free</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">// 记录内存使用情况，更新 used_memory</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="辅助函数">辅助函数</h1><h2 id="复制字符串">复制字符串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>; <span class="comment">// '\0' 结尾</span></span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用字符串复制函数 void* memcpy(void *dest, const void *src, size_t count);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-used_memory">获取 <code>used_memory</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line">    <span class="comment">// atomicGet(var,dstvar)</span></span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置异常处理函数">设置异常处理函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认异常处理函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置异常处理函数</span></span><br><span class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) &#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 内存分配及释放相关源码阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://yz1509.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="https://yz1509.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关小问题</title>
    <link href="https://yz1509.github.io//posts/e4b38dc/"/>
    <id>https://yz1509.github.io//posts/e4b38dc/</id>
    <published>2019-10-12T12:00:38.000Z</published>
    <updated>2019-10-30T10:04:00.783Z</updated>
    
    <content type="html"><![CDATA[<p>这个人明明遇到过很多问题，却总是忘了记录。</p><a id="more"></a><h1 id="手动卸载旧版本软件安装完新版本之后提示-no-such-file-or-directory-怎么办">手动卸载旧版本软件，安装完新版本之后，提示 No such file or directory 怎么办？</h1><ol type="1"><li>使用 <code>echo $PATH</code> 命令检查环境变量，如新版本软件安装路径不在环境变量中，添加。如新版本软件安装路径已在环境变量中，转 2.<ul><li>添加环境变量：编辑 <code>/etc/profile</code> or <code>/ect/environment</code> or <code>~/.bashrc</code></li></ul></li><li>因为 bash 路径是有缓存的，只要运行过的命令，bash 就会保存到一张 hash 表中，下次直接从 hash 表中找地址，故需要我们手动删除缓存<ul><li>运行 <code>hash</code> 命令，查看缓存的 hash 表</li><li>运行 <code>hash -d &lt;softname&gt;</code> 删除掉 <code>&lt;softname&gt;</code> 的缓存</li></ul></li></ol><h1 id="gccg-版本切换">gcc/g++ 版本切换</h1><ol type="1"><li>查看所安装的各个版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin/gcc*</span><br><span class="line">ls /usr/bin/g++*</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>设置候选优先级</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 gcc-5 和 gcc-7 为例，最后的数字是优先级，数字越大，优先级越高</span></span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 100</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 g++-5 和 g++-7 为例，最后的数字是优先级，数字越大，优先级越高</span></span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 100</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 80</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>切换版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config gcc</span><br><span class="line"></span><br><span class="line">update-alternatives --config g++</span><br></pre></td></tr></table></figure><p>注意保持 gcc 和 g++ 的版本一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个人明明遇到过很多问题，却总是忘了记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yz1509.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://yz1509.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Thrift-Protocol 概述</title>
    <link href="https://yz1509.github.io//posts/787e5648/"/>
    <id>https://yz1509.github.io//posts/787e5648/</id>
    <published>2019-07-30T14:57:40.000Z</published>
    <updated>2019-10-30T10:04:57.231Z</updated>
    
    <content type="html"><![CDATA[<p>Thrift 协议层简单介绍。</p><a id="more"></a><h1 id="协议层类关系图">协议层类关系图</h1><p>协议层相关的类主要实现与数据传输格式封装的协议相关的内容。可以发现，所有的协议类都直接或间接继承 TProtocol 类，协议层类关系图主要分为三部分来看：</p><ul><li>抽象基类 Tprotocol，它是所有协议类的基类，有很大一部分类直接从它继承实现它定义的接口函数（纯虚函数）</li><li>TProtocol 的默认实现 TProtocolDefaults 类和虚拟协议类 TVirtualProtocol 及其子类</li><li>各种协议类的对象生成工厂类，负责某一种具体协议类对象的生产</li></ul><h1 id="tprotocol">Tprotocol</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TProtocol.h</code></p><p>抽象类 TProtocol 对于每一种数据类型都提供了读写的开始和结束的方法，这里的读写方法应该是针对网络 I/O 读写，不过真正实现网络读写的是 TTransport 相关类，此处的读写方法主要针对数据的处理（如数据格式调整）。除了有针对具体的数据类型的读写方法，消息也可以通过网络传递。所以也定义了消息的读写方法。此外，还定义了一些公用的功能，例如跳过某一个结构不读，大小端数据格式调整、主机字节序和网络字节序的相互转换等。</p><h2 id="支持的数据结构">支持的数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thrift 协议支持的数据类型</span></span><br><span class="line"><span class="keyword">enum</span> TType &#123;</span><br><span class="line">  T_STOP       = <span class="number">0</span>,</span><br><span class="line">  T_VOID       = <span class="number">1</span>,</span><br><span class="line">  T_BOOL       = <span class="number">2</span>,</span><br><span class="line">  T_BYTE       = <span class="number">3</span>,</span><br><span class="line">  T_I08        = <span class="number">3</span>,</span><br><span class="line">  T_I16        = <span class="number">6</span>,</span><br><span class="line">  T_I32        = <span class="number">8</span>,</span><br><span class="line">  T_U64        = <span class="number">9</span>,</span><br><span class="line">  T_I64        = <span class="number">10</span>,</span><br><span class="line">  T_DOUBLE     = <span class="number">4</span>,</span><br><span class="line">  T_STRING     = <span class="number">11</span>,</span><br><span class="line">  T_UTF7       = <span class="number">11</span>,</span><br><span class="line">  T_STRUCT     = <span class="number">12</span>,</span><br><span class="line">  T_MAP        = <span class="number">13</span>,</span><br><span class="line">  T_SET        = <span class="number">14</span>,</span><br><span class="line">  T_LIST       = <span class="number">15</span>,</span><br><span class="line">  T_UTF8       = <span class="number">16</span>,</span><br><span class="line">  T_UTF16      = <span class="number">17</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thrift 支持的消息类型</span></span><br><span class="line"><span class="keyword">enum</span> TMessageType &#123;</span><br><span class="line">  T_CALL       = <span class="number">1</span>,</span><br><span class="line">  T_REPLY      = <span class="number">2</span>,</span><br><span class="line">  T_EXCEPTION  = <span class="number">3</span>,</span><br><span class="line">  T_ONEWAY     = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="写函数">写函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(*)</span><span class="title">Begin_virt</span><span class="params">(<span class="keyword">const</span> parameters)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(*)</span><span class="title">End_virt</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">writeFiledStop_virt</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 只有 Filed 有 stop</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">write</span><span class="params">(TtypeName)</span>_<span class="title">virt</span><span class="params">(<span class="keyword">const</span> parameter)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用相应纯虚函数的函数</span></span><br><span class="line"><span class="keyword">unit32_t</span> functionName(&lt;<span class="keyword">const</span> parameters&gt;)&#123;</span><br><span class="line">    T_VIRTUAL_CALL();       <span class="comment">// 调用打印日志函数</span></span><br><span class="line">    <span class="keyword">return</span> functionName_virt(&lt;<span class="keyword">const</span> parameters);  <span class="comment">// 调用纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读函数">读函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(*)</span><span class="title">Begin_virt</span><span class="params">(parameters)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(*)</span><span class="title">End_virt</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> unit32_t <span class="title">read</span><span class="params">(TtypeName)</span>_<span class="title">virt</span><span class="params">(parameter)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个 readBool() 函数，</span></span><br><span class="line"><span class="comment">// std::vector is specialized for bool, and its elements are individual bits</span></span><br><span class="line"><span class="comment">// rather than bools.   We need to define a different version of readBool()</span></span><br><span class="line"><span class="comment">// to work with std::vector&lt;bool&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">readBool_virt</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::reference value)</span> </span>= <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用相应纯虚函数的函数</span></span><br><span class="line"><span class="keyword">unit32_t</span> functionName(&lt;parameters&gt;)&#123;</span><br><span class="line">    T_VIRTUAL_CALL();       <span class="comment">// 调用打印日志函数</span></span><br><span class="line">    <span class="keyword">return</span> functionName_virt(&lt;parameters);  <span class="comment">// 调用纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  TProtocol(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TTransport&gt; ptrans)</span><br><span class="line">    : ptrans_(ptrans), input_recursion_depth_(<span class="number">0</span>), output_recursion_depth_(<span class="number">0</span>), recursion_limit_(DEFAULT_RECURSION_LIMIT)</span><br><span class="line">  &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="其他函数">其他函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过任意数据类型的函数</span></span><br><span class="line"><span class="keyword">uint32_t</span> skip(TType type) &#123;</span><br><span class="line">    T_VIRTUAL_CALL();</span><br><span class="line">    <span class="keyword">return</span> skip_virt(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">skip_virt</span><span class="params">(TType type)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用此命名空间下全局函数实现</span></span><br><span class="line">    <span class="comment">// 在该头文件的最后定义模板函数 skip 以适用于不同的 Protocol 类</span></span><br><span class="line">    <span class="keyword">return</span> ::apache::thrift::protocol::skip(*<span class="keyword">this</span>, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TTransport&gt; getTransport() &#123; <span class="keyword">return</span> ptrans_; &#125;</span><br></pre></td></tr></table></figure><p>此外还有一些与输入，输出递归深度有关的函数在上面并未列出。</p><h1 id="tprotocoldefaults">TProtocolDefaults</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TVirtualProtocol.h</code></p><h2 id="继承关系">继承关系</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TProtocolDefaults</span> :</span> <span class="keyword">public</span> TProtocol &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="主要操作">主要操作</h2><ol type="1"><li>重写了父类非虚拟的读写函数，这些函数都会抛出一个 <code>TProtocolException::NOT_IMPLEMENTED</code> 异常</li><li>重写了父类的 <code>skip</code> 函数，直接调用父类中的 <code>skip</code> 模板函数</li><li>构造函数直接调用父类的构造函数</li></ol><h1 id="tvirtualprotocol">TVirtualProtocol</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/protocol/TVirtualProtocol.h</code></p><h2 id="继承关系-1">继承关系</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Protocol_</span>, <span class="title">class</span> <span class="title">Super_</span> = <span class="title">TProtocolDefaults</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TVirtualProtocol</span> :</span> <span class="keyword">public</span> Super_ &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="读写函数">读写函数</h2><p>TVirtualProtocol 类中的读写函数会重写父类中的读写纯虚函数，其都是通过 <code>this</code> 指针调用模板参数 <code>class Protocol_</code> 中相应的实现方法来实现自己的读写函数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> writeMessageBegin_virt(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">                                <span class="keyword">const</span> TMessageType messageType,</span><br><span class="line">                                <span class="keyword">const</span> <span class="keyword">int32_t</span> seqid) override &#123; <span class="comment">// override 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Protocol_*&gt;(<span class="keyword">this</span>)-&gt;writeMessageBegin(name, messageType, seqid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他操作">其他操作</h2><ol type="1"><li>提供了 <code>skip</code> 函数和针对 <code>std::vector&lt;boo&gt;</code> 的 <code>readBool</code> 函数的默认实现</li><li>构造函数直接调用父类的构造函数</li></ol><h1 id="为何要有-tprotocoldefaults-和-tvirtualprotocol">为何要有 TProtocolDefaults 和 TVirtualProtocol ？</h1><p>下面来分析如果不从定义的默认实现类继承，直接从抽象类继承怎样会产生无限递归调用。现在我们假设直接从抽象类继承，那么如果一个指向子类对象的父类（TProtocol）调用 <code>writeMessageBegin</code> 方法，因为这个方法不是虚拟函数（不会动态绑定）所以就会调用父类的 <code>writeMessageBegin</code> 方法，然后父类会直接调用它的纯虚函数 <code>writeMessageBegin_virt</code>，这个函数就会动态绑定，就会执行子类的实现，在这里就是通过虚协议类 TVirtualProtocol 实现的，而这个函数又会调用之类的 <code>writeMessageBegin</code> 方法，如果子类没有实现这个方法，那么就又回到父类的这个方法了,从而产生无限递归调用。那么如果默认是从默认实现类 TProtocolDefaults 继承，那么就会执行它的 <code>writeMessageBegin</code> 方法，从而抛出一个异常，就不会产生无限递归调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Thrift 协议层简单介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://yz1509.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="thrift" scheme="https://yz1509.github.io/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>Thrift-Transport 概述</title>
    <link href="https://yz1509.github.io//posts/f531f65/"/>
    <id>https://yz1509.github.io//posts/f531f65/</id>
    <published>2019-07-30T14:57:26.000Z</published>
    <updated>2019-10-30T10:10:51.108Z</updated>
    
    <content type="html"><![CDATA[<p>Thrift 传输层简单介绍。</p><a id="more"></a><h1 id="传输层类关系图">传输层类关系图</h1><p>传输层类关系图主要分为三部分来看： * 抽象基类 TTransport，它是所有传输类的基类，有很大一部分类直接从它继承实现它定义的接口函数（纯虚函数） * TTransport 的默认实现 TTransportDefaults 类和虚拟传输类 TvirtualTransport 及其子类 * 各种传输类的对象生成工厂类，负责某一种具体传输类对象的生产</p><h1 id="ttransport">TTransport</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h</code></p><h2 id="模板函数-readall">模板函数 <code>readAll</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Transport_</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">uint32_t</span> <span class="title">readAll</span>(<span class="title">Transport_</span>&amp; <span class="title">trans</span>, <span class="title">uint8_t</span>* <span class="title">buf</span>, <span class="title">uint32_t</span> <span class="title">len</span>) &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> have = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> get = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (have &lt; len) &#123;</span><br><span class="line">    get = trans.read(buf + have, len - have);   <span class="comment">// 通过具体的传输类对象读取剩余的需要读取的数据</span></span><br><span class="line">    <span class="keyword">if</span> (get &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> TTransportException(TTransportException::END_OF_FILE, <span class="string">"No more data to read."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    have += get;    <span class="comment">// 已读取的字节数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> have;  <span class="comment">// 返回读取得字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ttransport-的接口定义">TTransport 的接口定义</h2><ol type="1"><li><code>isOpen()</code>：transport 是否 open</li><li><code>peek()</code>：测试是否仍然有数据可读或远程 transport 是否 open</li><li><code>open()</code>：打开 transport</li><li><code>close()</code>：关闭 transport</li><li><code>read()</code> &amp; <code>read_virt()</code>：尝试读取指定的字节数到字符串<ul><li><code>uint8_t* buf</code>：Reference to the location to write the data</li><li><code>uint32_t len</code>: How many bytes to read</li></ul></li><li><code>readAll()</code> &amp; <code>readAll_virt()</code>：必须读取指定长度的数据<ul><li><code>uint8_t* buf</code>：Reference to location for read data</li><li><code>uint32_t len</code>: How many bytes to read</li></ul></li><li><code>readEnd()</code>：读取完成时调用</li><li><code>write()</code> &amp; <code>write_virt()</code>：将字符串写入缓存<ul><li><code>uint8_t* buf</code>：The data to write out</li><li><code>uint32_t len</code>: How many bytes to write</li><li>必须调用 <code>flush()</code> 才能确保成功写入，析构一个 TTransport 对象并不会自动 flush pendng data.</li></ul></li><li><code>writeEnd()</code>：写入完成时调用</li><li><code>flush()</code>：Flushes any pending data to be written.</li><li><code>borrow()</code> &amp; <code>borrow_virt()</code>：尝试返回一个指向长为 len 的字符串缓存而不真正地读取消耗它</li></ol><ul><li><code>uint8_t* buf</code>：A buffer where the data can be stored if needed.</li><li><code>uint32_t* len</code>: len should initially contain the number of bytes to borrow.</li></ul><ol start="12" type="1"><li><code>consume()</code> &amp; <code>consume_virt()</code>：从传输层消耗 len 字节的数据</li></ol><ul><li><code>uint32_t len</code>: How many bytes to consume</li></ul><p>通常一个传输层的对象要么作为输出要么作为输入，但是通常不能同时作为输入和输出。上述已把所有支持的接口操作都简单的介绍了，后面介绍的具体某一个传输层类的实现都会实现这些接口，只是根据各个子类不同的作用和实现方式有不同而已。特别需要注意的是最后两组函数，这两组函数主要是用于支持可变长度编码的，所以如果传输层对象需要支持可变长度编码必须实现这两组函数。</p><h1 id="ttransportdefaults">TTransportDefaults</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h/TVirtualTransport.h</code></p><p>默认传输类 TTransportDefaults 是 TTransport 的子类，提供了抽象类 TTransport 的默认实现，实现了非虚拟的方法 <code>*_virt()</code> 方法。</p><h1 id="tvirtualtransport">TVirtualTransport</h1><p>源码路径：<code>thrift/lib/cpp/src/thrift/transport/TTransport.h/TVirtualTransport.h</code></p><p>虚拟传输类 TVirtualTransport 采用了模板的方式来实现多继承（同时从两个类继承），也就是说可以从一个默认的类继承，而另一个类采用模板参数传递。而默认传输类的作用就是防止那些没有实现默认传输类实现的方法的子类造成递归调用（死循环了）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Thrift 传输层简单介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://yz1509.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="thrift" scheme="https://yz1509.github.io/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 概述</title>
    <link href="https://yz1509.github.io//posts/56b70/"/>
    <id>https://yz1509.github.io//posts/56b70/</id>
    <published>2019-07-26T15:48:45.000Z</published>
    <updated>2019-10-30T10:04:24.610Z</updated>
    
    <content type="html"><![CDATA[<p>Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括 C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。</p><a id="more"></a><h1 id="软件栈">软件栈</h1><p>Thrift 对软件栈的定义非常的清晰, 使得各个组件能够松散的耦合, 针对不同的应用场景, 选择不同的方式去搭建服务。</p><div data-align="center"><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=8b52d3e0808ba61ecbe3c07d205dfc6f/29381f30e924b8999366ac126c061d950a7bf646.jpg" alt="技术栈" width="400"></div><p><br></p><ul><li>传输层(Transport Layer)：传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议；比如说 TCP/IP 传输、MemoryBuffer 等</li><li>协议层(Protocol Layer)：协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化；比如说 JSON、XML、二进制数据等</li><li>处理层(Processor Layer)：处理层作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口，是由具体的IDL（接口描述语言）生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的 Handler 进行处理</li><li>服务层(Server Layer)：整合上述组件，根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架，提供具体的网络线程/IO 服务模型，形成最终的服务</li><li>业务逻辑层(Your code)</li></ul><p>接下来我们按照自底向上的顺序介绍 thrift 的各个模块。</p><h2 id="传输层transport-layer">传输层(Transport Layer)</h2><p>Transport 与网络数据通信相关，thrift 通信协议有基于 TCP/IP 协议的实现。在现在的网络通信服务器中， TCP/IP 协议栈由 socket 来实现。Thrift 也不例外，在 thrift 源码中，是通过将 socket 包装成各种功能不同的 <code>TTransport</code> 来使用：</p><ul><li><code>TSocket</code>：使用阻塞式 I/O 进行传输，是常见的模式</li><li><code>TNonblockingTransport</code>：使用非阻塞方式，用于构建异步客户端</li><li><code>TFrameTransport</code>：使用非阻塞方式，按块的大小进行传输</li></ul><h2 id="协议层protocol-layer">协议层(Protocol Layer)</h2><p>Protocol 是 transport 的上一层，transport 负责数据传输，protocol 负责对数据进行解析，将数据解析成对应的数据结构代码，供程序直接调用。Thrift 支持各种语言，通过一个 <code>x.thrift</code> 的接口描述文件来通信。Thrift 的接口描述文件是各种语言通用的，其通过 thrift compiler 来生成对应的源代码，例如 C++ 对应的命令为 <code>thrift --gen cpp x.thrift</code>。</p><p>Thrift 可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本(text)和二进制(binary)传输协议。为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li><code>TBinaryProtocol</code>：二进制编码格式进行数据传输</li><li><code>TCompactProtocol</code>：高效率的、密集的二进制编码格式进行数据传输</li><li><code>TJSONProtocol</code>：使用 JSON 文本的数据编码协议进行数据传输</li><li><code>TSimpleJSONProtocol</code>：只提供 JSON 只写的协议，适用于通过脚本语言解析</li></ul><h2 id="处理层processor-layer">处理层(Processor Layer)</h2><p>服务调用组件。 Processor 封装了从输入流读取数据和向输出流写入数据的能力。输入和输出流由 Protocol objectss 表示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface TProcessor &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(TProtocol in, TProtocol out)</span> throws TException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务层server-layer">服务层(Server Layer)</h2><p>Server 主要做以下工作:</p><ul><li>Create a transport</li><li>Create input/output protocols for the transport</li><li>Create a processor based on the input/output protocols</li><li>Wait for incoming connections and hand them off to the processor</li></ul><p>根据单线程/多线程，同步/异步分为以下几种：</p><ul><li><code>TSimpleServer</code>：单线程服务器端，使用标准的阻塞式 I/O</li><li><code>TThreadPoolServer</code>：多线程服务器端，使用标准的阻塞式 I/O</li><li><code>TNonblockingServer</code>：单线程服务器端，使用非阻塞式 I/O</li><li><code>THsHaServer</code>：半同步半异步服务器端，基于非阻塞式 I/O 读写和多线程工作任务处理</li><li><code>TThreadedSelectorServer</code>：多线程选择器服务器端，对 <code>THsHaServer</code> 在异步 I/O 模型上进行增强</li></ul><h1 id="特点">特点</h1><ol type="1"><li><p>开发速度快</p><p>通过编写 RPC 接口 Thrift IDL 文件，利用编译生成器自动生成服务端骨架(Skeletons)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p><ul><li>服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(Handler)即实现类即可。</li><li>客户端：只需要拷贝 IDL 定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。</li></ul></li><li><p>接口维护简单</p><p>通过维护 Thrift 格式的 IDL（接口描述语言）文件（注意写好注释），即可作为给 Client 使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且 Thrift 协议可灵活支持接口的可扩展性。</p></li></ol><h1 id="数据类型">数据类型</h1><p>Thrifty 的数据类型包括预定义的基本类型，容器类型，用户自定义的结构体和异常，以及服务。</p><ol type="1"><li><p>基本类型(Base Type)</p><ul><li><code>bool</code>：布尔值，一个字节</li><li><code>i8(byte)</code>：8 位有符号整数</li><li><code>i16</code>：16 位有符号整数</li><li><code>i32</code>：32 位有符号整数</li><li><code>i64</code>：64 位有符号整数</li><li><code>double</code>：64 位浮点数</li><li><code>binary</code>：一个字节数组</li><li><code>string</code>：编码不可知的文本或二进制字符串</li></ul></li><li><p>容器类型(Container)</p><ul><li><code>list&lt;t&gt;</code>：元素类型为 t 的有序列表，容许元素重复</li><li><code>set&lt;t&gt;</code>：元素类型为 t 的无序表，不容许元素重复</li><li><code>map&lt;k,v&gt;</code>：key/value 映射，key 不允许重复</li><li>其中容器中的元素类型可以是除了 <code>service</code> 外的任何合法 Thrift 类型（包括结构体和异常）</li></ul></li><li><p>结构体类型 <code>struct</code></p><p>Thrift 中的 <code>struct</code> 类似于 C 语言，其在面向对象的语言中转换为 <code>class</code>。一个 <code>struct</code> 其由多个 <code>field</code> 组成，每个 <code>field</code> 包括唯一的整数标识符、<code>type</code>、<code>name</code> 和可选的默认值组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;    <span class="comment">// 没有逗号</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span>&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;</span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;</span><br><span class="line">    <span class="number">5</span>: optional TweetType tweetType = TweetType.TWEET;    <span class="comment">// 详见 enum</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"Endlish"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>field</code> 可用关键字 <code>optional</code> 或 <code>required</code> 进行标识</li><li><code>struct</code> 不能继承，但是可以嵌套，但不能嵌套自己</li><li>同一文件可以定义多个 <code>struct</code>，也可以定义在不同的文件中，利用 <code>include</code> 导入</li></ul></li><li><p>异常类型 <code>exception</code></p><p>异常在语法和功能上相当于结构体，差别是异常使用关键字 <code>exception</code> 而不是 <code>struct</code> 声明。它在语义上不同于结构体：当定义一个 RPC 服务时，开发者可能需要声明一个远程方法抛出一个异常。</p></li><li><p>服务类型 <code>service</code></p><p>服务的定义方法在语义上等同于面向对象语言中的接口，Thrift compiler 将用你所选择的语言据此生成 service interface code (for the server) and stubs (for the client)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service Twitter&#123;</span><br><span class="line">    <span class="comment">// A method definition looks like C code. It has a return type, arguments</span></span><br><span class="line">    <span class="comment">// and optionally a list of exceptions that it may throw. Note that argument</span></span><br><span class="line">    <span class="comment">// lists and exception list are specified using the exact same syntax as</span></span><br><span class="line">    <span class="comment">// field lists in structs.</span></span><br><span class="line">    void ping(),</span><br><span class="line">    bool postTweet(1:Tweet tweet) throws (1:TwitterUnavailable unavailable),</span><br><span class="line">    <span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// The 'oneway' modifier indicates that the client only makes a request and</span></span><br><span class="line">    <span class="comment">// does not wait for any response at all. Oneway methods MUST be void.</span></span><br><span class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数定义可以用分号或者逗号结尾</li><li>参数和返回值类型可以是基本类型或者结构体</li><li><code>void</code> 是函数的有效返回类型</li><li>服务支持继承，一个 <code>service</code> 可使用 <code>extends</code> 关键字继承另一个 <code>service</code></li><li>服务不支持重载</li></ul></li></ol><h1 id="其他特性">其他特性</h1><h2 id="typedef">Typedef</h2><p>Thrift 支持 C/C++ 风格的 typedef</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> i32 MyInteger   <span class="comment">// 结尾无分号</span></span><br><span class="line"><span class="keyword">typedef</span> Tweet ReTweet   <span class="comment">// struct 也可 typedef</span></span><br></pre></td></tr></table></figure><h2 id="enum">enum</h2><p>Thrift 支持 C 风格的 enum ，编译器从 0 开始分配默认值。Thrift 还不支持嵌套枚举，枚举常量大小不超过 32 位正整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType&#123;</span><br><span class="line">    TWEET,</span><br><span class="line">    RETWEET = <span class="number">2</span>,    <span class="comment">// 可以设置特定的整数值</span></span><br><span class="line">    DM = <span class="number">0xa</span>,       <span class="comment">// 支持 16 进制</span></span><br><span class="line">    REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="constant">constant</h2><p>Thrift 允许定义跨语言使用的常量，复杂类型和结构体使用 JSON 格式赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i32 INT_CONST = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; MAP_CONST = &#123;<span class="string">"hello"</span>: <span class="string">"world"</span>, <span class="string">"goodnight"</span>: <span class="string">"Kyoani"</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="generated-filesc">Generated Files(C++)</h1><ul><li>All constants go into a single <code>.cpp/.h</code> pair</li><li>All type definitions (enums and structs) go into another <code>.cpp/.h</code> pair</li><li>Each service gets its own <code>.cpp/.h</code> pair</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree gen-cpp</span><br><span class="line">|-- example_constants.cpp</span><br><span class="line">|-- example_constants.h</span><br><span class="line">|-- example_types.cpp</span><br><span class="line">|-- example_types.h</span><br><span class="line">|-- Twitter.cpp</span><br><span class="line">|-- Twitter.h</span><br><span class="line">`-- Twitter_server.skeleton.cpp</span><br></pre></td></tr></table></figure><p>Thrift 数据类型和 C++ 数据类型对应表</p><table><thead><tr class="header"><th style="text-align: left;">Thrift</th><th style="text-align: left;">C++</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">bool</td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;">byte</td><td style="text-align: left;">int8_t</td></tr><tr class="odd"><td style="text-align: left;">i16</td><td style="text-align: left;">int16_t</td></tr><tr class="even"><td style="text-align: left;">i32</td><td style="text-align: left;">int32_t</td></tr><tr class="odd"><td style="text-align: left;">i64</td><td style="text-align: left;">int64_t</td></tr><tr class="even"><td style="text-align: left;">double</td><td style="text-align: left;">double</td></tr><tr class="odd"><td style="text-align: left;">binary</td><td style="text-align: left;">std::string</td></tr><tr class="even"><td style="text-align: left;">string</td><td style="text-align: left;">std::string</td></tr><tr class="odd"><td style="text-align: left;">list<t1></t1></td><td style="text-align: left;">std::vector<t1></t1></td></tr><tr class="even"><td style="text-align: left;">set<t1></t1></td><td style="text-align: left;">std::set<t1></t1></td></tr><tr class="odd"><td style="text-align: left;">map&lt;t1, t2&gt;</td><td style="text-align: left;">std::map&lt;t1, t2&gt;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括 C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://yz1509.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="thrift" scheme="https://yz1509.github.io/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>后台开发面经</title>
    <link href="https://yz1509.github.io//posts/afaab92b/"/>
    <id>https://yz1509.github.io//posts/afaab92b/</id>
    <published>2018-08-28T03:01:15.000Z</published>
    <updated>2019-10-30T09:55:15.256Z</updated>
    
    <content type="html"><![CDATA[<p>后台开发岗面试可能会遇到遇到的问答记录（正确性无保证，仅供参考）。</p><a id="more"></a><h1 id="c">C++</h1><h2 id="virtual-关键字的作用构造和析构函数能不能定义虚函数为什么">virtual 关键字的作用、构造和析构函数能不能定义虚函数？为什么？</h2><p>基类希望其派生类覆盖的函数，通常将其定义为虚函数，通过指针或引用调用虚函数时，会在运行时解析该调用，在这种情况下对象的动态类型有可能与静态类型不同。这便是 OOP 的核心思想：多态性。</p><p>构造函数不能为虚函数，而析构函数可以且常常是虚函数。</p><p>首先，虚函数的实现原理是：在定义具有虚函数的类或者继承类的继承的时候，会相应建立一个虚函数表 vtable，即每个类都对应一个虚函数表，而在定义类的对象的时候，每个对象都会有一个指向相应类的虚表指针 vptr，vptr 指向虚表的入口地址，在调用相应的虚函数的时候，根据该入口地址寻找对应的函数。</p><p>对于构造函数，其作用是在对象实例化的时候自动调用，对该对象进行初始化操作。前述中提到，虚函数是通过 vptr 来调用的，而调用构造函数的时候实例化并未完成，也就是说此时并不存在vptr，因而，无法使用 vptr 来调用构造函数。</p><p>另一方面，虚函数的调用是虚调用，通过在运行时查询虚函数表得到具体函数入口地址，相当于只需要有部分信息就可以调用该函数。然而定义具体类的对象的时候，需要明确指定对象类型，而且在定义子类对象的时候首先调用的是父类的构造函数然后才是调用子类构造函数，如果使用了虚函数，那么仅仅是调用子类构造函数并不能完成对象的初始化。</p><p>而对于析构函数，则需要定义为虚析构函数，防止内存泄露的发生。在继承的时候， 我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p><h2 id="static-关键字修饰类的成员作用和其他成员函数的区别">static 关键字修饰类的成员作用，和其他成员函数的区别？</h2><p>当使用 static 修饰成员变量和成员函数时，表示该变量或函数属于一个类，而不是该类的某个实例化对象。</p><h2 id="c-调用-c-的关键字-extern-的作用">C++ 调用 C 的关键字 extern 的作用？</h2><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。也就是说extern有两个作用， * 第一，当它与 "C" 一起连用时，如: <code>extern "C" void fun(int a, int b);</code> 则告诉编译器在编译 fun 这个函数名时按着 C 的规则去翻译相应的函数名而不是 C++ 的，C++ 的规则在翻译这个函数名时会把 fun 这个名字变得面目全非，可能是 <code>fun@aBc_int_int#%$</code> 也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为 C++ 支持函数的重载。 * 第二，当 extern 不与 "C" 在一起修饰变量或函数时，如在头文件中: <code>extern int g_Int;</code> 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义！也就是说 B 模块(编译单元)要是引用模块(编译单元) A 中定义的全局变量或函数时，它只要包含 A 模块的头文件即可。在编译阶段，模块 B 虽然找不到该函数或变量，但它不会报错，它会在连接时从模块 A 生成的目标代码中找到此函数。</p><h2 id="map-和-unodered_map-的区别底层的实现">map 和 unodered_map 的区别，底层的实现</h2><ul><li>map：自动排序，底层数据结构为红黑树。</li><li>unoredered_map：乱序，底层数据结构为哈希表（开链法解决哈希冲突）。<ul><li>用一个 vector 来作为一个指针数组来存储节点的指针，_size 来保存当前哈希表中的有效元素个数。</li><li>由于是 K/V 结构，所以选择一个 pair 的结构来存储 K/V。</li><li>vector 中的每一个元素都指向一个链表，所有节点中需要一个 next 域的指针来指向下一个节点（采用单链表表结构）。</li><li>采用模板来实现哈希表可以存储任意数据类型的目的。</li><li>使用了仿函数技术。</li></ul></li></ul><h2 id="哈希冲突如何解决">哈希冲突如何解决</h2><ul><li>开放定址法<ul><li>线性探测再散列</li><li>二次探测再散列</li><li>伪随机探测再散列：增量序列伪随机</li></ul></li><li>再哈希法：同时构造多个不同的哈希函数</li><li>开链（哈希桶）</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ul><h2 id="c-的重载">C++ 的重载</h2><ul><li>函数名字相同但形参列表不同，称之为函数重载(overloaded)</li><li>main 函数不能重载</li><li>顶层 const 的形参和另一个没有顶层 const 不能区分，底层 const 则相反</li></ul><h2 id="c-程序的编译过程">C 程序的编译过程</h2><figure><img src="/posts/afaab92b/GCC_CompilationProcess.png" alt=""><figcaption>编译过程</figcaption></figure><ol type="1"><li>预处理(Preprocessing)：预处理用于将所有的 #include 头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。</li><li>编译(Compilation)：这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码 (assembly code) 的过程。</li><li>汇编(Assemble)：将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。</li><li>链接(Linking)：符号解析和重定位，将程序每一个全局变量和全局函数的引用和符号表里的一个符号对应起来，重定位确定每一个模板模块的全局变量和函数在可执行文件内存空间的位置，将多个目标文以及所需的库文件 (.so等) 链接成最终的可执行文件 (executable file)。</li></ol><h2 id="c-程序的内存空间">C 程序的内存空间</h2><p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。</p><figure><img src="/posts/afaab92b/001.png" alt=""><figcaption>内存分布</figcaption></figure><ul><li>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</li><li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局 const 变量等。</li><li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li><li>BSS 段(.bss)：未初始化的全局变量和局部静态变量一般放在 .bss 的段里，以节省内存空间。</li><li>堆：用来容纳应用程序动态分配的内存区域。当程序使用 malloc 或 new 分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li><li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li><li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li><li>保留区：内存中受到保护而禁止访问的内存区域。</li></ul><h2 id="mallocfree-与-newdelete-的区别">malloc/free 与 new/delete 的区别</h2><ul><li>malloc 与 free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请和释放动态内存。</li><li>对于非内部数据类型的对象而言，用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free，因此C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，和一个能完成清理与释放内存工作的运算符 delete。</li><li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void* 指针。new/delete 在实现上其实调用了 malloc/free 函数。</li><li>new 建立的是一个对象；malloc 分配的是一块内存。</li></ul><h2 id="析构函数的作用">析构函数的作用</h2><p>释放对象使用的资源，并销毁非 static 成员。</p><h2 id="堆和栈的区别">堆和栈的区别</h2><ol type="1"><li>申请管理方式<ul><li>栈：由编译器自动管理，无需我们手工控制。</li><li>堆：堆的申请和释放工作由程序员控制，容易产生内存泄漏。</li></ul></li><li>申请后系统的响应<ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li>申请大小的限制<ul><li>栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 1 M（可修改），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li>申请效率的比较<ul><li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li><li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在 Windows 下，最好的方式是用 VirtualAlloc 分配内存，它不是在堆，也不是在栈而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li></ul></li><li>堆与栈中的存储内容<ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li></ul></li></ol><p><strong>总结</strong>：堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；并且可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，ebp 和局部变量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是向堆申请内存更加灵活，有时候分配大量的内存空间，还是用堆好一些。</p><h2 id="重载-new-运算符什么时候需要重载">重载 new 运算符：什么时候需要重载</h2><ul><li>为了检测运用上的错误</li><li>为了收集动态分配内存的使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><hr><ul><li>lambda 的实质（编译器层面）</li></ul><h1 id="操作系统">操作系统</h1><h2 id="大端小端的区别应用以及如何判断大端小端">大端小端的区别、应用以及如何判断大端小端？</h2><p><code>低地址 --------------------&gt; 高地址</code> <code>0x12  |  0x34  |  0x56  |  0x78</code></p><ul><li>大端模式：Big-Endian 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</li></ul><p><code>低地址 --------------------&gt; 高地址</code> <code>0x78  |  0x56  |  0x34  |  0x12</code></p><ul><li>小端模式：Little-Endian 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li></ul><p><strong>区别</strong>：大端小端没有谁优谁劣，各自优势便是对方劣势</p><ul><li>大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</li><li>小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。</li></ul><p><strong>应用</strong>：一般操作系统都是小端，而通讯协议是大端的。</p><ul><li>常见 CPU 的字节序<ul><li>Big Endian : PowerPC、IBM、Sun</li><li>Little Endian : x86、DEC</li><li>ARM既可以工作在大端模式，也可以工作在小端模式。</li></ul></li><li>常见文件的字节序<ul><li>Big Endian：Adobe PS、JPEG、MacPaint</li><li>Little Endian：BMP、GIF、RTF</li></ul></li></ul><p><strong>判断</strong></p><ul><li>通过将 int 强制类型转换成 char 单字节，通过判断起始存储位置</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">char</span> b = *(<span class="keyword">char</span> *)&amp;a;  <span class="comment">//等于 取b等于a的低地址部分  </span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>联合体 union 的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了 CPU 对内存采用 Little-endian 还是 Big-endian 模式读写</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> NUM</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">    &#125;num;</span><br><span class="line">    num.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">if</span> (num.b == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程和进程的区别">线程和进程的区别</h2><p>进程是资源分配的基本单位；线程是独立调度的基本单位。</p><p><strong>区别</strong></p><p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p><h2 id="一个进程有-10-个线程如果-down-掉一个线程会不会对其他的有影响">一个进程有 10 个线程，如果 down 掉一个线程会不会对其他的有影响？</h2><p>有！因为线程没有自己单独的内存地址空间，所以一个线程挂掉会导致整个进程挂掉。</p><h2 id="什么情况下会发生死锁解决策略有哪些">什么情况下会发生死锁，解决策略有哪些？</h2><p><strong>死锁的必要条件</strong></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><p><strong>解决策略</strong></p><ul><li>鸵鸟策略：忽略它。</li><li>死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。三种恢复手段：<ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul></li><li>死锁预防：在程序运行之前预防发生死锁。<ul><li>破坏互斥条件</li><li>破坏占有和等待条件</li><li>破坏不可抢占条件</li><li>破坏环路等待</li></ul></li><li>死锁避免：在程序运行时避免发生死锁。</li></ul><h2 id="用户态和内核态">用户态和内核态</h2><ul><li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。只能受限的访问内存, 且不允许访问外围设备. 占用 CPU 的能力被剥夺, CPU 资源可以被其他程序获取</li><li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。CPU 可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU 也可以将自己从一个程序切换到另一个程序</li></ul><p><strong>用户态切换为内核态的三种情况</strong></p><ol type="1"><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断。</li><li>异常事件： 当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li><li>外围设备的中断：当外围设备完成用户的请求操作后，会向 CPU 发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li></ol><p>从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h2 id="执行一个系统调用时os-发生的过程越详细越好">执行一个系统调用时，OS 发生的过程，越详细越好</h2><p>系统调用, 在 CPU 中的实现称之为陷阱指令 (Trap Instruction)，工作流程如下:</p><ol type="1"><li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.</li><li>用户态程序执行陷阱指令</li><li>CPU 切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li><li>这些指令称之为陷阱 (trap) 或者系统调用处理器 (system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li><li>系统调用完成后, 操作系统会重置 CPU 为用户态并返回系统调用的结果</li></ol><h2 id="执行一个-io-调用读写文件到把数据写进磁盘发生的所有过程越详细越好">执行一个 IO 调用读/写文件，到把数据写进磁盘发生的所有过程，越详细越好</h2><p><strong>读文件</strong></p><ol type="1"><li>进程调用库函数向内核发起读文件请求；</li><li>内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</li><li>调用该文件可用的系统调用函数 read()</li><li>read() 函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的 inode；</li><li>在 inode 中，通过文件内容偏移量计算出要读取的页；</li><li>通过 inode 找到文件对应的 address_space；</li><li>在 address_space 中访问该文件的页缓存树，查找对应的页缓存结点：<ul><li>如果页缓存命中，那么直接返回文件内容；</li><li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode 找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第 7 步查找页缓存；</li></ul></li><li>文件内容读取成功。</li></ol><p><strong>写文件</strong></p><p>前 6 步和读文件一致，在 address_space 中查询对应页的页缓存是否存在：</p><ol start="7" type="1"><li>如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</li><li>如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode 找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第 7 步。</li><li>一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：<ul><li>手动调用 sync() 或者 fsync() 系统调用把脏页写回</li><li>pdflush 进程会定时把脏页写回到磁盘 同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</li></ul></li></ol><hr><ul><li><p>内核态的函数调用和用户态的函数调用有何区别？</p></li><li><p>一个二进制文件从执行到打印结果操作系统做了什么（从切换（PCB、寄存器）、权限、内存（缺页异常、地址转化之类的）、磁盘（inode之类的）、用户态内核态之类的说了一遍，把还记着的操作系统知识全部编进去了）</p></li><li><p>项目里如何设计缓存来减少不必要的 IO？</p></li><li><p>GDB 用过吗？怎么下断点，怎么追踪？死锁应该怎么调试？</p><ul><li>GDB：UNIX及UNIX-like下的调试工具。</li></ul></li><li><p>查内存泄露用什么工具？</p><ul><li>Leakdiag.</li></ul></li></ul><h1 id="计算机网络">计算机网络</h1><h2 id="网络的-4-层结构tcp协议属于哪一层">网络的 4 层结构？TCP协议属于哪一层？</h2><div data-align="center"><img src="/posts/afaab92b/426df589-6f97-4622-b74d-4a81fcb1da8e.png" width="600"></div><p><br></p><p><strong>五层协议</strong></p><ul><li><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</p></li><li><p><strong>运输层</strong> ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p><strong>网络层</strong> ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</p></li><li><p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><h2 id="tcp-和-udp-的区别">TCP 和 UDP 的区别</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h2 id="tcp-和-udp-的优缺点">TCP 和 UDP 的优缺点</h2><ul><li>TCP<ul><li>优点：可靠，稳定。TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，会断开连接用来节约系统资源。</li><li>缺点：慢，效率低，占用系统资源高，易被攻击。TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。 而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</li><li>使用场景：当对网络通讯可靠性有要求的时候。比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。 在日常生活中，常见使用 TCP 协议的应用如下： 浏览器，用的 HTTP；FlashFXP，用的 FTP；Outlook，用的POP、SMTP；Putty，用的 Telnet、SSH QQ 文件传输</li></ul></li><li>UDP<ul><li>优点：快，比TCP稍安全。UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood攻击</li><li>缺点：不可靠，不稳定。因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li><li>使用场景： 当对网络通讯可靠性要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 比如，日常生活中，常见使用U DP 协议的应用如下： QQ 语音、QQ 视频、TFTP、长视频等</li></ul></li></ul><h2 id="udp-如何实现可靠性传输">UDP 如何实现可靠性传输</h2><p>UDP 它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 TCP 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><p>实现确认机制、重传机制、窗口确认机制。</p><p>如果你不利用 Linux 协议栈以及上层 socket 机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</p><ul><li>发送：包的分片、包确认、包的重发</li><li>接收：包的调序、包的序号确认</li></ul><p>目前有如下开源程序利用 UDP 实现了可靠的数据传输。分别为 RUDP、RTP、UDT。</p><ul><li>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</li><li>实时传输协议（RTP）为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码</li><li>基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</li></ul><h2 id="tcp-首部格式">TCP 首部格式</h2><div data-align="center"><img src="/posts/afaab92b/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"></div><p><br></p><ul><li><p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="tcp-三次握手四次挥手的过程最后等待关闭连接要多长时间">TCP 三次握手，四次挥手的过程？最后等待关闭连接要多长时间？</h2><p><strong>三次握手</strong></p><div data-align="center"><img src="/posts/afaab92b/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"></div><p><br></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>四次挥手</strong></p><div data-align="center"><img src="/posts/afaab92b/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"></div><p><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h2 id="tcp-有哪些状态closed-状态出现在什么时候">TCP 有哪些状态，CLOSED 状态出现在什么时候？</h2><figure><img src="/posts/afaab92b/1350996969_2313.jpg" alt=""><figcaption>TCP 状态</figcaption></figure><p>全部共 11 种状态。</p><ul><li>客户端独有的：<ul><li>SYN_SENT</li><li>FIN_WAIT1</li><li>FIN_WAIT2</li><li>CLOSING</li><li>TIME_WAIT</li></ul></li><li>服务器独有的：<ul><li>LISTEN</li><li>SYN_RCVD</li><li>CLOSE_WAIT</li><li>LAST_ACK</li></ul></li><li>共有的<ul><li>CLOSED</li><li>ESTABLISHED</li></ul></li></ul><p>客户端 TCP 状态迁移： <code>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</code></p><p>服务器 TCP 状态迁移： <code>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</code></p><h2 id="tcp-用了哪些措施保证其可靠性">TCP 用了哪些措施保证其可靠性</h2><ul><li>连接管理：TCP 是面向连接的，三次握手和四次挥手都是为了保证本次数据传送的可靠性</li><li>序号：TCP 是面向字节流的，它对每一个字节都进行了编号，保证数据段的按序到达</li><li>确认应答机制：TCP 通过确认应答机制实现可靠的数据传输。在 TCP 的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位 ACK = 1 时确认首部的确认字段有效。进行确认时，确认号的值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。</li><li>超时重传机制：主机A发送给主机B数据报后一段时间内如果没有收到主机B对应的确认报文，就认为这一个或者这几个数据报都丢失了，即触发重传机制，重新发送没有被确认的报文。</li><li>流量控制：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。 因此 TCP 中引入了流量控制机制，意思就是根据接收端处理数据的能力来控制发送端发送数据的速度。</li><li>拥塞控制：如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</li></ul><h2 id="http-100-206-304-是什么-304-中-xxxxx-的-header-有什么作用">http 100 206 304 是什么？ 304 中 xxxxx 的 header 有什么作用？</h2><ul><li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li><li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li></ul><h2 id="http2.0了解吗做了什么优化处理">HTTP/2.0了解吗？做了什么优化处理？</h2><p><strong>HTTP/1.x 缺陷</strong></p><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><p><strong>HTTP/2.0 优化</strong></p><p>（1） 二进制分帧层</p><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p>（2） 服务端推送</p><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p>（3） 首部压缩</p><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><h2 id="sack-和-mss-这两个东西了解过吗">SACK 和 MSS 这两个东西了解过吗？</h2><ul><li>SACK：SACK(Selective ACK) 是 TCP 选项，它使得接收方能告诉发送方哪些报文段丢失，哪些报文段重传了，哪些报文段已经提前收到等信息。根据这些信息 TCP 就可以只重传哪些真正丢失的报文段。需要注意的是只有收到失序的分组时才会可能会发送 SACK，TCP 的 ACK 还是建立在累积确认的基础上的。也就是说如果收到的报文段与期望收到的报文段的序号相同就会发送累积的 ACK，SACK 只是针对失序到达的报文段的。SACK 包括了两个 TCP 选项，一个选项用于标识是否支持 SACK，是在 TCP 连接建立时发送；另一种选项则包含了具体的 SACK 信息。当我们接收到 ACK 的时候，我们会判断 SACK 段，如果包含 SACK 段的话，我们就要进行处理。</li><li>MSS：最大报文段长度 MSS 选项是 TCP 协议定义的一个选项，MSS 选项用于在TCP 连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。</li></ul><hr><ul><li>如何完全消除 time await？<ul><li>当初回答的时候设置属性和reuse都是判错的，要求从最后挥手的阶段开始分析</li></ul></li><li>怎么样设计一个比较好的函数完全读出一个 socket 的所有数据</li></ul><h1 id="算法题">算法题</h1><ol type="1"><li>二叉树两个节点之间距离</li></ol><p>假设 lca 是两个节点的最低公共祖先节点： <span class="math inline">\(Dist(n_1,n_2) = Dist(root,n_1) + Dist(root,n_2) - 2 \cdot Dist(root,lca)\)</span></p><hr><ul><li><p>一个不知道头节点的单链表，如何在 p 节点前插入一个节点？</p></li><li><p>1 亿个数字取 Top K。分成多个小文件，用小跟堆，堆排取小文件 Top k。之后再用外排或者继续堆排取所有的 Top k。</p></li><li><p>1000w个整数排序，范围0到100w，8g内存</p></li><li><p>非递归完成二叉树的先序遍历</p></li><li><p>实现查询链表的倒数第1000个节点</p></li><li><p>1000万个关键字，每个关键字小于等于50字节，求前K个热词，内存为1M</p></li><li><p>无向图两点之间最小跳数（深度优先）</p></li><li><p>数字数组中最长连续递增序列</p></li><li><p>100W个无序数中是否包含给出的K个元素</p></li><li><p>100W个数字中前K大的数字</p></li><li><p>两个 1T 文件使用 4G 内存比较相似度</p></li><li><p>对单词进行排序，比如 aa cee ee bb a 排序过后为 a aa bb cee ee</p></li><li><p>反转链表</p></li></ul><h1 id="数据库">数据库</h1><ul><li>数据库有啥索引，区别是什么，哪个插入快？为什么？你刚才提到了 B+Tree 索引，介绍一下B TREE 和 B+TREE，他们的区别是啥？</li><li>左连接</li></ul><h1 id="linux">Linux</h1><ul><li><p>Linux 下改变文件权限的命令有哪些？</p></li><li><p>硬链接和软链接的区别？</p></li><li><p>Linux 下查看程序内存状况</p><ul><li>top 指令可以查看按内存大小排序的查询内存状况，或者查看 /proc/pid/status 文件，这个文件会记录进程 id 所代表的进程的内存状态</li></ul></li><li><p>Linux 统计文本中每行第二个字段的和（awk搞定）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后台开发岗面试可能会遇到遇到的问答记录（正确性无保证，仅供参考）。&lt;/p&gt;
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="后台开发" scheme="https://yz1509.github.io/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
      <category term="面经" scheme="https://yz1509.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="https://yz1509.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="https://yz1509.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://yz1509.github.io/tags/Linux/"/>
    
      <category term="算法" scheme="https://yz1509.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>运维开发工程师面经</title>
    <link href="https://yz1509.github.io//posts/7543f9ab/"/>
    <id>https://yz1509.github.io//posts/7543f9ab/</id>
    <published>2018-08-18T04:34:54.000Z</published>
    <updated>2019-10-30T09:59:49.325Z</updated>
    
    <content type="html"><![CDATA[<p>我不会运维，也不懂开发，仅供参考。</p><a id="more"></a><p>整理自牛客网<strong>傻妞妞-MM</strong>的<a href="https://www.nowcoder.com/discuss/50625" target="_blank" rel="noopener">面经</a>。</p><h1 id="linux-系统">Linux 系统</h1><ul><li>基本命令（系统性能信息的各种查看命令、可能会继续向下延伸：比如实时 CPU 负载的获取、网卡流量的抓包获取等，建议有多详细整理多详细。防火墙，文件查看，各种常用命令，请参考鸟哥基础等等。）；</li><li>开机启动过程，run level 各个级别的意思；</li><li>文件系统区别；</li><li>shell 脚本对于日志文件获取有用信息的处理；</li><li>shell 中常使用参数的意义；</li><li>Awk、sed 等工具的使用；</li><li>软链接、硬链接；</li><li>常见的运维相关知识；</li></ul><h1 id="计算机网络">计算机网络</h1><h2 id="tcp-和-udp">TCP 和 UDP</h2><h3 id="tcp-和-udp-的区别">TCP 和 UDP 的区别</h3><ul><li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h3 id="三次握手四次挥手以及其中各个状态的转换为什么是三次和四次time_wait-等待的意义">三次握手四次挥手，以及其中各个状态的转换，为什么是三次和四次？Time_wait 等待的意义？</h3><p><strong>TCP 的三次握手</strong></p><div data-align="center"><img src="/posts/7543f9ab/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"></div><p><br></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>TCP 的四次挥手</strong></p><div data-align="center"><img src="/posts/7543f9ab/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"></div><p><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h3 id="tcp-保证可靠的传输机制">TCP 保证可靠的传输机制</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h3 id="tcp-滑动窗口和回退-n-帧协议">TCP 滑动窗口和回退 N 帧协议</h3><p><strong>TCP 滑动窗口</strong></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><div data-align="center"><img src="/posts/7543f9ab/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"></div><p><br></p><p><strong>回退 N 帧协议</strong></p><p>当有错误帧出现后，总是要重发该帧之后的所有帧</p><h3 id="tcp-的流量控制">TCP 的流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="tcp-的拥塞控制拥塞控制中的四个算法">TCP 的拥塞控制，拥塞控制中的四个算法</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><div data-align="center"><img src="/posts/7543f9ab/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"></div><p><br></p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><div data-align="center"><img src="/posts/7543f9ab/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"></div><p><br></p><div data-align="center"><img src="/posts/7543f9ab/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"></div><p><br></p><h3 id="syn-攻击以及解决办法">SYN 攻击以及解决办法</h3><p><strong>SYN 攻击原理</strong></p><p>SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以实施。</p><p>服务器接收到连接请求（syn=j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p><p><strong>SYN 攻击防范技术</strong></p><p>主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固 TCP/IP 协议栈防范。但必须清楚的是，SYN 攻击不能完全被阻止，我们所做的是尽可能的减轻 SYN 攻击的危害，除非将 TCP 协议重新设计。</p><ol type="1"><li>过滤网关防护</li></ol><p>这里，过滤网关主要指明防火墙，当然路由器也能成为过滤网关。防火墙部署在不同网络之间，防范外来非法攻击和防止保密信息外泄，它处于客户端和服务器之间，利用它来防护 SYN 攻击能起到很好的效果。过滤网关防护主要包括超时设置，SYN 网关和 SYN 代理三种。</p><ul><li>网关超时设置：防火墙设置 SYN 转发超时参数（状态检测的防火墙可在状态表里面设置），该参数远小于服务器的 timeout 时间。当客户端发送完 SYN 包，服务端发送确认包后（SYN+ACK），防火墙如果在计数器到期时还未收到客户端的确认包（ACK），则往服务器发送 RST 包，以使服务器从队列中删去该半连接。值得注意的是，网关超时参数设置不宜过小也不宜过大，超时参数设置过小会影响正常的通讯，设置太大，又会影响防范 SYN 攻击的效果，必须根据所处的网络应用环境来设置此参数。</li><li>SYN 网关：SYN 网关收到客户端的 SYN 包时，直接转发给服务器；SYN 网关收到服务器的 SYN/ACK 包后，将该包转发给客户端，同时以客户端的名义给服务器发 ACK 确认包。此时服务器由半连接状态进入连接状态。当客户端确认包到达时，如果有数据则转发，否则丢弃。事实上，服务器除了维持半连接队列外，还要有一个连接队列，如果发生 SYN 攻击时，将使连接队列数目增加，但一般服务器所能承受的连接数量比半连接数量大得多，所以这种方法能有效地减轻对服务器的攻击。</li><li>SYN 代理：当客户端 SYN 包到达过滤网关时，SYN 代理并不转发 SYN 包，而是以服务器的名义主动回复SYN/ACK包给客户，如果收到客户的ACK包，表明这是正常的访问，此时防火墙向服务器发送ACK包并完成三次握手。SYN代理事实上代替了服务器去处理SYN攻击，此时要求过滤网关自身具有很强的防范SYN攻击能力。</li></ul><ol start="2" type="1"><li>加固 TCP/IP 协议栈</li></ol><p>防范 SYN 攻击的另一项主要技术是调整 TCP/IP 协议栈，修改 TCP 协议实现。主要方法有 SynAttackProtect 保护机制、SYN cookies 技术、增加最大半连接和缩短超时时间等。TCP/IP 协议栈的调整可能会引起某些功能的受限，管理员应该在进行充分了解和测试的前提下进行此项工作。</p><ul><li>SynAttackProtect 机制：SynAttackProtect 机制是通过关闭某些 socket 选项，增加额外的连接指示和减少超时时间，使系统能处理更多的 SYN 连接，以达到防范 SYN 攻击的目的。</li><li>SYN cookies 技术：我们知道，TCP 协议开辟了一个比较大的内存空间 backlog 队列来存储半连接条目，当 SYN 请求不断增加， 致使系统丢弃 SYN 连接。为使半连接队列被塞满的情况下，服务器仍能处理新到的 SYN 请求，SYN cookies技术被设计出来。</li></ul><p>SYN cookies 应用于 linux、FreeBSD 等操作系统，当半连接队列满时，SYN　cookies 并不丢弃 SYN 请求，而是通过加密技术来标识半连接状态。</p><p>在 TCP 实现中，当收到客户端的 SYN 请求时，服务器需要回复 SYN+ACK 包给客户端，客户端也要发送确认包给服务器。通常，服务器的初始序列号由服务器按照一定的规律计算得到或采用随机数，但在 SYN cookies 中，服务器的初始序列号是通过对客户端 IP 地址、客户端端囗、服务器 IP 地址和服务器端囗以及其他一些安全数值等要素进行 hash 运算，加密得到的，称之为 cookie。当服务器遭受 SYN 攻击使得 backlog 队列满时，服务器并不拒绝新的 SYN 请求，而是回复 cookie（回复包的 SYN 序列号）给客户端， 如果收到客户端的 ACK 包，服务器将客户端的ACK序列号减去1得到 cookie 比较值，并将上述要素进行一次 hash 运算，看看是否等于此 cookie。如果相等，直接完成三次握手（注意：此时并不用查看此连接是否属于 backlog 队列）。</p><ul><li>增加最大半连接数：大量的 SYN 请求导致未连接队列被塞满，使正常的 TCP 连接无法顺利完成三次握手，通过增大未连接队列空间可以缓解这种压力。当然 backlog 队列需要占用大量的内存资源，不能被无限的扩大。</li><li>增加最大半连接数：大量的 SYN 请求导致未连接队列被塞满，使正常的 TCP 连接无法顺利完成三次握手，通过增大未连接队列空间可以缓解这种压力。当然 backlog 队列需要占用大量的内存资源，不能被无限的扩大。</li></ul><h2 id="http">HTTP</h2><h3 id="常见状态码">常见状态码</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr class="header"><th style="text-align: center;">状态码</th><th style="text-align: center;">类别</th><th style="text-align: center;">原因短语</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1XX</td><td style="text-align: center;">Informational（信息性状态码）</td><td style="text-align: center;">接收的请求正在处理</td></tr><tr class="even"><td style="text-align: center;">2XX</td><td style="text-align: center;">Success（成功状态码）</td><td style="text-align: center;">请求正常处理完毕</td></tr><tr class="odd"><td style="text-align: center;">3XX</td><td style="text-align: center;">Redirection（重定向状态码）</td><td style="text-align: center;">需要进行附加操作以完成请求</td></tr><tr class="even"><td style="text-align: center;">4XX</td><td style="text-align: center;">Client Error（客户端错误状态码）</td><td style="text-align: center;">服务器无法处理请求</td></tr><tr class="odd"><td style="text-align: center;">5XX</td><td style="text-align: center;">Server Error（服务器错误状态码）</td><td style="text-align: center;">服务器处理请求出错</td></tr></tbody></table><h3 id="长连接短连接">长连接、短连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="get-和-post-的区别">Get 和 Post 的区别</h3><p>（一） 作用</p><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><p>（二） 参数</p><ul><li>GET 和 POST 的请求都能使用额外的参数</li><li>GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中</li><li>URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参考支持标准字符集。</li></ul><p>（三） 安全</p><ul><li>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</li><li>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</li></ul><p>（四） 幂等性</p><ul><li>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</li><li>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 &gt; DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样 &gt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">&gt; DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><p>（五） 可缓存</p><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><p>（六） XMLHttpRequest</p><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h3 id="http-版本的区别">HTTP 版本的区别</h3><ul><li><p>HTTP/1.1 默认是长连接</p></li><li><p>HTTP/1.1 支持管线化处理</p></li><li><p>HTTP/1.1 支持同时打开多个 TCP 连接</p></li><li><p>HTTP/1.1 支持虚拟主机</p></li><li><p>HTTP/1.1 新增状态码 100</p></li><li><p>HTTP/1.1 支持分块传输编码</p></li><li><p>HTTP/1.1 新增缓存处理指令 max-age</p></li></ul><h3 id="https">HTTPS</h3><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><div data-align="center"><img src="/posts/7543f9ab/ssl-offloading.jpg" width="700"></div><p><br></p><p><strong>加密</strong></p><p>（一） 对称密钥加密</p><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><div data-align="center"><img src="/posts/7543f9ab/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" width="600"></div><p><br></p><p>（二） 非对称密钥加密</p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><div data-align="center"><img src="/posts/7543f9ab/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" width="600"></div><p><br></p><p>（三） HTTPs 采用的加密方式</p><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p><div data-align="center"><img src="/posts/7543f9ab/How-HTTPS-Works.png" width="600"></div><p><br></p><p><strong>认证</strong></p><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><div data-align="center"><img src="/posts/7543f9ab/2017-06-11-ca.png" width=""></div><p><br></p><p><strong>完整性保护</strong></p><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><p><strong>HTTPs 的缺点</strong></p><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="dns">DNS</h2><h3 id="dns-的解析过程">DNS 的解析过程</h3><div data-align="center"><img src="/posts/7543f9ab/dns.jpg" width=""></div><p><br></p><ul><li>DNS 中的字段</li><li>DNS 的工作原理是什么？</li><li>如果 DNS 解析出现错误，怎么解决？</li></ul><h2 id="常见的其他问题">常见的其他问题</h2><h3 id="ping-和-traceroute-的工作原理">Ping 和 Traceroute 的工作原理</h3><p>网际控制报文协议 ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p><strong>Traceroute</strong></p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h3 id="路由器和交换机的区别">路由器和交换机的区别</h3><p><strong>路由器</strong></p><p>路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。</p><p><strong>交换机</strong></p><p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p><p><strong>区别</strong></p><p>（一） 工作所在的OSI层次不一样（根本区别，导致接下来的区别）</p><ul><li>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单；</li><li>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。</li></ul><p>（二） 数据转发所依据的对象也不一样。</p><ul><li>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。</li><li>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。</li></ul><p>（三） 是否可以分割广播域</p><ul><li>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵；</li><li>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。</li></ul><h3 id="输入网址后背后发生了什么">输入网址后，背后发生了什么？</h3><ol type="1"><li>浏览器发起 DNS 查询请求</li><li>域名服务器向客户端返回查询结果域名，从而完成域名到 IP 地址的转换。</li><li>客户端向 web 服务器发送 HTTP 请求</li><li>web 服务器发送响应数据给客户端</li></ol><h3 id="io-模型以及同步异步阻塞非阻塞的区别">I/O 模型以及同步异步阻塞非阻塞的区别</h3><p><strong>I/O 模型</strong> 一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 下有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><p><strong>阻塞式 I/O</strong></p><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><div data-align="center"><img src="/posts/7543f9ab/1492928416812_4.png"></div><p><br></p><p><strong>非阻塞式 I/O</strong></p><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><div data-align="center"><img src="/posts/7543f9ab/1492928416812_4.png"></div><p><br></p><p><strong>同步 I/O 与异步 I/O</strong></p><ul><li>同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。</li><li>异步 I/O：不会阻塞。 阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</li></ul><h3 id="bs和cs的区别">B/S和C/S的区别</h3><p>Client/Server 是建立在局域网的基础上的。Browser/Server 是建立在广域网的基础上的，但并不是说B/S结构不能在局域网上使用，如智赢 IPOWER，在单机，局限网，广域网均能使用。</p><p>1．硬件环境不同:</p><ul><li>C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务.</li><li>B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行</li></ul><p>2．对安全要求不同</p><ul><li>C/S 对服务端、客户端都安全都要考虑。</li><li>B/S 因没有客户端，所以只注重服务端安全即可。</li></ul><p>3．对程序架构不同</p><ul><li>C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.</li><li>B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. 例如智赢IPOWER，采用AJAX和数据存储优化技术，相比一般B/S架构软件速度提高 30%至99%。</li></ul><p>4．软件重用不同</p><ul><li>C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.</li><li>B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子</li></ul><p>5．系统维护不同</p><ul><li>C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统</li><li>B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</li></ul><p>6．处理问题不同</p><ul><li>C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统</li><li>B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小.</li></ul><p>7．用户接口不同</p><ul><li>C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高</li><li>B/S 建立在浏览器上, 通过WEB服务或其他公共可识别描述语言可跨平台，使用更灵活。不仅可应用在Window平台上，还可应用于unix/Linux等平台。</li></ul><p>8．信息流不同</p><ul><li>C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低</li><li>B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更象交易中心。</li></ul><hr><ol type="1"><li>路由协议OSPF、BGP的区别（这个一般很少问，除非你说你懂网络协议）</li></ol><h1 id="操作系统">操作系统</h1><h2 id="进程和线程的区别">进程和线程的区别</h2><p>进程是资源分配的基本单位，线程是独立调度的基本单位。 （一）拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>（二）调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>（三）系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>（四）通信方面 进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p><h2 id="进程的状态进程的切换方式">进程的状态？进程的切换方式？</h2><div data-align="center"><img src="/posts/7543f9ab/ProcessState.png" width="480"></div><p><br></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="进程同步的方式有哪些">进程同步的方式有哪些</h2><ul><li>信号量</li><li>管程</li></ul><h2 id="进程的通信方式有哪些">进程的通信方式有哪些</h2><ul><li>管道</li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>套接字</li></ul><h2 id="操作系统的常见进程调度算法">操作系统的常见进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><p><strong>批处理系统</strong> 批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><ul><li>先来先服务 first-come first-serverd（FCFS）</li><li>短作业优先 shortest job first（SJF）</li><li>最短剩余时间优先 shortest remaining time next（SRTN）</li></ul><p><strong>交互式系统</strong> 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><ul><li>时间片轮转</li><li>优先级调度</li><li>多级反馈队列</li></ul><h2 id="死锁的四个条件解决与避免的方法">死锁的四个条件，解决与避免的方法</h2><p><strong>死锁的四个条件</strong></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><p><strong>办法</strong></p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h2 id="分页和分段有什么区别">分页和分段有什么区别</h2><ul><li>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</li><li>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</li><li><strong>段页式</strong>：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</li></ul><p><strong>分页与分段的比较</strong></p><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><hr><ol type="1"><li>数据从内存写到磁盘上发生的过程，具体行为是什么？</li></ol><h1 id="数据库">数据库</h1><h2 id="事务">事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h3 id="acid性质其中各个性质的含义">ACID性质，其中各个性质的含义</h3><ol type="1"><li>原子性（Atomicity）</li></ol><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><ol start="2" type="1"><li>一致性（Consistency）</li></ol><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><ol start="3" type="1"><li>隔离性（Isolation）</li></ol><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><ol start="4" type="1"><li>持久性（Durability）</li></ol><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p><h3 id="脏读丢失修改不可重复读幻影读">脏读、丢失修改、不可重复读、幻影读</h3><p><strong>丢失修改</strong></p><p><span class="math inline">\(T_1\)</span> 和 <span class="math inline">\(T_2\)</span> 两个事务都对一个数据进行修改，<span class="math inline">\(T_1\)</span> 先修改，<span class="math inline">\(T_2\)</span> 随后修改，<span class="math inline">\(T_2\)</span> 的修改覆盖了 <span class="math inline">\(T_1\)</span> 的修改。</p><p><strong>脏读</strong></p><p><span class="math inline">\(T_1\)</span> 修改一个数据，<span class="math inline">\(T_2\)</span> 随后读取这个数据。如果 <span class="math inline">\(T_1\)</span> 撤销了这次修改，那么 <span class="math inline">\(T_2\)</span> 读取的数据是脏数据。</p><p><strong>不可重复读</strong></p><p><span class="math inline">\(T_2\)</span> 读取一个数据，<span class="math inline">\(T_1\)</span> 对该数据做了修改。如果 <span class="math inline">\(T_2\)</span> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><strong>幻影读</strong></p><p><span class="math inline">\(T_1\)</span> 读取某个范围的数据，<span class="math inline">\(T_2\)</span> 在这个范围内插入新的数据，<span class="math inline">\(T_1\)</span> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。（统计求和等）</p><h3 id="隔离级别">隔离级别</h3><ul><li>未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。</li><li>提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同样数据的结果是一样的。</li><li>可串行化（SERIALIZABLE）：强制事务串行执行。</li></ul><table><thead><tr class="header"><th style="text-align: center;">隔离级别</th><th style="text-align: center;">脏读</th><th style="text-align: center;">不可重复读</th><th style="text-align: center;">幻影读</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">未提交读</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">提交读</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">可重复读</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">可串行化</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr></tbody></table><h2 id="数据库的锁机制">数据库的锁机制</h2><p><strong>封锁粒度</strong></p><ul><li>行级锁</li><li>表级锁</li></ul><p><strong>封锁类型</strong></p><ul><li>读写锁<ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul></li><li>意向锁：IX 、IS</li></ul><p><strong>封锁协议</strong></p><ul><li>三级封锁协议<ul><li>一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</li><li>二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</li><li>三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</li></ul></li><li>两段锁协议<ul><li>加锁和解锁分为两个阶段进行。</li><li>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</li></ul></li></ul><hr><ul><li>常见的SQL语句（内外联结）</li><li>索引、视图</li><li>Mysql 常见的引擎及区别</li><li>Mysql 的四种日志的意义</li><li>数据库的备份等</li><li>Mysql 的优化</li><li>Mysql 的复制</li></ul><h1 id="python">Python</h1><h2 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h2><p>在 python 中，对象赋值实际上是对象的引用。当创建一个对象，然后把它赋给另一个变量的时候，python 并没有拷贝这个对象，而只是拷贝了这个对象的引用。</p><ol type="1"><li>直接赋值，传递对象的引用而已，原始列表改变，被赋值的 b 也会做相同的改变</li><li>copy 浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>deepcopy 深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变</li></ol><hr><ul><li>闭包、装饰器</li><li>迭代器、生成器</li><li>多线程</li><li>内存管理</li><li>垃圾回收机制</li><li>*args,**kwargs</li></ul><h1 id="数据结构">数据结构</h1><ul><li>常见的<a href="https://yz1509.xyz/posts/7474c898/" target="_blank" rel="noopener">查找</a>、<a href="https://yz1509.xyz/posts/735e5788/" target="_blank" rel="noopener">排序</a>算法</li><li><a href="https://yz1509.xyz/posts/ee040603/" target="_blank" rel="noopener">图</a>、<a href="https://yz1509.xyz/posts/7b216a3b/" target="_blank" rel="noopener">树</a>、链表等各种知识点</li></ul><h1 id="运维相关">运维相关</h1><h2 id="高可用性负载均衡">高可用性、负载均衡</h2><p><strong>高可用性</strong></p><p>计算机系统的可用性用 [1] 平均无故障时间（MTTF）来度量，即计算机系统平均能够正常运行多长时间，才发生一次故障。系统的可用性越高，平均无故障时间越长。可维护性用平均维修时间（MTTR）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修时间越短。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%。由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。</p><p>工作方式： 1. 主从方式 （非对称方式） 工作原理：主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。</p><ol start="2" type="1"><li><p>双机双工方式（互备互援） 工作原理：两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。</p></li><li><p>集群工作方式（多服务器互备方式） 工作原理：多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。</p></li></ol><p><strong>负载均衡</strong></p><p>负载均衡可以将任务分摊到多个处理单元，从而提高并发处理能力。</p><p>（一） [协议层] HTTP 重定向协议实现负载均衡</p><ul><li>原理：根据用户的 HTTP 请求计算出一个真实的 web 服务器地址，并将该 web 服务器地址写入 HTTP 重定向响应中返回给浏览器，由浏览器重新进行访问。</li><li>优点：比较简单</li><li>缺点：<ul><li>浏览器需要两次请求服务器才能完成一次访问，性能较差。</li><li>HTTP 重定向服务器自身的处理能力可能成为瓶颈。</li><li>使用 HTTP302 响应重定向，有可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</li></ul></li></ul><p>（二） [协议层] DNS 域名解析负载均衡</p><ul><li>原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名www.baidu.com 对应一组 web 服务器 IP 地址，域名解析时经过 DNS 服务器的算法将一个域名请求分配到合适的真实服务器上。</li><li>优点：将负载均衡的工作交给了 DNS，省却了网站管理维护负载均衡服务器的麻烦，同时许多 DNS 还支持基于地理位置的域名解析，将域名解析成距离用户地理最近的一个服务器地址，加快访问速度吗，改善性能。</li><li>缺点：<ul><li>目前的 DNS 解析是多级解析，每一级DNS都可能化缓存记录A，当某一服务器下线后，该服务器对应的 DNS 记录 A 可能仍然存在，导致分配到该服务器的用户访问失败。</li><li>DNS负载均衡的控制权在域名服务商手里，网站可能无法做出过多的改善和管理。不能够按服务器的处理能力来分配负载。</li><li>DNS 负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。</li><li>可能会造成额外的网络问题。为了使本 DNS 服务器和其他 DNS 服务器及时交互，保证 DNS 数据及时更新，使地址能随机分配，一般都要将 DNS 的刷新时间设置的较小，但太小将会使 DNS 流量大增造成额外的网络问题。</li></ul></li></ul><p>（三） [协议层] 反向代理负载均衡</p><ul><li>原理：反向代理处于 web 服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组 web 服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的web 服务器处理，处理结果经过反向服务器返回给浏览器。</li><li>优点：部署简单，处于 HTTP 协议层面。</li><li>缺点：使用了反向代理服务器后，web 服务器地址不能直接暴露在外，因此 web服务器不需要使用外部 IP 地址，而反向代理服务作为沟通桥梁就需要配置双网卡、外部内部两套 IP 地址。</li></ul><p>（四） [网络层] IP负载均衡</p><ul><li>原理：在网络层通过修改目标地址进行负载均衡。用户访问请求到达负载均衡服务器，负载均衡服务器在操作系统内核进程获取网络数据包，根据算法得到一台真实服务器地址，然后将用户请求的目标地址修改成该真实服务器地址，数据处理完后返回给负载均衡服务器，负载均衡服务器收到响应后将自身的地址修改成原用户访问地址后再讲数据返回回去。类似于反向服务器负载均衡。</li><li>优点：在响应请求时速度较反向服务器负载均衡要快。</li><li>缺点：当请求数据较大（大型视频或文件）时，速度较慢。</li></ul><p>（五） [链路层] 数据链路层负载均衡</p><ul><li>原理：在数据链路层修改 MAC 地址进行负载均衡。负载均衡服务器的 IP 和它所管理的 web 服务群的虚拟 IP 一致；负载均衡数据分发过程中不修改访问地址的 IP 地址，而是修改 MAC 地址；通过这两点达到不修改数据包的原地址和目标地址就可以进行正常的访问。</li><li>优点：不需要负载均衡服务器进行地址的转换。数据响应时不需要经过负载均衡服务器。是目前大型网站所使用得最广的一种均衡手段。</li><li>缺点：负载均衡服务器的网卡带宽要求较高。</li></ul><hr><ol type="1"><li><p><strong>Docker</strong></p></li><li><p><strong>Nginx、lvs、keepalived、监控、cdn 等</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不会运维，也不懂开发，仅供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="面经" scheme="https://yz1509.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="https://yz1509.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="操作系统" scheme="https://yz1509.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="https://yz1509.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://yz1509.github.io/tags/Linux/"/>
    
      <category term="运维开发工程师" scheme="https://yz1509.github.io/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="Python" scheme="https://yz1509.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>认识STL</title>
    <link href="https://yz1509.github.io//posts/64d148d3/"/>
    <id>https://yz1509.github.io//posts/64d148d3/</id>
    <published>2018-07-31T02:48:06.000Z</published>
    <updated>2019-10-30T09:56:43.280Z</updated>
    
    <content type="html"><![CDATA[<p>STL 简单介绍，并不涉及源码剖析。</p><a id="more"></a><p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。</p><h1 id="标准库类型-string">标准库类型 string</h1><p>标准库类型 string 表示可变长的字符序列。</p><h2 id="定义和初始化-string-对象">定义和初始化 string 对象</h2><ul><li><p>初始化 string 对象的方式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;              <span class="comment">// 默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;          <span class="comment">// s2 是 s1 的一个副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;         <span class="comment">// 等价于 s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;     <span class="comment">// s3 是字面值 "value" 的副本，不包含字面值最后的空字符</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;    <span class="comment">// 等价于 s3("value")</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;      <span class="comment">// 把 s4 初始化为连续 n 个字符 c 组成的串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 string 的其他方法</span></span><br><span class="line"><span class="comment">// n, len2 和 pos2 都是无符号值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp, n)</span></span>;<span class="comment">// s 是指向 cp 指向的数组中的前 n 个字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 此数组至少应该包含 n 个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2)</span></span>;<span class="comment">// s 是 string s2 从下标 pos2 开始的字符的拷贝</span></span><br><span class="line">                        <span class="comment">// 若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s2, pos2, len2)</span></span>;<span class="comment">// s 是 string s2 从下标 pos2 开始 len2 个字符的  // 拷贝，若 pos2 &gt; s2.size()，构造函数的行为未定义</span></span><br><span class="line">                        <span class="comment">// 不管 len2 的值为多少，至多拷贝 s2.size()-pos2个字符</span></span><br></pre></td></tr></table></figure></p></li><li><p>直接初始化和拷贝初始化</p><ul><li>如果使用等号 = 初始化一个变量，实际执行的是拷贝初始化</li><li>如果不使用等号，则执行的是直接初始化（direct initialization）</li></ul></li></ul><h2 id="string-对象上的操作">string 对象上的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s;            <span class="comment">// 将 s 写到输出流 os 中，返回 os</span></span><br><span class="line">is &gt;&gt; s;            <span class="comment">// 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is</span></span><br><span class="line">                <span class="comment">// string 对象会自动忽略开头的空白并从第一个非空白字符开始</span></span><br><span class="line">                <span class="comment">// 直至遇见下一处空白为止。</span></span><br><span class="line">getline(is, s);     <span class="comment">// 从 is 中读取一行赋给 s，返回 is</span></span><br><span class="line">                    <span class="comment">// getline 函数从给定的流中读入内容，直到遇到</span></span><br><span class="line">                    <span class="comment">// 换行符为止（换行符也被读进来），</span></span><br><span class="line">                    <span class="comment">// 然后把所读内容存入到 string 对象中（注意不存换行符）</span></span><br><span class="line">s.empty();          <span class="comment">// s 为空返回 true</span></span><br><span class="line">s.size();           <span class="comment">// 返回 s 中字符的个数</span></span><br><span class="line">s[n];               <span class="comment">// 返回 s 中第 n 个字符的引用，位置 n 从 0 开始</span></span><br><span class="line">s1 + s2;            <span class="comment">// 返回 s1 和 s2 连接后的结果</span></span><br><span class="line">s1 = s2;            <span class="comment">// 用 s2 的副本代替 s1 中原来的字符</span></span><br><span class="line">s1 == s2;</span><br><span class="line">s1 != s2;           <span class="comment">// 大小写敏感</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=        <span class="comment">// 字典序比较，且大小写敏感</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子字符串操作</span></span><br><span class="line">s.substr(pos, n);<span class="comment">// 返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。</span></span><br><span class="line">                    <span class="comment">// pos 的默认值为 0，n 的默认值为 s.size() - pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 string 的操作</span></span><br><span class="line">s.insert(pos, args)<span class="comment">// 在 pos 之前插入 args 指定的字符</span></span><br><span class="line">                    <span class="comment">// pos 为下标的版本返回一个指向 s 的引用</span></span><br><span class="line">                    <span class="comment">// pos 为迭代器的版本返回指向第一个插入字符的迭代器</span></span><br><span class="line">s.erase(pos, len)<span class="comment">// 删除从位置 pos 开始的 len 个字符。如果 len 被省略，</span></span><br><span class="line">                    <span class="comment">// 则删除从 pos 开始直至 s 末尾的所有字符</span></span><br><span class="line">                    <span class="comment">// 返回一个指向 s 的引用</span></span><br><span class="line">s.assign(args)<span class="comment">// 将 s 中的字符替换为 args 指定的字符，返回一个指向 s 的引用</span></span><br><span class="line">s.append(args)<span class="comment">// 将 args 追加到 s, 返回一个指向 s 的引用</span></span><br><span class="line">s.replace(range, args)<span class="comment">// 删除 s 中范围 range 内的字符，替换为 args 指定的字符</span></span><br><span class="line">                        <span class="comment">// range 为一个下标+长度，或为一对指向 s 的迭代器</span></span><br><span class="line">                        <span class="comment">// 返回一个指向 s 的引用</span></span><br></pre></td></tr></table></figure><p>args 可以是下列形式之一，str 不能与 s 相同，迭代器 b 和 e 不能指向 s</p><table><thead><tr class="header"><th>args</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>str</td><td>字符串 str</td></tr><tr class="even"><td>str, pos, len</td><td>str 中从 pos 开始最多 len 个字符</td></tr><tr class="odd"><td>cp, len</td><td>从 cp 指向的字符数组的前(最多)len 个字符</td></tr><tr class="even"><td>cp</td><td>cp 指向的以空字符结尾的字符数组</td></tr><tr class="odd"><td>n, c</td><td>n 个字符 c</td></tr><tr class="even"><td>b, e</td><td>迭代器 b 和 e 指定的范围内的字符</td></tr><tr class="odd"><td>初始化列表</td><td>花括号包围的，以逗号分隔的字符列表</td></tr></tbody></table><p>append 和 assign 可以使用所有形式的 args</p><table><colgroup><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"></colgroup><thead><tr class="header"><th>args</th><th>replace(pos,len,args)</th><th>replace(b,e,args)</th><th>insert(pos,args)</th><th>insert(iter,args)</th></tr></thead><tbody><tr class="odd"><td>str</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr class="even"><td>str, pos, len</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr class="odd"><td>cp, len</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr class="even"><td>cp</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr class="odd"><td>n, c</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr class="even"><td>b, e</td><td>否</td><td>是</td><td>否</td><td>是</td></tr><tr class="odd"><td>初始化列表</td><td>否</td><td>是</td><td>否</td><td>是</td></tr></tbody></table><ul><li>size 函数返回的是一个 string::size_type 类型的值，它是一个无符号类型。这种配套类型体现了标准库类型与机器无关的特性。</li></ul><blockquote><p>Tip：如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。</p></blockquote><ul><li>当把 string 对象和字符（或字符串）字面值混在一条语句中使用时，必须确保每个加法运算符 (+) 的两侧的运算对象至少有一个是 string。（字符串字面值与 string 是不同的的类型）</li></ul><h1 id="标准库类型-vector">标准库类型 vector</h1><p>标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。因为引用不是对象，所以不存在引用的 vector。</p><h2 id="定义和初始化-vector-对象">定义和初始化 vector 对象</h2><ul><li><p>初始化 vector 对象的方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1;                   <span class="comment">// v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2(v1);               <span class="comment">// v2 中包含有 v1 所有元素的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2 = v1;              <span class="comment">// 等价于 v2(v1)</span></span><br><span class="line">                                <span class="comment">// 注意两个 vector 对象的类型必须相同</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val);           <span class="comment">// v3 包含了 n 个重复的元素，每个元素的值都为 val</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v4(n);                <span class="comment">// v4 包含了 n 个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5&#123;a, b, c, ... &#125;;    <span class="comment">// v5 包含了初始值个数的元素，每个元素被赋予相应的初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5 = &#123;a, b, c, ... &#125;; <span class="comment">// 等价于 v5&#123;a, b, c, ... &#125;</span></span><br></pre></td></tr></table></figure></p></li><li><p>在大多数情况下这些初始化的方式可以相互等价地使用，不过也有例外：</p><ul><li>使用拷贝初始化（即使用 =）时，只能提供一个初始值</li><li>如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化</li><li>如果提供的是初始元素值的列表，则只能把初始值放在花括号内执行列表初始化，而不能放圆括号内</li></ul></li><li><p>值初始化的两个特殊限制：</p><ul><li>有些类要求必须明确提供初始值时，只提供元素的数量而不设定初始值无法完成初始化工作</li><li>如果只提供了元素而没有设定初始值，只能使用直接初始化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = <span class="number">10</span>;    <span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(<span class="number">10</span>);     <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125;;        <span class="comment">// 列表初始化，v5 有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>);        <span class="comment">// 错误：不能用字符串字面值构造 vector 对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;          <span class="comment">// v7 有 10 个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;    <span class="comment">// v8 有 10 个值为 “hi” 的元素</span></span><br></pre></td></tr></table></figure></p></li></ul><h2 id="vector-支持的操作">vector 支持的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v.empty();              <span class="comment">// 如果 v 不含有任何元素，返回真；否则返回假</span></span><br><span class="line">v.size();               <span class="comment">// 返回 v 中元素的个数</span></span><br><span class="line">                        <span class="comment">// 返回值的类型是由 vector 定义的 size_type 类型</span></span><br><span class="line">v.push_back(t);         <span class="comment">// 向 v 的尾端添加一个值为 t 的元素</span></span><br><span class="line">v[n];                   <span class="comment">// 返回 v 中第 n 个位置上元素的引用</span></span><br><span class="line">v1 = v2;                <span class="comment">// 用 v2 中元素的拷贝替换 v1 中的元素</span></span><br><span class="line">v1 = &#123;a, b, c, ... &#125;;   <span class="comment">// 用列表中元素的拷贝替换 v1 中元素</span></span><br><span class="line">v1 == v2;               <span class="comment">// v1 和 v2 相等当且它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2;</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=            <span class="comment">// 字典序进行比较（前提是 vector 对象中元素的值可比较）</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用 size_type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type      <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type           <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h1 id="迭代器">迭代器</h1><h2 id="使用迭代器">使用迭代器</h2><p>和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 begin 和 end 的成员： * begin 成员负责返回指向第一个元素（或第一个字符）的迭代器 * end 成员则负责返回指向容器（或 string 对象）“尾元素的下一个位置（one past the end）”的迭代器，称为尾后迭代器（off-the-end iterator） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end();    <span class="comment">// b 和 e 的类型相同</span></span><br></pre></td></tr></table></figure></p><blockquote><p>如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。</p></blockquote><h2 id="标准容器迭代器的运算符">标准容器迭代器的运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*iter               <span class="comment">// 返回迭代器 iter 所指元素的引用</span></span><br><span class="line">iter-&gt;mem           <span class="comment">// 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem</span></span><br><span class="line">                    <span class="comment">// 箭头运算符 -&gt; 将解引用和成员访问两个操作结合在一起</span></span><br><span class="line">++iter              <span class="comment">// 令 iter 指示容器中的下一个元素</span></span><br><span class="line">--iter              <span class="comment">// 令 iter 指示容器中的上一个元素</span></span><br><span class="line">iter1 == iter2      <span class="comment">// 如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等</span></span><br><span class="line">iter1 != iter2      <span class="comment">// 反之，不相等</span></span><br></pre></td></tr></table></figure><blockquote><p>因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p></blockquote><h2 id="迭代器类型">迭代器类型</h2><p>实际上，那些拥有迭代器的标准库类型使用 iteration 和 const_iterator 来表示迭代器的类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;           <span class="comment">// it 能读写 vector&lt;int&gt; 的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;               <span class="comment">// it2 能读写 string 对象中的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;    <span class="comment">// it3 只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;         <span class="comment">// it4 只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure></p><ul><li>如果标准库类型对象是常量，只能使用 const_iterator</li><li>如果标准库类型对象不是常量，那么既能使用 iterator，也能使用 const_iterator</li><li>begin 和 end 返回的具体类型由对象是否是常量决定<ul><li>对象是常量，返回 const_iterator</li><li>对象不是常量，返回 iterator</li><li>专门返回 const_iterator 类型的函数：cbegin 和 cend</li></ul></li></ul><blockquote><p>WARNING：谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，这会使迭代器失效。</p></blockquote><h2 id="vector-和-string-迭代器支持的运算">vector 和 string 迭代器支持的运算</h2><p>string 和 vector 的迭代器比标准库容器迭代器提供了更多额外的运算符 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter + n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter - n        <span class="comment">// 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。</span></span><br><span class="line">                <span class="comment">// 结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一个位置</span></span><br><span class="line">iter += n       <span class="comment">// 迭代器加法的复合赋值语句</span></span><br><span class="line">iter -= n       <span class="comment">// 迭代器减法的复合赋值语句</span></span><br><span class="line">iter1 - iter2   <span class="comment">// 两个迭代器相减的结果是它们之间的距离。参与运算的两个迭代器必须指向的是同一个容器中的</span></span><br><span class="line">                <span class="comment">// 元素或者尾元素的下一个位置</span></span><br><span class="line">&gt;, &gt;=, &lt;, &lt;=    <span class="comment">// 参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置</span></span><br></pre></td></tr></table></figure></p><h1 id="顺序容器">顺序容器</h1><p>顺序容器是将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。标准库常用顺序容器如下： * vector，可变大小数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。 * deque，双端队列。支持快速随机访问，在头尾部插入速度很快。 * list，双向链表。支持双向顺序访问，在 list 中任何位置插入删除都很快。 * forward_list，单向链表。只支持单向顺序访问，在链表任何位置插入删除都很快。 容器只定义了少量操作，大多数额外操作则由算法库提供。容器类型的操作集合具有以下层次结构特点：一些操作适用于所有容器类型；另外一些操作则只适用于顺序或关联容器类型；还有一些操作只适用于顺序或关联容器类型的一个子集。</p><h2 id="顺序容器的定义和初始化">顺序容器的定义和初始化</h2><p>所有的容器都是类模版，要定义某种特殊的容器，必须在容器后的尖括号内提供存放元素的数据类型。容器元素类型必须满足以下两个约束： * 元素类型必须支持赋值运算； * 元素类型的对象必须可以复制。</p><p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。除了默认构造函数，容器类型还提供其他的构造函数，使程序员可以指定元素初值。在 C++11 中，我们可以对容器进行列表初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;  <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(svec);  <span class="comment">//将一个容器复制给另一个容器时，类型必须匹配</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());   <span class="comment">//初始化为一段元素的副本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::size_type list_size = <span class="number">64</span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(list_size, <span class="string">"eh"</span>);  <span class="comment">//分配和初始化指定数目的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Qin"</span>,<span class="string">"Li"</span>&#125;;  <span class="comment">//C++11列表初始化</span></span><br></pre></td></tr></table></figure></p><h2 id="顺序容器的常用操作">顺序容器的常用操作</h2><h3 id="添加元素">添加元素</h3><p><img src="/posts/64d148d3/001.png" alt="顺序容器添加元素"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; container;</span><br><span class="line"><span class="built_in">string</span> text_word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; text_word) </span><br><span class="line">     container.push_back(text_word); </span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">4</span>; ++ix) </span><br><span class="line">     ilist.push_front(ix);</span><br></pre></td></tr></table></figure></p><p>任何 insert 或 push 操作都可能导致迭代器失效。当编写循环将元素插入到 vector 或 deque 容器中时，程序必须确保迭代器在每次循环后都得到更新。为了避免存储 end 迭代器，可以在每次做完插入运算后重新计算 end 迭代器值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first = v.begin(); <span class="comment">//不要令last = v.end();</span></span><br><span class="line"><span class="keyword">while</span> (first != v.end()) </span><br><span class="line">&#123; </span><br><span class="line">     first = v.insert(first, <span class="number">42</span>); <span class="comment">// insert new value </span></span><br><span class="line">     ++first; <span class="comment">// advance first just past the element we added </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="改变容器的大小">改变容器的大小</h3><p>为避免每次添加元素都会执行内存分配和释放的操作，vector 和 string 每次获取新的内存空间时，都会分配比需求更大的空间作为备用，以此减少内存分配的次数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> a = c.size();  <span class="comment">//返回容器c中的元素个数</span></span><br><span class="line"><span class="keyword">bool</span> b = c.empty();  <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">c.resize(<span class="number">15</span>);<span class="comment">// 将 5 个值为 0 的元素添加到 c 的末尾</span></span><br><span class="line">c.resize(<span class="number">20</span>, <span class="number">-1</span>);<span class="comment">// 将 5 个值为 -1 的元素添加到 c 的末尾</span></span><br><span class="line">c.reserve(<span class="number">30</span>);  <span class="comment">// 分配至少能容纳 30 个元素的内存空间</span></span><br><span class="line">c.capacity();  <span class="comment">// 返回容器可以容纳的元素个数 30，此时 c.size()=20</span></span><br></pre></td></tr></table></figure></p><p>resize() 和 reserve() 区别： * size 指容器当前拥有的元素个数，调用 resize(n) 后，容器的 size 即为 n。 * capacity 则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。调用 reserve(n) 后，若容器的 <span class="math inline">\(capacity &lt; n\)</span>，则重新分配内存空间，从而使得 capacity 等于 n。如果 <span class="math inline">\(capacity \ge n\)</span>，capacity 无变化。 * 容器调用 resize() 函数后，所有的空间都已经初始化了，所以可以直接访问。而 reserve() 函数预分配出的空间没有被初始化，所以不可访问。</p><h3 id="删除元素">删除元素</h3><p><img src="/posts/64d148d3/002.png" alt="顺序容器删除元素"> pop_front 和 pop_back 函数的返回值并不是删除的元素值，而是 void。要获取删除的元素值，则必须在删除元素之前调用 front 或 back 函数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ilist.empty()) &#123; </span><br><span class="line">         process(ilist.front()); <span class="comment">// do something with the current top of ilist </span></span><br><span class="line">         ilist.pop_front();      <span class="comment">// done; remove first element </span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>erase 操作不会检查它的参数，因此必须确保用作参数的迭代器或迭代器范围是有效的。通常，程序员必须在容器中找出要删除的元素后，才使用 erase 操作。寻找一个指定元素的最简单方法是使用标准库的 find 算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">searchValue</span><span class="params">(<span class="string">"Quasimodo"</span>)</span></span>; </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = find(slist.begin(), slist.end(), searchValue); </span><br><span class="line"><span class="keyword">if</span> (iter != slist.end())    </span><br><span class="line">    slist.erase(iter);</span><br></pre></td></tr></table></figure></p><h2 id="容器适配器">容器适配器</h2><p>除了顺序容器外，标准库来提供了三种容器适配器：stack、queue 和 priority_queue。适配器（adaptor）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，使得某种事物的行为看起来像另外一件事物一样。</p><p>实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括 stack、queue 和 priority_queue 类型。</p><p>栈的常用操作： * s.empty()，判断栈是否为空，为空则返回true。 * s.size()，返回栈中元素个数。 * s.pop()，删除栈顶元素，但不返回其值。 * s.top()，返回栈顶元素的值，不降元素弹出栈。 * s.push()，在栈顶压入新元素。</p><p>队列的常用操作： * q.empty() , q.size() 同栈 * q.pop()，删除队首元素，但不返回其值。 * q.push()，在队尾压入一个新元素。 * q.front()，返回队首元素，但不删除此元素 * q.back()，返回队尾元素。（只适用于 queue） * q.top()，返回最高优先级元素，但不删除此元素（只适用于 priority_queue）</p><h1 id="关联容器">关联容器</h1><p>关联容器支持通过键来高效地查找和读取元素，两个基本的关联容器类型是 map 和 set。 * map 的元素以键-值（key-value）对的形式组织：键用于元素在 map 中的索引，而值则表示所存储和读取的数据。 * set 仅包含一个键，并有效地支持关于某个键是否存在的查询。map 可理解为字典，set 可理解为一类元素的集合。</p><p>关联容器和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。</p><p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。 ## pair 类型 pair 包含两个数据值。在创建 pair 对象时，必须提供两个类型名：pair 对象所包含的两个数据成员各自对应的类型名字。如果在创建 pair 对象时不提供初始化式，则调用默认构造函数对其成员采用值初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;   <span class="comment">//利用 typedef 简化其声明</span></span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是公有的，分别命名为 first 和 second。只需使用普通的点操作符（成员访问标志）即可访问其成员： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook; </span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author.second == <span class="string">"Joyce"</span>) </span><br><span class="line">    firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure></p><p>除了构造函数，标准库还定义了一个 make_pair 函数，由传递给它的两个实参生成一个新的 pair 对象。可如下使用该函数创建新的 pair 对象，并赋给已存在的 pair 对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth; </span><br><span class="line"><span class="built_in">string</span> first, last; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123; </span><br><span class="line">    next_auth = make_pair(first, last); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map-类型">map 类型</h2><p>map 对象的元素是键－值对，也即每个元素包含两个部分：键以及由键关联的值。map 的 value_type 就反映了这个事实。该类型比前面介绍的容器所使用的元素类型要复杂得多：value_type 是存储元素的键以及值的 pair 类型，而且键为 const。如下，word_count 数组的 value_type 为 pair&lt;const string, int&gt; 类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count.insert(make_pair(<span class="string">"James"</span>, <span class="string">"Joyce"</span>));</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin(); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second;</span><br></pre></td></tr></table></figure></p><h3 id="给-map-添加元素">给 map 添加元素</h3><p>map 容器中添加键－值元素对，可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。在这两种情况下，一个给定的键只能对应于一个元素这一事实影响了这些操作的行为。</p><p>用下标操作符来获取该键所关联的值。 * 如果该键已在容器中，则返回该键所关联的值。 * 只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。此时，所关联的值采用值初始化：类类型的元素用默认构造函数初始化，而内置类型的元素初始化为 0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; <span class="comment">// empty map from string to int </span></span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) </span><br><span class="line">    ++word_count[word];</span><br></pre></td></tr></table></figure></p><p>使用下标给 map 容器添加新元素时，元素的值部分将采用值初始化。通常，我们会立即为其赋值，其实就是对同一个对象进行初始化并赋值。而插入元素的另一个方法是：直接使用 insert 成员，其语法更紧凑： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>)); </span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure></p><p>map 对象中一个给定键只对应一个元素。如果试图插入的元素所对应的键已在容器中，则 insert 将不做任何操作。但是，带有一个键－值 pair 形参的 insert 版本将返回一个值：包含一个迭代器和一个 bool 值的 pair 对象，其中迭代器指向 map 中具有相应键的元素，而 bool 值则表示是否插入了该元素。如果该键已在容器中，则其关联的值保持不变，返回的 bool 值为 true。在这两种情况下，迭代器都将指向具有给定键的元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count; </span><br><span class="line"><span class="built_in">string</span> word; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) &#123; </span><br><span class="line">    <span class="comment">// inserts element with key equal to word and value 1; </span></span><br><span class="line">    <span class="comment">// if word already in word_count, insert does nothing </span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret =  word_count.insert(make_pair(word, <span class="number">1</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!ret.second)          <span class="comment">// word already in word_count </span></span><br><span class="line">        ++ret.first-&gt;second;  <span class="comment">// increment counter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找并读取-map-中的元素">查找并读取 map 中的元素</h3><p>不能使用下标来查找 map 中的某一元素是否存在，因为如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。</p><p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。find 操作返回指向元素的迭代器，如果元素不存在，则返回 end 迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"foobar"</span>);</span><br><span class="line"><span class="keyword">if</span>(it != wor_count.end())</span><br><span class="line">    occurs = it-&gt;second;</span><br></pre></td></tr></table></figure></p><h3 id="从-map-对象中删除元素">从 map 对象中删除元素</h3><p><img src="/posts/64d148d3/003.png" alt="map删除元素"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word_count.erase(removal_word)) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ok: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" removed\n"</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"oops: "</span> &lt;&lt; removal_word &lt;&lt; <span class="string">" not found!\n"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="map-对象的迭代遍历">map 对象的迭代遍历</h3><p>与其他容器一样，map 同样提供 begin 和 end 运算，以生成用于遍历整个容器的迭代器。例如，可如下将 map 容器 word_count 的内容输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = word_count.begin();</span><br><span class="line"><span class="keyword">while</span>(it != word_count.end())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs "</span></span><br><span class="line">            &lt;&lt; it-&gt;second &lt;&lt; <span class="string">" times "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="set-类型">set 类型</h2><p>map 容器是键－值对的集合，好比以人名为键的地址和电话号码。相反地，set 容器只是单纯的键的集合。例如，某公司可能定义了一个名为 bad_checks 的 set 容器，用于记录曾经给本公司发空头支票的客户。当只想知道一个值是否存在时，使用 set 容器是最适合的。例如，在接收一张支票前，该公司可能想查询 bad_checks 对象，看看该客户的名字是否存在。</p><p>set 容器支持大部分的 map 操作，包括上面描述的构造函数、 insert 操作、 count 和 find 操作、 erase 操作等。但是， 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。这一差别也体现了 set 存储的元素仅仅是键，而没有所关联的值。与 map 一样，set 容器存储的键也必须唯一，而且不能修改。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 20 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// prints 10 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; set1;</span><br><span class="line">set1.insert(<span class="string">"the"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset2;</span><br><span class="line">iset2. insert( ivec.begin(), ivec.end() );     <span class="comment">// iset2 has 10 elements</span></span><br><span class="line"></span><br><span class="line">iset.find(<span class="number">1</span>);     <span class="comment">// returns iterator that refers to the element with key == 1</span></span><br><span class="line">iset.find(<span class="number">11</span>);   <span class="comment">// returns iterator == iset.end() </span></span><br><span class="line">iset.count(<span class="number">1</span>);    <span class="comment">// returns 1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = isec.find(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>正如不能修改 map 中元素的键部分一样，set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p><h2 id="multimap-和-multiset-类型">multimap 和 multiset 类型</h2><p>map 和 set 容器中，一个键只能对应一个实例。而 multiset 和 multimap 类型则允许一个键对应多个实例。例如，在电话簿中，每个人可能有单独的电话号码列表。在作者的文章集中，每位作者可能有单独的文章标题列表。<strong>multimap 和 multiset 类型与相应的单元素版本具有相同的头文件定义：分别是 map 和 set 头文件。</strong></p><p>multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。为了顺应一个键可以对应多个值这一性质，map 和 multimap，或 set 和 multiset 中相同的操作都以不同的方式做出了一定的修改。在使用 multimap 或 multiset 时，对于某个键，必须做好处理多个值的准备，而非只有单一的值。</p><p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p><p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p><p>关联容器 map 和 set 的元素是按顺序存储的， multimap 和 multset 也一样。因此，在 multimap 和 multiset 容器中，如果某个键对应多个实例，则这些实例在容器中将相邻存放。 在 multimap 和 multiset 中查找元素有三种策略，而且三种策略都基于一个事实——在 multimap 中，同一个键所关联的元素必然相邻存放。 * 使用 find 和 count 操作 * lower_bound 和 upper_bound * enual_range 函数</p><figure><img src="/posts/64d148d3/004.png" alt=""><figcaption>multimap/set查找</figcaption></figure><p>equal_range 函数返回存储一对迭代器的 pair 对象。如果该值存在，则 pair 对象中的第一个迭代器指向该键关联的第一个实例，第二个迭代器指向该键关联的最后一个实例的下一位置。如果找不到匹配的元素，则 pair 对象中的两个迭代器都将指向此键应该插入的位置。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;authors_it, authors_it&gt; pos = authors.equal_range(search_item); </span><br><span class="line"><span class="keyword">while</span> (pos.first != pos.second) &#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    ++pos.first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常用泛型算法">常用泛型算法</h1><p>标准库为容器类型定义的操作很少，并没有为每个容器实现更多的操作。因为这部分操作可以抽象出来为所有的容器工作，那就是泛型算法。所谓“泛型”是指这些算法可以应用于多种容器类型上，而容器内的元素类型也可以多样化。标准库提供了 100 多个泛型算法，主要定义于头文件&lt;algorithm&gt; 中，还有一组泛化的算术算法定义于头文件 &lt;numeric&gt; 中。</p><p>大多数泛型算法是工作于容器的一对迭代器所标识的范围，并完全通过迭代器来实现其功能。这段由迭代器指定的范围称为“输入范围”。带有输入范围参数的算法总是使用前两个参数标记该范围，分别指向要处理的第一个元素和最后一个元素的下一个位置。</p><h2 id="查找">查找</h2><p>find 和 count 算法在输入范围中查找指定值。find 算法返回引用第一个匹配元素的迭代器，count 算法返回元素在输入序列中出现次数的计数。它们都在输入范围中查找等于 val 的元素，使用基础类型的相等（==）操作符。find 返回第一个匹配元素的迭代器，如果不存在在匹配元素就返回 end。count 返回 val 出现次数的计数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val); </span><br><span class="line">count(beg, end, val);</span><br></pre></td></tr></table></figure></p><p>find 函数的源码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*first == val)<span class="keyword">return</span> first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个例子，查找数组中的某个值。由于指针就像内置数组上的迭代器一样，因此可以用find在数组中查找值。使用begin和end函数可以获取指向数组首尾元素的指针。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myints[]=&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    p = find(begin(myints), end(myints), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != myints+<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="排序">排序</h2><p>C++ 中最经常使用的算法应该就是排序算法，也就是 sort 函数。当然还有 partial_sort 以及stable_sort。sort 函数排序默认是从小到大，如果想给自定义类型排序，可以重载运算符或者自定义比较函数。 * 升序：sort(begin, end, less&lt;data-type&gt;()); * 降序：sort(begin, end, greater&lt;data-type&gt;()); <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">43</span>,<span class="number">24</span>,<span class="number">65</span>&#125;,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a,a+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，也可以自己写比较函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">100</span>];   </span><br><span class="line">&#125;str[<span class="number">100</span>];  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Data &amp;elem1, <span class="keyword">const</span> Data &amp;elem2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(elem1.data, elem2.data) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, i;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str[i].data;  </span><br><span class="line">          </span><br><span class="line">        sort(str, str+n, cmp);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i].data &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="去重">去重</h2><p>unique 的作用是从输入序列中删除”所有相邻的重复元素。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器（容器的长度没变，只是元素顺序改变了），表示无重复的值范围的结束。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end());   <span class="comment">//排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator end_unique = </span><br><span class="line">            unique(words.begin(), words.end());  <span class="comment">//去重</span></span><br><span class="line">words.erase(end_unique, words.end());  <span class="comment">//删除结尾元素</span></span><br></pre></td></tr></table></figure></p><p>在 STL 中 unique 函数是一个去重函数， unique 的功能是去除相邻的重复元素(只保留一个)，其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中， 返回去重后最后一个元素的地址，因为 unique 去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p><p>源代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">unique</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (first==last) <span class="keyword">return</span> last;</span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (++first != last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*result == *first))    *(++result)=*first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="赋值">赋值</h2><p>fill 函数可以可以向容器当中的一定范围能赋值，一共接受 3 个参数，类似于 memset 函数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(beg, end, val)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL 简单介绍，并不涉及源码剖析。&lt;/p&gt;
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
      <category term="STL" scheme="https://yz1509.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++面试知识点</title>
    <link href="https://yz1509.github.io//posts/db684f2c/"/>
    <id>https://yz1509.github.io//posts/db684f2c/</id>
    <published>2018-07-28T02:52:52.000Z</published>
    <updated>2019-10-30T10:00:35.784Z</updated>
    
    <content type="html"><![CDATA[<p>面试可能会遇到的与 C++ 相关的问答记录。</p><a id="more"></a><p>整理自<a href="https://www.jianshu.com/u/ccb6e3e26ec3" target="_blank" rel="noopener">Mr希灵</a>的博文、面经以及《C++ Primer, 5E》等。 # C++ 基础知识点</p><h2 id="有符号类型和无符号类型">有符号类型和无符号类型</h2><ol type="1"><li>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数。</li><li>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的；此时，程序可能继续工作、可能崩溃。也可能生成垃圾数据。</li><li>如果表达式中既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动转换成无符号数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-2</span>;<span class="comment">// case 1, b = 4294967294 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 输出 4294967295</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;<span class="comment">// c = -1</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> e = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d + e &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// case 3， 输出 4294967295</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="引用与指针">引用与指针</h2><p>引用并非对象，它只是为一个已经存在的对象起的一个别名。在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p><p>指针是指向另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有许多不同点：</p><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝。而且在指针的生命周期内它可以先后指向几个不同的对象。引用不是对象，所以也不能定义指向引用的指针。</li><li>指针无须在定义时赋值。</li></ul><p>void* 是一种特殊的指针类型，可以存放任意对象的地址。但我们对该地址中存放的是什么类型的对象并不了解，所以也不能直接操作 void* 指针所指的对象。</p><h2 id="static-关键字">static 关键字</h2><ul><li>声明为 static 的局部变量，存储在静态存储区，其生存期不再局限于当前作用域，而是整个程序的生存期。</li><li>对于全局变量而言， 普通的全局变量和函数，其作用域为整个程序或项目，外部文件（其它 cpp文件）可以通过 extern 关键字访问该变量和函数；static 全局变量和函数，其作用域为当前 cpp 文件，其它的 cpp 文件不能访问该变量和函数。</li><li>当使用 static 修饰成员变量和成员函数时，表示该变量或函数属于一个类，而不是该类的某个实例化对象。</li></ul><h2 id="const-限定符">const 限定符</h2><p>const 的作用： 1. 在定义常变量时必须同时对它初始化，此后它的值不能再改变。常变量不能出现在赋值号的左边（不为“左值”）； 2. 对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const； 3. 在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； 4. 对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量； 5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为"左值"。例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator*的返回结果必须是一个const对象，否则下列代码编译出错</span></span><br><span class="line"><span class="keyword">const</span> classA <span class="keyword">operator</span>*(<span class="keyword">const</span> classA&amp; a1,<span class="keyword">const</span> classA&amp; a2);  </span><br><span class="line">classA a, b, c;</span><br><span class="line">(a*b) = c;  <span class="comment">//对a*b的结果赋值。操作(a*b) = c显然不符合编程者的初衷，也没有任何意义</span></span><br></pre></td></tr></table></figure></p><p>用 const 修饰符号常量的区别： * const 位于 * 的左边，表示被指物是常量 * const 位于 * 的右边，表示指针自身是常量（常量指针）。（口诀：左定值，右定向） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p;  <span class="comment">//指向const对象的指针，指针可以被修改，但指向的对象不能被修改。</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p; <span class="comment">//指向char类型的常量指针，指针不能被修改，但指向的对象可以被修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p;  <span class="comment">//指针及指向对象都不能修改。</span></span><br></pre></td></tr></table></figure></p><p>const 与 #define 的区别： * const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。 * 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。 * 在 C++ 程序中只使用 const 常量而不使用宏常量，即 const 常量完全取代宏常量。</p><h2 id="数组与指针的区别">数组与指针的区别</h2><ul><li>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</li><li>用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量。C/C++ 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</li><li>C++ 编译系统将形参数组名一律作为指针变量来处理。实际上在函数调用时并不存在一个占有存储空间的形参数组，只有指针变量。<ul><li>实参数组名 a 代表一个固定的地址，或者说是指针型常量，因此要改变 a 的值是不可能的。例如：<span class="math inline">\(a++;\)</span> 是错误的。</li><li>形参数组名 array 是指针变量，并不是一个固定的地址值。它的值是可以改变的。例如：<span class="math inline">\(array++;\)</span> 是合法的。</li></ul></li></ul><p>为了节省内存，C/C++ 把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量字符串初始化数组时，情况却有所不同。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 会为它们分配两个长度为12个字节的空间</span></span><br><span class="line"><span class="comment">// 并把 “Hello World” 的内容分别复制到数组中去，这是两个初始地址不同的数组。</span></span><br><span class="line"><span class="keyword">char</span> str1[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> str2[] = “Hello World”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str3 和 str4 是两个指针，我们无须为它们分配内存以存储字符串的内容</span></span><br><span class="line"><span class="comment">// 而只需要把它们指向 “Hello World” 在内存中的地址就可以了。</span></span><br><span class="line"><span class="comment">// 由于 “Hello World” 是常量字符串，它在内存中只有一个拷贝，</span></span><br><span class="line"><span class="comment">// 因此 str3 和 str4 指向的是同一个地址。</span></span><br><span class="line"><span class="keyword">char</span> *str3[] = “Hello World”;</span><br><span class="line"><span class="keyword">char</span> *str4[] = “Hello World”;</span><br></pre></td></tr></table></figure></p><h2 id="sizeof-运算符">sizeof 运算符</h2><p>sizeof 是 C 语言的一种单目操作符，它并不是函数。操作数可以是一个表达式或类型名。数据类型必须用括号括住，<span class="math inline">\(sizeof(int);\)</span>， 变量名可以不用括号括住。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>];<span class="comment">//sizeof(a)=200</span></span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];<span class="comment">//sizeof(a)=4;</span></span><br><span class="line">Class Test&#123;<span class="keyword">int</span> a; <span class="keyword">static</span> <span class="keyword">double</span> c&#125;;  <span class="comment">//sizeof(Test)=4</span></span><br><span class="line">Test *s;<span class="comment">//sizeof(s)=4</span></span><br><span class="line">Class Test&#123; &#125;;<span class="comment">//sizeof(Test)=1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> s[<span class="number">5</span>])</span></span>;<span class="comment">//sizeof(s)=4;</span></span><br></pre></td></tr></table></figure></p><p>当操作数不同时需要注意： * 数组类型，其结果是数组的总字节数；指向数组的指针，其结果是该指针的字节数。 * 函数中的数组形参或函数类型的形参，其结果是指针的字节数。 * 联合类型，其结果采用成员最大长度对齐。 * 结构类型或类类型，其结果是这种类型对象的总字节数，包括任何填充在内。 对类进行操作时需要注意： * 类中的静态成员不对结果产生影响，因为静态变量的存储位置与结构或者类的实例地址无关; * 没有成员变量的类的大小为 1，因为必须保证类的每一个实例在内存中都有唯一的地址; * 有虚函数的类都会建立一张虚函数表，表中存放的是虚函数的函数指针，这个表的地址存放在类中，所以不管有几个虚函数，都只占据一个指针大小。</p><h3 id="例题">例题</h3><ol type="1"><li>下列联合体的 sizeof(sampleUnion) 的值为多少。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">short</span> value;</span><br><span class="line">&#125; sampleUnion;</span><br></pre></td></tr></table></figure></li></ol><p>答案：4。联合体占用大小采用成员最大长度的对齐，最大长度是 short 的2字节。但 char flag[3] 需要 3 个字节，所以 sizeof(sampleUnion) = 2 * (2字节) = 4。注意对齐有两层含义，一个是按本身的字节大小数对齐，一个是整体按照最大的字节数对齐。 2. 在 32 位系统中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;<span class="comment">// 没有引号，为 ASCLL 值</span></span><br><span class="line"><span class="keyword">char</span> *str = arr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 5，strlen 函数求取字符串长度以 ASCII 值为 0 为止。</span></span><br></pre></td></tr></table></figure></p><ol start="3" type="1"><li>定义一个空的类型，里面没有任何成员变量和成员函数。 问：对该类型求sizeof，得到的结果是什么？ 答：1。 问：为什么不是0？ 答：当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio 中每个空类型的实例占用 1 字节的空间。 问：如果在该类型中添加一个构造函数和析构函数，结果又是什么？ 答：还是 1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。 问：那如果把析构函数标记为虚函数呢？ 答：C++ 的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在 32 位的机器上，指针占用 4 字节，因此求 sizeof 得到4；如果是 64位机器，将得到 8。</li></ol><h2 id="结构体的内存对齐">结构体的内存对齐</h2><p>内存对齐规则： * 每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍。为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。 * 最终占用字节数为成员类型中最大占用字节数的整数倍。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p><p>这个结构体在编译以后，为了字节对齐，会被整理成这个样子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">3</span>];</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p><p>所以编译前总的结构体大小为：8 个字节。编译以后字节大小变为：12 个字节。 但是，如果调整顺序： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></p><p>那么这个结构体在编译前后的大小都是 8 个字节。编译后不用填充字节就能保持所有的成员都按各自默认的地址对齐。这样可以节约不少内存！所以一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少。</p><h2 id="强制类型转换">强制类型转换</h2><p>C++ 中有以下四种命名的强制类型转换： 1. static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 2. const_cast：去const属性，只能改变运算对象的底层const。常用于有函数重载的上下文中。 3. reninterpret_cast：通常为运算对象的位模式提供较低层次的重新解释，本质依赖与机器。 4. dynamic_cast：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。主要用于多态类之间的转换。</p><p>一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告；但是当我们执行了显式的类型转换之后，警告信息就被关闭了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>,i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任何非常量对象的地址都能存入void*，通过static_cast可以将指针转换会初始的指针类型</span></span><br><span class="line"><span class="keyword">void</span>* p = &amp;slope;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p><p>只有 const_cast 能够改变表达式的常量属性，其他形式的强制类型转换改变表达式的常量属性都将引发编译器错误。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用const_cast去除底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc = &amp;c;</span><br><span class="line"><span class="keyword">char</span>* cp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line">*cp = <span class="string">'c'</span>;</span><br></pre></td></tr></table></figure></p><p>reinterpret_cast 常用于函数指针类型之间进行转换。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;return0;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FuncPtr)</span><span class="params">()</span></span>; <span class="comment">// FuncPtr是一个指向函数的指针，该函数没有参数，返回值类型为void</span></span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>]; <span class="comment">// 假设你希望把一个指向下面函数的指针存入funcPtrArray数组</span></span><br><span class="line"></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = &amp;doSomething;<span class="comment">// 编译错误！类型不匹配</span></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething); <span class="comment">// 不同函数指针类型之间进行转换</span></span><br></pre></td></tr></table></figure></p><p>dynamic_cast：有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)： * 安全的基类和子类之间转换。 * 必须要有虚函数。 * 相同基类不同子类之间的交叉转换。但结果是NULL。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iNum;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//基类必须有虚函数。保持多态特性才能使用dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span>*m_szName[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* pb =<span class="keyword">new</span> Derive();</span><br><span class="line">Derive *pd1 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，静态类型转换，正确但不推荐</span></span><br><span class="line">Derive *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb); <span class="comment">//子类-&gt;父类，动态类型转换，正确</span></span><br><span class="line"></span><br><span class="line">Base* pb2 =<span class="keyword">new</span> Base();</span><br><span class="line">Derive *pd21 = <span class="keyword">static_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></span><br><span class="line">Derive *pd22 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(pb2); <span class="comment">//父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></span><br></pre></td></tr></table></figure></p><h2 id="mallocfree-与-newdelete-的区别">malloc/free 与 new/delete 的区别</h2><ul><li>malloc 与 free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请和释放动态内存。</li><li>对于非内部数据类型的对象而言，用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free，因此C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new，和一个能完成清理与释放内存工作的运算符 delete。</li><li>new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void* 指针。new/delete 在实现上其实调用了 malloc/free 函数。</li><li>new 建立的是一个对象；malloc 分配的是一块内存。</li></ul><h1 id="面向对象编程">面向对象编程</h1><h2 id="string-类的实现">String 类的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString();</span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">char</span>);</span><br><span class="line">    ~MyString()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> length();<span class="comment">// 返回字符串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 返回字符串是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">c_str</span><span class="params">()</span></span>;<span class="comment">// 返回 c 风格的 str 的指针</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;, MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add operation</span></span><br><span class="line">    <span class="keyword">friend</span> MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compare operations</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> MyString &amp;, <span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数实现运算符重载,其实一般需要返回自身对象的，成员函数运算符重载会好一些</span></span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">size_t</span>)<span class="keyword">const</span>;</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    MyString &amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> MyString &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员操作函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">append</span><span class="params">(<span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">insert</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">const</span> MyString &amp;)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">size_t</span> index = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p_str;</span><br><span class="line">    <span class="keyword">size_t</span> strLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="派生类中构造函数与析构函数的调用顺序">派生类中构造函数与析构函数的调用顺序</h2><p>构造函数的调用顺序总是如下： 1. 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。 2. 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。 3. 派生类构造函数。 析构函数正好和构造函数相反。</p><h2 id="虚函数的实现原理">虚函数的实现原理</h2><p><strong>虚函数表</strong>：编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的虚函数表是一块连续的内存，每个内存单元中记录一个 JMP 指令的地址。类的每个虚函数占据虚函数表中的一块，如果类中有 N 个虚函数，那么其虚函数表将有 4N 字节的大小。</p><p>编译器在有虚函数的类的实例中创建了一个指向这个表的指针，该指针通常存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能）。这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p><p>有虚函数或虚继承的类实例化后的对象大小至少为 4 字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为 1 字节（没有非静态数据成员的情况下也要有 1 个字节来记录它的地址）。</p><p><strong>哪些函数适合声明为虚函数，哪些不能？</strong> * 当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果； * 内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； * 构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数； * 静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。</p><h2 id="虚继承的实现原理">虚继承的实现原理</h2><p>为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p><p>构造函数和析构函数的顺序：虚基类总是先于非虚基类构造，与它们在集成体系中的次序和位置无关。如果有多个虚基类，则按它们在派生列表中出现的顺序从左到右依次构造。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ZooAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ToyAnimal()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ToyAnimal construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Character()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Character construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BookCharacter()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BookCharacter construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter, <span class="keyword">public</span> Bear, <span class="keyword">virtual</span> <span class="keyword">public</span> ToyAnimal&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    TeddyBear()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"TeddyBear construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TeddyBear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器按照直接基类的声明顺序依次检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明顺序依次构造其他非虚基类。构造函数的顺序是：ZooAnimal, ToyAnimal, Character, BookCharacter, Bear, TeddyBear。析构过程与构造过程正好相反。</p><h1 id="内存管理">内存管理</h1><h2 id="程序加载时的内存分布">程序加载时的内存分布</h2><p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。</p><figure><img src="/posts/db684f2c/001.png" alt=""><figcaption>内存分布</figcaption></figure><ul><li>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</li><li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局 const 变量等。</li><li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li><li>BSS 段(.bss)：未初始化的全局变量和局部静态变量一般放在 .bss 的段里，以节省内存空间。</li><li>堆：用来容纳应用程序动态分配的内存区域。当程序使用 malloc 或 new 分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li><li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li><li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li><li>保留区：内存中受到保护而禁止访问的内存区域。</li></ul><h2 id="堆与栈的区别">堆与栈的区别</h2><ol type="1"><li>申请管理方式<ul><li>栈：由编译器自动管理，无需我们手工控制。</li><li>堆：堆的申请和释放工作由程序员控制，容易产生内存泄漏。</li></ul></li><li>申请后系统的响应<ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li>申请大小的限制<ul><li>栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 1 M（可修改），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li>申请效率的比较<ul><li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li><li>堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在 Windows 下，最好的方式是用 VirtualAlloc 分配内存，它不是在堆，也不是在栈而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</li></ul></li><li>堆与栈中的存储内容<ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li></ul></li></ol><p><strong>总结</strong>：堆和栈相比，由于大量 new/delete 的使用，容易造成大量的内存碎片；并且可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，ebp 和局部变量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是向堆申请内存更加灵活，有时候分配大量的内存空间，还是用堆好一些。</p><h2 id="常见的内存错误及其对策">常见的内存错误及其对策</h2><ol type="1"><li>内存分配未成功，却使用了它，因为没有意识到内存分配会不成功。 解决办法：在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 <span class="math inline">\(assert(p != NULL)\)</span> 进行检查。如果是用 malloc 或 new 来申请内存，应该用 <span class="math inline">\(if(p == NULL)\)</span> 或 <span class="math inline">\(if(p != NULL)\)</span> 进行防错处理。</li><li>内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：<ul><li>一是没有初始化的观念；</li><li>二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 解决方法：不要忘记为数组和动态内存赋初值，即便是赋零值也不可省略。防止将未被初始化的内存作为右值使用。</li></ul></li><li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1 ” 或者“少 1 ”的操作。特别是在 for 循环语句中，循环次数很容易搞错，导致数组操作越界。 解决方法：避免数组或指针的下标越界，特别要当心发生“多 1 ”或者“少 1 ”操作。</li><li>忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。 解决方法：动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定有错误（new/delete 同理）。</li><li>释放了内存却继续使用它。有三种情况：<ul><li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li><li>函数的 return 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li><li>使用 free 或 delete 释放了内存后，没有将指针设置为 NULL。导致产生“野指针”。 解决方法：用 free 或 delete 释放了内存之后，立即将指针设置为 NULL，防止产生“野指针”。</li></ul></li></ol><h2 id="智能指针">智能指针</h2><p>智能指针是在 &lt;memory&gt; 头文件中的 std 命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对 RAII “获取资源即初始化”编程至关重要，RAII 的主要原则是将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数，包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。在 C++11 中，定义了 3 种智能指针（unique_ptr、shared_ptr、weak_ptr），并删除了 C++98 中的 auto_ptr。</p><p>智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写 delete 语句删除指针指向的内存空间。</p><p><strong>unique_ptr</strong> “独占”所指向的对象。unique_ptr 小巧高效；大小等同于一个指针且支持 rvalue 引用，从而可实现快速插入和对 STL 集合的检索。</p><p><strong>shared_ptr</strong> 采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用 make_shared 标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的 shared_ptr。</p><p>智能指针支持的操作： * 使用重载的 -&gt; 和 * 运算符访问对象。 * 使用get成员函数获取原始指针，提供对原始指针的直接访问。你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。 * 使用删除器定义自己的释放操作。 * 使用 release 成员函数，作用是放弃智能指针对指针的控制权，将智能指针置空，并返回原始指针。（只支持unique_ptr） * 使用 reset 释放智能指针对对象的所有权。</p><p>智能指针的使用示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> _a): a(_a)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up1(<span class="keyword">new</span> Base(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Base&gt; up2 = up1;   //编译器提示未定义</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Base&gt; up2 = move(up1);  <span class="comment">//转移对象的所有权 </span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; up1-&gt;a &lt;&lt; endl; //运行时错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; up2-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//通过解引用运算符获取封装的原始指针 </span></span><br><span class="line">    up2.reset(); <span class="comment">// 显式释放内存 </span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp1(<span class="keyword">new</span> Base(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Base&gt; sp2 = sp1;  <span class="comment">//增加引用计数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//2</span></span><br><span class="line">    sp1.reset();  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"共享智能指针的数量："</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sp2-&gt;a &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">auto</span> sp3 = make_shared&lt;base&gt;(<span class="number">4</span>);<span class="comment">//利用make_shared函数动态分配内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="c-对象内存模型">C++ 对象内存模型</h1><p>在 C++ 中有两种类的数据成员：static 和 nonstatic，以及三种类的成员函数：static、nonstatic和virtual。</p><p>在 C++ 对象模型中 * 非静态数据<strong>成员</strong>被配置于每一个类的对象之中，静态数据<strong>成员</strong>则被存放在所有的类对象之外； * 静态及非静态成员<strong>函数</strong>也被放在类对象之外，虚函数则通过以下两个步骤支持： 1. 每一个类产生出一堆指向虚函数的指针，放在表格之中，这个表格被称为虚函数表（virtual table, vtbl）。 2. 每一个类对象被添加了一个指针，指向相关的虚函数表，通常这个指针被称为 vptr。vptr 的设定和重置都由每一个类的构造函数、析构函数和拷贝赋值运算符自动完成。另外，虚函数表地址的前面设置了一个指向 type_info 的指针，RTTI（Run Time Type Identification）运行时类型识别是由编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI 是为多态而生成的信息，所以只有具有虚函数的对象才会生成。</p><h2 id="继承下的对象内存模型">继承下的对象内存模型</h2><p>C++支持单一继承、多重继承和虚继承。在虚继承的情况下，虚基类不管在继承链中被派生多少次，永远只会存在一个实体。 1. 单一继承，继承关系为 class Derived : public Base。其对象的内存布局为：虚函数表指针、Base 类的非 static 成员变量、Derived 类的非 static 成员变量。 2. 多重继承，继承关系为 class Derived : public Base1, public Base2。其对象的内存布局为：基类 Base1 子对象和基类 Base2 子对象及 Derived 类的非 static 成员变量组成。基类子对象包括其虚函数表指针和其非 static 的成员变量。 3. 重复继承，继承关系如下。Derived 类的对象的内存布局与多继承相似，但是可以看到基类Base 的子对象在 Derived 类的对象的内存中存在一份拷贝。这样直接使用 Derived 中基类 Base 的相关成员时，就会引发歧义，可使用多重虚拟继承消除之。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></p><ol start="4" type="1"><li>虚继承，继承关系如下。其对象的内存布局与重复继承的类的对象的内存分布类似，但是基类Base 的子对象没有拷贝，在对象的内存中仅存在一个 Base 类的子对象。但是它的非 static 成员变量放置在对象的末尾处。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br></pre></td></tr></table></figure></li></ol><figure><img src="/posts/db684f2c/002.png" alt=""><figcaption>继承下的对象内存模型</figcaption></figure><h1 id="常见的设计模式">常见的设计模式</h1><h2 id="单例模式">单例模式</h2><p>当仅允许类的一个实例在应用中被创建的时候，我们使用单例模式（Singleton Pattern）。它保护类的创建过程来确保只有一个实例被创建，它通过设置类的构造方法为私有（private）来实现。要获得类的实例，单例类可以提供一个方法，如 GetInstance()，来返回类的实例。该方法是唯一可以访问类来创建实例的方法。</p><p><strong>优点</strong> 1. 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。 2. 减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 3. 避免对资源的多重占用。如避免对同一个资源文件的同时写操作。 4. 单例模式可以在系统设置全局的访问点，优化和共享资源访问。</p><p><strong>缺点</strong>：单例模式一般没有接口，扩展困难。不利于测试。</p><p><strong>使用场景</strong> 1. 在整个项目中需要一个共享访问点或共享数据。 2. 创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。 3. 需要定义大量的静态常量和静态方法的环境。</p><p><strong>实现</strong>：懒汉实现与饿汉实现 1. 懒汉实现，即实例化在对象首次被访问时进行。可以使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。同时需将默认构造函数声明为 private，防止用户调用默认构造函数创建对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Lock();</span><br><span class="line">        <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类有以下特征： * 它的构造函数是私有的，这样就不能从别处创建该类的实例。 * 它有一个唯一实例的静态指针 m_pInstance，且是私有的。 * 它有一个公有的函数，可以获取这个唯一的实例，并在需要的时候创建该实例。 * 此处进行了两次 m_Instance == NULL 的判断，是借鉴了 Java 的单例模式实现时，使用的所谓的“双检锁”机制。因为进行一次加锁和解锁是需要付出对应的代价的，而进行两次判断，就可以避免多次加锁与解锁操作，同时也保证了线程安全。</p><p>上面的实现存在一个问题，就是没有提供删除对象的方法。一个妥善的方法是让这个类自己知道在合适的时候把自己删除。程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如下面的代码中的 CGarbo 类（Garbo意为垃圾工人）: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="comment">//CGarbo类的唯一工作就是在析构函数中删除CSingleton的实例</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//定义一个静态成员，在程序结束时，系统会调用它的析构函数</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>类 CGarbo 被定义为 Singleton 的私有内嵌类，以防该类被在其他地方滥用。程序运行结束时，系统会调用 Singleton 的静态成员 Garbo 的析构函数，该析构函数会删除单例的唯一实例。</p><ol start="2" type="1"><li>饿汉实现：在程序开始时就自行创建实例。如果说懒汉实现是“时间换空间”，那么饿汉实现就是“空间换时间”，因为一开始就创建了实例，所以每次用到的之后直接返回就好了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_pInstance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo()&#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::m_pInstance != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo garbo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">Singleton* Singleton::GetInstance()&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="简单工厂模式">简单工厂模式</h2><p>简单工厂模式的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。 <img src="/posts/db684f2c/003.png" alt="简单工厂模式"> <strong>例子</strong>：有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显式地告诉生产工厂。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CTYPE &#123;COREA, COREB&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctype == COREA) <span class="comment">//工厂内部判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();  <span class="comment">//生产核A</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctype == COREB)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB();  <span class="comment">//生产核B</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样设计的主要缺点之前也提到过，就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。于是，工厂方法模式出现了。</p><h2 id="工厂方法模式">工厂方法模式</h2><p>工厂方法模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。 <img src="/posts/db684f2c/004.png" alt="工厂方法模式"> 例子：这家生产处理器核的厂家赚了不少钱，于是决定再开设一个工厂专门用来生产 B 型号的单核，而原来的工厂专门用来生产 A 型号的单核。这时，客户要做的是找好工厂，比如要 A 型号的核，就找 A 工厂要；否则找 B 工厂要，不再需要告诉工厂具体要什么型号的处理器核了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"SingleCore B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产A核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产B核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span>:</span> <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在 C++ 实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。</p><h2 id="抽象工厂模式">抽象工厂模式</h2><p>抽象工厂模式的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 <img src="/posts/db684f2c/005.png" alt="抽象工厂模式"> 例子：这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span>:</span> <span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span><span class="keyword">public</span> SingleCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Single Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreA</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core A"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreB</span> :</span> <span class="keyword">public</span> MultiCore&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Multi Core B"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span><span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiCoreA(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span> <span class="keyword">public</span> CoreFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiCoreB(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试可能会遇到的与 C++ 相关的问答记录。&lt;/p&gt;
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="C++" scheme="https://yz1509.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://yz1509.github.io//posts/ee040603/"/>
    <id>https://yz1509.github.io//posts/ee040603/</id>
    <published>2018-07-26T05:17:37.000Z</published>
    <updated>2019-10-30T09:58:04.454Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍图及其相关算法。</p><a id="more"></a><h1 id="什么是图">什么是图</h1><p><strong>定义</strong> 一个图 <span class="math inline">\(G = (V, E)\)</span> 由顶点（或结点）的非空集 <span class="math inline">\(V\)</span> 和边的集合 <span class="math inline">\(E\)</span> 构成，每条边有一个或两个顶点与它相连，这样的顶点称为边的端点。边连接它的端点。</p><h2 id="图的表示">图的表示</h2><ul><li>邻接链表：稀疏图</li><li>邻接矩阵：稠密图，或者需要快速判断任意两个结点之间是否有边的情况 <img src="/posts/ee040603/001.png" alt="图的表示"></li></ul><h1 id="广度优先搜索">广度优先搜索</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** u.color 存放结点 u 的颜色属性</span></span><br><span class="line"><span class="comment">  * 白色表示未被发现</span></span><br><span class="line"><span class="comment">  * 灰色表示邻接结点中还有白色结点</span></span><br><span class="line"><span class="comment">  * 黑色表示邻接结点均被发现</span></span><br><span class="line"><span class="comment">  * u.π 存放前驱结点</span></span><br><span class="line"><span class="comment">  * u.d 存放从源结点 s 到结点 u 之间的距离</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">BFS(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V - &#123;s&#125;</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = ∞</span><br><span class="line">        u.π = NIL</span><br><span class="line">    s.color = BLACK</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.π = NIL</span><br><span class="line">    Q = ∅</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅<span class="comment">// 灰色结点的集合</span></span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v in G.Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.π = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><blockquote><p>BFS 的总运行时间为 O(V + E)</p></blockquote><figure><img src="/posts/ee040603/002.png" alt=""><figcaption>BFS</figcaption></figure><h2 id="bfs-的性质">BFS 的性质</h2><ol type="1"><li>BFS 可以计算出从源结点 s 到 结点 v 的最短路径。</li><li>BFS 在对图进行搜索的过程中将创建一棵广度优先树</li></ol><h1 id="深度优先搜索">深度优先搜索</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** u.color 存放结点 u 的颜色属性</span></span><br><span class="line"><span class="comment">  * 白色表示未被发现</span></span><br><span class="line"><span class="comment">  * 灰色表示邻接结点中还有白色结点</span></span><br><span class="line"><span class="comment">  * 黑色表示邻接结点均被发现</span></span><br><span class="line"><span class="comment">  * u.π 存放前驱结点</span></span><br><span class="line"><span class="comment">  * u.d 记录结点 u 第一次被发现的时间</span></span><br><span class="line"><span class="comment">  * u.f 记录搜索完成对 u 的邻接链表扫描的事件</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">DFS(G)</span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V</span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.π = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u in G.V</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE</span><br><span class="line">            DFS-VISIT(G, u)</span><br><span class="line"></span><br><span class="line">DFS-VISIT(G, u)</span><br><span class="line">    time = time + <span class="number">1</span><span class="comment">// white vertex u has just been discovered</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY</span><br><span class="line">    <span class="keyword">for</span> each v in G.Adj[u]<span class="comment">// explore edge (u, v)</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE</span><br><span class="line">            v.π = u</span><br><span class="line">            DFS-VISIT(G, v)</span><br><span class="line">    u.color = BLACK<span class="comment">// blacken u, it is finished</span></span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time</span><br></pre></td></tr></table></figure><blockquote><p>DFS 的总运行时间为 O(V + E)</p></blockquote><figure><img src="/posts/ee040603/003.png" alt=""><figcaption>DFS</figcaption></figure><h2 id="dfs-的性质">DFS 的性质</h2><ol type="1"><li>括号化定理：在对有向或无向图进行的任意 DFS 中，对于任意两个结点 u 和 v 来说，下面三种情况只有一种成立：<ul><li>区间 <span class="math inline">\([u.d, u.f]\)</span> 和 区间 <span class="math inline">\([v.d, v.f\)</span> 完全分离，在深度优先森林中，结点 u 不是结点 v 的后代，结点 v 也不是结点 u 的后代</li><li>区间 <span class="math inline">\([u.d, u.f]\)</span> 完全包含在 区间 <span class="math inline">\([v.d, v.f\)</span> 内，在深度优先树中，结点 u 是结点 v 的后代</li><li>区间 <span class="math inline">\([v.d, v.f]\)</span> 完全包含在 区间 <span class="math inline">\([u.d, u.f\)</span> 内，在深度优先树中，结点 v 是结点 u 的后代</li></ul></li><li>边的分类<ul><li>树边：是深度优先森林 <span class="math inline">\(G_π\)</span> 中的边。如果结点 v 是因算法对边 (u, v) 的探索而首先被发现，则 (u, v) 是一条树边</li><li>后向边：是将结点 u 连接到其在深度优先树中祖先结点 v 的边。由于有向图中可以有自循环，自循环也被认为是后向边</li><li>前向边：是将结点 u 连接到其在深度优先树中后代结点 v 的边</li><li>横向边：其他所有的边 &gt; 在对无向图 G 进行深度优先搜索时，每条边要么是树边，要么是后向边。</li></ul></li></ol><h2 id="拓扑排序">拓扑排序</h2><p>对于一个有向无环图 G(V, E) 来说，其拓扑排序是 G 中所有结点的一种线性次序，该次序满足如下条件：如果图 G 包含边 (u, v)，则结点 u 在拓扑排序中处于结点 v 的前面。 <img src="/posts/ee040603/004.png" alt="拓扑排序"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">    call DFS(G) to compute finishing time v.f for each vertex v</span><br><span class="line">    as each vertex is finished, insert it onto the front of a linked <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">return</span> the linked of <span class="built_in">list</span> of vertices</span><br></pre></td></tr></table></figure></p><h2 id="强连通分量">强连通分量</h2><p><strong>定义：</strong> 如果一个有向图中任意两个顶点互相可达，则该有向图是强连通的。 图 G 的转置 <span class="math inline">\(G^T = (V, E^T)\)</span>，其中 <span class="math inline">\(E^T = {(u, v): (u, v) \in E}\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED-COMPONENTS(G)</span><br><span class="line">    call DFS(G) to compute finishing time u.f for each vertex u</span><br><span class="line">    compute G^T</span><br><span class="line">    call DFS(G^T), but in the main loop of DFS, consider the vertices</span><br><span class="line">        in order of decreasing u.f (as computed in line <span class="number">1</span>)</span><br><span class="line">    output the vertices of each tree in the depth-first forest formed</span><br><span class="line">        in line <span class="number">3</span> as a separate strongly connected component</span><br></pre></td></tr></table></figure></p><figure><img src="/posts/ee040603/005.png" alt=""><figcaption>强连通分量</figcaption></figure><h1 id="最小生成树">最小生成树</h1><p><strong>定义：</strong> 连通加权图里的最小生成树是具有边的权值之和最小的生成树。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在每遍循环之前，A 是某棵最小生成树的一个子集</span></span><br><span class="line"><span class="comment">// 加入集合 A 而不会破坏 A 的循环不变式的边称为集合 A 的安全边</span></span><br><span class="line">GENERIC-MST(G, w)</span><br><span class="line">    A = ∅</span><br><span class="line">    <span class="keyword">while</span> A does <span class="keyword">not</span> form a spanning tree</span><br><span class="line">        find an edge(u, v) that is safe <span class="keyword">for</span> A</span><br><span class="line">        A = A ∪ &#123;(u, v)&#125;</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p><p><strong>定理：</strong> 设 G = (V, E) 是一个在边 E 上定义了实数值权重函数 w 的连通无向图。设集合 A 为 E 的一个子集，且 A 包括在图 G 的某棵最小生成树中，设 (S, V - S) 是图 G 中尊重集合 A 的任意一个切割（集合 A 中不存在横跨该切割的边），又设 (u, v) 是横跨切割 (S, V - S) 的一条轻边。那么边 (u, v) 对于集合 A 是安全的。</p><h2 id="kruskal-算法">Kruskal 算法</h2><p>在 Kurskal 算法中，集合 A 是一个森林，其结点就是给定图的结点。每次加入集合 A 中的安全边永远是权重最小的连接两个不同分量的边。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MST-KRUSKAL(G, w)</span><br><span class="line">    A = ∅</span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V</span><br><span class="line">        MAKE-SET(v)</span><br><span class="line">    sort the edge of G.E into nondecreasing order by weight w</span><br><span class="line">    <span class="keyword">for</span> each edge (u, v) in G.E, taken in nondecreasing order by weight</span><br><span class="line">        <span class="keyword">if</span> FIND-SET(u) ≠ FIND-SET(v)</span><br><span class="line">            A = A ∪ &#123;(u, v)&#125;</span><br><span class="line">            UNION(u, v)</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p><blockquote><p>Kruskal 算法的时间复杂度为 <span class="math inline">\(O(ElgV)\)</span>。</p></blockquote><figure><img src="/posts/ee040603/006.png" alt=""><figcaption>Kruskal 算法</figcaption></figure><h2 id="prim-算法">Prim 算法</h2><p>在 Prim 算法里，集合 A 则是一棵树。这棵树从一个任意的根结点 r 开始，一直长大到覆盖 V 中的所有结点时为止。每次加入到 A 中的安全边永远是连接 A 和 A 之外某个结点的边中权重最小的边。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MST-PRIM(G, w, r)</span><br><span class="line">    <span class="keyword">for</span> each u in G.V</span><br><span class="line">        u.key = ∞</span><br><span class="line">        u.π = NIL</span><br><span class="line">    r.key = <span class="number">0</span></span><br><span class="line">    Q = G.V</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅</span><br><span class="line">        u = EXTRACT-MIN(Q)</span><br><span class="line">        <span class="keyword">for</span> each v in G.Adj[u]</span><br><span class="line">            <span class="keyword">if</span> v in Q <span class="keyword">and</span> w(u, v) &lt; v.key</span><br><span class="line">                v.π = u</span><br><span class="line">                v.key = w(u, v)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 <span class="math inline">\(O(ElgV)\)</span>； 如果使用斐波那契堆来实现最小优先队列 Q，则 Prim 算法的运行时间将改进到 <span class="math inline">\(O(E + VlgV)\)</span></p></blockquote><figure><img src="/posts/ee040603/007.png" alt=""><figcaption>Prim算法</figcaption></figure><h1 id="单源最短路径">单源最短路径</h1><ol type="1"><li>最短路径的子路径也是最短路径</li><li>如果从结点 s 到结点 v 的某条路径上存在权重为负值的环路，我们定义 <span class="math inline">\(\delta(s, v) = -\infty\)</span></li><li>一般地，我们假定在找到的最短路径中没有环路，即它们都是简单路径。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始化</span></span><br><span class="line"><span class="comment">  * v.d：s 到 v 的最短路径估计</span></span><br><span class="line"><span class="comment">  * v.π：前驱结点</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex v in G.V</span><br><span class="line">        v.d = ∞</span><br><span class="line">        v.π = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 松弛操作</span></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v)</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.π = u</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>Dijkstra 算法和用于有向无环图的最短路径算法对每条边仅松弛一次。 Bellman-Ford 算法则对每条边松弛 |V| - 1 次。</p></blockquote><h2 id="bellman-ford-算法">Bellman-Ford 算法</h2><p>Bellman-Ford 算法解决的是一般情况下的最短路径问题。该算法返回 TRUE 值当且仅当输入图不包含可以从源结点到达的权重为负值的环路。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s)</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V|<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u, v) in G.E</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge (u, v) in G.E</span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v)</span><br><span class="line">            <span class="keyword">return</span> FALSE</span><br><span class="line">    <span class="keyword">return</span> TRUE</span><br></pre></td></tr></table></figure></p><blockquote><p>Bellman-Ford 算法的总运行时间为 O(VE) <img src="/posts/ee040603/008.png" alt="Bellman-Ford 算法"></p></blockquote><h2 id="有向无环图中的单源最短路径问题">有向无环图中的单源最短路径问题</h2><p>根据结点的拓扑排序次序来对带权重的有向无环图 G = (V, E) 进行边的松弛操作，我们便可以在 <span class="math inline">\(O(V + E)\)</span> 时间内计算出从单个源结点到所有结点之间的最短路径。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DAG-SHOPTEST-PATHS(G, w, s)</span><br><span class="line">    topologically sort the vertice of G</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> each vertex u, taken in topologically sorted order</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.Adj[u]</span><br><span class="line">            RELAX(u, v, w)</span><br></pre></td></tr></table></figure></p><figure><img src="/posts/ee040603/009.png" alt=""><figcaption>DAG</figcaption></figure><h2 id="dijkstra-算法">Dijkstra 算法</h2><p>Dijkstra 算法解决的是带权重的有向图上的单源最短路径问题，该算法要求所有边的权重都为非负值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = ∅</span><br><span class="line">    Q = G.V</span><br><span class="line">    <span class="keyword">while</span> Q ≠ ∅</span><br><span class="line">        u = EXTRACT-MIN(Q)</span><br><span class="line">        S = S ∪ &#123;u&#125;</span><br><span class="line">        <span class="keyword">for</span> each vertex v in G.Adj[u]</span><br><span class="line">            RELAX(u, v, w)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果使用二叉最小优先队列来实现最小优先队列 Q，时间复杂度为 <span class="math inline">\(O(ElgV)\)</span>； 如果使用斐波那契堆来实现最小优先队列 Q，则 Dijkstra 算法的运行时间将改进到 <span class="math inline">\(O(E + VlgV)\)</span></p></blockquote><figure><img src="/posts/ee040603/010.png" alt=""><figcaption>Dijsktra算法</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍图及其相关算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="图" scheme="https://yz1509.github.io/tags/%E5%9B%BE/"/>
    
      <category term="BFS" scheme="https://yz1509.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://yz1509.github.io/tags/DFS/"/>
    
      <category term="拓扑排序" scheme="https://yz1509.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="强连通分量" scheme="https://yz1509.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="最小生成树" scheme="https://yz1509.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="Kruskal 算法" scheme="https://yz1509.github.io/tags/Kruskal-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Prim 算法" scheme="https://yz1509.github.io/tags/Prim-%E7%AE%97%E6%B3%95/"/>
    
      <category term="单源最短路径" scheme="https://yz1509.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Bellman-Ford 算法" scheme="https://yz1509.github.io/tags/Bellman-Ford-%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra 算法" scheme="https://yz1509.github.io/tags/Dijkstra-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>吐血bug合集（持续更新）</title>
    <link href="https://yz1509.github.io//posts/afec8fb8/"/>
    <id>https://yz1509.github.io//posts/afec8fb8/</id>
    <published>2018-07-25T12:23:21.000Z</published>
    <updated>2019-10-30T09:59:18.816Z</updated>
    
    <content type="html"><![CDATA[<p>量子波动更新。</p><a id="more"></a><ol type="1"><li>图片后缀名的大小写有区别，比如 ![avatar](sample.png) 本地可以正常加载 sample.PNG，但是上传后静态网页加载失败 = =</li><li>使用表格时，一定要前后都有空行，不然显示出 bug.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;量子波动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://yz1509.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="bug" scheme="https://yz1509.github.io/tags/bug/"/>
    
      <category term="图片显示" scheme="https://yz1509.github.io/tags/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://yz1509.github.io//posts/7b216a3b/"/>
    <id>https://yz1509.github.io//posts/7b216a3b/</id>
    <published>2018-07-25T07:06:19.000Z</published>
    <updated>2019-10-30T09:57:26.657Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍二叉树和红黑树。</p><a id="more"></a><h1 id="什么是树">什么是树</h1><p><strong>定义 1</strong> 树是没有简单回路的连通无向图。</p><p><strong>定义 2</strong> 有根树是指定一个顶点作为根并且每条边的方向都离开根的树。 <img src="/posts/7b216a3b/tree001.png" alt="树"></p><h2 id="二叉树">二叉树</h2><ul><li>如果 <span class="math inline">\(x.p = NIL\)</span>，则 <span class="math inline">\(x\)</span> 是根结点</li><li>属性 <span class="math inline">\(T.root\)</span> 指向整棵树 <span class="math inline">\(T\)</span> 的根结点，如果 <span class="math inline">\(T.root = NIL\)</span>，则该数为空 <img src="/posts/7b216a3b/tree002.png" alt="二叉树"></li></ul><h2 id="分支无限制的有根树">分支无限制的有根树</h2><ul><li><span class="math inline">\(x.left-child\)</span> 指向结点 <span class="math inline">\(x\)</span> 的最左边的孩子结点</li><li><span class="math inline">\(x.right-sibling\)</span> 指向结点 <span class="math inline">\(x\)</span> 右侧相邻的兄弟结点 <img src="/posts/7b216a3b/tree003.png" alt="分支无限制"></li></ul><h1 id="二叉搜索树">二叉搜索树</h1><h2 id="什么是二叉搜索树">什么是二叉搜索树</h2><p>二叉搜索树（binary-search-tree，BST）性质：设 <span class="math inline">\(x\)</span> 是二叉搜索树中的一个结点。如果 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 左子树中的一个结点，那么 <span class="math inline">\(y.key \leq x.key\)</span>；如果 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 右子树中的一个结点，那么 <span class="math inline">\(y.key \geq x.key\)</span>。</p><p>中序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">    <span class="keyword">if</span> x ≠ NIL</span><br><span class="line">        INOREDER-TREE-WALK(x.left)</span><br><span class="line">        print x.key</span><br><span class="line">        INOREDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure></p><blockquote><p>中序遍历时间复杂度为 O(n)，使用替换法，通过证明 <span class="math inline">\(T(n) \le (c+d)n + c\)</span>，可以证得 <span class="math inline">\(T(n) = O(n)\)</span></p></blockquote><h2 id="查询二叉搜索树">查询二叉搜索树</h2><h3 id="查找">查找</h3><ul><li><p>递归版本 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x, k)</span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.left, k)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure></p></li><li><p>迭代版本（效率更高） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k)</span><br><span class="line">    <span class="keyword">while</span> x ≠ NIL <span class="keyword">and</span> k ≠ x.key</span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span> x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="最大小关键字元素">最大（小）关键字元素</h3><ul><li><p>最小关键字 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUM(x)</span><br><span class="line">    <span class="keyword">while</span> x.left ≠ NIL</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p></li><li><p>最大关键字 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MAXIMUM(x)</span><br><span class="line">    <span class="keyword">while</span> x.right ≠ NIL</span><br><span class="line">        x = .right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="后继和前驱">后继和前驱</h3><p>如果所有的关键字互不相同，则一个结点 <span class="math inline">\(x\)</span> 的后继是大于 <span class="math inline">\(x.key\)</span> 的最小关键字的结点。二叉搜索树的性质允许我们没有任何关键字的比较来确定一个结点的后继。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line">    <span class="keyword">if</span> x.right ≠ NIL</span><br><span class="line">        <span class="keyword">return</span> TREE-MINIMUM(x.right)</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">while</span> y ≠ NIL <span class="keyword">and</span> x == y.right</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure></p><blockquote><p>在一棵高度为 <span class="math inline">\(h\)</span> 的二叉搜索树上，动态集合上的操作 SEARCH、MINIMUM、MAXIMUM、SUCCESSOR、PREDECESSOR 可以在 <span class="math inline">\(O(h)\)</span> 时间内完成。</p></blockquote><h2 id="插入和删除">插入和删除</h2><h3 id="插入">插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, z)</span><br><span class="line">    y = NIL<span class="comment">// 保存 z 要插入的位置</span></span><br><span class="line">    x = T.root</span><br><span class="line">    <span class="keyword">while</span> x ≠ NIL</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span> x = x.right</span><br><span class="line">    z.p = y</span><br><span class="line">    <span class="keyword">if</span> y == NIL</span><br><span class="line">        T.root = z<span class="comment">// tree T was empty</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span> y.right = z</span><br></pre></td></tr></table></figure><figure><img src="/posts/7b216a3b/tree004.png" alt=""><figcaption>插入</figcaption></figure><h3 id="删除">删除</h3><p>从二叉搜索树 <span class="math inline">\(T\)</span> 中删除结点 <span class="math inline">\(z\)</span> 分为三种基本情况 1. 如果 <span class="math inline">\(z\)</span> 没有孩子结点，那么直接将它删除，并修改它的父结点，用 NIL 替换 <span class="math inline">\(z\)</span> 2. 如果 <span class="math inline">\(z\)</span> 只有一个孩子，那么将这个孩子提升到树中 <span class="math inline">\(z\)</span> 的位置上，并修改 <span class="math inline">\(z\)</span> 的父结点，用 <span class="math inline">\(z\)</span> 的孩子来替换 <span class="math inline">\(z\)</span> 3. 如果 <span class="math inline">\(z\)</span> 有两个孩子，那么找到 <span class="math inline">\(z\)</span> 的后继 <span class="math inline">\(y\)</span>，用 <span class="math inline">\(y\)</span> 来占据树中 <span class="math inline">\(z\)</span> 的位置 <img src="/posts/7b216a3b/tree005.png" alt="删除"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一棵以 v 为根的子树来替换一棵以 u 为根的子树</span></span><br><span class="line">TRANSPLANT(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.p == NIL</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">        u.p.left = v</span><br><span class="line">    <span class="keyword">else</span> u.p.right = v</span><br><span class="line">    <span class="keyword">if</span> v ≠ NIL</span><br><span class="line">        v.p = u.p</span><br><span class="line">        </span><br><span class="line">TREE-DELETE(T, z)</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL<span class="comment">// (a)</span></span><br><span class="line">        TRANSPLANT(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == NIL<span class="comment">// (b)</span></span><br><span class="line">        TRANSPLANT(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span> y = TREE-MINIMUM(z.right)</span><br><span class="line">        <span class="keyword">if</span> y.p ≠ z<span class="comment">// (d)</span></span><br><span class="line">            TRANSPLANT(T, y, y.right)</span><br><span class="line">            y.right = z.right</span><br><span class="line">            y.right.p = y</span><br><span class="line">        TRANSPLANT(T, z, y)<span class="comment">// (c)</span></span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure></p><blockquote><p>在一棵高度为 <span class="math inline">\(h\)</span> 的二叉搜索树上，实现动态集合的操作 INSERT 和 DELETE，可以在 <span class="math inline">\(O(h)\)</span> 时间内完成。 一棵有 <span class="math inline">\(n\)</span> 个不同关键字的随机构建二叉搜索树的期望高度为 <span class="math inline">\(O(lg n)\)</span></p></blockquote><h1 id="红黑树">红黑树</h1><h2 id="红黑树的性质">红黑树的性质</h2><p>一棵红黑树是满足下面红黑性质的二叉搜索树： 1. 每个结点或是红色的，或是黑色的 2. 根结点是黑色的 3. 每个叶子结点（NIL）也是黑色的 4. 如果一个结点是红色的，则它的两个子结点都是黑色的 5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</p><p>从某个结点 <span class="math inline">\(x\)</span> 出发（不含该结点）到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的 black-height，记为 bh(x)。 <img src="/posts/7b216a3b/tree006.png" alt="红黑树"> &gt; 一棵有 <span class="math inline">\(n\)</span> 个内部结点的红黑树的高度至多为 <span class="math inline">\(2lg(n+1)\)</span>。</p><h2 id="旋转">旋转</h2><p>旋转是一种能保持二叉搜索树性质的局部操作。分为两种旋转：左旋和右旋。 <img src="/posts/7b216a3b/tree007.png" alt="旋转"> 在 LEFT-ROTATION 的伪代码中，假设 <span class="math inline">\(x.right \ne T.nil\)</span> 且根结点的父结点为 <span class="math inline">\(T.nil\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATION(T, x)</span><br><span class="line">    y = x.right<span class="comment">// set y</span></span><br><span class="line">    x.right = y = left<span class="comment">// turn y's left subtree into x's right subtree</span></span><br><span class="line">    <span class="keyword">if</span> y.left ≠ T.nil</span><br><span class="line">        y.left.p = x</span><br><span class="line">    y.p = x.p<span class="comment">// link x's parent to y</span></span><br><span class="line">    <span class="keyword">if</span> x.p == T.nil</span><br><span class="line">        T.root = y</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> x == x.p.left</span><br><span class="line">        x.p.left =y</span><br><span class="line">    <span class="keyword">else</span> x.p.right = y</span><br><span class="line">    y.left = x<span class="comment">// put x on y's left</span></span><br><span class="line">    x.p = y</span><br></pre></td></tr></table></figure></p><p>RIGHT-ROTATION 操作的伪代码是对称的。在旋转操作中只有指针改变，其他属性都保持不变。下图给出了一个 LEFT-ROTATION 操作修改二叉搜索树的例子。 <img src="/posts/7b216a3b/tree008.png" alt="左旋例子"></p><h2 id="插入-1">插入</h2><p>有三种情况： 1. <span class="math inline">\(z\)</span> 的叔结点 <span class="math inline">\(y\)</span> 是红色的 <img src="/posts/7b216a3b/tree009.png" alt="红黑树插入case1"> 2. <span class="math inline">\(z\)</span> 的叔结点 <span class="math inline">\(y\)</span> 是黑色的且 <span class="math inline">\(z\)</span> 是一个右孩子 3. <span class="math inline">\(z\)</span> 的叔结点 <span class="math inline">\(y\)</span> 是黑色的且 <span class="math inline">\(z\)</span> 是一个左孩子 <img src="/posts/7b216a3b/tree010_v2.png" alt="case2&amp;3"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 z 插入树 T 中，然后将 z 着为红色</span></span><br><span class="line">RB-INSERT(T, z)</span><br><span class="line">    y = T.nil</span><br><span class="line">    x = T.root</span><br><span class="line">    whil x ≠ T.nil</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span> x = x.right</span><br><span class="line">    z.p = y</span><br><span class="line">    <span class="keyword">if</span> y == T.nil</span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span> y.right = z</span><br><span class="line">    z.left = T.nil</span><br><span class="line">    z.right = T.nil</span><br><span class="line">    z.color = RED</span><br><span class="line">    RB-INSERT-FIXUP(T, z)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 z 后，对树进行调整来保持红黑性质</span></span><br><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line">    <span class="keyword">while</span> z.p.color == RED</span><br><span class="line">        <span class="keyword">if</span> z.p == z.p.p.left</span><br><span class="line">            y = z.p.p.right</span><br><span class="line">            <span class="keyword">if</span> y.color == RED</span><br><span class="line">                z.p.color = BLACK<span class="comment">// case 1</span></span><br><span class="line">                y.color = BLACK <span class="comment">// case 1</span></span><br><span class="line">                z.p.p.color = RED<span class="comment">// case 1</span></span><br><span class="line">                z = z.p.p<span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> z == z.p.right</span><br><span class="line">                z = z.p<span class="comment">// case 2</span></span><br><span class="line">                LEFT-ROTATION(T, z)<span class="comment">// case 2</span></span><br><span class="line">            z.p.color = BLACK<span class="comment">// case 3</span></span><br><span class="line">            z.p.p.color = RED<span class="comment">// case 3</span></span><br><span class="line">            RIGHT-ROTATION(T, z.p.p)<span class="comment">// case 3</span></span><br><span class="line">        <span class="keyword">else</span>(same as then clause</span><br><span class="line">                with <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    T.root.color = BLACK</span><br></pre></td></tr></table></figure></p><figure><img src="/posts/7b216a3b/tree011.png" alt=""><figcaption>红黑树插入</figcaption></figure><h2 id="删除-1">删除</h2><p>有四种情况： 1. <span class="math inline">\(x\)</span> 的兄弟结点 <span class="math inline">\(w\)</span> 是红色的 2. <span class="math inline">\(x\)</span> 的兄弟结点 <span class="math inline">\(w\)</span> 是黑色的，而且 <span class="math inline">\(w\)</span> 的两个子结点都是黑色的 3. <span class="math inline">\(x\)</span> 的兄弟结点 <span class="math inline">\(w\)</span> 是黑色的， <span class="math inline">\(w\)</span> 的左孩子是红色的，右孩子是黑色的 4. <span class="math inline">\(x\)</span> 的兄弟结点 <span class="math inline">\(w\)</span> 是黑色的，且 <span class="math inline">\(w\)</span> 的右孩子是红色的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一棵以 v 为根的子树来替换一棵以 u 为根的子树</span></span><br><span class="line">RB-TRANSPLANT(T, u, v)</span><br><span class="line">    <span class="keyword">if</span> u.p == T.nil</span><br><span class="line">        T.root = v</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">        u.p.left = v</span><br><span class="line">    <span class="keyword">else</span> u.p.right = v</span><br><span class="line">v.p = u.p</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过程和 TREE-DELETE 类似</span></span><br><span class="line">RB-DELETE(T, z)</span><br><span class="line">    y = z</span><br><span class="line">    y-original-color = y.color</span><br><span class="line">    <span class="keyword">if</span> z.left == T.nil</span><br><span class="line">        x = z.right</span><br><span class="line">        RB-TRANSPLANT(T, z, z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">        x = z.left</span><br><span class="line">        RB-TRANSPLANT(T, z, z.left)</span><br><span class="line">    <span class="keyword">else</span> y = TREE-MINIMUM(z.right)</span><br><span class="line">        y-orginal-color = y.color</span><br><span class="line">        x = y.right</span><br><span class="line">        <span class="keyword">if</span> y.p == z</span><br><span class="line">            x.p = y</span><br><span class="line">        <span class="keyword">else</span> RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">            y.right = z.right</span><br><span class="line">            y.right.p = y</span><br><span class="line">        RB-TRANSPLANT(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br><span class="line">        y.color = z.color</span><br><span class="line">    <span class="keyword">if</span> y-orginal-color == BLACK</span><br><span class="line">        RB-DELETE-FIXUP(T, x)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 通过改变颜色和执行旋转来恢复红黑性质</span></span><br><span class="line">RB-DELETE-FIXUP(T, x)</span><br><span class="line">    <span class="keyword">while</span> x ≠ T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">        <span class="keyword">if</span> x == x.p.left</span><br><span class="line">            w = x.p.right</span><br><span class="line">            <span class="keyword">if</span> w.color == RED</span><br><span class="line">                w.color = BLACK<span class="comment">// case 1</span></span><br><span class="line">                x.p.color = RED<span class="comment">// case 1</span></span><br><span class="line">                LEFT-ROTATION(T, x.p)<span class="comment">// case 1</span></span><br><span class="line">                w = x.p.right<span class="comment">// case 1</span></span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK</span><br><span class="line">                w.color = RED<span class="comment">// case 2</span></span><br><span class="line">                x = x.p<span class="comment">// case 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">                w.left.color = BLACK<span class="comment">// case 3</span></span><br><span class="line">                w.color = RED<span class="comment">// case 3</span></span><br><span class="line">                RIGHT-ROTATION(T, w)<span class="comment">// case 3</span></span><br><span class="line">                w = x.p.right<span class="comment">// case 3</span></span><br><span class="line">            w.color = x.p.color<span class="comment">// case 4</span></span><br><span class="line">            x.p.color = BLACK<span class="comment">// case 4</span></span><br><span class="line">            w.right.color = BLACK<span class="comment">// case 4</span></span><br><span class="line">            LEFT-ROTATION(T, x.p)<span class="comment">// case 4</span></span><br><span class="line">            x = T.root<span class="comment">// case 4</span></span><br><span class="line">        <span class="keyword">else</span> (same as then clause wiht</span><br><span class="line">                <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    x.color = BLACK</span><br></pre></td></tr></table></figure></p><figure><img src="/posts/7b216a3b/tree012.png" alt=""><figcaption>四种情况</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍二叉树和红黑树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="二叉搜索树" scheme="https://yz1509.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="红黑树" scheme="https://yz1509.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 204. Count Primes</title>
    <link href="https://yz1509.github.io//posts/9235f089/"/>
    <id>https://yz1509.github.io//posts/9235f089/</id>
    <published>2018-07-20T09:52:43.000Z</published>
    <updated>2019-10-30T10:03:20.991Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍素数判断及其分布规律。</p><a id="more"></a><h1 id="description">Description</h1><p><a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">题目链接</a> Count the number of prime numbers less than a non-negative number n.</p><p><strong>Example:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">10</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: There are <span class="number">4</span> prime numbers less than <span class="number">10</span>, they are <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7.</span></span><br></pre></td></tr></table></figure></p><h1 id="思路分析">思路分析</h1><p>使用埃拉托斯特尼筛选法，获取素数序列，从而得到小于 n 的素数个数。 &gt; 埃拉托斯特尼筛选法：埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数 n 以内的全部素数，必须把不大于 <span class="math inline">\(\sqrt{n}\)</span> 的所有素数的倍数剔除，剩下的就是素数。</p><h1 id="源码">源码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; NotPrime(n, <span class="literal">false</span>);<span class="comment">// bool变量初始为false较好</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> upper = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>)&#123;<span class="comment">// 剔除素数 2 的倍数</span></span><br><span class="line">        <span class="keyword">if</span> (!NotPrime[i])&#123;</span><br><span class="line">            ++sum;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; upper)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j += i)&#123; <span class="comment">// 剔除素数 i 的倍数</span></span><br><span class="line">            NotPrime[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展-素数判断">拓展 — 素数判断</h1><p>质数（Prime number），又称素数，为只有 1 个自身两个因数的数。下面介绍两种判断素数的方法。</p><ol type="1"><li><p>直观判断法 根据定义判断从 2 到 <span class="math inline">\(\sqrt{n}\)</span> 是否存在 n 的约数即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime_1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> upper = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= upper; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>应用素数分布规律 素数分布规律：大于等于 5 的素数一定和 6 的倍数相邻。例如 5 和 7，11 和 13,17 和 19 等等； 证明：令 <span class="math inline">\(x ≥ 1\)</span>，将大于等于 5 的自然数表示如下：</p></li></ol><p><span class="math inline">\(··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···\)</span></p><p>可以看到，不在 6 的倍数两侧，即 <span class="math inline">\(6x\)</span> 两侧的数为 <span class="math inline">\(6x+2\)</span>，<span class="math inline">\(6x+3\)</span>，<span class="math inline">\(6x+4\)</span>，可以表示为<span class="math inline">\(2(3x+1)\)</span>，<span class="math inline">\(3(2x+1)\)</span>，<span class="math inline">\(2(3x+2)\)</span>，所以它们一定不是素数，显然，素数要出现只可能出现在 6x 的相邻两侧。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime_2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">2</span> || num == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不在 6 的倍数两侧的一定不是素数</span></span><br><span class="line">    <span class="keyword">if</span> ((num % <span class="number">6</span> != <span class="number">1</span>) &amp;&amp; (num % <span class="number">6</span> != <span class="number">5</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在 6 的倍数两侧的也不一定是素数，需判断</span></span><br><span class="line">    <span class="keyword">int</span> upper = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="comment">/* num 为 6x-1 或 6x+1</span></span><br><span class="line"><span class="comment">     * num 为奇数，不能被 6x，6x+2，6x+4 整除</span></span><br><span class="line"><span class="comment">     * num 不可能被 3 整除，故不可能被 6x+3 整除</span></span><br><span class="line"><span class="comment">     * 因此，num 只可能被 6x-1 和 6x+1 形式的数整除</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= upper; i += <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num % i == <span class="number">0</span>) || (num % (i+<span class="number">2</span>) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>扩展阅读：<strong>孪生素数</strong>就是指相差 2 的素数对，例如 3 和 5，5 和 7，11 和 13…。孪生素数猜想正式由希尔伯特在 1900 年国际数学家大会的报告上第 8 个问题中提出，可以这样描述：存在无穷多个素数 <span class="math inline">\(p\)</span>，使得 <span class="math inline">\(p + 2\)</span> 是素数。素数对 <span class="math inline">\((p, p + 2)\)</span> 称为孪生素数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍素数判断及其分布规律。&lt;/p&gt;
    
    </summary>
    
      <category term="秋招" scheme="https://yz1509.github.io/categories/%E7%A7%8B%E6%8B%9B/"/>
    
    
      <category term="LeetCode" scheme="https://yz1509.github.io/tags/LeetCode/"/>
    
      <category term="素数" scheme="https://yz1509.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://yz1509.github.io//posts/735e5788/"/>
    <id>https://yz1509.github.io//posts/735e5788/</id>
    <published>2018-07-19T02:07:14.000Z</published>
    <updated>2019-10-30T09:55:58.964Z</updated>
    
    <content type="html"><![CDATA[<p>掌握了排序算法就不会失业.jpg</p><a id="more"></a><h1 id="前言">前言</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的八大排序算法，他们之间关系如下： <img src="/posts/735e5788/sort001.png" alt="avatar"></p><p>它们的性能比较： <img src="/posts/735e5788/sort002.png" alt="avatar"></p><p>下面，利用Python分别将他们进行实现。</p><h1 id="直接插入排序">直接插入排序</h1><h2 id="算法思想">算法思想</h2><p><img src="/posts/735e5788/sort006.gif" alt="插入排序示意图"> 直接插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤">算法步骤</h2><ol type="1"><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------------- 直接插入排序 ------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 遍历数组中的所有元素，其中 0 号元素默认已排序，因此从 1 开始</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, len(L)):</span><br><span class="line">        <span class="comment"># 将该元素与已排序好的前序数组依次比较，如果该元素小，则交换</span></span><br><span class="line">        <span class="comment"># range(x-1, -1, -1): 从 x-1 倒序循环到 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 判断：如果符合条件则交换</span></span><br><span class="line">            <span class="keyword">if</span> L[i] &gt; L[i+<span class="number">1</span>]:</span><br><span class="line">                L[i], L[i+<span class="number">1</span>] = L[i+<span class="number">1</span>], L[i]</span><br></pre></td></tr></table></figure><h1 id="希尔排序">希尔排序</h1><h2 id="算法思想-1">算法思想</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于直接插入排序的以下两点性质而提出改进方法的： * 直接插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率 * 但直接插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤-1">算法步骤</h2><ol type="1"><li>选择一个增量序列 <span class="math inline">\(t_1，t_2，… ，t_k\)</span>，其中 <span class="math inline">\(t_i &gt; t_{i+1}，t_k = 1\)</span>；</li><li>按增量序列个数 <span class="math inline">\(k\)</span>，对序列进行 <span class="math inline">\(k\)</span> 趟排序；</li><li>每趟排序，根据对应的增量 <span class="math inline">\(t_i\)</span>，将待排序列分割成若干长度为 <span class="math inline">\(m\)</span> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 <img src="/posts/735e5788/sort003.png" alt="avatar"></li></ol><h2 id="代码实现-1">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------------- 希尔排序 ---------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_shell</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化gap值，此处利用序列长度的一半为其赋值</span></span><br><span class="line">    gap = (int)(len(L)/<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 第一层循环：依次改变gap值对列表进行分组</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 下面，利用直接插入排序的思想对分组数据进行排序</span></span><br><span class="line">        <span class="comment"># range(gap, len(L)): 从gap开始</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(gap, len(L)):</span><br><span class="line">            <span class="comment"># range(x-gap, -1, -gap)：从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x-gap, <span class="number">-1</span>, -gap):</span><br><span class="line">                <span class="comment"># 如果该组当中两个元素满足交换条件，则进行交换</span></span><br><span class="line">                <span class="keyword">if</span> L[i] &gt; L[i+gap]:</span><br><span class="line">                    L[i], L[i+gap] = L[i+gap], L[i]</span><br><span class="line">        <span class="comment"># gap折半</span></span><br><span class="line">        gap = (int)(gap/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="简单选择排序">简单选择排序</h1><h2 id="算法思想-2">算法思想</h2><p>简单选择排序的基本思想：比较 + 交换。</p><h2 id="算法步骤-2">算法步骤</h2><ol type="1"><li>从待排序序列中，找到关键字最小的元素，存放在待排序序列的起始位置；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。</li></ol><h2 id="代码实现-2">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------------- 简单选择排序 ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 依次遍历序列中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, len(L)):</span><br><span class="line">        <span class="comment"># 将当前位置的元素定义为比伦循环当中的最小值</span></span><br><span class="line">        minmum = L[x]</span><br><span class="line">        <span class="comment"># 将该元素与剩下的元素依次比较寻找最小元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[i] &lt; minmum:</span><br><span class="line">                L[i], minmum = minmum, L[i]</span><br><span class="line">        L[x] = minmum</span><br></pre></td></tr></table></figure><h1 id="堆排序">堆排序</h1><h2 id="堆的概念">堆的概念</h2><p>堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。 利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。</p><h2 id="基本思想">基本思想</h2><p>堆排序可以按照以下步骤来完成： 1. 首先将序列构建称为大顶堆；（这样，位于根节点的元素一定是当前序列的最大值） <img src="/posts/735e5788/sort004.png" alt="avatar"> 2. 取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质） 3. 对交换后的前 n-1 个序列元素进行调整，使其满足大顶堆的性质； <img src="/posts/735e5788/sort005.png" alt="avatar"> 4. 重复 2、3步骤，直至堆中只有 1 个元素为止</p><h2 id="代码实现-3">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------- 堆排序 ----------------------</span></span><br><span class="line"><span class="comment">#************* 获取左右叶子结点 ***************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line"><span class="comment">#************ 调整大顶堆 ***************</span></span><br><span class="line"><span class="comment"># L：待调整序列</span></span><br><span class="line"><span class="comment"># length：序列长度</span></span><br><span class="line"><span class="comment"># i: 需要调整的结点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_max_heap</span><span class="params">(L, length, i)</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个int值保存当前序列最大值的下标</span></span><br><span class="line">    largest = i</span><br><span class="line">    <span class="comment"># 执行循环: 1.寻找最大值的下标； </span></span><br><span class="line">    <span class="comment">#           2.最大值与父节点交换</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 获得序列左右叶子结点的下标</span></span><br><span class="line">        left, right = LEFT(i),RIGHT(i)</span><br><span class="line">        <span class="comment"># 当左叶子节点的下标小于序列长度并且左叶子节点的值大于父节点时，将左叶子节点的下标赋值给largest</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; length) <span class="keyword">and</span> (L[left] &gt; L[i]):</span><br><span class="line">            largest = left</span><br><span class="line">            print(<span class="string">'左叶子节点'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest = i</span><br><span class="line">        <span class="comment"># 当右叶子节点的下标小于序列长度并且右叶子节点的值大于父节点时，将右叶子节点的下标赋值给largest</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; length) <span class="keyword">and</span> (L[right] &gt; L[largest]):</span><br><span class="line">            largest = right</span><br><span class="line">            print(<span class="string">'右边子节点'</span>)</span><br><span class="line">        <span class="comment"># 如果 largest 不等于 i，说明当前的父节点不是最大值，需要交换值</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i):</span><br><span class="line">            L[i], L[largest] = L[largest], L[i]</span><br><span class="line">            i = largest</span><br><span class="line">            print(largest)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#************* 建立大顶堆 *************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">(L)</span>:</span></span><br><span class="line">    length = len(L)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range((int)((length<span class="number">-1</span>)/<span class="number">2</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        adjust_max_heap(L, length, x)</span><br><span class="line"><span class="comment">#************* 堆排序 *************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 先建立大顶堆，保证最大值位于根节点，并且父节点的值大于叶子节点</span></span><br><span class="line">    build_max_heap(L)</span><br><span class="line">    <span class="comment"># i：当前堆中序列的长度，初始化为序列的长度</span></span><br><span class="line">    print(L)</span><br><span class="line">    i = len(L)</span><br><span class="line">    <span class="comment"># 执行循环：1.每次取出堆顶元素置于序列的最后(len-1, len-2, len-3...)</span></span><br><span class="line">    <span class="comment">#           2.调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>):</span><br><span class="line">        L[i<span class="number">-1</span>], L[<span class="number">0</span>] = L[<span class="number">0</span>], L[i<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 堆中序列长度减 1</span></span><br><span class="line">        i = i - <span class="number">1</span>   <span class="comment"># Python没有自加自减运算符！</span></span><br><span class="line">        <span class="comment"># 调整大顶堆</span></span><br><span class="line">        adjust_max_heap(L, i, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="冒泡排序">冒泡排序</h1><h2 id="基本思想-1">基本思想</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤-3">算法步骤</h2><ol type="1"><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h2 id="代码实现-4">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---------------- 冒泡排序 -------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    length = len(L)</span><br><span class="line">    <span class="comment"># 序列长度为 length 时，需要执行 length-1 轮交换</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">    <span class="comment"># 对于每一轮交换，都将序列当中的左右元素进行比较</span></span><br><span class="line">    <span class="comment"># 每轮交换中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length - x):</span><br><span class="line">            <span class="keyword">if</span> L[i] &gt; L[i+<span class="number">1</span>]:</span><br><span class="line">                L[i], L[i+<span class="number">1</span>] = L[i+<span class="number">1</span>], L[i]</span><br></pre></td></tr></table></figure><h1 id="快速排序">快速排序</h1><h2 id="算法思想-3">算法思想</h2><p>快速排序的基本思想： 1. 从序列当中选择一个基准数(pivot)，在这里我们选择序列当中第一个数最为基准数 2. 将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧 3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序，重复步骤 1、2，直到所有子集当中只有一个元素为止。</p><h2 id="代码实现-5">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------- 快速排序 -------------------</span></span><br><span class="line"><span class="comment"># L: 待排序的序列</span></span><br><span class="line"><span class="comment"># start：序列起始 index</span></span><br><span class="line"><span class="comment"># end：序列末尾 index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        i, j, pivot = start, end, L[start]</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j):</span><br><span class="line">            <span class="comment"># 从右向左找第一个小于pivot的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) <span class="keyword">and</span> (L[j] &gt;= pivot):</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将小于pivot的值移到左边</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j):</span><br><span class="line">                L[i] = L[j]</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从左到右找第一个大于pivot的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) <span class="keyword">and</span> (L[i] &lt; pivot):</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将大于pivot的值移到右边</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j):</span><br><span class="line">                L[j] = L[i]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot</span></span><br><span class="line">        <span class="comment"># pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可</span></span><br><span class="line">        <span class="comment"># 递归调用函数：依次对左侧序列：从 start 到 i-1</span></span><br><span class="line">        <span class="comment">#                     右侧序列：从 i+1 到 end</span></span><br><span class="line">        L[i] = pivot</span><br><span class="line">        <span class="comment"># 左侧序列继续排序</span></span><br><span class="line">        quick_sort(L, start, i<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右侧序列继续排序</span></span><br><span class="line">        quick_sort(L, i+<span class="number">1</span>, end)</span><br></pre></td></tr></table></figure><h1 id="归并排序">归并排序</h1><h2 id="算法思想-4">算法思想</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个典型的应用。它的基本操作是：将已有的有序子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p>归并排序其实要做两件事： * 分解----将序列每次折半拆分 * 合并----将划分后的序列段两两排序合并 因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何分解？</strong><br>在这里，我们采用递归的方法，首先将待排序列分成 A,B 两组；然后重复对 A、B 序列分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p><strong>如何合并？</strong><br><span class="math inline">\(L[first...mid]\)</span> 为第一段，<span class="math inline">\(L[mid+1...last]\)</span> 为第二段，并且两端已经有序，现在我们要将两端合成达到 <span class="math inline">\([first...last]\)</span> 并且也有序。 1. 首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给 <span class="math inline">\(temp[]\)</span> 2. 重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给 <span class="math inline">\(temp[]\)</span> 3. 此时将 <span class="math inline">\(temp[]\)</span> 中的元素复制给 <span class="math inline">\(L[]\)</span>，则得到的 <span class="math inline">\(L[first...last]\)</span> 有序</p><h2 id="代码实现-6">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---------------- 归并排序 -------------------</span></span><br><span class="line"><span class="comment">#*********** 合并函数 **************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergearray</span><span class="params">(L, first, mid, last, temp)</span>:</span></span><br><span class="line">    i, j, k = first, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当左右两边都有数时进行比较，取较小的数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) <span class="keyword">and</span> (j &lt;= last):</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= L[j]:</span><br><span class="line">            temp[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp[k] = L[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果左边序列还有数</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid):</span><br><span class="line">        temp[k] = L[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果右边序列还有数</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= last):</span><br><span class="line">        temp[k] = L[j]</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将temp当中该段有序元素赋值给 L 待排序序列使之部分有序</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, k):</span><br><span class="line">        L[first + x] = temp[x]</span><br><span class="line">        </span><br><span class="line"><span class="comment">#************ 分组函数 *************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(L, first, last, temp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        mid = (int)(first + (last - first)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 使左边序列有序</span></span><br><span class="line">        merge_sort(L, first, mid, temp)</span><br><span class="line">        <span class="comment"># 使右边序列有序</span></span><br><span class="line">        merge_sort(L, mid+<span class="number">1</span>, last, temp)</span><br><span class="line">        <span class="comment"># 将两个有序序列合并</span></span><br><span class="line">        mergearray(L, first, mid, last, temp)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#************ 归并排序 **************</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_array</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 声明一个长度为len(L)的空列表</span></span><br><span class="line">    temp = len(L)*[<span class="keyword">None</span>]</span><br><span class="line">    merge_sort(L, <span class="number">0</span>, len(L)<span class="number">-1</span>, temp)</span><br></pre></td></tr></table></figure><h1 id="基数排序">基数排序</h1><h2 id="算法思想-5">算法思想</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>通过序列中各个元素的值，对排序的 N 个元素进行若干趟的“分配”与“收集”来实现排序。 * 分配：我们将 <span class="math inline">\(L[i]\)</span> 中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中 * 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列 <span class="math inline">\(L[]\)</span> * 对新形成的序列 <span class="math inline">\(L[]\)</span> 重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束</p><h2 id="代码实现-7">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------- 基数排序 --------------------</span></span><br><span class="line"><span class="comment"># 确定排序的趟数</span></span><br><span class="line"><span class="comment"># 排序的顺序跟序列中最大数的位数相关</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort_nums</span><span class="params">(L)</span>:</span></span><br><span class="line">    maxNum = L[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 寻找序列中的最大数</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">        <span class="keyword">if</span> maxNum &lt; x:</span><br><span class="line">            maxNum = x</span><br><span class="line">    <span class="comment"># 确定序列中最大元素的位数</span></span><br><span class="line">    times = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(maxNum &gt; <span class="number">0</span>):</span><br><span class="line">        maxNum = (int)(maxNum/<span class="number">10</span>)</span><br><span class="line">        times = times + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到num从低到高第 pos 位的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_pos</span><span class="params">(num, pos)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ((int)(num/(<span class="number">10</span>**(pos<span class="number">-1</span>))))%<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    <span class="comment"># 存放各个桶的数据统计值</span></span><br><span class="line">    count = <span class="number">10</span>*[<span class="keyword">None</span>]</span><br><span class="line">    <span class="comment"># 暂时存放排序结果</span></span><br><span class="line">    bucket = len(L)*[<span class="keyword">None</span>]</span><br><span class="line">    <span class="comment"># 从低位到高位依次循环</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(<span class="number">1</span>, radix_sort_nums(L)+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 置空各个桶的数据统计值</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            count[x] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 统计当前位数（个位，十位，百位...）的元素数目</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, len(L)):</span><br><span class="line">            <span class="comment"># 统计各个桶将要装进去的元素个数</span></span><br><span class="line">            j = get_num_pos(int(L[x]), pos)</span><br><span class="line">            count[j] = count[j] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># count[i] 表示第 i 个桶的右边界索引</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            count[x] = count[x] + count[x<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 将数据依次装入桶中</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(L)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 求出元素第 k 位的数字</span></span><br><span class="line">            j = get_num_pos(L[x], pos)</span><br><span class="line">            <span class="comment"># 放入对应的桶中，count[j]-1 是第 j 个桶的右边界索引</span></span><br><span class="line">            bucket[count[j]<span class="number">-1</span>] = L[x]</span><br><span class="line">            <span class="comment"># 对应桶的装入数据索引 -1</span></span><br><span class="line">            count[j] = count[j] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, len(L)):</span><br><span class="line">            L[x] = bucket[x]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握了排序算法就不会失业.jpg&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="归并排序" scheme="https://yz1509.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快排" scheme="https://yz1509.github.io/tags/%E5%BF%AB%E6%8E%92/"/>
    
      <category term="排序" scheme="https://yz1509.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="直接插入排序" scheme="https://yz1509.github.io/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://yz1509.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="简单选择排序" scheme="https://yz1509.github.io/tags/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://yz1509.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://yz1509.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="https://yz1509.github.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://yz1509.github.io//posts/7474c898/"/>
    <id>https://yz1509.github.io//posts/7474c898/</id>
    <published>2018-07-18T13:59:06.000Z</published>
    <updated>2019-10-30T09:54:06.615Z</updated>
    
    <content type="html"><![CDATA[<p>分治算法学习笔记。</p><a id="more"></a><h1 id="分治的基本概念">分治的基本概念</h1><p>把一个任务，分成形式和原任务相同，但规模更小的几个部分任务（通常是两个部分），分别完成，或只需要选一部分完成。然后再处理完成后的这一个或几个部分的结果，实现整个任务的完成。</p><h1 id="分治的典型应用">分治的典型应用</h1><h2 id="二分查找">二分查找</h2><p>二分查找函数中，为了防止 <span class="math inline">\(L + R\)</span> 过大益处，<span class="math inline">\(mid = L + (R - L)/2\)</span>.</p><h3 id="例题">例题</h3><ul><li>输入n ( n&lt;= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯定有解)。题中所有整数都能用 int 表示。</li><li>POJ 2456: Aggressive cows</li></ul><h2 id="归并排序">归并排序</h2><p>数组排序任务可以如下完成： * 把前一半排序 * 把后一半排序 * 将两半归并到一个新的有序数组，然后再拷贝回原数组，排序完成。</p><h2 id="快速排序">快速排序</h2><p>数组排序任务可以如下完成： * 设 <span class="math inline">\(k = a[0]\)</span>，将 <span class="math inline">\(k\)</span> 挪到适当位置，使得比 <span class="math inline">\(k\)</span> 小的元素都在 <span class="math inline">\(k\)</span> 左边,比 <span class="math inline">\(k\)</span> 大的元素都在 <span class="math inline">\(k\)</span> 右边，和 <span class="math inline">\(k\)</span> 相等的，不关心在 <span class="math inline">\(k\)</span> 左右出现均可 （<span class="math inline">\(O(n)\)</span>时间完成） * 把 <span class="math inline">\(k\)</span> 左边的部分快速排序 * 把 <span class="math inline">\(k\)</span> 右边的部分快速排序</p><h1 id="例题-1">例题</h1><ul><li>输出前 <span class="math inline">\(m\)</span> 大的数<ul><li>应用快排的思想</li></ul></li><li>求排列的逆序数<ul><li>在归并排序的基础上完成</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分治算法学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://yz1509.github.io/categories/DataStructure-Algorithm/"/>
    
    
      <category term="二分查找" scheme="https://yz1509.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="归并排序" scheme="https://yz1509.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快排" scheme="https://yz1509.github.io/tags/%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
</feed>
