<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HTT - ふわふわ時間</title>
    <link>https://k-on.me/</link>
    <description>Recent content on HTT - ふわふわ時間</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 21 May 2021 16:03:49 +0800</lastBuildDate>
    
        <atom:link href="https://k-on.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Raft</title>
      <link>https://k-on.me/post/raft/</link>
      <pubDate>Fri, 21 May 2021 16:03:49 +0800</pubDate>
      
      <guid>https://k-on.me/post/raft/</guid>
      
        <description>&lt;p&gt;Raft 算法相关笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;一致性算法是在&lt;a href=&#34;https://en.wikipedia.org/wiki/State_machine_replication&#34;&gt;状态机复制&lt;/a&gt;的背景下提出，而状态机复制通常通过复制日志实现，保证复制日志在每个服务器上相同就是一致性算法的目的。Raft 通过使用强领导人的方式，将一致性问题分解为以下三个相对独立的子模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;领导选举 (Leader election)&lt;/strong&gt;：领导人处理所有的客户端请求，所以当现存领导人宕机之时，必须选举一个新的领导人，否则服务不可用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日志复制 (Log replication)&lt;/strong&gt;：领导人需要将从客户端接受到的日志条目(log entires，其实也就是请求)复制至集群中的其他节点，并且需保证其他节点的日志和自己相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性 (Safety)&lt;/strong&gt;：Raft 算法需要保证以下几点，才能满足一致性要求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Election safety&lt;/code&gt;：对于一个给定的任期号 (term)，最多只会有一个领导人选举成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leader Append-Only&lt;/code&gt;: 领导人从不覆写或删除自己的日志条目，只会附加新的日志条目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Log Matching&lt;/code&gt;: 如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leader Completeness&lt;/code&gt;: 如果某个日志条目在某个任期号中已经被提交 (commit)，那么这个条目必然出现在更大任期号的所有领导人中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State Machine Safety&lt;/code&gt;: 如一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Safety: what a system must not do; Liveness: something does happen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出安全性是对领导选举和日志复制的额外约束，因此在后续介绍中，会将安全性相关的点穿插在领导选举和日志复制之中。&lt;/p&gt;
&lt;h2 id=&#34;2-相关术语&#34;&gt;2. 相关术语&lt;/h2&gt;
&lt;h3 id=&#34;21-状态&#34;&gt;2.1. 状态&lt;/h3&gt;
&lt;p&gt;所有服务器上的&lt;strong&gt;持久性&lt;/strong&gt;状态 (在响应 RPCs 之前已更新至可靠的存储设备中)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;currentTerm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器已探知的最大任期号 (服务器首次启动时初始化为 0，单调递增)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;votedFor&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当前任期内所投选票的候选者 ID (若无则为 null)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;log[]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;日志条目；每个日志条目中包含了应用于状态机的命令，以及领导人收到该命令时的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所有服务器上的&lt;strong&gt;易失性&lt;/strong&gt;状态&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commitIndex&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已知已提交 (committed) 的最新日志条目的索引值 (初始为 0，单调递增)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lastApplied&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已被应用于 (applied) 状态机的最新日志条目的索引值 (初始为 0，单调递增)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;领导人&lt;/strong&gt;的易失性状态&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nextIndex[]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发送至其他节点的下一条日志的索引值 (初始值为领导人最新日志条目的索引值 $+1$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;matchIndex[]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已知已复制至该节点的最新日志条目的索引值 (初始为 0，单调递增)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-rpc&#34;&gt;2.2. RPC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AppendEntries RPC&lt;/code&gt;：领导人调用，用于日志复制和心跳检测&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Sends&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领导人的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leaderId&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领导人 ID，因此跟随者可以据此将客户端请求重定向至领导人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;prevLogIndex&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧邻新日志条目之前的日志条目的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;prevLogTerm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;紧邻新日志条目之前的日志条目的任期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要被保存的日志条目 (为了提高效率可能一次性发送复数条日志；用于心跳检测时，该项为空)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leaderCommit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领导人的 commitIndex，用于更新跟随者的 commitIndex = min(leaderCommit, index of last new entry)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Results&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;供领导人判断自己的任期号是否已过期，按需更新 currentTerm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;success&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;值为 true 时表示跟随者所含日志条目可以和 prevLogIndex 以及 prevLogTerm 匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;RequestVote RPC&lt;/code&gt;：候选人调用，用于征集选票&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Sends&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;候选人的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;candidateId&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;候选人 ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lastLogIndex&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;候选人最新日志条目的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lastLogTerm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;候选人最新日志条目的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Results&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;供候选人按需更新自己的 currentTerm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;voteGranted&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;值为 true 时表示候选人赢得此张选票&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;InstallSnapshot RPC&lt;/code&gt;: 领导人调用，用于将日志快照发送给跟随者，通常是将快照分为多个 chunks 后按序发送&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Sends&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领导人的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leaderId&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;领导人 ID，因此跟随者可以据此将客户端请求重定向至领导人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lastIncludedIndex&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快照中包含的最后日志条目的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lastIncludedTerm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快照中包含的最后日志条目的任期号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;offset&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该 chunk 在快照中的字节偏移量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;data[]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该 chunk 的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;done&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果这是快照的最后一个 chunk 时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Results&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;供领导人判断自己的任期号是否已过期，按需更新 currentTerm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-领导人选举&#34;&gt;3. 领导人选举&lt;/h2&gt;
&lt;p&gt;在 Raft 中，每个服务器节点都处于以下三种状态之一：领导人(leader)、跟随者(follower)或候选人(candidate)。其状态转移图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/raft/raft_server_status.png&#34; alt=&#34;服务器状态&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;31-选举流程&#34;&gt;3.1. 选举流程&lt;/h3&gt;
&lt;p&gt;Raft 使用心跳检测机制触发领导人选举。具体而言，领导人会周期性地向所有跟随者发送心跳包 (AppendEntries RPCs that carry no log entries) 来让跟随者知道自己的存活状态，如果一个跟随者在一段时间 (election timeout，选举超时) 内未收到领导人的心跳包，那么他就会认为当前系统中领导人不可用，从而发起选举以选出新的领导人。&lt;/p&gt;
&lt;p&gt;跟随者转变成候选人开始选举后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Increment &lt;code&gt;currentTerm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vote for self&lt;/li&gt;
&lt;li&gt;Reset election timer&lt;/li&gt;
&lt;li&gt;Send RequestVote RPCs to all other servers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;候选人的结果可能为以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;赢得选举，成为领导人&lt;/strong&gt;: 当候选人从整个集群的大多数节点处获得了针对&lt;strong&gt;同一任期号&lt;/strong&gt;的选票时赢得选举&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他服务器成为领导人&lt;/strong&gt;: 候选人在等待选票时，若从其他节点接收到 &lt;code&gt;AppendEntries RPC&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;如该 RPC 中的 &lt;code&gt;term&lt;/code&gt; &lt;strong&gt;不小于&lt;/strong&gt;候选人的 &lt;code&gt;currentTerm&lt;/code&gt;，那么候选人会承认领导人合法，并切换至跟随者状态&lt;/li&gt;
&lt;li&gt;如该 RPC 中的 &lt;code&gt;term&lt;/code&gt; 小于候选人的 &lt;code&gt;currentTerm&lt;/code&gt;，那么候选人会拒绝这次 RPC 并保持候选人状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本次选举超时&lt;/strong&gt;: 如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数节点的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举
&lt;ul&gt;
&lt;li&gt;Raft 算法使用随机选举超时时间的方法来减少发生选票瓜分的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-选举原则&#34;&gt;3.2. 选举原则&lt;/h3&gt;
&lt;p&gt;Raft 应用以下选举原则以确保 &lt;code&gt;election safety&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每一个服务器按照先来先服务的原则，最多会对一个任期号投出一张选票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有从整个集群的大多数节点处获得了针对&lt;strong&gt;同一任期号&lt;/strong&gt;的选票时赢得选举&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此处可以不要求 majority, 只要求 quorum 即可，详见&lt;a href=&#34;https://blog.openacid.com/algo/quorum/&#34;&gt;后分布式时代: 多数派读写的&amp;quot;少数派&amp;quot;实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在收到 &lt;code&gt;RequestVote RPC&lt;/code&gt; 时，除了检测 RPC 中的 &lt;code&gt;term&lt;/code&gt;，还会根据 &lt;code&gt;lastLogIndex&lt;/code&gt; 和 &lt;code&gt;LastLogTerm&lt;/code&gt; 判断候选人的日志是否比自己新，投票人会拒绝那些日志没有自己新的投票 RPC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果两份日志最后的条目的任期号不同，那么任期号大的日志更新&lt;/li&gt;
&lt;li&gt;如果两份日志最后的条目任期号相同，那么日志比较长(index 大)的那个就更新&lt;/li&gt;
&lt;li&gt;通过这条限制保证了能当选的候选人包含了所有已经提交的日志条目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Raft 在系统满足以下时间要求时可以选举并维持一个稳定的领导人：&lt;/p&gt;
&lt;p&gt;$$broadcastTime \ll electionTimeout \ll MTBF$$&lt;/p&gt;
&lt;p&gt;其中，广播时间(broadcastTime)指的是从一个服务器并行地发送 RPCs 给集群中的其他服务器并接收响应的平均时间；平均故障间隔时间(MTBF)就是对于一台服务器而言，两次故障之间的平均时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-选举相关问题思考&#34;&gt;3.3. 选举相关问题思考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Q: 选举时为何要先投给自己？&lt;/p&gt;
&lt;p&gt;A: 考虑 3 个节点的系统，当领导人宕机后，如果选举时不先投给自己，那么如何选举出新的 leader..&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q: 假设某个跟随者节点因网络分区成为孤立节点，由于接收不到来自领导人的心跳检测包，因此会不断发起选举 -&amp;gt; 选举超时，导致 term 一直增加。网络分区结束后回到原集群会将原领导人降级为跟随者，导致重新选举，造成服务中断，如何解决？&lt;/p&gt;
&lt;p&gt;A: 将选举拆成两阶段提交的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先进行一轮 prevote，在 prevote 阶段并不会自增 &lt;code&gt;currentTerm&lt;/code&gt;，仅在 &lt;code&gt;RequestVote RPC&lt;/code&gt; 中令 &lt;code&gt;term = currentTerm + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;prevote 收到多数派的选票时，发起真正的选举&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-日志复制&#34;&gt;4. 日志复制&lt;/h2&gt;
&lt;p&gt;在 Raft 中，领导人处理所有的客户端请求，因此领导人需要将从客户端接受到的日志条目(其实也就是请求)复制至集群中的其他节点，并且需保证其他节点的日志和自己相同。日志的组织方式大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/raft/raft_log_composed.png&#34; alt=&#34;日志组织方式&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;41-日志特性&#34;&gt;4.1. 日志特性&lt;/h3&gt;
&lt;p&gt;Raft 通过维护以下日志特性，而保证 &lt;code&gt;Log Matching&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果在不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令 (唯一性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;领导人在给定任期和索引值下，最多仅创建一条日志&lt;/li&gt;
&lt;li&gt;日志条目的位置保证不会发生改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同 (无空洞)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AppendEntries RPC&lt;/code&gt; 一致性检查：领导人在发送 &lt;code&gt;AppendEntries RPC&lt;/code&gt; 时会包含 &lt;code&gt;prevLogIndex&lt;/code&gt; 和 &lt;code&gt;prevLogTerm&lt;/code&gt; 信息，跟随者发现这两者不匹配时会拒绝该 RPC&lt;/li&gt;
&lt;li&gt;只有当一致性检查成功时，跟随者才会接受该 RPC 中的日志条目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AppendEntries RPC 一致性检查失败时的处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个节点刚成为领导人时，他会将所有跟随者的 &lt;code&gt;nextIndex&lt;/code&gt; 值初始化为自己最新日志条目的 &lt;code&gt;index + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;AppendEntries RPC&lt;/code&gt; 一致性检查失败时，领导人会减小 &lt;code&gt;nextIndex&lt;/code&gt; 值并进行重试，直至找到两者日志一致之处&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种机制，新的领导人不需要任何特殊的操作来恢复日志的一致性。他只需要进行正常的 &lt;code&gt;AppendEntries RPC&lt;/code&gt; 操作，然后领导人和其他节点日志就能自动地趋于一致。&lt;/p&gt;
&lt;h3 id=&#34;42-提交日志-commited&#34;&gt;4.2. 提交日志 (commited)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当领导人将&lt;strong&gt;创建&lt;/strong&gt;的日志条目复制到大多数的节点上时，日志条目就会被提交
&lt;ul&gt;
&lt;li&gt;与此同时，领导人日志中之前所有日志条目也会被间接提交，包括由其他领导人创建的日志条目&lt;/li&gt;
&lt;li&gt;领导人不会通过判断多数派是否已复制的方式去提交之前任期的日志条目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一旦跟随者知道一条日志已被提交，那么他也会将该日志条目应用到本地的状态机中 (按照日志顺序)&lt;/li&gt;
&lt;li&gt;Raft 算法保证所有已提交的日志条目都已持久化并且最终会被所有可用的状态机执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-成员变更&#34;&gt;5. 成员变更&lt;/h2&gt;
&lt;p&gt;服务器直接从旧配置转换至新配置是不安全的，如下图所示，当集群节点数从 $3$ 增加至 $5$ 时，存在一个时间点，如在此时发生选举，同一任期内两个不同的候选人都可以选举成功，成为领导人：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server 1 和 server 2 通过旧配置(3 节点)选举 server 1 为领导人&lt;/li&gt;
&lt;li&gt;server 3、server 4 和 server 5 通过新配置( 5 节点)选举 server 3 为领导人&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/raft/raft_membership_change_problem.png&#34; alt=&#34;成员变更问题&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;51-问题原因&#34;&gt;5.1. 问题原因&lt;/h3&gt;
&lt;p&gt;引用 &lt;a href=&#34;https://blog.openacid.com/algo/quorum/#quorum-vs-majority&#34;&gt;后分布式时代: 多数派读写的&amp;quot;少数派&amp;quot;实现&lt;/a&gt; 中对 majority 和 quorum 的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;majority&lt;/code&gt;：多数派；多于半数；$\ge \lfloor \frac{n}{2} \rfloor + 1$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quorum&lt;/code&gt;: 法定人数，不一定是多数派，但需满足任意 $2$ 个 quorum 之间必须有交集(该条件保证了按照 quorum 集合选举出的领导人是唯一的)
&lt;blockquote&gt;
&lt;p&gt;majority 显然满足 quorum 的约束条件，因此 quorum 是 majority 概念的一个推广&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般我们提到的 quorum (或 majority)，其实可以用节点集合 $Q$ 代表，我们把系统中所有的 quorum 集合记为 $\mathbb{Q} = \{Q_1, Q_2, \dots\}$，例如对于一个三节点系统 $\{a, b, c\}$，$\mathbb{Q} = \{ \{a, b\}, \{a, c\}, \{b, c\}, \{a, b, c\} \}$。&lt;/p&gt;
&lt;p&gt;因此在上述成员变更问题中，是因为那个时刻 $\mathbb{Q} = \{ \{s1, s2\}, \{s3, s4, s5\} \}$，不满足 quorum 之间必须有交集的条件，所以会选举出两个不同的领导人出来。&lt;/p&gt;
&lt;h3 id=&#34;52-解决办法joint-consensus&#34;&gt;5.2. 解决办法：Joint consensus&lt;/h3&gt;
&lt;p&gt;解决问题的关键点就是让 $\mathbb{Q}$ 满足集合中任意 $2$ 个 quorum 之间必须有交集这一约束条件。作者在论文中提出一个两阶段变更方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先将集群切换至一个旧配置和新配置结合的过渡配置，称为 &lt;code&gt;Joint consensus&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;Joint consensus&lt;/code&gt; 被提交后(复制到了多数派)，再将集群切换至新配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在变更的过程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志条目会被复制给集群中所有的节点，不论是该节点是使用新配置还是旧配置&lt;/li&gt;
&lt;li&gt;使用新、旧配置的节点都可以被选举成为领导人&lt;/li&gt;
&lt;li&gt;节点间达成一致 (针对选举和提交) 需要分别在两种配置上都获得大多数的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置切换的具体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/raft/raft_configuration_change_timeline.png&#34; alt=&#34;配置切换时间线&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当领导人接收到一个配置变更请求时，其会将 &lt;code&gt;Joint consensus&lt;/code&gt;: $C_{old, new}$ 作为日志条目应用并复制至其他节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此时 $\mathbb{Q} = \mathbb{Q}_{old}$，即达成一致只需旧配置上的 quorum 之间达成一致即可&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;集群配置信息作为特殊的日志条目存储和通信，所有服务器在将配置日志条目添加进其日志存储中时，其会立刻使用该配置进行之后的决策，而不论该配置日志条目是否已被提交&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领导人使用 $C_{old, new}$ 配置的规则决定 $C_{old, new}$ 日志条目是否可以被提交，一旦 $C_{old, new}$ 被提交，则仅靠 $C_{old}$ 或 $C_{new}$ 配置无法在节点间达成一致，且 &lt;code&gt;Leader Completeness&lt;/code&gt; 保证了只有含有 $C_{old, new}$ 日志条目的节点才有可能被选举为领导人&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$C_{old, new}$ 提交后，$\mathbb{Q} = \mathbb{Q}_{old, new} = \mathbb{Q}_{old} \times \mathbb{Q}_{new}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 $C_{old, new}$ 被提交后，领导人可以创建、应用一条关于 $C_{new}$ 配置的日志条目，随后将其复制至其他节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathbb{Q} = \mathbb{Q}_{new}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当领导人发现日志条目 $C_{new}$ 可以在新配置的规则下被提交，则变更结束，不在新配置中的节点可以安全从集群中移除&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;依然以往 $\{s1, s2, s3\}$ 中添加 $\{s4, s5\}$ 为例，如下所示，容易知道任意时刻 quorum 集合中任意两个 quorum 之间都有交集，因此可以被选举出的领导人是唯一的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;当前状态&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;quorum 集合 $\mathbb{Q}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$C_{old, new}$ 已应用，未提交&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$\mathbb{Q}_{old} = \{ \{s1, s2\}, \{s2, s3\}, \{s1, s3\} \}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$C_{old, new}$ 已提交， $C_{new}$ 未应用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$\mathbb{Q}_{old, new} = \{ \{s1, s2, s3\}, \{s1, s2, s4\}, \{s1, s2, s3, s4\}$, $\{s1, s2, s5\}, \{s1, s2, s3, s5\}, \{s1, s3, s5\}, \{s1, s2, s4, s5\}$, $\{s1, s2 ,s3, s4, s5\}, \{s1, s3, s4 , s5\}, \{s2 ,s3, s4\}$, $\{s2, s3 ,s5\}, \{s2 ,s3, s4, s5\} \}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$C_{new}$ 已提交&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$\mathbb{Q}_{new} = \{ \{s1 ,s2, s3\},\{s1 ,s2, s4\}, \{s1 ,s2, s5\}$, $\{s1 ,s3, s4\}, \{s1 ,s3, s5\}, \{s1 ,s4, s5\}$, $\{s2 ,s3, s4\}, \{s2 ,s3, s5\}, \{s2 ,s4, s5\}, \{s3 ,s4, s5\} \}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Joint consensus&lt;/code&gt; 通过令配置变更中间状态的&lt;/p&gt;
&lt;p&gt;$$\mathbb{Q}_{old,new} = \mathbb{Q}_{old} \times \mathbb{Q}_{new}$$&lt;/p&gt;
&lt;p&gt;而非 $\mathbb{Q}_{old}$ 和 $\mathbb{Q}_{new}$ 简单求并集，从而满足了 quorum 集合的约束条件，避免了同一时刻可能有多个领导人被选举出来的情况。&lt;/p&gt;
&lt;h3 id=&#34;53-成员变更相关问题&#34;&gt;5.3. 成员变更相关问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Q: 当一个全新的服务节点加入集群时，因为其未存储任何日志条目，需要一段时间来追赶最新的日志，在追赶期间很可能集群无法提交新的日志条目 (3 节点集群加入 2 个新节点，且有个旧节点宕机时，此时集群不可用)，怎么办？&lt;/p&gt;
&lt;p&gt;A: 新节点加入集群时以 &lt;code&gt;non-voting&lt;/code&gt; 的身份加入，也即其不参与决策过程，但是领导人会复制日志给新节点，待新节点追赶上最新的日志时，再给予其投票权。&lt;/p&gt;
&lt;p&gt;具体而言，在追赶日志阶段可以配置固定的 Rounds 数，新节点尝试在 Rounds 内追赶日志，一旦最后一轮追赶日志耗时小于 &lt;code&gt;election timeout&lt;/code&gt; 时，则认为新节点已追赶上最新的日志，给予其投票权，开始成员变更。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q: 配置变更的时候，当服务器收到配置相关的日志条目时，会立即应用新配置，如果当前领导人不在新配置中，怎么办？&lt;/p&gt;
&lt;p&gt;A: 对于这种情况，我们可以规定领导人在 $C_{new}$ 提交后再退位，进行选举。这意味着，存在这样的一段时间，领导人管理者集群，但是其自身无投票权，因此计算 $C_{new}$ 是否可提交时需将自身排除在外。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q: 如果新配置需要移除部分节点，直接移除该节点可能会造成集群不可用：被移除的服务器由于没接收到来自领导人的心跳检测，因此会发起选举，这可能会导致领导人回退至跟随者状态 (领导人当前任期小于选举 RPC 中的 &lt;code&gt;term&lt;/code&gt;)，即使选举出了新的领导人，被移除节点仍会因为选举超时而发起选举干扰集群运行。&lt;/p&gt;
&lt;p&gt;A: 跟随者在收到 &lt;code&gt;RequestVote RPC&lt;/code&gt; 时，可以判断在 &lt;code&gt;election timeout&lt;/code&gt; 期间是否有收到当前领导人的心跳检测包，如有，则跟随者认为领导人可用，跟随者便不会更新 &lt;code&gt;currentTerm&lt;/code&gt; 值，也不会投票。&lt;/p&gt;
&lt;p&gt;使用该策略，领导人如能够发送心跳检测给集群中的多数节点，那么他就不会被更大的任期号罢黜，从而避免被移除的服务器扰乱集群的正常运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;54-单步变更&#34;&gt;5.4. 单步变更&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Joint consensus&lt;/code&gt; 较为复杂，在实际的实现中大多会采用单步变更算法，也即每次仅从集群中添加/删除一个节点。&lt;/p&gt;
&lt;p&gt;详细介绍可参考 &lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;6-日志压缩&#34;&gt;6. 日志压缩&lt;/h2&gt;
&lt;p&gt;在 Raft 中，每个节点独立地创建快照，其仅包括已被提交地日志条目。如下图所示，在快照中主要包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;last included index&lt;/code&gt;: 被快照取代的最后一条日志的索引值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last included term&lt;/code&gt;: 被快照取代的最后一条日志的任期号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state machine state&lt;/code&gt;: 状态机状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/raft/raft_snapshot.png&#34; alt=&#34;snapshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然快照由每个节点独立创建，但有时还是需要领导人发送快照至跟随者（如新加节点等）。此时，领导人可以使用 &lt;code&gt;InstallSnapshot RPC&lt;/code&gt; 将快照分块发送至跟随者，跟随者在接收到快照后，依据 RPC 中的 &lt;code&gt;lastIncludedIndex&lt;/code&gt; 和 &lt;code&gt;lastIncludedTerm&lt;/code&gt; 信息，删除被快照包含的日志条目，保留未被快照包含的日志条目。&lt;/p&gt;
&lt;h2 id=&#34;7-客户端交互&#34;&gt;7. 客户端交互&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Raft 中由领导人处理所有的客户端请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端随机挑选集群中的一个节点进行通信，当该节点不是领导人时，那么该节点会拒绝客户端请求，并提供他最近接收到的领导人信息(&lt;code&gt;AppendEntries RPC&lt;/code&gt; or &lt;code&gt;InstallSnapshot RPC&lt;/code&gt; 中的 &lt;code&gt;leaderId&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了避免客户端请求因为重试而被执行多次，可以为每一个请求赋予一个唯一的序列号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然只读的请求不需要记录日志，但领导人直接返回结果至客户端时，可能因为该领导人被罢黜而导致返回脏数据。在不使用新增日志条目的情况下，如要保证读请求返回的正确性，需要做到以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;领导人必须拥有关于被提交日志的最新信息
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Leader Completeness&lt;/code&gt; 保证了领导人拥有所有已被提交的日志&lt;/li&gt;
&lt;li&gt;但在领导人任期刚开始时，他可能不知道哪些日志已经被之前的领导人提交，为了知道这些信息，领导人可以在任期刚开始时提交一个空的日志条目
&lt;blockquote&gt;
&lt;p&gt;在单步变更时也是通过在任期开始提交一条 NoOp 的日志，避免已提交变更日志的丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;领导人在处理只读请求之前必须依赖心跳机制检查自己的领导人身份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-参考资料&#34;&gt;8. 参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In search of an understandable consensus algorithm (extended version)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&#34;&gt;中文翻译地址&lt;/a&gt;
&lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/Classes/739/Spring2004/Papers/raft.pdf&#34;&gt;英文原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://wcl.cs.rpi.edu/pilots/library/papers/consensus/RAFTOngaroPhD.pdf&#34;&gt;CONSENSUS: BRIDGING THEORY AND PRACTICE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/187506841&#34;&gt;Raft算法相关工程问题以及解释&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Introduction to Infiniband for End Users</title>
      <link>https://k-on.me/post/introduction-to-infiniband-for-end-users/</link>
      <pubDate>Sat, 13 Mar 2021 15:05:02 +0800</pubDate>
      
      <guid>https://k-on.me/post/introduction-to-infiniband-for-end-users/</guid>
      
        <description>&lt;p&gt;《Introduction to Infiniband for End Users》 阅读笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;http://www.smallake.kr/wp-content/uploads/2014/03/Intro_to_IB_for_End_Users.pdf&#34;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-basic-concepts&#34;&gt;1. Basic Concepts&lt;/h2&gt;
&lt;h3 id=&#34;11-infiniband-vs-traditional-newworking&#34;&gt;1.1. InfiniBand vs traditional newworking&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传统的计算机网络&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;network centric&amp;rdquo; view，重点关注在硬件以及其管理上&lt;/li&gt;
&lt;li&gt;应用程序共享的硬件资源统一由操作系统管理，无法 direct access
&lt;ul&gt;
&lt;li&gt;网络通信时，数据包每次需要复制 2 到 3 次：I/O -&amp;gt; anonymous buffer pool -&amp;gt; Application&amp;rsquo;s virtual memory space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;byte stream-oriented，传递字节流，一条消息完整地传递至对端时，接收端可能会触发多次系统调用以读取完整的消息&lt;/li&gt;
&lt;li&gt;数据中心网络可能由三个独立的网络组成
&lt;ul&gt;
&lt;li&gt;one for networking&lt;/li&gt;
&lt;li&gt;one for storage&lt;/li&gt;
&lt;li&gt;one for IPC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InfiniBand&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;application centric&amp;rdquo; view，为应用程序提供 messaging service，重点关注在便于应用程序之间简单、高效的通信上&lt;/li&gt;
&lt;li&gt;direct access, stack bypass，可以不依赖操作系统
&lt;ul&gt;
&lt;li&gt;avoiding operating system calls&lt;/li&gt;
&lt;li&gt;avoiding unnecessary buffer copies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;message-oriented，传递消息，单个消息大小可达 $2^{31}$ bytes
&lt;ul&gt;
&lt;li&gt;发送端 InfiniBand 硬件自动将 outbound message 分成多个 packets 传递至接收端应用程序虚拟缓冲区&lt;/li&gt;
&lt;li&gt;只有在接收端收到完整的 messsage 时才会通知应用程序&lt;/li&gt;
&lt;li&gt;可以发现，在传递消息的过程中，不需要发送端和接收端应用程序参与&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;InfiniBand 会统一处理 storage, networking 和 IPC I/O，因此只需单一底层网络即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-infiniband-architecture&#34;&gt;1.2. InfiniBand Architecture&lt;/h3&gt;
&lt;p&gt;InfiniBand 通过在应用程序之间创建 &lt;em&gt;channel&lt;/em&gt; 连接 (故可称为 &lt;code&gt;Channel I/O&lt;/code&gt;) 以提供 messaging service 进行通信，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Queue Pairs(QPs)&lt;/code&gt;: 指 channel 的端点，每个 QP 包含一个 Send Queue 和一个 Receive Queue&lt;/li&gt;
&lt;li&gt;通过将 QPs 映射为应用程序的虚拟内存空间，以实现应用程序直接访问 QPs&lt;/li&gt;
&lt;li&gt;InfiniBand 提供两种 transfer semantics 用于传递消息
&lt;ul&gt;
&lt;li&gt;channel semantic: &lt;code&gt;SEND&lt;/code&gt; / &lt;code&gt;RECEIVE&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;接收方预先在自己的 Receive Queue 中定义数据结构&lt;/li&gt;
&lt;li&gt;发送方无需知道接收方 RQ 中的数据结构，仅负责调用 &lt;code&gt;SEND&lt;/code&gt; 发送消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;memory semantic: &lt;code&gt;RDMA READ&lt;/code&gt; / &lt;code&gt;RDMA WRITE&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;接收方在自己的虚拟内存空间中注册一个 buffer，并将控制权交予发送方&lt;/li&gt;
&lt;li&gt;发送方通过调用 &lt;code&gt;RDMA READ&lt;/code&gt; 或 &lt;code&gt;RDMA WRITE&lt;/code&gt; 读写该 buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/intro_to_ib_for_end/channel.png&#34; alt=&#34;channel&#34;&gt;&lt;/p&gt;
&lt;p&gt;InfiniBand Achitecture 如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SoftWare transport interface&lt;/code&gt; 层包含创建/管理 channel 和使用 QPs 传递消息的 APIs and libraries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InfiniBand transport&lt;/code&gt; 层提供 reliablity &amp;amp; delivery guarantees，类似 TCP transport&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Network&lt;/code&gt; 层类似于 IP 层&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Link&lt;/code&gt; &amp;amp; &lt;code&gt;Physical&lt;/code&gt;: wires &amp;amp; switches&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/intro_to_ib_for_end/architecture.png&#34; alt=&#34;architecture&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;13-hardware-components&#34;&gt;1.3. Hardware Components&lt;/h3&gt;
&lt;p&gt;为了获取 InfiniBand Architecture 所提供功能，需要以下特定硬件的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Host Channel Adapter(HCA)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 InfiniBand end node 连接至 InbiniBand network&lt;/li&gt;
&lt;li&gt;提供 address translation mechnisms，以让应用程序可直接访问物理内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Target Channel Adapter(TCA)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌入式环境下专用的 channel adapter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Switches&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Designed to be &amp;ldquo;cut through&amp;rdquo; for performance and cost reasons and they implement InfiniBand&amp;rsquo;s link layer flow control portocol to avoid dropped packets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Routers&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可将规模较大的网络切分为多个子网，为 InfiniBand network 提供可扩展性&lt;/li&gt;
&lt;li&gt;用来连接物理距离较远的两个 InfiniBand subnet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Cables and Connectors&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-infiniband-for-hpc&#34;&gt;2. InfiniBand for HPC&lt;/h2&gt;
&lt;p&gt;InfiniBand 架构的特性可为 HPC 带来以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ultra-low latency for
&lt;ul&gt;
&lt;li&gt;Scalability&lt;/li&gt;
&lt;li&gt;Cluster performance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Channel I/O delivers:
&lt;ul&gt;
&lt;li&gt;Scalable storage bandwidth performance&lt;/li&gt;
&lt;li&gt;Support for shard disk cluster file systems and parallel file systems&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-infiniband-for-the-enterprise&#34;&gt;3. InfiniBand for the Enterprise&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Devoting Server Resources to Application Processing&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟化只是提升了服务器资源的利用率&lt;/li&gt;
&lt;li&gt;使用 InfiniBand 由于避免了无必要的系统调用和内存拷贝，可将服务器资源充分用于 Applications&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;A Flexible Server Architecture&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现有服务器会将 I/O 带宽资源按照一定比例预分配给 storage fabric(HBA) 和 ethernet network(NIC)，可能并不适合应用程序所需&lt;/li&gt;
&lt;li&gt;InfiniBand 则会统一处理 storage, networking 和 IPC，无需对 I/O 带宽资源进行预分配&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-designing-with-infiniband&#34;&gt;4. Designing with InfiniBand&lt;/h2&gt;
&lt;p&gt;如下图所示，应用程序通过使用 &lt;code&gt;verbs&lt;/code&gt; 将 work request 置于 work queue (也就是 QPs) 中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;verbs&lt;/code&gt; 只是应用程序使用/管理 InfiniBand 服务的规范，而非具体的 APIs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/intro_to_ib_for_end/access_level.png&#34; alt=&#34;access_level&#34;&gt;&lt;/p&gt;
&lt;p&gt;实现 InfiniBand 所需的软件部分大致可分为以下三类，全部源码可从 &lt;a href=&#34;https://downloads.openfabrics.org/OFED/&#34;&gt;OFED&lt;/a&gt; 获取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upper Layer Protocols(ULPs) and associated libraries&lt;/li&gt;
&lt;li&gt;mid-layer functions: 用于配置和管理底层 InfiniBand Fabric，并为 ULPs 提供所需的服务&lt;/li&gt;
&lt;li&gt;hardware specific device drivers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ULP 有两种接口:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;upward-facing interface: 供应用程序调用&lt;/li&gt;
&lt;li&gt;downward-facing interface: 通过 QPs 使用底层的 InfiniBand messaging service&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OFED 提供了多种 ULPs 以满足应用程序的不同需求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/intro_to_ib_for_end/ulps.png&#34; alt=&#34;ulps&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SDP&lt;/code&gt;: Sockets Direct Protocol. This ULP allows a sockets application to take advantage of an InfiniBand network with no change to the application&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SRP&lt;/code&gt;: SCSI RDMA Protocol. This allows a SCSI file system to directly connect to a remote block storage chassis using RDMA semantics. Again, there is no impact to the file system itself.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iSER&lt;/code&gt;: iSCSI Extensions for RDMA. iSCSI is a protocol allowing a block storage file system to access a block storage device over a generic network. iSER allows the user to operate the iSCSI protocol over an RDMA capable network.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPoIB&lt;/code&gt;: IP over InfiniBand. This important part of the suite of ULPs allows an application hosted in, for example, an InfiniBand-based network to communicate with other sources outside the InfiniBand network using standard IP semantics. Although often used to transport TCP/IP over an InfiniBand network, the IPoIB ULP can be used to transport any of the suite of IP protocols including UDP, SCTP and others.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NFS-RDMA&lt;/code&gt;: Network File System over RDMA. NFS is a well-known and widely-deployed file system providing file level I/O (as opposed to block level I/O) over a conventional TCP/IP network. This enables easy file sharing. NFS-RDMA extends the protocol and enables it to take full advantage of the high bandwidth and parallelism provided naturally by InfiniBand.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lustre support&lt;/code&gt;: Lustre is a parallel file system enabling, for example, a set of clients hosted on a number of servers to access the data store in parallel. It does this by taking advantage of InfiniBand’s Channel I/O architecture, allowing each client to establish an independent, protected channel between itself and the Lustre Metadata Servers (MDS) and associated Object Storage Servers and Targets (OSS, OST).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RDS&lt;/code&gt;: Reliable Datagram Sockets offers a Berkeley sockets API allowing messages to be sent to multiple destinations from a single socket. This ULP, originally developed by Oracle, is ideally designed to allow database systems to take full advantage of the parallelism and low latency characteristics of InfiniBand.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MPI&lt;/code&gt;: The MPI ULP for HPC clusters provides full support for MPI function calls.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-infiniband-architecture-and-features&#34;&gt;5. InfiniBand Architecture and Features&lt;/h2&gt;
&lt;h3 id=&#34;51-address-translation&#34;&gt;5.1. Address Translation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HCA 占有一块物理地址，应用程序可通过内存注册过程请求必要的地址转换，然后由 HCA 使用地址转换表执行所需的虚拟地址到物理地址转换&lt;/li&gt;
&lt;li&gt;I/O channel 由 HCA 创建，QP 可以理解为应用程序访问 HCA 的接口，单个 HCA 可支持最多 $2^{24}$ 个 QPs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得益于 HCA 提供地址转换功能，可实现 InfiniBand 的两个核心功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态访问 InfiniBand messaging service&lt;/li&gt;
&lt;li&gt;使用 InfiniBand messaging service 可“直接”访问其他应用程序的 virtual address spaces
&lt;ul&gt;
&lt;li&gt;使用对端提供的 key 和 virtual address，执行 &lt;code&gt;RDMA Read&lt;/code&gt;/&lt;code&gt;RDMA Write&lt;/code&gt; 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52-the-infiniband-transport&#34;&gt;5.2. The InfiniBand Transport&lt;/h3&gt;
&lt;p&gt;InfiniBand transport 可提供以下几种 message transport services:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel semantic operations: a reliable or an unreliable &lt;code&gt;SEND&lt;/code&gt;/&lt;code&gt;RECEIVE&lt;/code&gt; service，类似于 TCP/UDP
&lt;ul&gt;
&lt;li&gt;可靠性由 transport recovery 和 notifies application 机制实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEND&lt;/code&gt;/&lt;code&gt;RECEIVE&lt;/code&gt; operations 常用于传输 short control messages&lt;/li&gt;
&lt;li&gt;执行流程:
&lt;ol&gt;
&lt;li&gt;接收端应用程序使用 &lt;code&gt;Post Receive Request&lt;/code&gt; verb 将 WRs 置于 RQ，其中每个 &lt;code&gt;RECEIVE WR&lt;/code&gt; 代表应用程序虚拟内存空间中的一块 buffer&lt;/li&gt;
&lt;li&gt;发送端应用程序使用 &lt;code&gt;Post Send Request&lt;/code&gt; verb 将 WRs 置于 SQ，其中每个 &lt;code&gt;SEND WR&lt;/code&gt; 代表一条消息，&lt;code&gt;SEND&lt;/code&gt; 操作的目标为接收端 RECEIVE WR 关联的 buffer&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory semantic operations: &lt;code&gt;RDMA Read&lt;/code&gt; and &lt;code&gt;RDMA Write&lt;/code&gt; service
&lt;ul&gt;
&lt;li&gt;常用于传输 bulk data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Atomic Operations&lt;/li&gt;
&lt;li&gt;Multicast services&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-infiniband-link-layer-considerations&#34;&gt;5.3. InfiniBand Link Layer Considerations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;InfiniBand link layer &lt;strong&gt;lossless&lt;/strong&gt; flow control：利用硬件检测接收端缓冲区使用量，仅在可容纳消息时才会传递消息，保证消息不会被丢失&lt;/li&gt;
&lt;li&gt;TCP &lt;strong&gt;lossy&lt;/strong&gt; flow control: 并不会在发送前检测下游是否可容纳 packets，因此 packets 可能会丢失，事实上 TCP 还会利用丢包信息判断下游状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;54-managment-and-servcices&#34;&gt;5.4. Managment and Servcices&lt;/h3&gt;
&lt;p&gt;与 autonomous Ethernet fabric 相反，InfiniBand 为集中式管理，其管理主要分为以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Subnet Management(SM) and Subnet Administration(SA): 发现、初始化和维护 InfiniBand fabric&lt;/li&gt;
&lt;li&gt;Communication management: 将一对 QPs 关联以便在两个应用程序之间创建 channel 连接&lt;/li&gt;
&lt;li&gt;Performance management&lt;/li&gt;
&lt;li&gt;Device management&lt;/li&gt;
&lt;li&gt;Baseboard management&lt;/li&gt;
&lt;li&gt;SNMP tunneling&lt;/li&gt;
&lt;li&gt;Vendor-specific class&lt;/li&gt;
&lt;li&gt;Application specific classes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-achieving-an-interoperable-solution&#34;&gt;6. Achieving an Interoperable Solution&lt;/h2&gt;
&lt;p&gt;可以不看&lt;/p&gt;
&lt;h2 id=&#34;7-infiniband-performance-capabilities-and-examples&#34;&gt;7. InfiniBand Performance Capabilities and Examples&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;2010 年的文档，注意时效性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;throughput&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server to server: $40 Gb/s$&lt;/li&gt;
&lt;li&gt;switch to switch: $120 Gb/s$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;latency&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;application: $1 \mu s$&lt;/li&gt;
&lt;li&gt;swicth: $100 ns$ to $150 ns$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前数据可查看 &lt;a href=&#34;https://www.infinibandta.org/infiniband-roadmap/&#34;&gt;InfiniBand Roadmap&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>RDMA notes</title>
      <link>https://k-on.me/post/rdma-notes/</link>
      <pubDate>Fri, 12 Mar 2021 12:17:44 +0800</pubDate>
      
      <guid>https://k-on.me/post/rdma-notes/</guid>
      
        <description>&lt;p&gt;RDMA 相关笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-rdma-相关资源&#34;&gt;1. RDMA 相关资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mellanox/libvma/&#34;&gt;libvma&lt;/a&gt;: VMA Source Code and Documentation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/linux-rdma/rdma-core&#34;&gt;rdma-core&lt;/a&gt;: RDMA core userspace libraries and daemons&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/linux-rdma/perftest&#34;&gt;perftest&lt;/a&gt;: Infiniband Verbs Performance Tests&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jcxue/RDMA-Tutorial&#34;&gt;RDMA-Tutorial&lt;/a&gt;: A tutorial on RDMA based programming using code examples&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-rdma-相关术语&#34;&gt;2. RDMA 相关术语&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Abbr&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Term&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Remote_direct_memory_access&#34;&gt;Remote Direct Memory Access&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HPC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Supercomputer&#34;&gt;High-Performance Computing&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IPC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inter-process_communication&#34;&gt;InterProcess Communication&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SCSI&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SCSI&#34;&gt;Small Computer System Interface&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;MPI&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Message_Passing_Interface&#34;&gt;Message Passing Interface&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HBA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Host Bus Adapter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HCA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Host_adapter&#34;&gt;Host Channel Adapter&lt;/a&gt;: usually used to describe InfiniBand interface cards, is the point at which an InfiniBand end node connects to the InfiniBand network&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TCA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Target Channel Adapter, is a specialized version of a channel adapter intended for use in an embedded environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;MMIO&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Memory-mapped_I/O&#34;&gt;Memory Mapped I/O&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;VIA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtual_Interface_Architecture&#34;&gt;Virtual Interface Architecture&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RoCE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet&#34;&gt;RDMA over Converged ethernet&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IB&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/InfiniBand&#34;&gt;InfiniBand&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IBTA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/InfiniBand_Trade_Association&#34;&gt;InfiniBand Trade Association&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;iWARP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/IWARP&#34;&gt;internet Wide Area RDMA Protocol&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NIC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_interface_controller&#34;&gt;Network Interface Controller&lt;/a&gt;(Cards)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;VMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://community.mellanox.com/s/article/what-is-vma-x&#34;&gt;Mellanox&amp;rsquo;s Messaging Accelerator&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ULPs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Upper Layer Protocols&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Reliable Connection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unreliable Connection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UD&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unreliable Datagram&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Verb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Defines the types of communication operations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PD&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Protection Domain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Completion Queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;QP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Queue Pair, the endpoint of the Channel I/O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Send Queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Receive Queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Work Request, represents a single quantum of work that the application wants to perform&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;MR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Memory Registration&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-rdma-相关博文&#34;&gt;3. RDMA 相关博文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/55142557&#34;&gt;RDMA技术详解（一）：RDMA概述&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍了 RDMA 相关基础概念，适合入门观看。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://community.mellanox.com/s/article/vma-improves-redis-transaction-rate-and-latency--memtier-benchmark-x&#34;&gt;VMA Improves Redis Transaction Rate and Latency (Memtier Benchmark)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在这篇文章中测试了分别在 No VMA，VMA on Server 和 VMA on both 三种情况下， Redis GET/SET 请求的吞吐量和延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thegeekinthecorner.wordpress.com/2013/02/02/rdma-tutorial-pdfs/&#34;&gt;RDMA tutorial PDFs by thegeekinthecorner&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-rdma-相关论文&#34;&gt;4. RDMA 相关论文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://crad.ict.ac.cn/CN/abstract/abstract3859.shtml&#34;&gt;基于 RDMA 的分布式存储系统研究综述&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDMA 背景介绍
&lt;ul&gt;
&lt;li&gt;RDMA 允许本地 CPU 绕过操作系统，直接读写远端节点内存，该过程无需远端 CPU 的参与&lt;/li&gt;
&lt;li&gt;RDMA 通信链路可以被配置为 3 种模式：RC, UC 和 UD&lt;/li&gt;
&lt;li&gt;RDMA 访问远端内存依靠 2 类原语
&lt;ul&gt;
&lt;li&gt;消息语义：Send/Recv&lt;/li&gt;
&lt;li&gt;内存语义：Write/Read&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RDMA 与硬件管理
&lt;ul&gt;
&lt;li&gt;缓存管理：网卡缓存用于暂存 CPU 发起的网络请求和相应的网络状态信息，其主要缓存 3 类数据
&lt;ul&gt;
&lt;li&gt;注册内存容逻辑地址到物理地址的映射表&lt;/li&gt;
&lt;li&gt;QP 状态，存放 QP 对应的元数据信息&lt;/li&gt;
&lt;li&gt;由 CPU 发起的网络请求条目&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当网卡处理能力不及 CPU 时，需控制 CPU 请求速率，避免网络吞吐下降&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;CPU 调度
&lt;ul&gt;
&lt;li&gt;多核并发&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;QP 共享 (会引入时序问题)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RDMA 与软件重构
&lt;ul&gt;
&lt;li&gt;RDMA 在 Key-Value 系统中的应用: Pilaf, HERD, HydraDB, RFP, C-Hint, FaRM, Nessie&lt;/li&gt;
&lt;li&gt;RDMA 在文件系统中的应用: Octopus, NVFS, Crail&lt;/li&gt;
&lt;li&gt;RDMA 在分布式事务中的应用: DrTM, FaRM, FaSST&lt;/li&gt;
&lt;li&gt;RDMA 的通用性优化
&lt;ul&gt;
&lt;li&gt;网络负载重分派&lt;/li&gt;
&lt;li&gt;数据备份与持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://ir.nsfc.gov.cn/paperDownload/ZD2959605.pdf&#34;&gt;Accelerating Redis with RDMA over InfiniBand&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 客户端使用处于 UC 传输类型下的设置为 unsignaled 模式和 inlined 模式的 RDMA Write 操作来传输客户端请求至 Redis 服务器端&lt;/li&gt;
&lt;li&gt;Redis 服务器端使用处于 UD 传输类型下的设置为 inlined 模式的 Send 操作响应客户端的请求&lt;/li&gt;
&lt;li&gt;当 Redis 启动时，在 HCA 上注册 M 个 Chunk，每个 Chunk 包含 Request Buffer 和 Respond Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.smallake.kr/wp-content/uploads/2014/03/Intro_to_IB_for_End_Users.pdf&#34;&gt;Introduction to infiniband for end users&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍了 InfiniBand 相关概念，只需阅读 1、4、5 三章即可。&lt;a href=&#34;https://k-on.me/post/introduction-to-infiniband-for-end-users/#infiniband-architecture-and-features&#34;&gt;笔记地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>LSM Based Storage Techniques: A Survey</title>
      <link>https://k-on.me/post/lsm-based-storage-techniques-a-survey/</link>
      <pubDate>Sun, 07 Feb 2021 15:48:24 +0800</pubDate>
      
      <guid>https://k-on.me/post/lsm-based-storage-techniques-a-survey/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1812.07527.pdf&#34;&gt;《LSM-based Storage Techniques: A Survey》&lt;/a&gt; 阅读笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-lsm-tree-basics&#34;&gt;1. LSM-tree Basics&lt;/h2&gt;
&lt;h3 id=&#34;11-history-of-lsm-tree&#34;&gt;1.1. History of LSM-tree&lt;/h3&gt;
&lt;h4 id=&#34;111-update-index-structure&#34;&gt;1.1.1. Update index structure&lt;/h4&gt;
&lt;p&gt;In general, an index structure can choose one of two strategies to handle updates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in-place&lt;/code&gt; update structure: directly overwrites old records to store new updates (such as $B^+$-tree)
&lt;ul&gt;
&lt;li&gt;优点：数据仅保留一份，利于读操作&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;由于随机写入的影响，写操作性能不佳&lt;/li&gt;
&lt;li&gt;由于更新和删除操作的影响，容易形成碎片，降低磁盘空间利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out-of-place&lt;/code&gt; update structure: always stores updates into new locations instead of overwriting old entries (such as LSM-tree)
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;得益于顺序 IO，写操作性能提升&lt;/li&gt;
&lt;li&gt;因为无须修改旧数据，因此故障恢复逻辑简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;数据保留多份，读操作性能不佳&lt;/li&gt;
&lt;li&gt;已废弃数据仍保存在磁盘中，降低磁盘空间利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因此需要 compaction，以提升磁盘空间利用率和读操作性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;112-the-original-lsm-tree-design&#34;&gt;1.1.2. The original LSM-tree design&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://www.inf.ufpr.br/eduardo/ensino/ci809/papers/lsmtree.pdf&#34;&gt;Paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/lsm/original_lsm-tree_designs.png&#34; alt=&#34;original_lsm-tree_designs&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contains a sequence of components $C_0, C_1, \cdots, C_k$, each component is structured as a $B^+$-tree&lt;/li&gt;
&lt;li&gt;$C_0$ resides in memory and servers incoming writes, while $C_1, \cdots, C_k$ reside on disk&lt;/li&gt;
&lt;li&gt;When $C_i$ is full, a rolling merge process is triggered to merge of leaf pages from $C_i$ into $C_{i+1}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Principle&lt;/code&gt;: Under a stable workload, where the number of levels remains static, write performance is optimized when the size ratios $T_i = \frac{|C_{i+1}|}{|C_i|}$ between all adjacent components are the same.&lt;/p&gt;
&lt;h4 id=&#34;113-stepped-merge-policy&#34;&gt;1.1.3. Stepped-merge policy&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://www.vldb.org/conf/1997/P016.PDF&#34;&gt;Paper&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Similar structure with the original LSM-tree&lt;/li&gt;
&lt;li&gt;Organizes the components into levels, and when level $L$ is full with $T$ components, these $T$ components are merged together into a new component at level $L+1$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-todays-lsm-tree&#34;&gt;1.2. Today$&#39;$s LSM-tree&lt;/h3&gt;
&lt;h4 id=&#34;121-basic-structure&#34;&gt;1.2.1. Basic Structure&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Apply updates &lt;em&gt;out-of-place&lt;/em&gt; to reduce random I/Os&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All incoming writes are appended into a memory component&lt;/li&gt;
&lt;li&gt;An insert or update operation simply adds a new entry&lt;/li&gt;
&lt;li&gt;A delete operations adds an anti-matter entry indicating that a key has been deleted&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exploit the immutability of disk components to simplify concurrency control and recovery.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multiple disk components are merged together into a new one without modifying existing components&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An LSM-tree component can be implemented using &lt;em&gt;any&lt;/em&gt; index structure&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Organize memory components using a &lt;em&gt;concurrent&lt;/em&gt; data structure
&lt;ul&gt;
&lt;li&gt;skip-list&lt;/li&gt;
&lt;li&gt;$B^+$-tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Organize disk components using &lt;em&gt;sorted&lt;/em&gt; data structure
&lt;ul&gt;
&lt;li&gt;Sorted-String Tables (SST): contains a list of data blocks and an index block
&lt;ul&gt;
&lt;li&gt;a data block stores key-value pairs ordered by keys&lt;/li&gt;
&lt;li&gt;an index block stores the key ranges of all data blocks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$B^+$-tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;point lookup query&lt;/em&gt;, which fetches the value for a specific key, can simply search all components one by one, from newest to oldest, and stop immediately after the first match is found.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;range query&lt;/em&gt; can search all components at the same time, feeding the search results into a priority queue to perform reconciliation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Two types of merge policies&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;leveling merge&lt;/code&gt; policy (query optimized)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each level only maintains $1$ component&lt;/li&gt;
&lt;li&gt;The component at level $L$ is $T$ times larger than the component at level $L - 1$&lt;/li&gt;
&lt;li&gt;优点：components 数量少，query 性能较佳&lt;/li&gt;
&lt;li&gt;缺点：$L$ 层的 component 在达到本层大小阈值之前，需要和 $L - 1$ 层的 component 合并复数次，写放大较大
&lt;blockquote&gt;
&lt;p&gt;写放大 = 磁盘写入的数据量 / 实际的数据量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tiering merge&lt;/code&gt; policy (write optimized)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maintains up to $T$ components per level (overlapping key ranges)&lt;/li&gt;
&lt;li&gt;When level $L$ is full, its $T$ components are merged together into a new component at level $L + 1$
&lt;blockquote&gt;
&lt;p&gt;If level $L$ is already the configured maximum level, then the resulting component remains at level $L$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;优点：降低 merge 频率，写性能较佳&lt;/li&gt;
&lt;li&gt;缺点：components 数量多，query 性能稍差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/lsm/lsm-tree_merge_policies.png&#34; alt=&#34;lsm-tree_merge_policies&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;122-some-well-known-optimizations&#34;&gt;1.2.2. Some Well-Known Optimizations&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bloom Filter&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;improve point lookup performance&lt;/li&gt;
&lt;li&gt;the false positive rate is: $(1 - e^{-\frac{nk}{m}})^k$
&lt;ul&gt;
&lt;li&gt;$m$ is the total number of bits&lt;/li&gt;
&lt;li&gt;$n$ is the number of keys&lt;/li&gt;
&lt;li&gt;$k$ is the number of hash functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the optimal $k$ that minimizes the false positive rate is $k = \frac{m}{n}\ln{2}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partitioning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;partitioning is &lt;em&gt;orthogonal&lt;/em&gt; to merge policies, both leveling and tiering (as well as other emerging merge policies) can be adapted to support partitioning.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Partitioned leveling merge policy&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The disk component at each level(except level 0) is range-partitined into multiple fixed-size SSTables&lt;/li&gt;
&lt;li&gt;To merge an SSTable from level $L$ into level $L + 1$, all of its overlapping SSTables at level $L + 1$ are selected, and these SSTables are merged with it to produce new SSTables still at level $L + 1$&lt;/li&gt;
&lt;li&gt;LevelDB uses a round-robin policy to select which SSTable to merge next at each level&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/lsm/partitioned_leveling_merge_policy.png&#34; alt=&#34;partitioned_leveling_merge_policy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Partitioned tiering with vertical grouping&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Overlapping key ranges are grouped together so that the groups have &lt;em&gt;disjoint key ranges&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Merge: all of the SSTables in a group are merged together to produce the resulting SSTables &lt;em&gt;based on the key ranges&lt;/em&gt; of the overlapping groups at the next level, which are then added to these overlapping groups&lt;/li&gt;
&lt;li&gt;SSTables are &lt;em&gt;no longer fixed-size&lt;/em&gt; since they are produced based on the key ranges of the overlapping groups at the next level&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/lsm/partitioned_tiering_with_vertical_grouping.png&#34; alt=&#34;partitioned_tiering_with_vertical_grouping&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Partitioned tiering with horizontal grouping&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each component is range-partitioned into a set of &lt;em&gt;fixed-size&lt;/em&gt; SSTables, serves as logical group directly&lt;/li&gt;
&lt;li&gt;Each level $L$ further maintains an &lt;em&gt;active group&lt;/em&gt; to rreceive new SSTables merged from the previous level&lt;/li&gt;
&lt;li&gt;Merge: selects the SSTables with overlapping key ranges from all of the groups at a level, and the resulting SSTables are added to the active group at the next level&lt;/li&gt;
&lt;li&gt;It is possible one SSTable from a group may overlap a large number of SSTables in the remaining groups&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/lsm/partitioned_tiering_with_horizontal_grouping.png&#34; alt=&#34;partitioned_tiering_with_horizontal_grouping&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;123-concurrency-control-and-recovery&#34;&gt;1.2.3. Concurrency Control and Recovery&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Concurrency Control&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use a locking scheme or a multi-version scheme&lt;/li&gt;
&lt;li&gt;maintain a reference counter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Recovery&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write-ahead logging(WAL)&lt;/li&gt;
&lt;li&gt;a no-steal buffer management policy&lt;/li&gt;
&lt;li&gt;For unpartitioned LSM-trees, adding a pair of timestamps to each disk component&lt;/li&gt;
&lt;li&gt;For partitioned LSM-tress, (LevelDB and RocksDB) maintains a separate metadata log (manifest) to store all changes to the structural metadata, such as adding or deleting SSTables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips:&lt;/em&gt; Steal vs No-Steal buffer management&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dirty Page&lt;/code&gt;: A page with modifications by an uncommitted transaction is a dirty page until either commit or rollback processing for that transaction has been completed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Steal policy&lt;/code&gt;: pages can be written out to disk even if the transaction having modified the pages is still active&lt;/li&gt;
&lt;li&gt;&lt;code&gt;No-Steal policy&lt;/code&gt;: all dirty pages are retained in the buffer pool until the final outcome of the transaction has been determined&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-cost-analysis&#34;&gt;1.3. Cost Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The cost of writes and queries is measured by counting the number of disk I/Os per operation
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Write amplification&lt;/code&gt;: measures the overall I/O cost for this entry to be merged into the largest level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Space amplification&lt;/code&gt;: the overall number of entries divided by the number of unique entries&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This analysis considers an &lt;em&gt;unpartitioned&lt;/em&gt; LSM-tree and represents a worst-case cost&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leveling&lt;/code&gt; is optimized for query performance and space utilization by maintaining one component per level, while with higher write cost by a factor of $T$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tiering&lt;/code&gt; is optimized for write performance by maintaining up to $T$ components at each level, while will decrease query performance and worsen space utilization by a factor of $T$&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Merge Policy&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Leveling&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Tiering&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Write amplification&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(T \cdot \frac{L}{B})$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(\frac{L}{B})$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Point Lookup (Zero-Result)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(L \cdot e^{-\frac{m}{n}})$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(T \cdot L \cdot e^{-\frac{m}{n}})$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Point Lookup (Non-Zero-Result)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(1)$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Short Range Query&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(L)$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(T \cdot L)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Long Range Query&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(\frac{s}{B})$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(T \cdot \frac{s}{B})$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Space Amplification&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(\frac{T+1}{T})$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$O(T)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;where,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;: size ratio of a given LSM-tree&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;: total levels&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;: the number of entries that each data page can store&lt;/li&gt;
&lt;li&gt;False positive rate: $O(e^{-\frac{m}{n}})$, $m$ bits and $n$ total keys&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;: the number of unique keys accessed by a range query
&lt;ul&gt;
&lt;li&gt;Long Range Query: $\frac{s}{B} &amp;gt; 2 \cdot L$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-lsm-tree-improvements&#34;&gt;2. LSM-tree improvements&lt;/h2&gt;
&lt;h3 id=&#34;reducing-write-amplification&#34;&gt;Reducing Write Amplification&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Tiering&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-representative-lsm-based-systems&#34;&gt;3. Representative LSM-based systems&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>LSM Notes</title>
      <link>https://k-on.me/post/lsm-notes/</link>
      <pubDate>Sun, 07 Feb 2021 14:39:21 +0800</pubDate>
      
      <guid>https://k-on.me/post/lsm-notes/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log-structured_merge-tree&#34;&gt;Log-Structured Merge-tree&lt;/a&gt; 相关笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-博文&#34;&gt;1. 博文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.benstopford.com/2015/02/14/log-structured-merge-trees/&#34;&gt;Log Structured Merge Trees&lt;/a&gt; &lt;a href=&#34;https://www.open-open.com/lib/view/open1424916275249.html&#34;&gt;中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简要的介绍了 LSM 背景知识、算法理念以及 Compaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/&#34;&gt;SSTable and Log Structured Storage: LevelDB&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leveldb-handbook.readthedocs.io/zh/latest/rwopt.html&#34;&gt;leveldb-handbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Leveldb-handbook 是基于 goleveldb 项目，为读者讲述 leveldb 背后的系统结构及设计原理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-论文&#34;&gt;2. 论文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1812.07527.pdf&#34;&gt;LSM-based Storage Techniques: A Survey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一篇关于 LSM 很详尽的综述，本文首先讲述了 LSM 的基础知识，随后介绍了从多个方面提升 LSM 性能的一些技术，最后简单介绍了现有基于 LSM 实现的 NoSQL 数据引擎。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://k-on.me/post/lsm-based-storage-techniques-a-survey/&#34;&gt;笔记地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Time, Clocks, and the Ordering of Events in a Distributed System</title>
      <link>https://k-on.me/post/time-clocks-and-the-ordering-of-events-in-a-distributed-system/</link>
      <pubDate>Thu, 04 Feb 2021 18:14:47 +0800</pubDate>
      
      <guid>https://k-on.me/post/time-clocks-and-the-ordering-of-events-in-a-distributed-system/</guid>
      
        <description>&lt;p&gt;《Time, Clocks, and the Ordering of Events in a Distributed System》 阅读笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;https://citemaster.net/get/10b50274-7bc5-11e5-8aa1-00163e009cc7/p558-lamport.pdf&#34;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-the-partial-ordering&#34;&gt;1. The Partial Ordering&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;System model&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The system is composed of a collection of processes&lt;/li&gt;
&lt;li&gt;Each process consists of a sequence of events&lt;/li&gt;
&lt;li&gt;Sending or receiving a message is an event in a process&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Happened before&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The relation &amp;ldquo;happened before&amp;rdquo; (denoted by $\rightarrow$) on the set of events of a system is the smallest relation satisfying the following three conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if $a$ and $b$ are events in the same process, and $a$ comes before $b$, then $a \rightarrow b$&lt;/li&gt;
&lt;li&gt;if $a$ is the sending of a message by one process and $b$ is the receipt of the same message by another process, then $a \rightarrow b$&lt;/li&gt;
&lt;li&gt;if $a \rightarrow b$ and $b \rightarrow c$ then $a \rightarrow c$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two distinct events $a$ and $b$ are said to be &lt;em&gt;concurrent&lt;/em&gt; if $a \nrightarrow b$ and $b \nrightarrow a$. We assume that $a \nrightarrow a$ for any event $a$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Causally affect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Another way of viewing the definition is to say that $a \to b$ means that it is possible for event $a$ to causally affect event $b$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compare to special relativity&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In relativity, the ordering of events is defined in terms of messages that &lt;em&gt;could&lt;/em&gt; be sent.&lt;/li&gt;
&lt;li&gt;In &amp;ldquo;happened before&amp;rdquo; relation, only considering messages that &lt;em&gt;actually&lt;/em&gt; are send.
&lt;blockquote&gt;
&lt;p&gt;也就是说，在分布式系统的 &amp;ldquo;happened before&amp;rdquo; 中不考虑隐式因果关系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-logical-clocks&#34;&gt;2. Logical Clocks&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We define a clock $C_i$ for each process $P_i$ to be a function which assigns a number $C_i(a)$ to any event $a$ in that process.&lt;/li&gt;
&lt;li&gt;The entire system of clocks is represented by the function $C$ which assigns to any event $b$ the number $C(b)$, where $C(b) = C_j(b)$ if $b$ is an event in process $P_j$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Clock Condition&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Clock Condition&lt;/code&gt;: For any event $a, b$: if $a \to b$ then $C(a) &amp;lt; C(b)$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;based on the order in which events occur.&lt;/li&gt;
&lt;li&gt;$C(a) &amp;lt; C(b) \nRightarrow a \to b$, since that would imply that any two concurrent events must occur at the same time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is easy to see from our definition of the relation $\to$ that the Clock Condition is satisfied if the following two conditions hold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C1&lt;/code&gt;: If $a$ and $b$ are events in process $P_i$, and $a$ comes before $b$, then $C_i(a) &amp;lt; C_i(b)$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C2&lt;/code&gt;: If $a$ is the sending of a message by process $P_i$ and $b$ is the receipt of that message by pocess $P_j$, then $C_i(a) &amp;lt; C_j(b)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Implementation Rule of Clock Condition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IR1&lt;/code&gt; (meet condition &lt;code&gt;C1&lt;/code&gt;): Each process $P_i$ increments $C_i$ between any two successive events&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IR2&lt;/code&gt; (meet condition &lt;code&gt;C2&lt;/code&gt;)
&lt;ul&gt;
&lt;li&gt;If event $a$ is the sending of a message $m$ by process $P_i$, then the message $m$ contains a timestamp $T_m = C_i(a)$&lt;/li&gt;
&lt;li&gt;Upon receiving a message $m$, process $P_j$ sets $C_j$ greater than or equal to its present value and greater than $T_m$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-ordering-the-events-totally&#34;&gt;3. Ordering the Events Totally&lt;/h2&gt;
&lt;p&gt;至今为止，我们只能得到事件的偏序关系，为了得到事件的全局顺序，我们可通过附加一个 processes 之间的比较关系 $\prec$ 达成目的。&lt;/p&gt;
&lt;p&gt;More precisely, we define a relation $\Rightarrow$ as follows: if $a$ is an event in process $P_i$ and $b$ is an event in process $P_j$, then $a \Rightarrow b$ if and only if either&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$C_i(a) &amp;lt; C_i(b)$
&lt;blockquote&gt;
&lt;p&gt;Implies that if $a \to b$ then $a \Rightarrow b$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;$C_i(a) = C_j(b)$ and $P_i \prec P_j$
&lt;blockquote&gt;
&lt;p&gt;The oridering $\Rightarrow$ depends upon the system of clocks $C_i$, and is not unique.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-strong-clock-condition&#34;&gt;4. Strong Clock Condition&lt;/h2&gt;
&lt;p&gt;因为所构建的系统可能没有包含所有的因果关系，因此可能所构建系统内的事件顺序和实际上的事件顺序不符。因此，为了和实际相符，逻辑时钟需满足以下约束：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Strong Clock Condition&lt;/code&gt;: For any events $a, b$ in $\varphi$, if $a \leadsto b$ then $C(a) &amp;lt; C(b)$.&lt;/p&gt;
&lt;p&gt;where,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\varphi$ denote the set of all system events.&lt;/li&gt;
&lt;li&gt;$\leadsto$ denote the &amp;ldquo;happened before&amp;rdquo; relation for $\bar{\varphi}$
&lt;ul&gt;
&lt;li&gt;$\bar{\varphi}$ denote the set of events which contains the events in $\varphi$ together with all other relevant external events&lt;/li&gt;
&lt;li&gt;$a \leadsto b \nRightarrow a \to b$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-physical-clocks&#34;&gt;5. Physical Clocks&lt;/h2&gt;
&lt;p&gt;For mathematical convenience, we assume that $C_i(t)$ is a continuous, differentiable function of $t$ except for isolated jump discontinuities where the clock is reset.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical Clock Condition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC1&lt;/code&gt;(correct): There exists a constant $\kappa \ll 1$, such that for all $i$: $|\frac{dC_i(t)}{dt} - 1| &amp;lt; \kappa$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC2&lt;/code&gt;(synchronized): There must be a sufficiently small constant $\epsilon$, such that for all $i, j$: $|C_i(t) - C_j(t)| &amp;lt; \epsilon$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Implementation Rule&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let $m$ be a message which is sent at physical time $t$ and received at time $t&#39;$. We define $v_m = t&#39; - t$ to be the total delay of the message $m$. This delay will, of course, not be known to the process which receives $m$. However, we assume that the receiving process knows some minimum delay $\mu_m &amp;gt; 0$ such that $\mu_m \le v_m$. We call $\xi_m = v_m - \mu_m$ the unpredictable delay of the message.&lt;/p&gt;
&lt;p&gt;We now specialize rules &lt;code&gt;IR1&lt;/code&gt; and &lt;code&gt;IR2&lt;/code&gt; for our physical clocks as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PCIR1&lt;/code&gt;: For each $i$, if $P_i$ does not receive a message at physical time $t$, then $C_i$ is differentiable at $t$ and $\frac{dC_i(t)}{dt} &amp;gt; 0$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PCIR2&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;If $P_i$ sends a message $m$ at physical time $t$, then $m$ contains a timestamp $T_m = C_i(t)$&lt;/li&gt;
&lt;li&gt;Upon receiving a message $m$ at time $t&#39;$, process $P_j$ sets $C_j(t&#39;)$ equal to maximum $(C_j(t&#39; - 0), T_m + \mu_m)$
&lt;blockquote&gt;
&lt;p&gt;$C_j(t&#39; - 0) = lim_{\delta \to 0} C_j(t&#39; - |\delta|)$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;THEOREM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Assume a strongly connected graph of processs with diameter $d$ which always obeys rules &lt;code&gt;PCIR1&lt;/code&gt; and &lt;code&gt;PCIR2&lt;/code&gt;. Assume that for any message $m$, $\mu_m \le \mu$ for some constant $\mu$, and that for all $t \ge t_0$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PC1&lt;/code&gt; holds&lt;/li&gt;
&lt;li&gt;There are constants $\tau$ and $\xi$ such that every $\tau$ seconds a message with an unpredictable delay less than $\xi$ is sent over every arc. Then &lt;code&gt;PC2&lt;/code&gt; is satisfied with $\epsilon \approx d(2\kappa \tau + \xi)$ for all $t \gtrsim t_0 + \tau d$, where the approximations assume $\mu + \xi \ll \tau$&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>TLC Model Checker</title>
      <link>https://k-on.me/post/tlc-model-checker/</link>
      <pubDate>Thu, 14 Jan 2021 16:33:37 +0800</pubDate>
      
      <guid>https://k-on.me/post/tlc-model-checker/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://tla.msr-inria.inria.fr/tlatoolbox/doc/model/model.html&#34;&gt;TLC moder checker&lt;/a&gt; 相关文档阅读笔记，专注于相关概念内容，省略 IDE 界面介绍部分。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/tlaplus/tlaplus&#34;&gt;TLA+ Toolbox&lt;/a&gt; uses the TLC model checker to model check the current spec. &lt;em&gt;More precisely, TLC checks a model of the specification&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;1-models&#34;&gt;1. Models&lt;/h2&gt;
&lt;p&gt;当我们写完 Spec 之后，可以使用 TLC 验证该 Spec。具体做法是先创建和 Spec 关联的 model (a spec may contain multiple models)，再使用 TLC 验证该 model，model 需给予 TLC 以下几个关键信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What the behavior spec is ?&lt;/li&gt;
&lt;li&gt;What TLC should check ?&lt;/li&gt;
&lt;li&gt;What values to substitute for constant parameters ?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;11-what-the-behavior-spec-is-&#34;&gt;1.1. What the behavior spec is ?&lt;/h3&gt;
&lt;p&gt;In TLA+, the term &lt;em&gt;specification&lt;/em&gt; (or spec) is used to mean one of two things, We take the word &lt;em&gt;specification&lt;/em&gt; by itself to have the first meaning. We use the term &lt;em&gt;behavior specification&lt;/em&gt; when we mean the second.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Specification&lt;/strong&gt;: The collection of modules consisting of the root module and and all modules that are imported by the root module, either directly or indirectly, with &lt;code&gt;EXTENDS&lt;/code&gt; or &lt;code&gt;INSTANCE&lt;/code&gt; statements.
&lt;blockquote&gt;
&lt;p&gt;In the context of the Toolbox, we exclude from this collection the standard TLA+ modules such as the &lt;code&gt;Naturals&lt;/code&gt; module. All the specification&amp;rsquo;s module files must be in the same directory as the root module file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Behavior Specification&lt;/strong&gt;: The TLA formula that specifies the set of allowed behaviors of the system or algorithm being specified.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are two ways to write the behavior spec:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Init and Next&lt;/strong&gt;: A pair of formulas that specify the initial state and the next-state relation, respectively.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single formula&lt;/strong&gt;: A single temporal formula of the form $Init \land \Box [Next]_{vars} \land F$.
&lt;ul&gt;
&lt;li&gt;$Init$ is the initial predicate&lt;/li&gt;
&lt;li&gt;$Next$ is the next-state relation&lt;/li&gt;
&lt;li&gt;$vars$ is the tuple of variables&lt;/li&gt;
&lt;li&gt;$F$ is an optional fairness formula&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-what-tlc-should-check-&#34;&gt;1.2. What TLC should check ?&lt;/h3&gt;
&lt;p&gt;There are three kinds of properties of the behavior spec that TLC can check:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deadlock&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A deadlock is said to occur in a state for which the next-state relation allows no successor states.&lt;/li&gt;
&lt;li&gt;Termination is deadlock that is not considered an error. If you want the behavior spec to allow termination, then you should uncheck the deadlock option.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Invariants&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An invariant is a state predicate that is true of all reachable states&amp;ndash;that is, states that can occur in a behavior allowed by the behavior spec.&lt;/li&gt;
&lt;li&gt;You can include a list of invariants. The checking of each invariant can be enabled or disabled by checking or unchecking its box.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Properties&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLC can check if the behavior spec satisfies (implies) a temporal property, which is expressed as a temporal-logic formula.&lt;/li&gt;
&lt;li&gt;You can specify a list of such properties, each with a check-box for enabling or disabling its checking.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-what-values-to-substitute-for-constant-parameters-&#34;&gt;1.3. What values to substitute for constant parameters ?&lt;/h3&gt;
&lt;p&gt;The most basic part of a model is an assignment of values to declared constants. A model must specify the values of all declared constants. There are three wasy to assign a value to a constant:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ordinary assignment&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can set the value of the constant to any constant TLA+ expression that contains only symbols defined in the spec.&lt;/li&gt;
&lt;li&gt;The expression can even include declared constants, as long as the value assigned to a constant does not depend on that constant.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Model value&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ordinary Model Values&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A model value is an unspecified value that TLC considers to be unequal to any value that youcan express in TLA+.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Since TLC cannot evaluate the unbounded $CHOOSE$ expression, to allow TLC to handle the follow spec, you need to substitute a model value for $NotANat$.
$$NotANat = CHOOSE \enspace n : n \notin Nat$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这条要注意！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Typed Model Values&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLC considers a typed model value to be unequal to any other model value of the same type.&lt;/li&gt;
&lt;li&gt;It produces an error when evaluating an expression requires it to determine if a typed model value is equal to any value other than a model value of the same type or an oridinary model value
&lt;blockquote&gt;
&lt;p&gt;普通的 model value 和其他值做比较时，只会返回 FALSE，但有可能比较行为本身就是错误的。为了发现这类错误，可以使用 typed model value，其只允许相同类型的 model value 之间的比较行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;A model-value type consists of a single letter, so there are $52$ different types because  &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are different types.&lt;/li&gt;
&lt;li&gt;A model value has type &lt;code&gt;T&lt;/code&gt; if and only if its name begins with the two characters &lt;code&gt;T_&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Set of model values&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An important resson for substituting a set of model value for constants is to len TLC take advantage of &lt;em&gt;symmetry&lt;/em&gt;. A set is &lt;em&gt;a symmetry set&lt;/em&gt; meaning that permuting the elements in the set of values does not change whether or not a behavior satisfies that behavior spec. TLC can take advantage of this to speed up its check.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can declare more than one set of model values to be a symmetry set. However, the union of all the symmetry sets cannot contain two typed model values with different types.&lt;/li&gt;
&lt;li&gt;TLC does not check if a set you declare to be a symmetry set really is one.&lt;/li&gt;
&lt;li&gt;The only TLA+ operator that can produce a non-symmetric expression when applied to a symmetric expression is $CHOOSE$.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Symmetry sets should not be used when checking liveness properties. Doing so can make TLC fail to find errors, or to report nonexistent errors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-options&#34;&gt;2. Options&lt;/h2&gt;
&lt;h3 id=&#34;21-spec-options&#34;&gt;2.1. Spec Options&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Additional Definitions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不想在 Spec 内部定义的 operators 可以置于此处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;State Constraint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spec 的状态空间大多是无限延伸的，可于此处限制遍历的状态空间范围&lt;/li&gt;
&lt;li&gt;A state constraint is a state predicate, which is a Boolean-valued expression that contains unprimed variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Action Constraint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An action constraint is much like a state constraint, except that the constraint formula may also include primed variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Model Values&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definition Override&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似于 C 的 define 语句&lt;/li&gt;
&lt;li&gt;If the operator whose definition you are overriding has arguments, you will be presented with a form for writing the new definition in the obvious way.&lt;/li&gt;
&lt;li&gt;If it has no arguments, you have two options.  With the Ordinary assignment option, you just write the new definition.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-tlc-options&#34;&gt;2.2. TLC Options&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Configuration&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Number of worker threads&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not set it to be greater than the number of separate processors&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fraction of physical memory allocated to TLC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setting the this parameter too large may produce a &lt;em&gt;Could not create the Java virtual machine&lt;/em&gt; error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Log base 2 of number of disk storage files&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Checking Mode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Model-checking mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is the normal method of running TLC, in which it essentially tries to check all possible behaviors allowed by the behavior spec.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simulation Mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It checks an unending series of behaviors, each of which it constructs by starting from a randomly choosen initial state and repeatedly making a random choice of a possible next state.&lt;/li&gt;
&lt;li&gt;When run in simulation mode, the only statistics TLC reports are for &lt;em&gt;States Found&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Features&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Checkpoint Recovery&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLC takes regular checkpoints, from which it can be restarted if it is stopped for any reason.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Profiling&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLC supports detailed profiling at the action as well as the expression level.&lt;/li&gt;
&lt;li&gt;Profiling negatively impacts model checking performance and should thus be off when checking large models.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visualize state graph after completion&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can reasonably display only state graphs with at most around a hundred states.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Parameters&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Verrify temporal properties upon termination only&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check temporal properties(liveness) only after the complete state space has been checked for invariant(safety) violations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fingerprint seed index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLC saves only 64-bit fingerprints (hashes) of the reachable states that it finds, not the complete states.&lt;/li&gt;
&lt;li&gt;If two different reachable states have the same fingerprint, a situation called a collision, TLC may not find all reachable states.&lt;/li&gt;
&lt;li&gt;The fingerprint seed index specifies which of 64 fingerprint functions TLC should use.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cardinality of largest enumerable set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If TLC tries to enumerate the elements of a set, it will report an error if the set contains more than this number of elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM arguments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TLC command line parameters&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are options given to TLC when it is run on the model.&lt;/li&gt;
&lt;li&gt;A complete list of TLC options can be found in &lt;a href=&#34;https://github.com/tlaplus/tlaplus/blob/v1.8.0/tlatools/org.lamport.tlatools/src/tlc2/TLC.java#L213&#34;&gt;TLC.java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-model-checking&#34;&gt;3. Model Checking&lt;/h2&gt;
&lt;h3 id=&#34;31-how-tlc-is-run&#34;&gt;3.1. How TLC is Run&lt;/h3&gt;
&lt;p&gt;The Toolbox runs TLC on a module named &lt;code&gt;MC&lt;/code&gt; that it constructs from the model. It writes the module file &lt;code&gt;MC.tla&lt;/code&gt; and the TLC configuration file &lt;code&gt;MC.cfg&lt;/code&gt; when validating the model.&lt;/p&gt;
&lt;h3 id=&#34;32-statistics&#34;&gt;3.2. Statistics&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;State space progress&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This show a history of TLC&amp;rsquo;s reachable state space computation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Diameter: The diameter of the reachable-state graph.  It is the length of the longest behavior found so far.&lt;/li&gt;
&lt;li&gt;States Found: The total number of states TLC has examined so far.&lt;/li&gt;
&lt;li&gt;Distinct States: The number of distinct states among the states found.&lt;/li&gt;
&lt;li&gt;Queue Size: The number of (distinct) states found whose successor states TLC has not yet determined.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sub-Actions of next-state&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A common error in writing a behavior spec is for an action not to be enabled when it should be, so the spec cannot reach states that represent reachable states of the actual system being specified.&lt;/li&gt;
&lt;li&gt;This kind of error leads to a violation of desired liveness properties, but does not cause any violation of safety.&lt;/li&gt;
&lt;li&gt;Sub-Actions of next-state shows the number of states generated by each sub-action of the next-state relation.&lt;/li&gt;
&lt;li&gt;The action statistics give you a way of catching such an error even if you&amp;rsquo;re not checking liveness.&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>The Missing Semester of Your CS Education</title>
      <link>https://k-on.me/post/the-missing-semester-of-your-cs-education/</link>
      <pubDate>Wed, 13 Jan 2021 20:07:43 +0800</pubDate>
      
      <guid>https://k-on.me/post/the-missing-semester-of-your-cs-education/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://missing-semester-cn.github.io/&#34;&gt;The Missing Semester of Your CS Education&lt;/a&gt; 阅读笔记.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-the-shell&#34;&gt;1. The Shell&lt;/h2&gt;
&lt;p&gt;Shell: 允许你执行程序,输入并获取某种半结构化的输出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html&#34;&gt;Bash Reference Manual&lt;/a&gt;
&lt;a href=&#34;https://tldp.org/LDP/abs/html/&#34;&gt;Advanced Bash-Scripting Guide&lt;/a&gt;
&lt;a href=&#34;https://mywiki.wooledge.org/BashGuide&#34;&gt;Bash Guide&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-s&#34; data-lang=&#34;s&#34;&gt;&lt;span class=&#34;n&#34;&gt;kumiko&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:~$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kumiko&lt;/code&gt;：主机名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt;：当前工作目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;：表示您现在的身份不是 root 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;11-在程序间创建连接&#34;&gt;1.1. 在程序间创建连接&lt;/h3&gt;
&lt;p&gt;在 shell 中，程序有两个主要的“流”：输入流和输出流。通常，一个程序的输入输出流都是终端（键盘作为输入，显示器作为输出）；但是，我们也可以重定向这些流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; file&lt;/code&gt; &amp;amp; &lt;code&gt;&amp;gt; file&lt;/code&gt;: 将程序的输入输出流分别重定向至文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;：向一个文件追加内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;：将一个程序的输出和另外一个程序的输入连接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得注意的是，&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 是通过 shell 执行的，而不是被各个程序单独执行。因此会有以下情况发生&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# error&lt;/span&gt;
sudo &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &amp;gt; brightness
An error occurred &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; redirecting file &lt;span class=&#34;s1&#34;&gt;&amp;#39;brightness&amp;#39;&lt;/span&gt;
open: Permission denied

&lt;span class=&#34;c1&#34;&gt;# ok&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee brightness
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;12-shell-脚本-bash&#34;&gt;1.2. shell 脚本 (bash)&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;a href=&#34;https://github.com/koalaman/shellcheck&#34;&gt;shellcheck&lt;/a&gt; 定位 shell 脚本中的错误。&lt;/p&gt;
&lt;p&gt;在 shell 脚本中使用空格以分割参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;foo=bar&lt;/code&gt;：变量 &lt;code&gt;foo&lt;/code&gt; 赋值为 &lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foo = bar&lt;/code&gt;：调用程序 &lt;code&gt;foo&lt;/code&gt; 并将 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 作为参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bash 中的字符串通过 &lt;code&gt;&#39;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;&lt;/code&gt; 分隔符来定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;&lt;/code&gt; 定义的字符串为原义字符串，其中的变量不会被转义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;&lt;/code&gt; 定义的字符串会将变量值进行替换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nv&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bar

&lt;span class=&#34;c1&#34;&gt;# bar&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$foo&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# $foo&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;$foo&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;mcd &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  mkdir -p &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$0&lt;/code&gt;： 脚本名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$1&lt;/code&gt;-&lt;code&gt;$9&lt;/code&gt;： 脚本的参数列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;：所有参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$#&lt;/code&gt;：参数个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;：前一个命令的返回值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt;：当前脚本的进程识别码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!!&lt;/code&gt;：完整的上一条命令，包括参数
&lt;blockquote&gt;
&lt;p&gt;当你因为权限不足执行命令失败时，可以使用 &lt;code&gt;sudo !!&lt;/code&gt; 再尝试一次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_&lt;/code&gt;：上一条命令的最后一个参数
&lt;ul&gt;
&lt;li&gt;如果你正在使用的是交互式 shell，可以通过按下 &lt;code&gt;Esc&lt;/code&gt; 之后键入 &lt;code&gt;.&lt;/code&gt; 来获取这个值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命令输出&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 黄前久美子世界第一！&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;黄前久美子世界第一！&amp;#34;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# nothing&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;黄前久美子世界第一！&amp;#34;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 黄前久美子世界第一！&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;黄前久美子世界第一！&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;命令通常使用 &lt;code&gt;STDOUT&lt;/code&gt; 来返回输出值，使用 &lt;code&gt;STDERR&lt;/code&gt; 来返回错误及错误码&lt;/li&gt;
&lt;li&gt;返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生&lt;/li&gt;
&lt;li&gt;退出码可以搭配 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 使用，用来进行条件判断，决定是否执行其他程序&lt;/li&gt;
&lt;li&gt;程序 &lt;code&gt;true&lt;/code&gt; 的返回码永远是 0，&lt;code&gt;false&lt;/code&gt; 的返回码永远是 1&lt;/li&gt;
&lt;li&gt;同一行的多个命令可以用 &lt;code&gt;;&lt;/code&gt; 分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Command/Process Substitution&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# date 会被替换成日期和时间&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Starting program at &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 显示文件夹 foo 和 bar 中文件的区别&lt;/span&gt;
diff &amp;lt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;ls foo&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &amp;lt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;ls bar&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Command Substitution &lt;code&gt;$(cmd)&lt;/code&gt;：执行 &lt;code&gt;cmd&lt;/code&gt;，并使用输出结果替换 &lt;code&gt;$(cmd)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Porcess Substitution &lt;code&gt;&amp;lt;(cmd)&lt;/code&gt;：执行 &lt;code&gt;cmd&lt;/code&gt;，将结果输出到一个临时文件中，并将 &lt;code&gt;&amp;lt;(cmd)&lt;/code&gt; 替换成临时文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; file in &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
    grep foobar &lt;span class=&#34;nv&#34;&gt;$file&lt;/span&gt; &amp;gt; /dev/null 2&amp;gt; /dev/null
    &lt;span class=&#34;c1&#34;&gt;# 如果模式没有找到，则grep退出状态为 1&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$?&lt;/span&gt; -ne &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;File &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$file&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; does not have any foobar, adding one&amp;#34;&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;# foobar&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$file&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在 bash 中进行比较时，尽量使用双方括号 &lt;code&gt;[[ ]]&lt;/code&gt; 而不是单方括号 &lt;code&gt;[ ]&lt;/code&gt;，这样会降低犯错的几率，尽管这样并不能兼容 &lt;code&gt;sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可通过 &lt;code&gt;man test&lt;/code&gt; 查看 Bash 中的 test 手册，下面给出常见的比较操作说明：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;布尔运算&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; expression &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;# 返回表达式值，输入注意括号前反斜杆&lt;/span&gt;
exp1 -a exp2        &lt;span class=&#34;c1&#34;&gt;# 与&lt;/span&gt;
exp1 -o exp2        &lt;span class=&#34;c1&#34;&gt;# 或&lt;/span&gt;
! expression        &lt;span class=&#34;c1&#34;&gt;# 非&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串判断&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;-n str1             &lt;span class=&#34;c1&#34;&gt;# 字符串不为空(长度不为零)，等同于 str1&lt;/span&gt;
-z str1             &lt;span class=&#34;c1&#34;&gt;# 字符串为空(长度等于零)&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; str2         &lt;span class=&#34;c1&#34;&gt;# 相等&lt;/span&gt;
str1 !&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; str2        &lt;span class=&#34;c1&#34;&gt;# 不等&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整型比较&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;num1 -eq num2       &lt;span class=&#34;c1&#34;&gt;# == &lt;/span&gt;
num1 -ne num2       &lt;span class=&#34;c1&#34;&gt;# !=&lt;/span&gt;
num1 -lt num2       &lt;span class=&#34;c1&#34;&gt;# &amp;lt;&lt;/span&gt;
num1 -le num2       &lt;span class=&#34;c1&#34;&gt;# &amp;lt;=&lt;/span&gt;
num1 -gt num2       &lt;span class=&#34;c1&#34;&gt;# &amp;gt;&lt;/span&gt;
num1 -ge num2       &lt;span class=&#34;c1&#34;&gt;# &amp;gt;=&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件判断&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;-e file             &lt;span class=&#34;c1&#34;&gt;# file exists&lt;/span&gt;
-d file             &lt;span class=&#34;c1&#34;&gt;# file exists and is a directory&lt;/span&gt;
-f file             &lt;span class=&#34;c1&#34;&gt;# file exists and is a regular file&lt;/span&gt;
-h file             &lt;span class=&#34;c1&#34;&gt;# file exists and is a symbolic link&lt;/span&gt;
-L file             &lt;span class=&#34;c1&#34;&gt;# same as -h file&lt;/span&gt;
-S file             &lt;span class=&#34;c1&#34;&gt;# file exists and is a socket&lt;/span&gt;

file1 -ef file2     &lt;span class=&#34;c1&#34;&gt;# file1 and file2 have the same device and inode numbers&lt;/span&gt;
file1 -nt file2     &lt;span class=&#34;c1&#34;&gt;# file1 is newer(modification date) than file2&lt;/span&gt;
file1 -ot file2     &lt;span class=&#34;c1&#34;&gt;# file1 is older than file2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通配(globbing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通配符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 匹配一个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 匹配任意个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;花括号 &lt;code&gt;{}&lt;/code&gt;：当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;convert image.&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;png,jpg&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 会展开为&lt;/span&gt;
convert image.png image.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-shell-工具&#34;&gt;1.3. Shell 工具&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查看命令如何使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命令行输入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;cmd_name -h
cmd_name --help
man cmd_name
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt; 获得的使用手册太过详实，推荐使用 &lt;a href=&#34;https://tldr.sh/&#34;&gt;TLDR pages&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查找文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man1/find.1.html&#34;&gt;find&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sharkdp/fd&#34;&gt;fd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man1/locate.1.html&#34;&gt;locate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other&#34;&gt;locate vs find&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找文件内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man1/grep.1.html&#34;&gt;grep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://beyondgrep.com/&#34;&gt;ack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ggreer/the_silver_searcher&#34;&gt;ag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;rg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查找 shell 历史命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;history&lt;/code&gt; 命令允许您以程序员的方式来访问 shell 中输入的历史命令&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;Ctrl+R&lt;/code&gt; 对命令历史记录进行回溯搜索&lt;/li&gt;
&lt;li&gt;输入命令时，如果您在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。如果你不小心忘了在前面加空格，可以通过编辑 &lt;code&gt;bash_history&lt;/code&gt; 或 &lt;code&gt;.zhistory&lt;/code&gt; 来手动地从历史记录中移除那一项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;目录切换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://github.com/clvv/fasd&#34;&gt;fasd&lt;/a&gt; 可以查找最常用和/或最近使用的文件和目录&lt;/li&gt;
&lt;li&gt;也可以使用 &lt;a href=&#34;https://github.com/wting/autojump&#34;&gt;autojump&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>The Problem With Embedded CRDT Counters and a Solution</title>
      <link>https://k-on.me/post/the-problem-with-embedded-crdt-counters-and-a-solution/</link>
      <pubDate>Thu, 31 Dec 2020 17:09:00 +0800</pubDate>
      
      <guid>https://k-on.me/post/the-problem-with-embedded-crdt-counters-and-a-solution/</guid>
      
        <description>&lt;p&gt;《The Problem With Embedded CRDT Counters and a Solution》 阅读笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/2911151.2911159&#34;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-目前存在的问题&#34;&gt;1. 目前存在的问题&lt;/h2&gt;
&lt;p&gt;当直接使用 &lt;code&gt;OR-Set&lt;/code&gt; 记录 Map 的 field ，&lt;code&gt;PN-Counter&lt;/code&gt; 存储对应的 value 时，可能存在以下问题：利用 &lt;code&gt;OR-Set&lt;/code&gt; 虽可确定某 field 是否存在，但其对应的 value 并未包含所有历史操作信息，仅记录了当前状态值。因此，对于该 field 的删除操作在同步至对端时，并不能撤消所观察到的历史操作的影响。&lt;/p&gt;
&lt;p&gt;例如，在经历以下操作序列之后&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;time&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;replica 1&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;replica 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$t_1$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;m[&amp;lsquo;a&amp;rsquo;].inc(2)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$t_2$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;ndash; sync &amp;ndash;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;ndash; sync &amp;ndash;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$t_3$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;m[&amp;lsquo;a&amp;rsquo;].inc(3)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;m.remove(&amp;lsquo;a&amp;rsquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$t_4$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;ndash; sync &amp;ndash;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;ndash; sync &amp;ndash;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们期望的结果是最终收敛至 $3$：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/crdt/embedded_crdt_counters_anomaly_desired.png&#34; alt=&#34;embedded_crdt_counters_anomaly_desired&#34;&gt;&lt;/p&gt;
&lt;p&gt;但事实上，会收敛至 $5$，因为在 $t_4$ 同步时，$t_3$ 的 &lt;code&gt;m.remove(&#39;a&#39;)&lt;/code&gt; 并未撤销在 $t_2$ 已同步的 &lt;code&gt;m[&#39;a&#39;].inc(2)&lt;/code&gt; 操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/crdt/embedded_crdt_counters_anomaly_fact.png&#34; alt=&#34;embedded_crdt_counters_anomaly_fact&#34;&gt;&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;remove-wins set&lt;/code&gt; 作为 field 时，虽然可以撤销所观察的操作，但同时也会丢弃未观察到的并发操作，收敛至 $0$：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/crdt/embedded_crdt_counters_anomaly_remove_win.png&#34; alt=&#34;embedded_crdt_counters_anomaly_remove_win&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;add-wins 在每次 &lt;code&gt;inc&lt;/code&gt; 操作时更新 tag，remove-wins 则会复用已存在的 tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-可行解&#34;&gt;2. 可行解&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个 field 在删除时，存储 tombstone。虽然可行，但是 GC 较为麻烦，希望可以将 GC 控制在 key 维度，如此 GC 的实现便可借鉴 key 的主动过期机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove-wins set&lt;/code&gt; 加 fresh 机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;remove-wins set&lt;/code&gt; 记录 Map 的 field&lt;/li&gt;
&lt;li&gt;在将状态传输至其他 replicas 之后调用 fresh 生成新的 tag，以防止本地后续更新被其他 replicas 并行的 reset 操作覆盖&lt;/li&gt;
&lt;li&gt;该方法的缺点是 tag 的数量较多，与调用 fresh 的次数成正比&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/crdt/embedded_crdt_counters_remove_win_fresh.png&#34; alt=&#34;embedded_crdt_counters_remove_win_fresh&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-resettable-counter&#34;&gt;3. Resettable Counter&lt;/h2&gt;
&lt;p&gt;基于之前的讨论，作者提出了 &lt;code&gt;Resettable Counter&lt;/code&gt;，其描述如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/crdt/embedded_crdt_counters_resettable_counter.png&#34; alt=&#34;embedded_crdt_counters_resettable_counter&#34;&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;Resettable Counter&lt;/code&gt; 和 &lt;code&gt;OR-Set&lt;/code&gt; 有效结合便可实现我们想要的数据结构(如，&lt;code&gt;ZSET&lt;/code&gt;)。但需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上述数学描述给出的 &lt;code&gt;Resettable Counter&lt;/code&gt; 是 reset-wins 的，因此需要手动调用 fresh 接口防止更新操作被并行的 reset 所覆盖&lt;/li&gt;
&lt;li&gt;只有在计数器状态被发送到其他 replicas 后调用 fresh 可适当减少 tag 数量&lt;/li&gt;
&lt;li&gt;上述数学描述是 state-CRDT，在与 &lt;a href=&#34;https://k-on.me/post/efficient-state-based-crdts-by-delta-mutation/#delta-crdts-for-add-wins-or-sets&#34;&gt;Optimized Add-Wins OR-Set&lt;/a&gt; 结合时，需要进行适当修改&lt;/li&gt;
&lt;li&gt;事实上，当 &lt;code&gt;Resettable Counter&lt;/code&gt; 和 &lt;code&gt;Optimized Add-Wins OR-Set&lt;/code&gt; 结合后，在集合 $s$ 中存储的即为操作历史(五元组 &lt;code&gt;&amp;lt;id, seq, ele, pcnt, ncnt&amp;gt;&lt;/code&gt;)，利用 tag(&lt;code&gt;&amp;lt;id, seq&amp;gt;&lt;/code&gt;) 的唯一性、集合的互异性以及加减操作满足结合律和交换律的性质使得集合 $s$ 的 join 满足交换律、结合律和幂等的性质，故最后所有副本收敛至同一状态&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Specifying Systems Notes</title>
      <link>https://k-on.me/post/specifying-systems-notes/</link>
      <pubDate>Tue, 08 Dec 2020 10:23:40 +0800</pubDate>
      
      <guid>https://k-on.me/post/specifying-systems-notes/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://lamport.azurewebsites.net/tla/book-02-08-08.pdf&#34;&gt;《Specifying Systems》&lt;/a&gt; 阅读笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-a-little-simple-math&#34;&gt;1. A Little Simple Math&lt;/h2&gt;
&lt;h3 id=&#34;11-propositional-logic&#34;&gt;1.1. Propositional Logic&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Propositional_calculus&#34;&gt;Propositional Logic&lt;/a&gt; (命题逻辑) is the mathematics of the two Boolean values &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; and the five operators whose names are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\land$ conjunction (and)&lt;/li&gt;
&lt;li&gt;$\lor$ disjunction (or)&lt;/li&gt;
&lt;li&gt;$\lnot$ negation (not)&lt;/li&gt;
&lt;li&gt;$\Rightarrow$ implication (implies)&lt;/li&gt;
&lt;li&gt;$\equiv$ equivalence (is equivalent to)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tautology_(logic)&#34;&gt;Tautology&lt;/a&gt; (恒真式) is a formula or assertion that is ture in every possible interpretation. 比如 $F \Rightarrow G \equiv \lnot F \lor G$ 是一个 tautology。&lt;/p&gt;
&lt;h3 id=&#34;12-predicate-logic&#34;&gt;1.2. Predicate Logic&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/First-order_logic&#34;&gt;Predicate Logic&lt;/a&gt; (谓词逻辑) extends propositional logic with the two quantifiers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\forall$ universal quantification (for all)&lt;/li&gt;
&lt;li&gt;$\exists$ existential quantification (there exists)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，&lt;a href=&#34;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&#34;&gt;Predicate&lt;/a&gt; 可以看作为一个布尔值函数，而 &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantifier_(logic)&#34;&gt;quantifiers&lt;/a&gt; 指定了该 predicate 成立的程度。&lt;/p&gt;
&lt;h2 id=&#34;2-specifying-a-simple-clock&#34;&gt;2. Specifying a Simple Clock&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;: an assignment of values to varibles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;behavior&lt;/strong&gt; is an infinite sequence of states.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;step&lt;/strong&gt;: a pair of successive states.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;action&lt;/strong&gt;: an action is a formula, is true or false of a step.
&lt;ul&gt;
&lt;li&gt;A step is satisfies the action $A$ is called an $A$ step&lt;/li&gt;
&lt;li&gt;An action is a formula, and formulas aren&amp;rsquo;t executed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stuttering steps&lt;/strong&gt;: steps that leave specified state(vars) unchanged.
&lt;ul&gt;
&lt;li&gt;In TLA, we let $[Next]_{vars}$ stand for $Next \lor (vars&#39; = vars)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;theorem&lt;/strong&gt;: a temporal formula satisfied by every behavior is called a theorem.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-小结&#34;&gt;2.1. 小结&lt;/h3&gt;
&lt;p&gt;在本章中作者通过简单的 Clock 例子展示了使用 TLA+ 描述一个系统时的大致流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先给出系统初始状态 $Init$&lt;/li&gt;
&lt;li&gt;再描述系统状态变化的行为 $Next$&lt;/li&gt;
&lt;li&gt;然后，得到 $Spec \triangleq Init \land \Box [Next]_{vars}$&lt;/li&gt;
&lt;li&gt;最后给出系统应满足的条件：$\mathrm{THEOREM} \enspace Spec \Rightarrow \mathrm{Temporal \enspace formula}$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-an-asynchronous-interface&#34;&gt;3. An Asynchronous Interface&lt;/h2&gt;
&lt;h3 id=&#34;31-invariant--type&#34;&gt;3.1. Invariant &amp;amp; Type&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;state function&lt;/strong&gt; is an ordinary expression (one with no prime or $\Box$) that can contain variables and constants.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;state predicate&lt;/strong&gt; is a Boolean-valued state function. (one with no prime or $\Box$)&lt;/li&gt;
&lt;li&gt;An &lt;strong&gt;invariant&lt;/strong&gt; $Inv$ of a specification $Spec$ is a state predicate such that $Spec \Rightarrow \Box Inv$ is a theorem.&lt;/li&gt;
&lt;li&gt;A variable $v$ has &lt;strong&gt;type&lt;/strong&gt; $T$ in a specification $Spec$ iff $v \in T$ is an invariant of $Spec$.&lt;/li&gt;
&lt;li&gt;PS: TLA+ is an untyped language. Type correctness is just a name for a certain invariance property.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-record&#34;&gt;3.2. Record&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;record&lt;/strong&gt; is a function whose domain is a finite set of strings.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eg. $[val \mapsto d, ack \mapsto 1, rdy \mapsto 0]$ can be written&lt;/p&gt;
&lt;p&gt;$[i \in \lbrace &amp;ldquo;val&amp;rdquo;, &amp;ldquo;ack&amp;rdquo;, &amp;ldquo;rdy&amp;rdquo;\rbrace \mapsto $
$$\mathrm{IF} \enspace i = &amp;ldquo;val&amp;rdquo; \enspace \mathrm{THEN} \enspace  d \enspace  \mathrm{ELSE \enspace IF} \enspace i = &amp;ldquo;ack&amp;rdquo; \enspace \mathrm{THEN} \enspace 1 \enspace \mathrm{ELSE} \enspace 0]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The set of records is written: $[val : Data, rdy : \{0, 1\}, ack : \{0, 1\}]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The fields of a record are not ordered&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In general, for any record $r$, the expression $[r \enspace \mathrm{EXCEPT} \enspace !.c_1 = e_1, \cdots , !.c_n = e_n]$ is the record obtained from $r$ by replacing $r.c_i$ with $e_i$, for each $i$ in $1 .. n$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; as standing for the new record $r&#39;$&lt;/li&gt;
&lt;li&gt;an &lt;code&gt;@&lt;/code&gt; in the expression $e_i$ stands for $r.c_i$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-definitions&#34;&gt;3.3. Definitions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;operators&lt;/strong&gt;: We define operators that take &lt;em&gt;more than one argument&lt;/em&gt; in the obvious way, the general form being&lt;/p&gt;
&lt;p&gt;$$Id(p_1, \dots, p_n) \triangleq exp$$&lt;/p&gt;
&lt;p&gt;where the $p_i$ are distinct identifiers and $exp$ is an expression.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;symbol&lt;/strong&gt;: mean an identifier or an operator.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Every symbol declaration or definition has a &lt;strong&gt;scope&lt;/strong&gt; within the symbol may bes used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The statement $\mathrm{EXTENDS}$ extends the scope of symbols&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A symbol cannot be declared or defined if it already has a meaning.&lt;/p&gt;
&lt;p&gt;eg. $\exists v \in S : (exp1 \land \exists v \in T : exp2)$ is illegal.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-comments&#34;&gt;3.4. Comments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单行注释：&lt;code&gt;\*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多行注释：&lt;code&gt;(*....*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-小结&#34;&gt;3.5. 小结&lt;/h3&gt;
&lt;p&gt;在本章中，作者通过示例展示了在描述一个系统时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以通过定义 &lt;code&gt;invariant&lt;/code&gt; 描述系统该满足的条件，以便于理解，比如 type-correctness invariant&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;record&lt;/code&gt; 将多个变量整合为单个变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-a-fifo&#34;&gt;4. A FIFO&lt;/h2&gt;
&lt;h3 id=&#34;41-instantiation-examined&#34;&gt;4.1. Instantiation Examined&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Instantiation Is Substitution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s now consider an arbitrary $\mathrm{INSTANCE}$ statement&lt;/p&gt;
&lt;p&gt;$$IM \triangleq \mathrm{INTANCE} \enspace M \enspace \mathrm{WITH} \enspace p_1 \leftarrow e_1, \dots, p_n \leftarrow e_n$$&lt;/p&gt;
&lt;p&gt;Let $\Sigma$ be a symbol defined in module $M$ and let $d$ be its &amp;ldquo;real&amp;rdquo; definition.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The $\mathrm{INSTANCE}$ statement defines $IM!\Sigma$ to have as its real definition the expression obtained from $d$ by replacing all instances of $p_i$ by the expression $e_i$, for each $i$.&lt;/li&gt;
&lt;li&gt;The definition of $IM!\Sigma$ must contain only the parameters (declared constants and variables) of the current module, not the ones of module $M$.
&lt;ul&gt;
&lt;li&gt;Hence, the $p_i$ must consist of all the parameters of module $M$.&lt;/li&gt;
&lt;li&gt;The $e_i$ must be expressions that are meaningful in the current module.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Parametrized Instantiation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$InChan \triangleq \mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace Data \leftarrow Message, chan \leftarrow in$$
$$OutChan \triangleq \mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace Data \leftarrow Message, chan \leftarrow out$$&lt;/p&gt;
&lt;p&gt;可以使用参数实例化，将上述两个实例化语句合为一条语句：&lt;/p&gt;
&lt;p&gt;$$Chan(ch) \triangleq \mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace Data \leftarrow Message, chan \leftarrow ch$$&lt;/p&gt;
&lt;p&gt;其中 $ch \in \lbrace in, out \rbrace$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implicit Substitutions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们也可以使用当前 module 中的参数替代将要实例化的 module 中同名参数，例如:&lt;/p&gt;
&lt;p&gt;$$InChan \triangleq \mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace Data \leftarrow Data, chan \leftarrow in$$&lt;/p&gt;
&lt;p&gt;TLA+ allows us to drop any substiotution of the form $\Sigma \leftarrow \Sigma$, for a symbol $\Sigma$. So, the statement above can be written as&lt;/p&gt;
&lt;p&gt;$$InChan \triangleq \mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace chan \leftarrow in$$&lt;/p&gt;
&lt;p&gt;其中，$Data$ 参数会被当前 module 中的 $Data$ 参数隐式替代。特别地，当所有参数都使用隐式替代时，$\mathrm{WITH}$ 语句可以省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Instantiation Without Renaming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当同一 module 有多个实例或使用参数实例化时，我们需要使用 $IM!\Sigma$ 重命名 $\Sigma$ 以区分不同的实例。但当该 module 只有一个实例时，我们可以省略重命名，此时，实例化语句可以使用如下格式：&lt;/p&gt;
&lt;p&gt;$$\mathrm{INTSANCE} \enspace Channel \enspace \mathrm{WITH} \enspace Data \leftarrow D, chan \leftarrow x$$&lt;/p&gt;
&lt;p&gt;This instantiates $Channel$ with no renaming, but with substitution.&lt;/p&gt;
&lt;h3 id=&#34;42-hiding-variables&#34;&gt;4.2. Hiding variables&lt;/h3&gt;
&lt;p&gt;In TLA, we hide a variable with the existential quantifier &lt;strong&gt;∃&lt;/strong&gt; of temporal logic.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the formula &lt;strong&gt;∃&lt;/strong&gt;$x : F$, the symbol $x$ is declared to be a variable in $F$.&lt;/li&gt;
&lt;li&gt;Unlike $\exists r : F$, which asserts the existence of a single value $r$, the formula &lt;strong&gt;∃&lt;/strong&gt;$x : F$ asserts the exitence of a value for $x$ in each state of a behavior.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们可以通过结合量词 &lt;strong&gt;∃&lt;/strong&gt; 和参数实例化的特性达到隐藏变量的目的，例如：&lt;/p&gt;
&lt;p&gt;$ Inner(q) \triangleq \mathrm{INSTANCE} \enspace InnerFIFO$&lt;/p&gt;
&lt;p&gt;$Spec \triangleq$ &lt;strong&gt;∃&lt;/strong&gt; $q : Inner(q)!Spec$&lt;/p&gt;
&lt;p&gt;The variable parameter $q$ of module $InnerFIFO$ is instantiated with the parameter $q$ of the definition of $Inner$.&lt;/p&gt;
&lt;h3 id=&#34;43-assume&#34;&gt;4.3. ASSUME&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An $\mathrm{ASSUME}$ statement should be used only to make assumptions about &lt;strong&gt;constants&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;我们不需要假定某个常量是集合类型，because in TLA+, every value is a set.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;44-小结&#34;&gt;4.4. 小结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;介绍了 Instantiation，并展示了如何利用实例化以使用其他 module&lt;/li&gt;
&lt;li&gt;通过利用量词 &lt;strong&gt;∃&lt;/strong&gt; 和参数实例化的特性可达到隐藏变量的目的&lt;/li&gt;
&lt;li&gt;利用 $\mathrm{ASSUME}$ 语句可以设定 $\mathrm{CONSTANT}$ 的取值范围&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-a-caching-memory&#34;&gt;5. A Caching Memory&lt;/h2&gt;
&lt;h3 id=&#34;51-parameters&#34;&gt;5.1. Parameters&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The way to leave something unspecified in a specification is to make ti a parameter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLA+ provides only $\mathrm{CONSTANCE}$ and $\mathrm{VARIABLE}$ parameters, not action parameters, we can declare a &lt;strong&gt;constant operator&lt;/strong&gt; to descirbe the action.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In TLA+, we declare $Send$ to be a constant operator that takes four arguments by writing:&lt;/p&gt;
&lt;p&gt;$$\mathrm{INSTANCE} \enspace Send(\rule[-0pt]{0.3cm}{0.5pt}， \rule[-0pt]{0.3cm}{0.5pt}， \rule[-0pt]{0.3cm}{0.5pt}， \rule[-0pt]{0.3cm}{0.5pt})$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The expression $\mathrm{CHOOSE} \enspace x : F$ equals an arbitrarily chosen value $x$ that satisfies the formula $F$. If no such $x$ exists, the expression has a completely arbitrary value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The follow statement defines $NoVal$ to be some value this is not an element of $Val$.
$$NoVal \triangleq \mathrm{CHOOSE} \enspace v : v \notin Val$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52-functions&#34;&gt;5.2. Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A function $f$ has a domain, written $\mathrm{DOMAIN} \enspace f$, and it assigns to each element $x$ of its domain the value $f[x]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For any sets $S$ and $T$, the set of all functions whose domain equals $S$ and whose range is any subset of $T$ is written $[S \rightarrow T]$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A record is a function whose domain is a finite set of strings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In general, $[f \enspace \mathrm{EXCEPT} \enspace ![c_1] = e_1, \dots, ![c_n] = e_n]$ is the function $\hat{f}$ that is the same as $f$ except with $\hat{f}[c_i]= e_i$ for each $i$. More precisely, this expression equals&lt;/p&gt;
&lt;p&gt;$$[\dots[[f \enspace \mathrm{EXCEPT} \enspace ![c_1] = e_1]\enspace \mathrm{EXCEPT} \enspace ![c_2] = e_2]\dots \enspace \mathrm{EXCEPT} \enspace ![c_n] = e_n]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Functions correspond to the arrays of programming languages. A function whose range is a set of functions corresponds to an array of arrays. eg:&lt;/p&gt;
&lt;p&gt;$$[f \enspace \mathrm{EXCEPT} \enspace ![c][d] = e]$$&lt;/p&gt;
&lt;p&gt;can be written as&lt;/p&gt;
&lt;p&gt;$$[f \enspace \mathrm{EXCEPT} \enspace ![c] = [@ \enspace \mathrm{EXCEPT} \enspace ![d] = e]]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLA+ uniformly maintains the notation that $\sigma.c$ is an abbreviation for $\sigma[&amp;ldquo;c&amp;rdquo;]$. For example, this implies&lt;/p&gt;
&lt;p&gt;$$[f \enspace \mathrm{EXCEPT} \enspace ![c].d = e] = [f \enspace \mathrm{EXCEPT} \enspace ![c][&amp;ldquo;d&amp;rdquo;] = e]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In TLA+, as in ordinary mathematics, a function of multiple arguments is one whose domain is a set of tuples. For example, $f[5, 3, 1]$ is an abbreviation for $f[\langle 5, 3, 1 \rangle]$, the value of the function $f$ applied to the triple $\langle 5, 3, 1 \rangle$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLA+ provides the Cartesian product operator $\times$ of ordinary mathematics, where $A \times B \times C$ is the set of all 3-tuples $\langle a, b, c \rangle$ such that $a \in A, b \in B$, and $c \in C$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The $\mathrm{LET}$ clause consists of a sequence of definitions whose scope extends until the end of the $\mathrm{IN}$ clause.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When writing specifications, we almost always want to specify the new value of a variable $f$ rather than the new values of $f[i]$ for all $i$ in some set.
$$\text{(a)} \space f&#39; = [i \in Nat \mapsto i + 1] \qquad \surd$$
$$\text{(b)} \space \forall i \in Nat : f&#39;[i] = i + 1 \qquad \times$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Formula (a) uniquely determines $f&#39;$, asserting that it&amp;rsquo;s a function with domain $Nat$&lt;/li&gt;
&lt;li&gt;Formula (b) is satisfied by lots of different values of $f&#39;$.In fact, wo can&amp;rsquo;t even deduce that $f&#39;$ is a function.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Recursive function&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Follow definition is illegal because the occurrence of fact to the right of the $\triangleq$ is undefined
$$fact \triangleq [n \in Nat \mapsto \mathrm{IF} \enspace n = 0 \enspace \mathrm{THEN} \enspace 1 \enspace \mathrm{ELSE} \enspace n * fact[n-1]]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In general, a definition of the form $f[x \in S] \triangleq e$ can be used to define &lt;strong&gt;recursively&lt;/strong&gt; a function $f$ with domain $S$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In general, $f[x \in S] \triangleq e$ is an abbreviation for
$$f \triangleq \mathrm{CHOOSE} \enspace f : f = [x \in S \mapsto e]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLA+ does not allow mutually recursive definition, but you can convert any mutually recursive definitions into a single recursive definition of a record-valued function whose fields are the desired functions.(P68-69, 6.3)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;53-invariance&#34;&gt;5.3. Invariance&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In general, when $P \land N \Rightarrow P&#39;$ holds, we say that predicate $P$ is an invariant of action $N$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;54-小结&#34;&gt;5.4. 小结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当不知如何规范化描述某事物时，可先将其看作 parameter&lt;/li&gt;
&lt;li&gt;可以利用 $\mathrm{CHOOSE}$ 表示不属于某集合的值&lt;/li&gt;
&lt;li&gt;invariant of action $\neq$ invariant of formula&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-some-more-math&#34;&gt;6. Some More Math&lt;/h2&gt;
&lt;h3 id=&#34;61-sets&#34;&gt;6.1. Sets&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;built-in operators of TLA+&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The most common operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;intersection $\cap$&lt;/li&gt;
&lt;li&gt;union $\cup$&lt;/li&gt;
&lt;li&gt;subset $\subseteq$&lt;/li&gt;
&lt;li&gt;set difference $\setminus$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\mathrm{UNION} \enspace S$: The union of the elements of $S$. For example,
$$\mathrm{UNION} \enspace \lbrace \lbrace 1, 2 \rbrace, \lbrace 2, 3 \rbrace, \lbrace 3, 4 \rbrace \rbrace = \lbrace 1, 2, 3, 4 \rbrace$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\mathrm{SUBSET} \enspace S$: The set of all subsets of $S$. For example,
$$\mathrm{SUBSET} \enspace \lbrace 1, 2 \rbrace = \lbrace \lbrace \rbrace, \lbrace 1 \rbrace, \lbrace 2 \rbrace, \lbrace 1, 2 \rbrace \rbrace$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\{x \in S : p\}$: The subset of $S$ consisting of all elements $x$ satisfying property $p$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\{e : x \in S\}$: The set of elements of the form $e$, for all $x$ in the set $S$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Russell&amp;rsquo;s paradox&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let $\mathcal{R}$ be the set of all sets $S$ such that $S \notin S$. The definiton of $\mathcal{R}$ implies that $\mathcal{R} \in \mathcal{R}$ is true iff $\mathcal{R} \notin \mathcal{R}$ is true.&lt;/p&gt;
&lt;p&gt;A collection $\mathcal{C}$ is too big to be a set if it is as big as the collection of all sets &amp;mdash; meaning that we can assign to every set a different element of $\mathcal{C}$. That is, $\mathcal{C}$ is too big to be a set if we can define an operator $SMap$ such that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$SMap(S)$ is in $\mathcal{C}$, for any set $S$&lt;/li&gt;
&lt;li&gt;If $S$ and $T$ are two different sets, then $SMap(S) \neq SMap(T)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-silly-expressions&#34;&gt;6.2. Silly Expressions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TLA+ is based on the usual formalization of mathematics by mathematicians, which doesn&amp;rsquo;t hava types.&lt;/li&gt;
&lt;li&gt;A correct formula can contain silly expressions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;63-functions-versus-operators&#34;&gt;6.3. Functions versus Operators&lt;/h3&gt;
&lt;p&gt;$$Tail(s) \triangleq [i \in 1 .. (Len(s) - 1) \mapsto s[i+1]]$$
$$fact[n \in Nat] \triangleq \mathrm{IF} \enspace n = 0 \enspace \mathrm{THEN} \enspace 1 \enspace \mathrm{ELSE} \enspace n*fact[n-1]$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function like $fact$ by itself is a complete expression that denote a value, but an operator like $Tail$ is not.&lt;/li&gt;
&lt;li&gt;Unlike an operator, a function must have a domain, which is a set.&lt;/li&gt;
&lt;li&gt;Unlike a function, an operator cannot be defined recursively in TLA+.
&lt;blockquote&gt;
&lt;p&gt;However, we can usually transform an illegal recursive operator definition into a nonrecursive one using a recursive function definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Operators also differ from functions in that an operator can take an operator as an argument.&lt;/li&gt;
&lt;li&gt;The definition of $Tail$ defines $Tail(s)$ for all values of $s$. whatever $Tail(s)$ means, it equals $Tail(s)$. But the definition of $fact$ defines $fact[n]$ only for $n \in Nat$, it tells us nothing about the value of $fact[1/2]$.&lt;/li&gt;
&lt;li&gt;TLA+ doesn&amp;rsquo;t permit us to define infix functions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-writing-a-specification-some-advice&#34;&gt;7. Writing a Specification: Some Advice&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Why Specify?
&lt;ul&gt;
&lt;li&gt;help the design process&lt;/li&gt;
&lt;li&gt;consice way of communicating a design&lt;/li&gt;
&lt;li&gt;find errors in the design and to help in testing the system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;What to Specify?
&lt;ul&gt;
&lt;li&gt;TLA+ is particularly effective at revealing concurrency errors - ones that arise through the interraction of asynchronous components. So when writing a TLA+ specification, you will probably concentrate your efforts on the parts of the system that are most likely to have such errors.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The level of abstraction &amp;mdash; tradeoff of precise and cost
&lt;ul&gt;
&lt;li&gt;The Grain of Atomicity&lt;/li&gt;
&lt;li&gt;The Data Structures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Writing the Specification
&lt;ol&gt;
&lt;li&gt;Pick the variables and define the type invariant and initial predicate&lt;/li&gt;
&lt;li&gt;Write the next-state action, which forms the bulk of the specification&lt;/li&gt;
&lt;li&gt;Write the temporal part of the specification&lt;/li&gt;
&lt;li&gt;Assert theorems about the specification&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Some Further Hints
&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t be too clever, make a specification easy to read&lt;/li&gt;
&lt;li&gt;A type invariant is not an assumption, is a property of a specification&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t be too abstract&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t assume values that look different are unequal
&lt;ul&gt;
&lt;li&gt;The rules of TLA+ do not imply that $1 \neq &amp;ldquo;a&amp;rdquo;$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Move quantification to the outside&lt;/li&gt;
&lt;li&gt;Prime only what you mean to prime
&lt;ul&gt;
&lt;li&gt;PS: you can prime only an expression, not an operator&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Write comments as comments&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-liveness-and-fairness&#34;&gt;8. Liveness and Fairness&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Safety properties: what a system must not do&lt;/li&gt;
&lt;li&gt;Liveness properties: something does happen&lt;/li&gt;
&lt;li&gt;We express liveness properties as temporal formulas&lt;/li&gt;
&lt;li&gt;Liveness properties are likely to be the least important part of your specification&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;81-temporal-formulas&#34;&gt;8.1. Temporal Formulas&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A temporal formula is true or false of a $behavior$.&lt;/li&gt;
&lt;li&gt;Formally, a temporal formula $F$ assigns a Boolean value, which we write $\sigma \models F$, to a behavior $\sigma$.&lt;/li&gt;
&lt;li&gt;We say that $F$ is true of $\sigma$, or that $\sigma$ satisfies $F$, iff $\sigma \models F$ equals $\mathrm{TRUE}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;PS: reviews&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Term&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;A formula is true or false of this term&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state predicate $P$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;setp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;action $A$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;behavior&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;temporal formula $F$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Unquantified temporal formuals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;All the unquantified temporal formulas that we&amp;rsquo;ve seen have been Boolean combinations of three simple kinds of formulas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A $state \ predicate$ $P$, viewed as a temporal formula, is true of a behavior iff it is true in the first state of the behavior.&lt;/li&gt;
&lt;li&gt;A formula $\Box P$, where $P$ is a $state \ predicate$, is true of a behavior iff $P$ is true in every state of the behavior&lt;/li&gt;
&lt;li&gt;A formula $\Box [N]_v$, where $N$ is an $action$ and $v$ is a state function, is true of a behavior iff every successive pair of steps in the behavior is a $[N]_v$ step.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Since a state predicate is an action that contains no primed variables, than
$$\{P, \Box P, \Box [N]_v\} \equiv \{A, \Box A\}$$
where $A$ is an action.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We interpret an arbitrary action $A$ as a temporal formula by defining $\sigma \models A$ to be true iff the first two states of $\sigma$ are an $A$ step
&lt;ul&gt;
&lt;li&gt;use the notation $\sigma_i$ that is the $(i+1)^{st}$ state of the behavior $\sigma$, for any natural number $i$, so $\sigma$ is the behavior $\sigma_0 \rightarrow \sigma_1 \rightarrow \sigma_2 \rightarrow \cdots$&lt;/li&gt;
&lt;li&gt;That is, $\sigma \models A$ is true iff $\sigma_0 \rightarrow \sigma_1$ is an $A$ step&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We defined $\sigma \models \Box A$ to be true iff $\sigma_n \rightarrow \sigma_{n+1}$ is an $A$ step for all $n$. In other words:
$$\sigma \models \Box A \quad \equiv \quad \forall n \in Nat : \sigma^{+n} \models A$$
where $\sigma^{+n} \triangleq \sigma_n \rightarrow \sigma_{n+1} \rightarrow \sigma_{n+2} \rightarrow \cdots$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The obvious generalization is&lt;/p&gt;
&lt;p&gt;$$\sigma \models \Box F \quad \triangleq \quad \forall n \in Nat : \sigma^{+n} \models F$$&lt;/p&gt;
&lt;p&gt;for any temporal formula $F$. In other words, $\sigma$ satisfies $\Box F$ iff every $\sigma^{+n}$ of $\sigma$ satisfies $F$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This defines the meaning of the temporal operator $\Box$. We can therefore read $\Box$ as &lt;em&gt;always&lt;/em&gt; or &lt;em&gt;henceforth&lt;/em&gt; or &lt;em&gt;from then on&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;We say that a formula $F$ is &lt;em&gt;invariant under stuffering&lt;/em&gt; iff adding or deleting a stuffering step to a behavior $\sigma$ does not affect whether $\sigma$ satisfies $F$
&lt;ul&gt;
&lt;li&gt;TLA allows you to write only temporal formulas that are invariant under stuttering&lt;/li&gt;
&lt;li&gt;A state predicate (viewed as a temporal formula) is invariant under stuttering&lt;/li&gt;
&lt;li&gt;In general, the formula $\Box [A]_v$ is invariant under stuttering, for ant action $A$ and state function $v$. However, $\Box A$ is not invariant under stuttering for an arbitrary action $A$&lt;/li&gt;
&lt;li&gt;Invariant under stuttering is preserved by $\Box$ and by Boolean operators &amp;mdash; that is, if $F$ and $G$ are invariant under stuttering, then so are $\Box F$, $\lnot F$, $F \land G$, $\forall x \in S : F$, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Five especially important classes of formulas&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\Diamond F \quad$ is defined to equal $\lnot \Box \lnot F$. It asserts that $F$ is not always false, which means that $F$ is true at some time&lt;/p&gt;
&lt;p&gt;$$\sigma \models \Diamond F \quad \equiv \quad \exists n \in Nat : \sigma^{+n} \models F$$&lt;/p&gt;
&lt;p&gt;We usually read $\Diamond$ as &lt;em&gt;eventually&lt;/em&gt;, taking eventually to include now.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$F \rightsquigarrow G \quad$ is defined to equal $\Box(F \Rightarrow \Diamond G)$. It asserts that whenever $F$ is true, $G$ is eventually true &amp;mdash; that is, $G$ is true then or at some later time.&lt;/p&gt;
&lt;p&gt;$\sigma \models (F \rightsquigarrow G) \quad \equiv \quad $
$$\forall n \in Nat : (\sigma^{+n} \models F) \Rightarrow (\exists m \in Nat : (\sigma^{+(n+m)} \models G))$$&lt;/p&gt;
&lt;p&gt;We read $\rightsquigarrow$ as &lt;em&gt;leads to&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Diamond \langle A \rangle_v \quad$ is defined to equal $\lnot \Box [\lnot A]_v$, where $A$ is an action and $v$ is a state function. It asserts that not every step is a $(\lnot A) \lor (v&#39; = v)$ step, so some step is a $A \land (v&#39; \ne v)$ &amp;mdash; that is, an $A$ step that changes $v$. We defines the action $\langle A \rangle_v$ by&lt;/p&gt;
&lt;p&gt;$$\langle A \rangle_v \triangleq A \land (v&#39; \ne v)$$&lt;/p&gt;
&lt;p&gt;so $\Diamond \langle A \rangle_v$ asserts that eventually $\langle A \rangle_v$ step occurs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Box \Diamond F \quad$ asserts that at all times, $F$ is true then or at some later time.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It asserts that $F$ is &lt;em&gt;infinitely often&lt;/em&gt; true (无限但不连续)&lt;/li&gt;
&lt;li&gt;In particular, $\Box \Diamond \langle A \rangle_v$ asserts that infinitely many $\langle A \rangle_v$ steps occur&lt;/li&gt;
&lt;li&gt;$(\sigma \models \Box \Diamond F) \equiv (\exists_\infty i \in Nat : \sigma^{+i} \models F)$, where $\exists_\infty i \in Nat : P(i)$ means $P(i)$ is true for infinitely many natural numbers $i$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Diamond \Box F \quad$ asserts that eventually (at some time), $F$ becomes true and remains true thereafter.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It asserts $F$ is &lt;em&gt;eventually always&lt;/em&gt; true (连续)&lt;/li&gt;
&lt;li&gt;In particular, $\Diamond \Box [N]_v$ asserts that, eventually, every step is a $[N]_v$ step&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;82-temporal-tautologies&#34;&gt;8.2. Temporal Tautologies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;temporal theorem&lt;/em&gt; is a temporal formula that is satisfied by all behaviors.&lt;/li&gt;
&lt;li&gt;A formula like $\Box F \Rightarrow F$ that is true when any formulas are substituted for its identifiers is called a tautology, tautologies containing temporal operators are sometimes called &lt;em&gt;temporal tautologies&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;some temporal tautologies&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A genneral law: from any temporal tautology, we obtain a dual tautology by making the replacements&lt;/p&gt;
&lt;p&gt;$$\Box \leftarrow \Diamond \quad \Diamond \leftarrow \Box \quad \land \leftarrow \lor \quad \lor \leftarrow \land$$&lt;/p&gt;
&lt;p&gt;and reversing the direction of all implications. (Any $\equiv$ or $\lnot$ is left unchanged.)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\lnot \Box F \equiv \Diamond \lnot F$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$F$ is not always true iff it is eventually false.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Box(F \land G) \equiv (\Box F) \land (\Box G) \qquad$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$F$ and $G$ are both always true iff $F$ is always true and $G$ is always true&lt;/li&gt;
&lt;li&gt;$\Box$ distributes over $\land$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Diamond (F \lor G) \equiv (\Diamond F) \lor (\Diamond G)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$F$ or $G$ is eventually true iff $F$ is eventually true or $G$ is eventually true&lt;/li&gt;
&lt;li&gt;$\Diamond$ distributes over $\lor$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$(\Box F) \lor (\Box G) \Rightarrow \Box(F \lor G) \qquad \Diamond (F \land G) \Rightarrow (\Diamond F) \land (\Diamond G)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One can be derived from the derived from the another by substituting $\lnot F$ for $F$ and $\lnot G$ for $G$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\Box \Diamond (F \lor G) \equiv (\Box \Diamond F) \lor (\Box \Diamond G) \qquad \Diamond \Box(F \land G) \equiv (\Diamond \Box F) \land (\Diamond \Box G)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\Box \Diamond$ distributes over $\lor$ and $\Diamond \Box$ distributes over $\land$ (取决于右边的符号)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In any TLA tautology, replacing a temporal formula by an action yields a tautology &amp;mdash; a formula that is true for all behaviors &amp;mdash; even if that formula isn&amp;rsquo;t a legal TLA formula. For example, let&amp;rsquo;s substitue $\langle A \rangle_v$ and $\langle B \rangle_v$ for $F$ and $G$ in $5$ to get&lt;/p&gt;
&lt;p&gt;$$\Box \Diamond (\langle A \rangle_v \lor \langle B \rangle_v) \quad \equiv \quad (\Box \Diamond \langle A \rangle_v) \lor (\Box \Diamond \langle B \rangle_v)$$&lt;/p&gt;
&lt;p&gt;but $(\langle A \rangle_v \lor \langle B \rangle_v)$ isn&amp;rsquo;t a TLA formula (TLA allows you to write only temporal formulas that are invariant under stuttering). We can apply the following rules of logic to transform those nonTLA tautologies into TLA tautologies:&lt;/p&gt;
&lt;p&gt;$$[A \land B]_v \quad \equiv \quad [A]_v \land [B]_v \qquad \qquad \langle A \lor B \rangle_v \quad \equiv \quad \langle A \rangle_v \lor \langle B \rangle_v$$&lt;/p&gt;
&lt;p&gt;Substituting $\langle A \rangle_v \lor \langle B \rangle_v$ for $\langle A \lor B \rangle_v$, gives us the following TLA tautology:&lt;/p&gt;
&lt;p&gt;$$\Box \Diamond \langle A \lor B \rangle_v \quad \equiv \quad (\Box \Diamond \langle A \rangle_v) \lor (\Box \Diamond \langle B \rangle_v)$$&lt;/p&gt;
&lt;h3 id=&#34;83-temporal-proof-rules&#34;&gt;8.3. Temporal Proof Rules&lt;/h3&gt;
&lt;p&gt;A &lt;em&gt;proof rule&lt;/em&gt; is a rule for deducing true formulas from other true formulas.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modus Ponens Rule&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for any formulas $F$ and $G$, if we have proved $F$ and $F \models G$, then we can deduce $G$&lt;/li&gt;
&lt;li&gt;the laws of propositional logic hold for temporal logic as well&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Temporal Proof Rules&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modus Ponens Rule&lt;/li&gt;
&lt;li&gt;Generalization Rule: From $F$ we can infer $\Box F$, for any temporal formula $F$
&lt;ul&gt;
&lt;li&gt;This rule asserts that, if $F$ is true for all behaviors, then so is $\Box F$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implies Generalization Rule: From $F \models G$ we can infer $\Box F \models \Box G$, for any temporal formulas $F$ and $G$.
&lt;ul&gt;
&lt;li&gt;The Generalization Rule can be derived from the Implies Generalization Rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Difference between proof rule and tautology&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In propositional logic, every proof rule has a corressponding tautology.&lt;/li&gt;
&lt;li&gt;In temporal logic, a proof rule need not imply a tautology&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;84-weak-fairness&#34;&gt;8.4. Weak Fairness&lt;/h3&gt;
&lt;p&gt;When writing liveness properties, the syntax of TLA often forces us to write $\langle A \rangle_v$ instead of $A$, for some action $A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Because if $A$ does allow stuttering steps, we want to require not that an $A$ step eventually occurs, but that a nonstuttering $A$ step occurs &amp;mdash; that is, an $\langle A \rangle_v$ step.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TLA+ defines $\quad \mathrm{ENABLED} \ A \quad$ to be the &lt;em&gt;predicate&lt;/em&gt; that is true iff action $A$ is enabled.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General liveness condition for an action $A$:&lt;/p&gt;
&lt;p&gt;$$\Box(\mathrm{ENABLED}\langle A \rangle_v \Rightarrow \Diamond \langle A \rangle_v)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Weaker formula $WF_v(A)$, defined to equal(3 种等价描述) &amp;mdash; weak fairness on $A$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If $A$ is enabled forever, then an $A$ step eventually occurs&lt;/p&gt;
&lt;p&gt;$\Box(\Box \mathrm{ENABLED}\langle A \rangle_v \Rightarrow \Diamond \langle A \rangle_v)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$A$ is infinitely often disabled, or infinitely many $A$ steps occur&lt;/p&gt;
&lt;p&gt;$\Box \Diamond (\lnot \mathrm{ENABLED}\langle A \rangle_v) \lor \Box \Diamond \langle A \rangle_v$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If $A$ is eventually enabled forever, then infinitely many $A$ steps occur&lt;/p&gt;
&lt;p&gt;$\Diamond \Box (\mathrm{ENABLED} \langle A \rangle_v) \Rightarrow \Box \Diamond \langle A \rangle_v$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-the-standard-modules&#34;&gt;9. The Standard Modules&lt;/h2&gt;
&lt;h3 id=&#34;91-sequences-module&#34;&gt;9.1. Sequences Module&lt;/h3&gt;
&lt;p&gt;The Sequences module defines the following operators on sequences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$Seq(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The set of all sequence of elements of the set $S$&lt;/li&gt;
&lt;li&gt;For example, $\langle 3, 7 \rangle$ is an element of $Seq(Nat)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Head(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first element of sequence $s$&lt;/li&gt;
&lt;li&gt;For example, $Head(\langle 3, 7 \rangle)$ equals $3$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Tail(s)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The tail of sequence $s$, which consists of $s$ with its head removed&lt;/li&gt;
&lt;li&gt;For example, $Tail(\langle 3, 7 \rangle)$ equals $\langle 7 \rangle$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Append(s, e)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sequence obtained by appending element $e$ to the tail of sequence $s$&lt;/li&gt;
&lt;li&gt;For example, $Append(\langle 3, 7 \rangle, 3)$ equals $\langle 3, 7, 3 \rangle$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$s \circ t$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sequence obtained by concatenating the sequences $s$ and $t$&lt;/li&gt;
&lt;li&gt;For example, $\langle 3, 7 \rangle \circ \langle 3 \rangle$ euqals $\langle 3, 7, 3 \rangle$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$Len(s)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length og sequence $s$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$SubSeq(s, m, n)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The subsequence $\langle s[m], s[m+1], \dots, s[n] \rangle$ consisting of the $m^{th}$ through $n^{th}$ elements of $s$&lt;/li&gt;
&lt;li&gt;It is underfined if $m &amp;lt; 1$ or $n &amp;gt; Len(s)$, except that it equals the empty sequence if $m &amp;gt; n$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$SelectSeq(s, Test)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The subsequence of $s$ consisting of the elements $s[i]$ such that $Test(s[i])$ equals $\mathrm{TRUE}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_sequence_module.png&#34; alt=&#34;tla_sequence_module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;92-finitesets-module&#34;&gt;9.2. FiniteSets Module&lt;/h3&gt;
&lt;p&gt;The FiniteSets module defines the following operators on set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$Cardinality(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of elements in set $S$, if $S$ is a finite set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$IsFiniteSet(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True iff $S$ is a finite set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_finitesets_module.png&#34; alt=&#34;tla_finitesets_module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;93-bags-module&#34;&gt;9.3. Bags Module&lt;/h3&gt;
&lt;p&gt;A bag, also called a multiset, is a set that can contain multiple copies of the same element. A bag can have infinitely many elements, but only the finitely many copies of any single element.&lt;/p&gt;
&lt;p&gt;The Bags module defines a bag to be a function whose range is a subset of the positive integers. The module defines the following operators:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$IsABag(B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True iff $B$ is a bag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$BagToSet(B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The set of elements of which bag $B$ contains at least one copy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$SetToBag(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bag that contains one copy of every element i nthe set $S$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$BagIn(e, B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True iff bag $B$ contains at least one copy of $e$.&lt;/li&gt;
&lt;li&gt;$BagIn$ is the $\in$ operator for bags&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$EmptyBag$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bag containing no elements&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$CopiesIn(e, B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of copies of $e$ in bag $B&lt;/li&gt;
&lt;li&gt;it is equal to $0$ iff $BagIn(e, B)$ is false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$B1 \oplus B2$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The union of bags $B1$ and $B2$&lt;/li&gt;
&lt;li&gt;The operator $\oplus$ satifies
$$CopiesIn(e, B1 \oplus B2) = CopiesIn(e, B1) + CopiesIn(e, B2)$$
for any $e$ and any bags $B1$ and $B2$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$B1 \ominus B2$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bag $B1$ with the elements of $B2$ removed &amp;mdash; that is, with one copy of an element removed from $B1$ for each copy of the same element in $B2$&lt;/li&gt;
&lt;li&gt;If $B2$ has at least as many copies of $e$ as $B1$, then $B1 \ominus B2$ has no copies of $e$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$BagUnion(S)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bag union of all elements of the set $S$ of bags.&lt;/li&gt;
&lt;li&gt;$BagUnion$ is the analog of $\mathrm{UNION}$ for bags.&lt;/li&gt;
&lt;li&gt;For example, $BagUnion(\{B1, B2, B3\})$ equals $B1 \oplus B2 \oplus B3$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$B1 \sqsubseteq B2$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True iff, for all $e$, bag $B2$ has at least as many copies of $e$ as bag $B1$ does&lt;/li&gt;
&lt;li&gt;$\sqsubseteq$ is the analog for bags of $\subseteq$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$SubBag(B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The set of all subbags of bag $B$&lt;/li&gt;
&lt;li&gt;$SubBag$ is the analog of $\mathrm{SUBSET}$ for bags&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$BagOfAll(F, B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is thg bag that contains, for each element $e$ of bag $B$, one copy of $F(e)$ for every copy of $e$ in $B$&lt;/li&gt;
&lt;li&gt;This defines a bag iff, for any value $v$, the set of $e$ in $B$ such that $F(e) = v$ is finite&lt;/li&gt;
&lt;li&gt;The bag analog of the construct $\{F(x) : x \in B\}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$BagCardinality(B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If $B$ is a finite bag (one such that $BagToSet(B)$ is a finite set), then this is its cardinality &amp;mdash; the total number of copies of elements in $B$.&lt;/li&gt;
&lt;li&gt;Its value is unspecified if $B$ is not a finite bag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_bags_module.png&#34; alt=&#34;tal_bags_module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;94-the-numbers-modules&#34;&gt;9.4. The Numbers Modules&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_numbers_modules.png&#34; alt=&#34;tla_numbers_module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;95-realtime-module&#34;&gt;9.5. RealTime Module&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_realtime_module.png&#34; alt=&#34;tla_realtime_module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;96-tlc-module&#34;&gt;9.6. TLC Module&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_tlc_module.png&#34; alt=&#34;tla_tlc_module&#34;&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>TLA&#43; notes</title>
      <link>https://k-on.me/post/tla_notes/</link>
      <pubDate>Mon, 09 Nov 2020 17:17:41 +0800</pubDate>
      
      <guid>https://k-on.me/post/tla_notes/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/TLA%2B&#34;&gt;TLA+&lt;/a&gt; 相关笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-tla-相关资源&#34;&gt;1. TLA+ 相关资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://lamport.azurewebsites.net/tla/tla.html&#34;&gt;The TLA+ Home Page by Leslie Lamport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cmschmtt/tla-plus-resources&#34;&gt;TLA+ Reading and Resource List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tlaplus/tlaplus&#34;&gt;TLA+ IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tla.msr-inria.inria.fr/tlatoolbox/doc/contents.html&#34;&gt;TLA+ Toolbox User&amp;rsquo;s Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-个人笔记&#34;&gt;2. 个人笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://k-on.me/post/specifying-systems-notes/&#34;&gt;Specifying Systems Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://k-on.me/post/tlc-model-checker/&#34;&gt;TLC Model Checker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在生成 PDF 文件时，个人比较喜欢将 documentclass 设置为 &lt;code&gt;standalone&lt;/code&gt;，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;documentclass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;preview&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;standalone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tlatex&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setboolean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shading&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bottombar&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bottombar&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-operators-of-standard-modules-p272&#34;&gt;3. Operators of standard modules (P272)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_module_operators.png&#34; alt=&#34;module_operators&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-typeset-symbols-of-tla-p273&#34;&gt;4. Typeset symbols of TLA+ (P273)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/tla/tla_typeset.png&#34; alt=&#34;symbols&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Operator&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;line comment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;(*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;block comment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;is assignment in the &lt;code&gt;variables&lt;/code&gt; block,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;is the equality check in everywhere else&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;:=&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;assignment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;/=&lt;/code&gt; or &lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;not equal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;/\&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;and&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\/&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;or&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;not&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;define an operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Specify tuples and they are 1-indexed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\o&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Combine two sequences&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\X&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Cartesian product operator: &lt;code&gt;set1 \X set2&lt;/code&gt; is the set of&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;all tuples &lt;code&gt;t&lt;/code&gt; where &lt;code&gt;t[1] \in set1&lt;/code&gt; and &lt;code&gt;t[2] \in set2&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;{...}&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\in&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;in set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\notin&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;not in set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\subseteq&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;is subset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\union&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;set union&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\intersect&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;set intersection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;S1 \ S2&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;the elements in &lt;code&gt;S1&lt;/code&gt; not in &lt;code&gt;S2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\E&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;exists&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~\E&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;not exists&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;\A&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;all&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~\A&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;not all&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;P =&amp;gt; Q&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If P is true, then Q must also be true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;It’s equivalent to writing &lt;code&gt;~P \/ Q&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;P &amp;lt;=&amp;gt; Q&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Either both P and Q are true or both are false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;It’s equivalent to writing &lt;code&gt;(~P /\ ~Q) \/ (P /\ Q)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;|-&amp;gt;&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;map. use &lt;code&gt;|-&amp;gt;&lt;/code&gt; when you want one function that maps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;the domain to a specific range. Use &lt;code&gt;-&amp;gt;&lt;/code&gt; when you want&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;the set of functions that maps the domain to the range.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;||&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lets multiple assignments all use the old values&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;an invariant. &lt;code&gt;[]P&lt;/code&gt; means that P is true for all states&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;eventually. &lt;code&gt;&amp;lt;&amp;gt;P&lt;/code&gt; means that for every possible behavior,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;at least one state has P as true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leads to. &lt;code&gt;P ~&amp;gt; Q&lt;/code&gt; implies that if P ever becomes true,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;at some point afterwards Q must be true.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stays. &lt;code&gt;&amp;lt;&amp;gt;[]P&lt;/code&gt; says that at some point P becomes true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;and then stays true.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- Server</title>
      <link>https://k-on.me/post/redis-sourcecode-server/</link>
      <pubDate>Tue, 27 Oct 2020 20:01:48 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-server/</guid>
      
        <description>&lt;p&gt;Redis Server 相关源码阅读笔记，源码文件 &lt;code&gt;server.h&lt;/code&gt; &amp;amp; &lt;code&gt;server.c&lt;/code&gt; &amp;amp;  &lt;code&gt;networking.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-启动流程&#34;&gt;1. 启动流程&lt;/h2&gt;
&lt;h3 id=&#34;11-main&#34;&gt;1.1. main&lt;/h3&gt;
&lt;p&gt;从 Redis 的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.c#L5305&#34;&gt;main&lt;/a&gt; 函数中，可以发现在 Redis 启动时主要做了以下几个工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加载配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;initServerConfig&lt;/code&gt; 设置默认配置值&lt;/li&gt;
&lt;li&gt;处理命令行参数值&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;loadServerConfig&lt;/code&gt; 加载配置文件中的配置项覆盖默认配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;initServer&lt;/code&gt; 初始化服务器&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;moduleLoadFromQueue&lt;/code&gt; 加载 modules 列表&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;InitServerLast&lt;/code&gt; 初始化线程，为了防止&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.c#L3049&#34;&gt;线程本地存储初始化与 dlopen 调用冲突的问题&lt;/a&gt;，故须在加载 modules 之后完成&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;loadDataFromDisk&lt;/code&gt; 加载先前可能存在的数据集
&lt;blockquote&gt;
&lt;p&gt;优先从 AOF 文件中恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行：调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L5310&#34;&gt;aeMain&lt;/a&gt; 启动 event loop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;12-initserver&#34;&gt;1.2. initServer&lt;/h3&gt;
&lt;p&gt;在调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.c#L2835&#34;&gt;initServer&lt;/a&gt; 初始化服务器的过程中，Redis 主要进行以下几项初始化工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置信号处理函数 —— &lt;code&gt;setupSignalHandlers&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 &lt;code&gt;server&lt;/code&gt; 结构体中相应 fields&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要为 common configs &amp;amp; clients configs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;createSharedObjects&lt;/code&gt; 初始化共享 Redis 数据对象列表 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.c#L66&#34;&gt;shared&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;adjustOpenFilesLimit&lt;/code&gt; 根据 open file limit 设置真实的最大客户端连接数 &lt;code&gt;server.maxclients&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会尝试按需更改 file limit 以满足最大客户端连接数设置&lt;/li&gt;
&lt;li&gt;会预留 &lt;code&gt;CONFIG_MIN_RESERVED_FDS&lt;/code&gt;(32) 个 fd 用于持久化、监听 scokets 和日志文件等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;aeCreateEventLoop&lt;/code&gt; 初始化服务器的 event loop &lt;code&gt;server.el&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件事件容量设置为 &lt;code&gt;server.maxclients&lt;/code&gt; + &lt;code&gt;CONFIG_MIN_RESERVED_FDS&lt;/code&gt; + $96$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听配置的地址，接收来自用户的请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP socket: &lt;code&gt;listenToPort&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;可通过 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L68&#34;&gt;bind&lt;/a&gt; 设置绑定的 IP 地址，默认监听机器上的所有 IP 地址&lt;/li&gt;
&lt;li&gt;可监听的 IP 地址上限为 &lt;code&gt;CONFIG_BINDADDR_MAX&lt;/code&gt;(16)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unix domain socket: &lt;code&gt;anetUnixServer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 &lt;code&gt;server&lt;/code&gt; 内嵌的数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;server.db&lt;/code&gt; 数组，长度为 &lt;code&gt;server.dbnum&lt;/code&gt;，并初始化每个 &lt;code&gt;redisDb&lt;/code&gt; 的状态&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;evictionPoolAlloc&lt;/code&gt; 初始化 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-db/#eviction-pool&#34;&gt;eviction pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;初始化 Pub/Sub 客户端&lt;/li&gt;
&lt;li&gt;初始化 RDB/AOF 相关状态，调用 &lt;code&gt;aofRewriteBufferReset&lt;/code&gt; 重置 AOF rewrite buffer&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;resetServerStats&lt;/code&gt; 重置服务器数据统计状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加事件至服务器的 event loop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加时间事件 &lt;code&gt;serverCron&lt;/code&gt; 处理定期任务&lt;/li&gt;
&lt;li&gt;添加&lt;strong&gt;可读&lt;/strong&gt;文件事件处理客户端连接及请求
&lt;ul&gt;
&lt;li&gt;TCP sockets: &lt;code&gt;acceptTcpHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TCP sockets with TLS: &lt;code&gt;acceptTLSHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Unix socket: &lt;code&gt;acceptUnixHandler&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;添加&lt;strong&gt;可读&lt;/strong&gt;文件事件监听 module 中阻塞的客户端 fd&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;beforeSleep&lt;/code&gt; &amp;amp; &lt;code&gt;afterSleep&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Others&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open the AOF file if needed.&lt;/li&gt;
&lt;li&gt;如为 cluster 模式，则调用 &lt;code&gt;clusterInit&lt;/code&gt; 进行相应的初始化操作&lt;/li&gt;
&lt;li&gt;Initialize the script cache.&lt;/li&gt;
&lt;li&gt;Initialize the scripting environment.&lt;/li&gt;
&lt;li&gt;Initialize the slow log.&lt;/li&gt;
&lt;li&gt;Latency monitor initialization.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-定期任务&#34;&gt;2. 定期任务&lt;/h2&gt;
&lt;h3 id=&#34;21-servercron&#34;&gt;2.1. serverCron&lt;/h3&gt;
&lt;p&gt;Redis 在初始化时，会添加一个 time event &lt;code&gt;serverCron&lt;/code&gt; 至 event loop，其运行频率为 &lt;code&gt;server.hz&lt;/code&gt;；如果配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L1714&#34;&gt;dynamic_hz&lt;/a&gt; 设置为 &lt;code&gt;yes&lt;/code&gt;，则该频率会随着当前客户端连接数的增加而增加，上限为 &lt;code&gt;CONFIG_MAX_HZ&lt;/code&gt; (500)。&lt;/p&gt;
&lt;p&gt;该函数内部分任务的运行频率并不是 &lt;code&gt;server.hz&lt;/code&gt;，而是由 &lt;code&gt;run_with_period(milliseconds) {...}&lt;/code&gt; 中的 &lt;code&gt;milliseconds&lt;/code&gt; 确定。&lt;/p&gt;
&lt;p&gt;但是从 Redis 的&lt;a href=&#34;https://k-on.me/post/redis-sourcecode-ae/#event-loop-1&#34;&gt;事件循环处理过程&lt;/a&gt;可知 Redis 在处理时间事件之前会先遍历处理已触发的文件事件，因此 &lt;code&gt;serverCron&lt;/code&gt; 实际上的运行频率可能比理论上低。&lt;/p&gt;
&lt;p&gt;在该定期执行的任务中，主要做了以下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新服务器状态，可通过 &lt;code&gt;INFO&lt;/code&gt; 命令查看这些状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如初始化时设置的信号处理函数 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.c#L5032&#34;&gt;sigShutdownHandler&lt;/a&gt; 收到 &lt;code&gt;SIGTERM&lt;/code&gt;，则 Redis 会在调用 &lt;code&gt;prepareForShutdown&lt;/code&gt; 处理以下工作后退出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清理 lua debugger forked、RDB saving child、module child、AOF saving child&lt;/li&gt;
&lt;li&gt;在开启 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L1094&#34;&gt;AOF 持久化&lt;/a&gt;时，将 AOF 缓冲区内容 flush 至 AOF 文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L307&#34;&gt;save&lt;/a&gt; 开启时，保存 RDB 文件&lt;/li&gt;
&lt;li&gt;触发 module 注册的关闭时需处理事件&lt;/li&gt;
&lt;li&gt;Flush slave output buffers&lt;/li&gt;
&lt;li&gt;Close the listening sockets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行客户端相关定期任务：&lt;code&gt;clientsCron&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次调用遍历的客户端数量
&lt;ul&gt;
&lt;li&gt;当客户端数量低于 &lt;code&gt;CLIENTS_CRON_MIN_ITERATIONS&lt;/code&gt;(5) 时，会在单次调用中遍历全部客户端&lt;/li&gt;
&lt;li&gt;当客户端数量大于 $5$ 时，会确保尽量在 $1s$ 内遍历全部客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查/更新 客户端状态流程
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clientsCronHandleTimeout&lt;/code&gt;: 检测客户端 idle 时间是否超过设置的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L112&#34;&gt;timeout&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;No timeout for slaves, monitors, masters, blocked and Pub/Sub clients&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientsCronResizeQueryBuffer&lt;/code&gt;: 尝试对客户端缓冲区进行缩容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientsCronTrackExpansiveClients&lt;/code&gt;: 记录客户端输入/输出缓冲区最大值，一段时间后便会 reset 为 $0$，用于在 &lt;code&gt;INFO&lt;/code&gt; 中展示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientsCronTrackClientsMemUsage&lt;/code&gt;: 计算客户端内存占用，用于在 &lt;code&gt;INFO&lt;/code&gt; 中展示
&lt;ul&gt;
&lt;li&gt;服务器客户端的内存统计按客户端的类型进行分类求和，是在多次调用 &lt;code&gt;clientsCron&lt;/code&gt; 完成，因此不是实时数据&lt;/li&gt;
&lt;li&gt;由于客户端类型可能会变化，因此需要记录上次客户端的类型及内存使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行数据库相关定期任务：&lt;code&gt;databasesCron&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清理已过期 key: &lt;code&gt;activeExpireCycle (ACTIVE_EXPIRE_CYCLE_SLOW)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;碎片整理: &lt;code&gt;activeDefragCycle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前无子进程时：
&lt;ul&gt;
&lt;li&gt;缩容：&lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt; 载荷因子小于 $0.1$ 触发&lt;/li&gt;
&lt;li&gt;渐进式 Rehash：若配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L1630&#34;&gt;activerehashing&lt;/a&gt; 为 &lt;code&gt;yes&lt;/code&gt;，且当前数据库正在进行 Rehash，则尝试进行时长为 $1ms$ 的 Rehash 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上述两步均会对 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt; 和 &lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt; 执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行持久化相关操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前无子进程且有 AOF rewrite 需求时，调用 &lt;code&gt;rewriteAppendOnlyFileBackground&lt;/code&gt; 在后台执行 AOF rewrite&lt;/li&gt;
&lt;li&gt;当前有子进程时，检测子进程是否终止&lt;/li&gt;
&lt;li&gt;当前子进程无任务时：
&lt;ul&gt;
&lt;li&gt;根据 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L307&#34;&gt;save&lt;/a&gt; 相关配置项决定当前是否要调用 &lt;code&gt;rdbSaveBackground&lt;/code&gt; 保存数据库状态&lt;/li&gt;
&lt;li&gt;根据配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1159&#34;&gt;auto-aof-rewrite-percentage&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1160&#34;&gt;auto-aof-rewrite-min-size&lt;/a&gt; 决定当前是否要调用 &lt;code&gt;rewriteAppendOnlyFileBackground&lt;/code&gt; 进行 AOF rewrite 以减少 AOF 文件磁盘空间占用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依据当前是否有子进程，调整 Rehash 扩容&lt;a href=&#34;https://k-on.me/post/redis-sourcecode-dict/#dictaddraw&#34;&gt;载荷因子阈值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如此前有推迟的 AOF 落盘任务或 AOF 写入发生错误，则调用 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 将 AOF 缓冲区内容落盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clear the paused clients flag if needed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行主从同步相关定期任务：&lt;code&gt;replicationCron&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若处于 cluster mode，则执行集群相关定期任务：&lt;code&gt;clusterCron&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若处于 sentinel mode，则执行 sentinel 相关定期任务 &lt;code&gt;sentinelTimer&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Others&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cleanup expired MIGRATE cached sockets: &lt;code&gt;migrateCloseTimedoutSockets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Stop the I/O threads if we don&amp;rsquo;t have enough pending work: &lt;code&gt;stopThreadedIOIfNeeded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resize tracking keys table if needed: &lt;code&gt;trackingLimitUsedSlots&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前子进程无任务且有 BGSAVE 需求时，调用 &lt;code&gt;rdbSaveBackground&lt;/code&gt; 在后台执行 BGSAVE&lt;/li&gt;
&lt;li&gt;Fire the cron loop modules event: &lt;code&gt;moduleFireServerEvent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-beforesleep--aftersleep&#34;&gt;2.2. beforeSleep / afterSleep&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;3-请求处理-todo&#34;&gt;3. 请求处理 (TODO)&lt;/h2&gt;
&lt;p&gt;Redis 服务器处理客户端请求时大致经历了以下过程(以监听 TCP 端口且无 TLS 为例)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在服务器初始化时，调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2857&#34;&gt;listenToPort&lt;/a&gt; 监听指定端口，将相应的 scoket FD 存储至 &lt;code&gt;server.ipfd&lt;/code&gt; 数组中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于机器上可能会有多个网卡，因此可通过配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L69&#34;&gt;bind&lt;/a&gt; 绑定指定的网卡接口，若无设置则默认为绑定所有的网卡接口，其数量上限为 &lt;code&gt;CONFIG_BINDADDR_MAX&lt;/code&gt; (16)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 &lt;code&gt;server.ipfd&lt;/code&gt; 数组中的每个 socket FD 调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2951&#34;&gt;aeCreateFileEvent&lt;/a&gt;，为其创建 File Event &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L986&#34;&gt;acceptTcpHandler&lt;/a&gt;，并添加至 event loop &lt;code&gt;server.el&lt;/code&gt; 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L986&#34;&gt;acceptTcpHandler&lt;/a&gt; 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L994&#34;&gt;anetTcpAccept&lt;/a&gt;: 建立连接&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1002&#34;&gt;connCreateAcceptedSocket&lt;/a&gt;: 包装连接 FD 得到结构体 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/connection.h#L73&#34;&gt;connection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L955&#34;&gt;createClient&lt;/a&gt;: 若当前客户端数量不高于 &lt;code&gt;server.maxclients&lt;/code&gt;，则使用 &lt;code&gt;connection&lt;/code&gt; 创建客户端 &lt;code&gt;client&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;code&gt;connection&lt;/code&gt; 非空，则添加事件 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L101&#34;&gt;readQueryFromClient&lt;/a&gt; 至 event loop &lt;code&gt;server.el&lt;/code&gt;，用于读取客户端请求&lt;/li&gt;
&lt;li&gt;初始化客户端 fields&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;connection&lt;/code&gt; 非空，将新建客户端加入服务器的客户端列表 &lt;code&gt;server.clients&lt;/code&gt; 中，便于管理&lt;/li&gt;
&lt;li&gt;Client state initialization for MULTI/EXEC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L975&#34;&gt;connAccept&lt;/a&gt;: Initiate accept, the socket is ready for I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 File event &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1926&#34;&gt;readQueryFromClient&lt;/a&gt; 中，将来自用户的请求内容写入客户端的输入缓冲区 &lt;code&gt;client-&amp;gt;querybuf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将输入缓冲区中的内容解析为 Redis Command，并填充 &lt;code&gt;client-&amp;gt;argv&lt;/code&gt; &amp;amp; &lt;code&gt;client-&amp;gt;argc&lt;/code&gt;: &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1843&#34;&gt;processInputBuffer&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理请求：&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1825&#34;&gt;processCommandAndResetClient&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将回复内容写入客户端输出缓冲区并将当前客户端加入列表 &lt;code&gt;redisServer-&amp;gt;clients_pending_write&lt;/code&gt; 中，后续会遍历该列表中的客户端，将其输出缓冲区内容写至相应的 socket：&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L301&#34;&gt;addReply.*&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进入 event loop 之前 (&lt;code&gt;beforeSleep&lt;/code&gt;)，调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2190&#34;&gt;handleClientsWithPendingWritesUsingThreads&lt;/a&gt;，在该函数中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1440&#34;&gt;writeToClient&lt;/a&gt; 将客户端输出缓冲区的内容同步写入相应的 socket&lt;/li&gt;
&lt;li&gt;若客户端输出缓冲区仍有未写入的内容，则注册写事件 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1456&#34;&gt;sendReplyToClient&lt;/a&gt; 至 event loop，以完成剩余内容的写入&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看出会有同步写入回复至 socket 操作，因此为满足 &amp;ldquo;write the AOF before replying to the client&amp;rdquo; 的条件，在 &lt;code&gt;beforeSleep&lt;/code&gt; 中，&lt;code&gt;handleClientsWithPendingWritesUsingThreads&lt;/code&gt; 的调用应在 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 之后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-客户端管理&#34;&gt;4. 客户端管理&lt;/h2&gt;
&lt;h3 id=&#34;41-新建&#34;&gt;4.1. 新建&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;acceptTcpHandler&lt;/code&gt; (&lt;code&gt;acceptTLSHandler&lt;/code&gt;/&lt;code&gt;acceptUnixHandler&lt;/code&gt;) 中新建连接，当客户端连接数不超过上限 &lt;code&gt;server.maxclients&lt;/code&gt; 时，为该连接创建 &lt;code&gt;client&lt;/code&gt; 结构体并加入 &lt;code&gt;server.clients&lt;/code&gt; 中。&lt;/p&gt;
&lt;h3 id=&#34;42-释放&#34;&gt;4.2. 释放&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同步释放：直接调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1134&#34;&gt;freeClient&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;异步释放：调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1258&#34;&gt;freeClientAsync&lt;/a&gt; 将客户端加入待释放列表 &lt;code&gt;server.clients_to_close&lt;/code&gt;，随后在 &lt;code&gt;beforeSleep&lt;/code&gt; 中调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1279&#34;&gt;freeClientsInAsyncFreeQueue&lt;/a&gt; 释放列表 &lt;code&gt;server.clients_to_close&lt;/code&gt; 中的客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-缓冲区管理&#34;&gt;5. 缓冲区管理&lt;/h2&gt;
&lt;h3 id=&#34;51-输入缓冲区&#34;&gt;5.1. 输入缓冲区&lt;/h3&gt;
&lt;p&gt;客户端使用 sds string &lt;code&gt;client-&amp;gt;querybuf&lt;/code&gt; 作为输入缓冲区&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩容：在 &lt;code&gt;readQueryFromClient&lt;/code&gt; 中，为了存放用户的请求内容，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1957&#34;&gt;sdsMakeRoomFor&lt;/a&gt; 对输入缓冲区扩容&lt;/li&gt;
&lt;li&gt;限制：在扩容并读取内容后，若此时输入缓冲区中字符串长度大于 &lt;code&gt;server.client_max_querybuf_len&lt;/code&gt;，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1990&#34;&gt;freeClientAsync&lt;/a&gt; 异步释放该客户端。其中 &lt;code&gt;server.client_max_querybuf_len&lt;/code&gt; 可由配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1666&#34;&gt;client-query-buffer-limit&lt;/a&gt; 进行设置&lt;/li&gt;
&lt;li&gt;缩容：在定期执行的 &lt;code&gt;serverCron&lt;/code&gt; 中，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L1521&#34;&gt;clientsCronResizeQueryBuffer&lt;/a&gt; 对输入缓冲区进行适当地缩容操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若客户端为 master，则还会使用 &lt;code&gt;client-&amp;gt;pending_querybuf&lt;/code&gt; 存储尚未执行完毕的请求，其同样在 &lt;code&gt;readQueryFromClient&lt;/code&gt; 中扩容，在 &lt;code&gt;clientsCronResizeQueryBuffer&lt;/code&gt; 中缩容。&lt;/p&gt;
&lt;h3 id=&#34;52-输出缓冲区&#34;&gt;5.2. 输出缓冲区&lt;/h3&gt;
&lt;p&gt;客户端的输出缓冲区分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小固定为 &lt;code&gt;PROTO_REPLY_CHUNK_BYTES&lt;/code&gt;(16KB) 大小的字符数组 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L868&#34;&gt;client-&amp;gt;buf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;由 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L650&#34;&gt;clientReplyBlock&lt;/a&gt; 组成的 reply 链表 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L807&#34;&gt;client-&amp;gt;reply&lt;/a&gt;，每个链表节点容量最小为 &lt;code&gt;PROTO_REPLY_CHUNK_BYTES&lt;/code&gt;(16KB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在将回复写入输出缓冲区时:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会先调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L248&#34;&gt;_addReplyToBuffer&lt;/a&gt; 尝试将回复内容写入 &lt;code&gt;client-&amp;gt;buf&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;若数组剩余空间不足，则会选择调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L265&#34;&gt;_addReplyProtoToList&lt;/a&gt; 将回复内容写入 &lt;code&gt;client-&amp;gt;reply&lt;/code&gt;，写入回复内容后会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L2742&#34;&gt;checkClientOutputBufferLimits&lt;/a&gt; 检查 &lt;code&gt;client-&amp;gt;reply&lt;/code&gt; 使用内存大小是否超出设定的上限，若超上限则会调用 &lt;code&gt;freeClientAsync&lt;/code&gt; 异步释放该客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出缓冲区大小(实际上只计算 &lt;code&gt;client-&amp;gt;reply&lt;/code&gt;，而不包含 16KB 的定长字符数组)的限制可由配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1656&#34;&gt;client-output-buffer-limit&lt;/a&gt; 进行设置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以为三种客户端分别进行设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;normal&lt;/code&gt;: normal clients including MONITOR clients&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replica&lt;/code&gt;: replica clients&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pubsub&lt;/code&gt;: clients subscribed to at least one pubsub channel or pattern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 &lt;code&gt;client-&amp;gt;reply&lt;/code&gt; 内存使用量达到 hard limit，或保持在 soft limit 超过 soft seconds 时，会调用 &lt;code&gt;freeClientAsync&lt;/code&gt; 异步释放该客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于 &lt;code&gt;normal&lt;/code&gt; 客户端属于 &amp;ldquo;pull&amp;rdquo; 方式拉取数据，因此默认不设置上限，而 &lt;code&gt;replica&lt;/code&gt; 和 &lt;code&gt;pubsub&lt;/code&gt; 客户端属于 &amp;ldquo;push&amp;rdquo; 方式推送数据至指定的 replicas 或 subscribers，未防止对方消费速度低于生产速度，因此默认会设置上限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-解析请求---resp&#34;&gt;6. 解析请求 - RESP&lt;/h2&gt;
&lt;p&gt;Redis 使用 RESP 协议进行 client-server 通信，可阅读 &lt;a href=&#34;https://redis.io/topics/protocol&#34;&gt;Redis Protocol specification&lt;/a&gt; 了解详情。&lt;/p&gt;
&lt;p&gt;在 RESP 中，主要分为以下几种数据类型，每种数据类型编码的终止符均为 &lt;code&gt;\r\n&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Encoding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Simple Strings&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;+[content]\r\n&lt;/code&gt; (non binary safe strings)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Errors&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;-[err-type][err-msg]\r\n&lt;/code&gt; (non binary safe)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Integers&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;:[integer]\r\n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bulk Strings&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;$[length]\r\n[content]\r\n&lt;/code&gt; (binary safe, $\le 512MB$)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Null Bulk String -&amp;gt; &lt;code&gt;$-1\r\n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Arrays&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;*[array-count]\r\n&amp;lt;other-data-type&amp;gt;...&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Null Array -&amp;gt; &lt;code&gt;*-1\r\n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Can contain mixed types, include Null Bulk String &amp;amp; Arrays&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上述介绍的协议其实为 RESP2，新版本 RESP3 的介绍可阅读 &lt;a href=&#34;https://github.com/antirez/RESP3/blob/master/spec.md&#34;&gt;RESP3 specification&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;客户端请求通常为两种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PROTO_REQ_MULTIBULK&lt;/code&gt;: a RESP Array consisting of just Bulk Strings&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROTO_REQ_INLINE&lt;/code&gt;: inline command, space-separated arguments without encoding&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1843&#34;&gt;processInputBuffer&lt;/a&gt; 中解析客户端输入缓冲区的内容为完整的 Redis command 后将其填充至 &lt;code&gt;client-&amp;gt;argv&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;7-处理请求&#34;&gt;7. 处理请求&lt;/h2&gt;
&lt;p&gt;在解析完一条完整的 Redis command 并将其填充至 &lt;code&gt;client-&amp;gt;argv&lt;/code&gt; 后，Redis 会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1910&#34;&gt;processCommandAndResetClient&lt;/a&gt; 来处理该请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其首先调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1828&#34;&gt;processCommand&lt;/a&gt; 处理请求，当请求处理完毕后，调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/networking.c#L1829&#34;&gt;commandProcessed&lt;/a&gt; 更新客户端相关状态。&lt;/li&gt;
&lt;li&gt;当在处理请求过程中客户端被 free 时，该函数返回 &lt;code&gt;C_ERR&lt;/code&gt;，否则返回 &lt;code&gt;C_OK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;71-rediscommand&#34;&gt;7.1. redisCommand&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L1480&#34;&gt;redisCommand&lt;/a&gt; 结构体的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisCommand&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;redisCommandProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sflags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;redisGetKeysProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getkeys_proc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstkey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastkey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keystep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;microseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;: A string representing the command name.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;proc&lt;/code&gt;: Pointer to the C function implementing the command, the function prototype is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;redisCommandProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arity&lt;/code&gt;: Number of arguments, it is possible to use -N to say &amp;gt;= N&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sflags&lt;/code&gt;: Command flags as string. 详情可阅读 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L113&#34;&gt;the meaning of the flags&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt;: Flags as bitmask. Computed by Redis using the &amp;lsquo;sflags&amp;rsquo; field: &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3027&#34;&gt;populateCommandTableParseFlags&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getkeys_proc&lt;/code&gt;: An optional function to get key arguments from a command. This is only used when the following three fields are not enough to specify what arguments are keys. the function prototype is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;redisGetKeysProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisCommand&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                              &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numkeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;firstkey&lt;/code&gt;: First argument that is a key (0 = no keys)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lastkey&lt;/code&gt;: Last argument that is a key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;keystep&lt;/code&gt;: Step to get all the keys from first to last argument. For instance in &lt;code&gt;MSET&lt;/code&gt; the step is two since arguments are key,val,key,val,&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;microseconds&lt;/code&gt;: Microseconds of total execution time for this command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;calls&lt;/code&gt;: Total number of calls of this command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;: Command bit identifier for ACLs or other goals.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中, &lt;code&gt;flags&lt;/code&gt;、&lt;code&gt;microseconds&lt;/code&gt; 和 &lt;code&gt;calls&lt;/code&gt; 由 Redis 自身计算填充，初始时均设为 0 即可。&lt;/p&gt;
&lt;p&gt;在 Redis server 初始化时，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2428&#34;&gt;populateCommandTable&lt;/a&gt; 使用全局变量 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L182&#34;&gt;redisCommandTable&lt;/a&gt; 填充 &lt;code&gt;server.commands&lt;/code&gt; 和 &lt;code&gt;server.orig_commands&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;72-processcommand&#34;&gt;7.2. processCommand&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;processCommand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3507&#34;&gt;processCommand&lt;/a&gt; 函数的处理流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;moduleCallCommandFilters&lt;/code&gt; 将原 Redis Command 替换成在 module 中想要替换的 Redis Command&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;handle &lt;code&gt;QUIT&lt;/code&gt; command&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 command name 从 &lt;code&gt;server.commands&lt;/code&gt; 中查找相应的 &lt;code&gt;redisCommand&lt;/code&gt;，并验证 &lt;code&gt;client-&amp;gt;argc&lt;/code&gt; 的有效性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check if the user is authenticated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check if the user can run this command according to the current ACLs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If cluster is enabled perform the cluster redirection here. However we don&amp;rsquo;t perform the redirection if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The sender of this command is our master.&lt;/li&gt;
&lt;li&gt;The command has no key arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;freeMemoryIfNeededAndSafe&lt;/code&gt; 检查当前内存使用情况，以满足 &lt;code&gt;server.maxmemory&lt;/code&gt; 的限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果当前有执行超时的 lua 脚本时，为了不混淆 lua 脚本运行时和驱逐键时传播出的 &lt;code&gt;DEL&lt;/code&gt; 命令，因此不会检查内存使用情况&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;freeMemoryIfNeededAndSafe&lt;/code&gt; 中，如果当前有执行超时的 lua 脚本，或者正在 loading data 时，不会释放内存，直接返回 &lt;code&gt;C_OK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make sure to use a reasonable amount of memory for client side caching metadata.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t accept write commands if there are problems(AOF/RDB errors) persisting on disk and if this is a master instance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当主从复制延迟小于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L595&#34;&gt;min-replicas-max-lag&lt;/a&gt; 的从库数量小于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L594&#34;&gt;min-replicas-to-write&lt;/a&gt; 时，阻止写命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当实例为只读从库时，检测写命令是否来自 master，若不为真，则拒绝该写命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only allow a subset of commands in the context of Pub/Sub if the connection is in RESP2 mode. With RESP3 there are no limits.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only allow commands with flag &amp;ldquo;t&amp;rdquo;, such as INFO, SLAVEOF and so on, when &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L421&#34;&gt;replica-serve-stale-data&lt;/a&gt; is &lt;code&gt;no&lt;/code&gt; and we are a slave with a broken link with master.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loading DB? Return an error if the command has not the CMD_LOADING flag.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lua script too slow? Only allow a limited number of commands.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行该命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若在 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 上下文中，则将命令加入数组 &lt;code&gt;client-&amp;gt;mstate.commands&lt;/code&gt; 中，返回 &lt;code&gt;+QUEUED\r\n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则，调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3750&#34;&gt;call(c, CMD_CALL_FULL)&lt;/a&gt; 处理该请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;721-call&#34;&gt;7.2.1. call&lt;/h4&gt;
&lt;p&gt;The prototype of &lt;code&gt;call&lt;/code&gt; is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;flags&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_NONE&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;No flags&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_SLOWLOG&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Check command speed and log in the slowlog if needed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_STATS&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Populate command stats&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_PROPAGATE_AOF&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Append command to AOF if it modified the dataset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;or if the client flags are forcing propagation.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_PROPAGATE_REPL&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Send command to slaves if it modified the dataset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;or if the client flags are forcing propagation.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_PROPAGATE&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Alias for PROPAGATE_AOF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_FULL&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Alias for SLOWLOG&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;CMD_CALL_NOWRAP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Don&amp;rsquo;t wrap also propagate array into MULTI/EXEC:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;the caller will handle it.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;call&lt;/code&gt; 时，如果设置了 &lt;code&gt;CMD_CALL_PROPAGATE_AOF&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;若客户端设置了 &lt;code&gt;CLIENT_FORCE_AOF&lt;/code&gt;，则即使该命令不改变 dataset 也会传播&lt;/li&gt;
&lt;li&gt;若客户端设置了 &lt;code&gt;CLIENT_PREVENT_AOF_PROP&lt;/code&gt;，则即使该命令改变 dataset 也不会传播&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;call&lt;/code&gt; 时，如果未设置 &lt;code&gt;CMD_CALL_PROPAGATE_AOF&lt;/code&gt;，则无论客户端设置何种标识，该命令也不会传播&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CMD_CALL_PROPAGATE_REPL&lt;/code&gt; 同理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该函数的处理流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;server.fixed_time_expire++&lt;/code&gt;: 表示当前正在处理请求 &lt;code&gt;call&lt;/code&gt; 上下文中，当判断 key 是否过期时，会使用缓存的 &lt;code&gt;server.mstime&lt;/code&gt;(调用请求处理函数 &lt;code&gt;redisCommand-&amp;gt;proc&lt;/code&gt; 前更新) 作为当前时间，这样做是为了防止在处理请求多次访问同一 key 时，该 key 可能中途过期造成不一致的现象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Send the command to clients in MONITOR mode if applicable. Administrative commands are considered too dangerous to be shown.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 &lt;code&gt;call()&lt;/code&gt; 可能会递归调用，因此在调用 &lt;code&gt;redisCommand-&amp;gt;proc&lt;/code&gt; 前需要做以下准备工作，以在调用请求处理函数后相关状态可以恢复至调用前的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;client_old_flags&lt;/code&gt; 存储此时的 &lt;code&gt;client-&amp;gt;flags&lt;/code&gt;，随后清除命令传播相关标志位：&lt;code&gt;CLIENT_FORCE_AOF&lt;/code&gt;, &lt;code&gt;CLIENT_FORCE_REPL&lt;/code&gt;, &amp;amp; &lt;code&gt;CLIENT_PREVENT_PROP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;prev_also_propagate&lt;/code&gt; 存储此时的 &lt;code&gt;server.also_propagate&lt;/code&gt;，随后将其初始化为空值&lt;/li&gt;
&lt;li&gt;记录此时的数据库状态 &lt;code&gt;server.dirty&lt;/code&gt; 和时间 &lt;code&gt;server.ustime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3334&#34;&gt;redisCommand-&amp;gt;proc&lt;/a&gt; 处理该请求，可能会修改 &lt;code&gt;client-&amp;gt;flags&lt;/code&gt; 和 &lt;code&gt;server.also_propagate&lt;/code&gt;，因此需要存储调用该函数之前的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按需记录慢日志，更新 Redis Command 相关状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3400&#34;&gt;propagate&lt;/a&gt; 将命令传播至 AOF 和 replications，决定是否传播由 dataset 是否有变化和相关 flags 决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求相关 flags &lt;code&gt;CMD_CALL_PROPAGATE&lt;/code&gt; 是必要不充分条件&lt;/li&gt;
&lt;li&gt;客户端相关 flags &lt;code&gt;CLIENT_FORCE_(AOF|REPL)&lt;/code&gt; 或 &lt;code&gt;CLIENT_PREVENT_(AOF|REPL)_PROP&lt;/code&gt; 是强制条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;client_old_flags&lt;/code&gt; 将 &lt;code&gt;client-&amp;gt;flags&lt;/code&gt; 恢复至调用 &lt;code&gt;redisCommand-&amp;gt;proc&lt;/code&gt; 前的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输 &lt;code&gt;server.also_propagate&lt;/code&gt; 中的请求至 AOF 和 replications。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在处理请求时，可能会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3229&#34;&gt;alsoPropagate&lt;/a&gt; 将想要额外传播的请求加入 &lt;code&gt;server.also_propagate&lt;/code&gt; 数组中&lt;/li&gt;
&lt;li&gt;只需请求相关 flags 决定是否传播，不受客户端 flags 影响，因此这一步在第 6 步之后没问题&lt;/li&gt;
&lt;li&gt;传递多条请求时，会使用 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 上下文包装，以保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;prev_also_propagate&lt;/code&gt; 将 &lt;code&gt;server.also_propagate&lt;/code&gt; 恢复至调用 &lt;code&gt;redisCommand-&amp;gt;proc&lt;/code&gt; 前的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the client has keys tracking enabled for client side caching, make sure to remember the keys it fetched via this command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;server.fixed_time_expire--&lt;/code&gt;: 离开 &lt;code&gt;call&lt;/code&gt; 上下文&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;722-propagate&#34;&gt;7.2.2. propagate&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Propagate the specified command (in the context of the specified database id)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * to AOF and Slaves. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;propagate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisCommand&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
               &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;flags&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;PROPAGATE_NONE&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;no propagation of command at all&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;PROPAGATE_AOF&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;propagate into the AOF file if is enabled&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;PROPAGATE_REPL&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;propagate into the replication link&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/aof.c#L584&#34;&gt;feedAppendOnlyFile&lt;/a&gt; 将命令写至 AOF&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/replication.c#L208&#34;&gt;replicationFeedSlaves&lt;/a&gt; 将命令写至 replications&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;73-commandprocessed&#34;&gt;7.3. commandProcessed&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Perform necessary tasks after a command was executed:
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 1. The client is reset unless there are reasons to avoid doing it.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 2. In the case of master clients, the replication offset is updated.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 3. Propagate commands we got from our master to replicas down the line. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;commandProcessed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- ae</title>
      <link>https://k-on.me/post/redis-sourcecode-ae/</link>
      <pubDate>Sat, 24 Oct 2020 16:01:48 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-ae/</guid>
      
        <description>&lt;p&gt;Redis event loop 相关源码阅读笔记，源码文件 &lt;code&gt;ae.h&lt;/code&gt; &amp;amp; &lt;code&gt;ae.c&lt;/code&gt; &amp;amp; &lt;code&gt;ae_epoll.c&lt;/code&gt; &amp;amp; &lt;code&gt;ae_evport.c&lt;/code&gt; &amp;amp; &lt;code&gt;ae_kqueue.c&lt;/code&gt; &amp;amp; &lt;code&gt;ae_select.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Redis 会按序处理各个已触发的事件，无抢占&lt;/li&gt;
&lt;li&gt;因为 Redis 在处理时间事件之前，会先处理文件事件，所以时间事件的处理时间通常比设定值晚一些&lt;/li&gt;
&lt;li&gt;文件事件的 &lt;code&gt;AE_BARRIER&lt;/code&gt; 和时间事件的 &lt;code&gt;refcount&lt;/code&gt; 这两种特性，在 Redis 目前的实现中尚未使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环遍历链表时，如果需要删除链表节点，可以使用标记删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-数据结构&#34;&gt;2. 数据结构&lt;/h2&gt;
&lt;h3 id=&#34;21-文件事件&#34;&gt;2.1. 文件事件&lt;/h3&gt;
&lt;p&gt;Redis 的文件事件的数据结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* File event structure */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeFileEvent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* one of AE_(READABLE|WRITABLE|BARRIER) */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeFileProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rfileProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeFileProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wfileProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clientData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeFileEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mask&lt;/code&gt;: 文件事件的类型，可为以下几种叠加&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AE_NONE&lt;/code&gt;: 初始值，未注册读写事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AE_READABLE&lt;/code&gt;: 读事件，监听 fd 是否可读&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AE_WRITABLE&lt;/code&gt;: 写事件，监听 fd 是否可写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AE_BARRIER&lt;/code&gt;: 用于 fd 同时可读写时，控制读写处理的顺序
&lt;ul&gt;
&lt;li&gt;同一个 fd 可同时读写时，一般我们会先处理读事件，这样利于我们在处理完一个查询操作后立马返回查询结果&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;AE_BARRIER&lt;/code&gt; 被设置时，我们会先处理写事件，再处理读事件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;按照 &lt;a href=&#34;https://github.com/redis/redis/issues/7098#issuecomment-614435928&#34;&gt;issues/7098&lt;/a&gt; 所述，且查看代码后，发现目前 Redis 好像没用到 &lt;code&gt;AE_BARRIER&lt;/code&gt; 特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rfileProc&lt;/code&gt;: 读事件处理函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wfileProc&lt;/code&gt;: 写事件处理函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;clientData&lt;/code&gt;: 在 &lt;code&gt;rfileProc&lt;/code&gt;/&lt;code&gt;wfileProc&lt;/code&gt; 中可能会用到的数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fired file event 结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* A fired event */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeFiredEvent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* file descriptor */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* same with aeFileEvent*/&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeFiredEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;22-时间事件&#34;&gt;2.2. 时间事件&lt;/h3&gt;
&lt;p&gt;Redis 的时间事件的数据结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Time event structure */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeTimeEvent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* time event identifier. */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;when_sec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* seconds */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;when_ms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* milliseconds */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeTimeProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timeProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeEventFinalizerProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalizerProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clientData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeTimeEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeTimeEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* refcount to prevent timer events from being
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                    * freed in recursive time event calls. */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeTimeEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;: 时间事件的 ID，单调递增，即新产生的时间事件 ID 大于已有时间事件的 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;when_sec&lt;/code&gt; + &lt;code&gt;when_ms&lt;/code&gt;：时间点，记录时间事件触发的时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeProc&lt;/code&gt;：时间事件处理函数，当前时间不小于 &amp;lt;&lt;code&gt;when_sec&lt;/code&gt;, &lt;code&gt;when_ms&lt;/code&gt;&amp;gt; pair 时需调用 &lt;code&gt;timeProc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finalizerProc&lt;/code&gt;: 时间事件终结处理函数，删除时间事件时调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientData&lt;/code&gt;: 在 &lt;code&gt;timeProc&lt;/code&gt;/&lt;code&gt;finalizerProc&lt;/code&gt; 中可能会用到的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prev&lt;/code&gt; / &lt;code&gt;next&lt;/code&gt;: 分别指向前/后一个时间事件，在 event loop 中时间事件为双向链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refcount&lt;/code&gt;: 引用计数，防止递归调用 &lt;code&gt;processTimeEvents&lt;/code&gt; 时，时间事件被释放
&lt;blockquote&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://github.com/redis/redis/pull/7253&#34;&gt;pull/7253&lt;/a&gt;，Redis 现有实现无递归调用 &lt;code&gt;processTimeEvents&lt;/code&gt; 的 case&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-event-loop&#34;&gt;2.3. Event loop&lt;/h3&gt;
&lt;p&gt;Redis 的 event loop 的数据结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* State of an event based program */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* highest file descriptor currently registered */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;setsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* max number of file descriptors tracked */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeEventNextId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;time_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* Used to detect system clock skew */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeFileEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Registered events */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeFiredEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fired&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Fired events */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeTimeEvent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timeEventHead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;apidata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* This is used for polling API specific data */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeBeforeSleepProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beforesleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;aeBeforeSleepProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aftersleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;maxfd&lt;/code&gt;: 注册至 event loop 中的文件事件的最大 fd，其值不超过 &lt;code&gt;setsize&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;setsize&lt;/code&gt;: event loop 中可容纳的文件事件数量上限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;event&lt;/code&gt;：event loop 中文件事件按照数组形式保存，其长度为 &lt;code&gt;setsize&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未注册部分 &lt;code&gt;aeFileEvent-&amp;gt;mask&lt;/code&gt; 为 &lt;code&gt;AE_NONE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fired&lt;/code&gt;: Fired file event 数组，长度同样为 &lt;code&gt;setsize&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apidata&lt;/code&gt;: used for polling API specific data，记录 polling API 的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis 的 ae 包装了不同的 I/O 多路复用函数库，在编译时会按照选择系统中性能最佳的函数库，顺序为 &lt;code&gt;ae_evport&lt;/code&gt; -&amp;gt; &lt;code&gt;ae_epoll&lt;/code&gt; -&amp;gt; &lt;code&gt;ae_kqueue.c&lt;/code&gt; -&amp;gt; &lt;code&gt;ae_select.c&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用 Linux 的 &lt;code&gt;epoll&lt;/code&gt; 时，&lt;code&gt;apidata&lt;/code&gt; 存储的内容为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aeApiState&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeApiState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;timeEventHead&lt;/code&gt;: event loop 中时间事件头节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;timeEventNextId&lt;/code&gt;：已注册的时间事件的 ID 最大值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次调用 &lt;code&gt;aeCreateTimeEvent&lt;/code&gt; 注册时间事件时加 1&lt;/li&gt;
&lt;li&gt;Use: Make sure we don&amp;rsquo;t process time events created by time events in this iteration&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不过在目前的实现中这个 check 是多余的，因为新增的时间事件添加在时间事件链表头部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lastTime&lt;/code&gt;：记录 event loop 上次调用 &lt;code&gt;processTimeEvents&lt;/code&gt; 的时间戳&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当发生时钟跳变时，为了不推迟时间事件的触发执行，将所有时间事件的 &lt;code&gt;when_sec&lt;/code&gt; 设置为 0，即立马处理该事件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因为在 Redis 中其实只会注册一个时间事件 &lt;code&gt;serverCron&lt;/code&gt;，所以问题不大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stop&lt;/code&gt;: 值不为 0 时，停止轮询处理事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforesleep&lt;/code&gt;: 调用 &lt;code&gt;epoll_wait&lt;/code&gt; 前可能会调用的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;aftersleep&lt;/code&gt;: 调用 &lt;code&gt;epoll_wait&lt;/code&gt; 后可能会调用的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt;: 值可以设置为 &lt;code&gt;AE_DONT_WAIT&lt;/code&gt;，表示调用 &lt;code&gt;epoll_wait&lt;/code&gt; 时 timeout 为 0 ，即不等待&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-api&#34;&gt;3. API&lt;/h2&gt;
&lt;h3 id=&#34;31-文件事件&#34;&gt;3.1. 文件事件&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a file evet and add to event loop */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeCreateFileEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;aeFileProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clientData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete the file event specified by fd */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeDeleteFileEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Get the file event specified by fd */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeGetFileEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，在添加/删除文件事件时，不仅会修改文件事件数组 &lt;code&gt;aeEventLoop-&amp;gt;events&lt;/code&gt;，而且也会修改 &lt;code&gt;aeEventLoop-&amp;gt;apidata&lt;/code&gt;，即 polling api state.&lt;/p&gt;
&lt;h3 id=&#34;32-时间事件&#34;&gt;3.2. 时间事件&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a time event and add to event loop */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeCreateTimeEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;aeTimeProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;proc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clientData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;aeEventFinalizerProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalizerProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete a time event specified by id */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeDeleteTimeEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在添加时间事件时，&lt;code&gt;milliseconds&lt;/code&gt; 指的是时间间隔&lt;/li&gt;
&lt;li&gt;在删除时间事件时，并不会真的从时间事件链表中删除该节点，而是将其 &lt;code&gt;id&lt;/code&gt; 标记为 &lt;code&gt;AE_DELETED_EVENT_ID&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;真正的删除操作在 &lt;code&gt;processTimeEvents&lt;/code&gt; 中实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-event-loop&#34;&gt;3.3. Event loop&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Process time events */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;processTimeEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先依据 &lt;code&gt;aeEventLoop-&amp;gt;lastTime&lt;/code&gt; 值判断是否发生了时钟跳变，若为真，则将所有时间事件设置为立马触发执行&lt;/li&gt;
&lt;li&gt;从前往后遍历时间事件链表，执行已触发的时间事件
&lt;ul&gt;
&lt;li&gt;首先判断时间事件是否已被标记为删除，若为真，则从链表中删除该时间事件并释放内存空间&lt;/li&gt;
&lt;li&gt;在执行完时间事件处理函数后，依据返回值决定是否将该时间事件标记为删除
&lt;ul&gt;
&lt;li&gt;返回值为 &lt;code&gt;AE_NOMORE&lt;/code&gt;(-1)，表示该时间事件是个定时事件，执行一次后可删除，故标记为 &lt;code&gt;AE_DELETED_EVENT_ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回值为其他值时，表示该时间事件为定期事件，返回值为执行时间间隔，故利用返回值更新 &lt;code&gt;when_sec&lt;/code&gt; &amp;amp; &lt;code&gt;when_ms&lt;/code&gt;，即下次触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回处理的时间事件数量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;：循环遍历链表时，如果需要删除链表节点，可以使用标记删除。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Process every pending time event, then every pending file event */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeProcessEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;形参 &lt;code&gt;flags&lt;/code&gt; 的取值可为以下几种叠加：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Flags&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$0$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;啥都不干，立马返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_ALL_EVENTS&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;执行已触发的文件事件和时间事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_FILE_EVENTS&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;执行已触发的文件事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_TIME_EVENTS&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;执行已触发的时间事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_DONT_WAIT&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用 &lt;code&gt;epoll_wait&lt;/code&gt; 时，timeout 设置为 $0$，不等待&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_CALL_BEFORE_SLEEP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用 &lt;code&gt;epoll_wait&lt;/code&gt; 前调用 beforesleep 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;AE_CALL_AFTER_SLEEP&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调用 &lt;code&gt;epoll_wait&lt;/code&gt; 返回后调用 aftersleep 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;函数执行流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 &lt;code&gt;flags&lt;/code&gt; 的设置决定调用 &lt;code&gt;epoll_wait&lt;/code&gt; 的 timeout 值
&lt;ul&gt;
&lt;li&gt;timeout 为 $0$：最近将触发的时间事件时间戳不大于当前时间戳或 &lt;code&gt;AE_DONT_WAIT&lt;/code&gt; 被设置&lt;/li&gt;
&lt;li&gt;timeout 大于 $0$：最近将触发的时间事件时间戳大于当前时间戳且未设置 &lt;code&gt;AE_DONT_WAIT&lt;/code&gt;，则 timeout 为两者差值&lt;/li&gt;
&lt;li&gt;timeout 为 $-1$：不处理时间事件或时间事件链表为空且未设置 &lt;code&gt;AE_DONT_WAIT&lt;/code&gt;，则 timeout 为 $-1$，即一直等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;aeEventLoop-&amp;gt;beforesleep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;epoll_wait&lt;/code&gt; 检查已触发的文件事件&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;aeEventLoop-&amp;gt;aftersleep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;处理已触发的文件事件
&lt;ul&gt;
&lt;li&gt;同一个 fd 可同时读写时，一般先处理读事件，当 &lt;code&gt;AE_BARRIER&lt;/code&gt; 被设置时，会先处理写事件，再处理读事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;processTimeEvents&lt;/code&gt; 处理时间事件&lt;/li&gt;
&lt;li&gt;返回处理的文件事件和时间事件数量之和&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeMain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;aeProcessEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AE_ALL_EVENTS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
                                   &lt;span class=&#34;n&#34;&gt;AE_CALL_BEFORE_SLEEP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
                                   &lt;span class=&#34;n&#34;&gt;AE_CALL_AFTER_SLEEP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事件循环主函数，会尝试同时处理文件事件和时间事件，且在调用 &lt;code&gt;epoll_wait&lt;/code&gt; 前后会分别调用已设置的 &lt;code&gt;aeEventLoop-&amp;gt;beforesleep&lt;/code&gt; 和 &lt;code&gt;aeEventLoop-&amp;gt;aftersleep&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a event loop and initialize */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;aeCreateEventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;setsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete a event loop and free */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeDeleteEventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* set aeEventLoop-&amp;gt;stop = 1 */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Call `poll` to wait for milliseconds until 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * the given file descriptor becomes writable/readable/exception */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;milliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Return the name of the multiplexing layer currently in use */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;aeGetApiName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Setup the before sleep process */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeSetBeforeSleepProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeBeforeSleepProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;beforesleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Setup the after sleep process */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeSetAfterSleepProc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aeBeforeSleepProc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aftersleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Return the current set size */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeGetSetSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Resize the maximum set size of the event loop. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeResizeSetSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;setsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Change aeEventLoop-&amp;gt;flags
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Tells the next iteration/s of the event processing to set timeout of 0 */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;aeSetDontWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aeEventLoop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventLoop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- 持久化</title>
      <link>https://k-on.me/post/redis-sourcecode-persistence/</link>
      <pubDate>Tue, 20 Oct 2020 20:43:16 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-persistence/</guid>
      
        <description>&lt;p&gt;Redis 持久化相关源码阅读笔记，源码文件 &lt;code&gt;rdb.h&lt;/code&gt; &amp;amp; &lt;code&gt;rdb.c&lt;/code&gt; &amp;amp; &lt;code&gt;aof.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Redis 提供两种持久化方式供选择：RDB 和 AOF，其详细介绍可阅读 &lt;a href=&#34;https://redis.io/topics/persistence&#34;&gt;Redis Persistence&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1-rdb&#34;&gt;1. RDB&lt;/h2&gt;
&lt;p&gt;RDB 为数据集在某一时间点的 snapshot，可通过 &lt;a href=&#34;https://redis.io/commands/bgsave&#34;&gt;BGSAVE&lt;/a&gt; 或 &lt;a href=&#34;https://redis.io/commands/save&#34;&gt;SAVE&lt;/a&gt; 命令主动触发，也同通过配置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L287&#34;&gt;save&lt;/a&gt; 相关参数&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L1985&#34;&gt;被动触发&lt;/a&gt;达到备份数据的目的。除此之外，Redis 的&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/replication.c#L638&#34;&gt;主从全量同步&lt;/a&gt;时也会生成 rdb 文件以供同步使用。&lt;/p&gt;
&lt;h3 id=&#34;11-rdb-编码格式&#34;&gt;1.1. RDB 编码格式&lt;/h3&gt;
&lt;p&gt;在 RDB 文件中，每种数据类型都会按照 &lt;code&gt;&amp;lt;type&amp;gt; &amp;lt;len&amp;gt; &amp;lt;data&amp;gt;&lt;/code&gt; 的顺序编码，当 &lt;code&gt;type&lt;/code&gt; 为某些类型时，会省略 &lt;code&gt;data&lt;/code&gt; 字段。&lt;code&gt;type&lt;/code&gt; 字段长度固定为 1 byte (0-255)，值得注意的是，其不仅涵盖不同的数据对象类型，还包含多种 RDB opcodes。这些 RDB opcodes 类型用于在编码(解码)时存储(加载)除了数据对象内容外的额外信息，以备份(恢复)数据库的完整状态。&lt;/p&gt;
&lt;h4 id=&#34;111-object-types&#34;&gt;1.1.1. Object types&lt;/h4&gt;
&lt;p&gt;从 &lt;code&gt;rdbSaveObjectType&lt;/code&gt; 函数中我们可以知道不同的数据对象类型与 RDB type 的对应关系如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;robj-&amp;gt;type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;robj-&amp;gt;encoding&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_STRING&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_STRING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_QUICKLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_LIST_QUICKLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_SET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_INTSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_SET_INTSET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_HT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_SET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ZSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_ZSET_ZIPLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_ZSET_2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_HASH&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_HASH_ZIPLIST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_HT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_HASH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_STREAM&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_STREAM_LISTPACKS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_MODULE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_MODULE_2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;RDB_TYPE_ZSET&lt;/code&gt; 和 &lt;code&gt;RDB_TYPE_MODULE&lt;/code&gt; 目前在编码时已不再使用，仅供解码时使用，以便能兼容之前版本的 RDB。容易看出高版本的 Redis 可以解码低版本的 RDB 文件，而低版本的 Redis 不可解码高版本的 RDB 文件。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;rdbSaveKeyValuePair&lt;/code&gt; 函数中我们可以看到，在存储数据对象内容时会按照 &lt;code&gt;&amp;lt;RDB type&amp;gt; &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 的顺序排布，其中 &lt;code&gt;key&lt;/code&gt; 和字符串对象值的存储格式一致，均调用 &lt;code&gt;rdbSaveStringObject&lt;/code&gt; 进行存储。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;rdbSaveObject&lt;/code&gt; 中我们可以发现 &lt;code&gt;value&lt;/code&gt; 的存储格式与数据对象的类型(RDB type)有关，其对应关系如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB content (不考虑压缩)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_STRING&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;len&amp;gt; [data]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_LIST_QUICKLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;ql-&amp;gt;len&amp;gt; &amp;lt;zlbytes&amp;gt; [zdata] ......&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_SET_INTSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;intsetBytes&amp;gt; [intset.data]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_SET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;dictSize&amp;gt; &amp;lt;ele.len&amp;gt; [ele.data] ......&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_ZSET_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;zlbytes&amp;gt; [zdata]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_ZSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;兼容旧版 RDB，已弃用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_ZSET_2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;zsl-&amp;gt;length&amp;gt; &amp;lt;member.len&amp;gt; [member.data] &amp;lt;score&amp;gt; ......&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_HASH_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;zlbytes&amp;gt; [zdata]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_HASH&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;&amp;lt;dictSize&amp;gt; &amp;lt;field.len&amp;gt; [field.data] &amp;lt;value.len&amp;gt; [value.data] ......&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_STREAM_LISTPACKS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TODO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_MODULE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;兼容旧版 RDB，已弃用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_TYPE_MODULE_2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TODO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 表示该项必定存在，&lt;code&gt;[]&lt;/code&gt; 表示该项可能不存在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_STRING&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rdbSaveStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rdb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;字符串对象调用 &lt;code&gt;rdbSaveStringObject&lt;/code&gt; 进行存储，其编码会在以下情况下省略 &lt;code&gt;data&lt;/code&gt; 字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;robj-&amp;gt;encoding&lt;/code&gt; 为 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt; 且数值范围为 $[2^{-31}, 2^{31}-1]$ (&lt;code&gt;int32_t&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;字符串长度小于 11 且可转化为 &lt;code&gt;int32_t&lt;/code&gt; 范围内的整型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过阅读 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 可以发现，当使用 &lt;code&gt;&amp;lt;len&amp;gt; &amp;lt;data&amp;gt;&lt;/code&gt; 存储字符串对象时，若 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L330&#34;&gt;rdbcompression&lt;/a&gt; 配置为 yes，且字符串长度大于 20，则会尝试对字符串进行 LZF 压缩，若压缩后最小可节省 4 byte，则调用 &lt;code&gt;rdbSaveLzfBlob&lt;/code&gt; 存储压缩后的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;+----------+--------------+--------------+---------------+
| 11000011 | compress_len | original_len | compress_data |
+----------+--------------+--------------+---------------+
   1 byte
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;OBJ_ENCODING_QUICKLIST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先存储 &lt;code&gt;ql-&amp;gt;len&lt;/code&gt;，即 quicklist 中节点的个数；然后遍历 quicklist，如果当前 &lt;code&gt;quicklistNode&lt;/code&gt; 已被压缩，则调用 &lt;code&gt;rdbSaveLzfBlob&lt;/code&gt; 存储压缩后的 &lt;code&gt;ziplist&lt;/code&gt;，否则调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储 &lt;code&gt;ziplist&lt;/code&gt;。可以看出 &lt;code&gt;ziplist&lt;/code&gt; 被当成字符串直接存储，便于存取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_SET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当集合类型使用 &lt;code&gt;dict&lt;/code&gt; 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_SET&lt;/code&gt;。在 &lt;code&gt;RDB_TYPE_SET&lt;/code&gt; 中，首先存储集合大小 &lt;code&gt;dictSize&lt;/code&gt;；随后遍历 &lt;code&gt;dict&lt;/code&gt;，调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储 &lt;code&gt;dictEntry-&amp;gt;key&lt;/code&gt; (集合类型中 &lt;code&gt;dictEntry-&amp;gt;val&lt;/code&gt; 为空)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_SET_INTSET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当集合类型使用 &lt;code&gt;intset&lt;/code&gt; 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_SET_INTSET&lt;/code&gt;，调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储整个 &lt;code&gt;intset&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_ZSET_ZIPLIST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 ZSET 使用 &lt;code&gt;ziplist&lt;/code&gt; 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_ZSET_ZIPLIST&lt;/code&gt;，调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储整个 &lt;code&gt;ziplist&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_ZSET_2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 ZSET 使用 skiplist 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_ZSET_2&lt;/code&gt;。首先存储 skiplist 中的节点个数 &lt;code&gt;zskiplist-&amp;gt;length&lt;/code&gt;，随后逆序遍历 skiplist，调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储 &lt;code&gt;zskiplistNode-&amp;gt;ele&lt;/code&gt;；调用 &lt;code&gt;rdbSaveBinaryDoubleValue&lt;/code&gt; 存储 &lt;code&gt;zskiplistNode-&amp;gt;score&lt;/code&gt;。逆序遍历的目的是为了在 RDB load 阶段便于 skiplist 的插入操作，由于每个将要插入的节点都小于当前最小的节点，因此只需往头部插入即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_HASH_ZIPLIST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Hash 使用 &lt;code&gt;ziplist&lt;/code&gt; 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_HASH_ZIPLIST&lt;/code&gt;，调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 存储整个 &lt;code&gt;ziplist&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_HASH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Hash 使用 &lt;code&gt;dict&lt;/code&gt; 作为底层实现时，其对应的 RDB type 为 &lt;code&gt;RDB_TYPE_HASH&lt;/code&gt;。首先存储哈希表大小 &lt;code&gt;dictSize&lt;/code&gt;；随后遍历 &lt;code&gt;dict&lt;/code&gt;，调用两次 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 按序存储 &lt;code&gt;dictEntry-&amp;gt;key&lt;/code&gt; 和 &lt;code&gt;dictEntry-&amp;gt;v.val&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_STREAM_LISTPACKS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB_TYPE_MODULE_2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h4 id=&#34;112-rdb-opcodes&#34;&gt;1.1.2. RDB opcodes&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Meaning&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RDB content&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_MODULE_AUX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Module auxiliary data&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TODO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_IDLE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LRU idle time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;len: &lt;code&gt;&amp;lt;idletime&amp;gt;&lt;/code&gt; (seconds)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_FREQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LFU frequency&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Raw: &lt;code&gt;&amp;lt;LFUCounter&amp;gt;&lt;/code&gt; (8-bit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_AUX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB aux field&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Str: &lt;code&gt;&amp;lt;key.len&amp;gt; [key.data] &amp;lt;val.len&amp;gt; [val.data]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_RESIZEDB&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Hash table resize hint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;len: &lt;code&gt;&amp;lt;db_size&amp;gt; &amp;lt;expires_size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_EXPIRETIME_MS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Expire time in milliseconds&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Raw: &lt;code&gt;&amp;lt;expiretime&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_EXPIRETIME&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Old expire time in seconds&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;兼容旧版 RDB，已弃用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_SELECTDB&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DB number of the following keys&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;len: &lt;code&gt;&amp;lt;current_db_id&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RDB_OPCODE_EOF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;End of the RDB file&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Raw: &lt;code&gt;&amp;lt;cksum&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;省略 redis module sub opcodes&lt;/li&gt;
&lt;li&gt;len 表示该字段内容与 &lt;code&gt;len&lt;/code&gt; 字段编码规则相同，将在下节讲述&lt;/li&gt;
&lt;li&gt;Raw 表示该字段内容定长，直接写入存储&lt;/li&gt;
&lt;li&gt;Str 表示该字段调用 &lt;code&gt;rdbSaveRawString&lt;/code&gt; 写入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-length-编码&#34;&gt;1.2. length 编码&lt;/h3&gt;
&lt;p&gt;Redis 为了节省存储空间，不仅会对 &lt;code&gt;data&lt;/code&gt; 字段进行压缩，而且也会使用不定长空间存储 &lt;code&gt;len&lt;/code&gt; 字段。通过读取 &lt;code&gt;len&lt;/code&gt; 字段首个字节可知道此时的编码格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;长度信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过阅读 &lt;code&gt;rdbSaveLen&lt;/code&gt; 可以发现，在使用 &lt;code&gt;len&lt;/code&gt; 字段存储长度信息时，其原生值为整型，根据整型值的大小可用以下四种编码方式之一进行存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;00|XXXXXX&lt;/code&gt;: the len is the 6 bits of this byte&lt;/li&gt;
&lt;li&gt;&lt;code&gt;01|XXXXXX XXXXXXXX&lt;/code&gt;: the len is 14 byes, 6 bits + 8 bits of next byte&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10|000000 &amp;lt;32 bit integer&amp;gt;&lt;/code&gt;: A full 32 bit len in net byte order will follow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10|000001 &amp;lt;64 bit integer&amp;gt;&lt;/code&gt;:  A full 64 bit len in net byte order will follow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串对象编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如之前所说，在存储字符串对象时，一般会使用 &lt;code&gt;len&lt;/code&gt; 字段存储字符串长度，&lt;code&gt;data&lt;/code&gt; 字段存储字符串内容，但在字符串对象可用整型表示时或可压缩节省空间时，&lt;code&gt;len&lt;/code&gt; 字段所存储的信息便不是字符串长度信息，通过阅读 &lt;code&gt;rdbEncodeInteger&lt;/code&gt;，可以发现根据 &lt;code&gt;len&lt;/code&gt; 字段首字节我们可以知道字符串对象此时的编码方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;11|000000 &amp;lt;8 bit integer&amp;gt;&lt;/code&gt;: 字符串对象可用 8 bit 整型表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;11|000001 &amp;lt;16 bit integer&amp;gt;&lt;/code&gt;: 字符串对象可用 16 bit 整型表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;11|000010 &amp;lt;32 bit integer&amp;gt;&lt;/code&gt;: 字符串对象可用 32 bit 整型表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;11|000011 &amp;lt;compress_len&amp;gt; &amp;lt;original_len&amp;gt; &amp;lt;compress_data&amp;gt;&lt;/code&gt;: 字符串对象可压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-rdb-文件内容排布&#34;&gt;1.3. RDB 文件内容排布&lt;/h3&gt;
&lt;p&gt;通过阅读 &lt;code&gt;rdbSaveRio&lt;/code&gt;，我们可以知道 RDB 文件内容的排布方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 版本号：格式为 &lt;code&gt;REDIS0009&lt;/code&gt;，其中 $9$ 为Redis-6.0.8 的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/rdb.h#L41&#34;&gt;RDB_VERSION&lt;/a&gt;，直接写入二进制串无编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Aux Fields: 编码格式 &lt;code&gt;&amp;lt;RDB_OPCODE_AUX&amp;gt; &amp;lt;key.len&amp;gt; [key.data] &amp;lt;val.len&amp;gt; [val.data]&lt;/code&gt;，key-val 对内容如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;key&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;value&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;redis-ver&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;REDIS_VERSION&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redis 当前版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;redis-bits&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;sizeof(void*)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;处理器运算位数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;ctime&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time(NULL)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;used-mem&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;zmalloc_used_memory()&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实际分配内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;repl-stream-db&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;rsi-&amp;gt;repl_stream_db&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DB to select in server.master client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;repl-id&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;server.replid&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;My current replication ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;repl-offset&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;server.master_repl_offset&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;My current replication offset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;aof-preamble&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0 or 1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Load/save the RDB as AOF preamble?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若传入的 &lt;code&gt;rdbSaveInfo&lt;/code&gt;(rsi) 为空，则无须存储 &lt;code&gt;repl-stream-db&lt;/code&gt;、&lt;code&gt;repl-id&lt;/code&gt; 和 &lt;code&gt;repl-offset&lt;/code&gt; 信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aof-preamble&lt;/code&gt; 为 1 时，表示该 rdb 文件是 AOF 重写时生成的，可通过配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1195&#34;&gt;aof-use-rdb-preamble&lt;/a&gt; 修改该值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Module-specific aux values: Iterate over modules, and trigger rdb aux saving for the ones modules types who asked for it. (when is &lt;code&gt;REDISMODULE_AUX_BEFORE_RDB&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历及存储每个 &lt;code&gt;redisDb&lt;/code&gt; 的具体信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;db 编号：&lt;code&gt;&amp;lt;RDB_OPCODE_SELECTDB&amp;gt; &amp;lt;current_db_id&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;db 大小：&lt;code&gt;RDB_OPCODE_RESIZEDB &amp;lt;db_size&amp;gt; &amp;lt;expires_size&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt;，存储数据对象相关信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如有过期时间，则存储 &lt;code&gt;&amp;lt;RDB_OPCODE_EXPIRETIME_MS&amp;gt; &amp;lt;expiretime&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;expiretime&lt;/code&gt; is the absolute unix time in milliseconds&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照内存管理策略存储 LRU/LFU 信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LRU: &lt;code&gt;&amp;lt;RDB_OPCODE_IDLE&amp;gt; &amp;lt;idletime&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LFU: &lt;code&gt;&amp;lt;RDB_OPCODE_FREQ&amp;gt; &amp;lt;LFUCounter&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据对象内容：&lt;code&gt;&amp;lt;type&amp;gt; &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;，详细内容可参照 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-persistence/#object-types&#34;&gt;Object types&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lua scripts: 若传入的 &lt;code&gt;rdbSaveInfo&lt;/code&gt; 不为空，则遍历及存储此时缓存的 lua 脚本信息，每个 lua 脚本的编码格式为 &lt;code&gt;&amp;lt;RDB_OPCODE_AUX&amp;gt; &amp;lt;lua&amp;gt; &amp;lt;lua-script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Module-specific aux values: Iterate over modules, and trigger rdb aux saving for the ones modules types who asked for it. (when is &lt;code&gt;REDISMODULE_AUX_AFTER_RDB&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EOF opcode: &lt;code&gt;&amp;lt;RDB_OPCODE_EOF&amp;gt; &amp;lt;cksum&amp;gt;&lt;/code&gt;，若未启用计算校验和，则 &lt;code&gt;cksum&lt;/code&gt; 值为 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-rdb-相关命令&#34;&gt;1.4. RDB 相关命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SAVE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BGSAVE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;2-aof&#34;&gt;2. AOF&lt;/h2&gt;
&lt;p&gt;Redis 除了使用数据集的 snapshot (RDB) 提供持久化保证之外，还会使用 Append Only Flie(AOF) 记录写请求。&lt;/p&gt;
&lt;h3 id=&#34;21-写入-aof-缓冲区&#34;&gt;2.1. 写入 AOF 缓冲区&lt;/h3&gt;
&lt;p&gt;在 Redis 调用 &lt;code&gt;propagate&lt;/code&gt; 函数将请求同步至 AOF 和 replications 时，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3212&#34;&gt;feedAppendOnlyFile&lt;/a&gt; 函数将请求写入 AOF 缓冲区，该函数的接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;feedAppendOnlyFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisCommand&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其执行流程大致为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如传入的 &lt;code&gt;dictid&lt;/code&gt; 和上次记录请求时的 db 不同，则写入 &lt;code&gt;SELECT dictid&lt;/code&gt; 请求以切换 db&lt;/li&gt;
&lt;li&gt;命令转换，将过期相对时间改为绝对时间：
&lt;ul&gt;
&lt;li&gt;Translate &lt;code&gt;EXPIRE&lt;/code&gt;/&lt;code&gt;PEXPIRE&lt;/code&gt;/&lt;code&gt;EXPIREAT&lt;/code&gt; into &lt;code&gt;PEXPIREAT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Translate &lt;code&gt;SETEX&lt;/code&gt;/&lt;code&gt;PSETEX&lt;/code&gt; to &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;PEXPIREAT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Translate &lt;code&gt;SET [EX seconds][PX milliseconds]&lt;/code&gt; to &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;PEXPIREAT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将内容追加至 AOF 缓冲区 &lt;code&gt;server.aof_buf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如此时有子进程正在执行 AOF rewrite，则会将内容追加之 AOF rewrite buff &lt;code&gt;server.aof_rewrite_buf_blocks&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-写入-aof-文件&#34;&gt;2.2. 写入 AOF 文件&lt;/h3&gt;
&lt;p&gt;AOF 缓冲区的数据会在以下几种情况下调用 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 写入 AOF 文件，同时可选择是否启用强制模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;CONFIG&lt;/code&gt; 命令&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/aof.c#L238&#34;&gt;关闭 AOF 功能时&lt;/a&gt;，模式为&lt;strong&gt;强制模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在服务器定期执行 &lt;code&gt;serverCron&lt;/code&gt; 时，发现&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2026&#34;&gt;此前有被推迟执行的写入 AOF 文件操作时&lt;/a&gt;，模式为非强制模式，执行频率为 &lt;code&gt;server.hz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在服务器定期执行 &lt;code&gt;serverCron&lt;/code&gt; 时，发现&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2034&#34;&gt;此前写入 AOF 文件有错误发生时&lt;/a&gt;，模式为非强制模式，执行频率为 $1$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3826&#34;&gt;关闭服务器&lt;/a&gt;之前，模式为&lt;strong&gt;强制模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;因为要求在返回客户端响应之前将内容写入 AOF 文件，因此我们需在进入 event loop 之前的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2187&#34;&gt;beforeSleep&lt;/a&gt; 函数中调用 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 写入 AOF 文件，模式为非强制模式。 (&lt;strong&gt;主要情形&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 的接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;flushAppendOnlyFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;阅读 &lt;a href=&#34;http://oldblog.antirez.com/post/redis-persistence-demystified.html&#34;&gt;Redis persistence demystified&lt;/a&gt; 后我们知道，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当调用 &lt;code&gt;write()&lt;/code&gt; 后，此时数据在 kernel&amp;rsquo;s buffer&lt;/li&gt;
&lt;li&gt;继续调用 &lt;code&gt;fsync()&lt;/code&gt; 后，数据在 disk cache (也可选择让 OS 自行控制何时 flush)&lt;/li&gt;
&lt;li&gt;随后由  disk controller 将数据写入物理介质&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 1 2 可控，而 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 主要也可分为这两部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;write&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在使用强制模式时，如果此时 AOF 缓冲区非空，则一定会调用 &lt;code&gt;write()&lt;/code&gt;，即使可能阻塞 Redis，因此使用 &lt;code&gt;CONFIG&lt;/code&gt; 命令关闭 AOF 功能可能会阻塞 Redis&lt;/li&gt;
&lt;li&gt;只有当 &lt;code&gt;fsync&lt;/code&gt; 的策略为 &lt;code&gt;everysec&lt;/code&gt; 时，非强制模式才会在下述情况下阻止调用 &lt;code&gt;write()&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;当前有 background fsync 进程在运行，且此前无推迟的 &lt;code&gt;write&lt;/code&gt; 调用，记录本次推迟的 &lt;code&gt;write&lt;/code&gt; 调用时间并返回&lt;/li&gt;
&lt;li&gt;当前有 background fsync 进程在运行，且此前推迟的 &lt;code&gt;write&lt;/code&gt; 调用在 $2s$ 内，则直接返回
&lt;blockquote&gt;
&lt;p&gt;若超过 2s，则不会阻止调用 &lt;code&gt;write&lt;/code&gt;，此时可能会阻塞 Redis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;fsync&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AOF 调用 &lt;code&gt;fsync()&lt;/code&gt; 的频率可通过配置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1118&#34;&gt;appendfsync&lt;/a&gt; 进行控制，可选项有三：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;no&lt;/code&gt;: don&amp;rsquo;t fsync, just let the OS flush the data when it wants. Faster.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;always&lt;/code&gt;: fsync after every write to the append only log. Slow, Safest.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;everysec&lt;/code&gt;: fsync only one time every second. Compromise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过在 &lt;code&gt;write&lt;/code&gt; 阶段的介绍可知，当使用 &lt;code&gt;everysec&lt;/code&gt; 策略时，事实上可能会丢失 $2s$ 的写入，而不是 $1s$。&lt;/p&gt;
&lt;p&gt;如果有 RDB saving 或 AOF rewriting 子进程，可能会消耗 IO 资源，导致 &lt;code&gt;fsync&lt;/code&gt; 操作耗时过长阻塞 Redis，因此为性能考虑可以通过配置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1140&#34;&gt;no-appendfsync-on-rewrite&lt;/a&gt; 为 &lt;code&gt;yes&lt;/code&gt; 阻止调用 &lt;code&gt;fsync&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;23-aof-rewrite&#34;&gt;2.3. AOF Rewrite&lt;/h3&gt;
&lt;p&gt;由于 AOF 文件的 Append Only 要求，会使得该文件大小单调递增，因此 Redis 提供了 AOF rewrite 的功能，使用 rewrite 生成的 AOF 文件替换旧的 AOF 文件，以减小 AOF 文件所占用的磁盘空间大小。既可以主动发起 &lt;a href=&#34;https://redis.io/commands/bgrewriteaof&#34;&gt;BGREWRITEAOF&lt;/a&gt; 请求要求进行 AOF rewrite，亦可以通过配置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1159&#34;&gt;auto-aof-rewrite-percentage&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1160&#34;&gt;auto-aof-rewrite-min-size&lt;/a&gt; 调整自发进行 AOF rewrite 的条件。当当前 AOF 文件大小 &lt;code&gt;server.aof_current_size&lt;/code&gt; 大于 &lt;code&gt;auto-aof-rewrite-min-size&lt;/code&gt; 且与上次 rewrite 之后 AOF 文件大小 &lt;code&gt;server.aof_rewrite_base_size&lt;/code&gt; 相比增长率超过 &lt;code&gt;auto-aof-rewrite-percentage&lt;/code&gt; 时，Redis 会自动触发 AOF rewrite 操作 —— 调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2018&#34;&gt;rewriteAppendOnlyFileBackground&lt;/a&gt;，其接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* This is how rewriting of the append only file in background works:
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 1) The user calls BGREWRITEAOF
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 2) Redis calls this function, that forks():
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    2a) the child rewrite the append only file in a temp file.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    2b) the parent accumulates differences in server.aof_rewrite_buf_blocks.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 3) When the child finished &amp;#39;2a&amp;#39; exists.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 4) The parent will trap the exit code, if it&amp;#39;s OK, will append the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    data accumulated into server.aof_rewrite_buf_blocks into the temp file, and
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    finally will rename(2) the temp file in the actual file name.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    The the new file is reopened as the new append only file. Profit! */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rewriteAppendOnlyFileBackground&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;231-aof-rewrite-buffer&#34;&gt;2.3.1. AOF Rewrite Buffer&lt;/h4&gt;
&lt;p&gt;由于在 AOF rewrite 执行过程中，Redis 不会停止服务，因此需要记录这期间数据库的变化。Redis 使用双端链表 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L1215&#34;&gt;aof_rewrite_buf_blocks&lt;/a&gt; 实现 AOF Rewirte buffer，每个 listNode 指向一个大小为 $10MB$ 的内存块 &lt;code&gt;aofrwblock&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* 10 MB per block */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;aofrwblock&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AOF_RW_BUF_BLOCK_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aofrwblock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果此时正在进行 AOF rewrite，则 Redis 主进程除了将写请求写入 AOF 缓冲区之外，还会通过调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/aof.c#L650&#34;&gt;aofRewriteBufferAppend&lt;/a&gt;将数据写入 AOF rewrite buffer。在 &lt;code&gt;aofRewriteBufferAppend&lt;/code&gt; 中，以 append 的形式写入数据，同时会创建 &lt;code&gt;aofChildWriteDiffData&lt;/code&gt; file event，以将 AOF rewrite buffer 中的内容从前往后遍历写入管道 &lt;code&gt;server.aof_pipe_write_data_to_child&lt;/code&gt;，以供子进程读取，写入管道成功后会释放该节点所占用的内存块。因此，AOF rewrite buffer 如同一个先进先出的队列，在 append 时(链表尾部)申请内存，在写入管道后(链表头部)释放内存。&lt;/p&gt;
&lt;h4 id=&#34;232-use-rdb-preamble&#34;&gt;2.3.2. Use RDB preamble&lt;/h4&gt;
&lt;p&gt;因为 RDB 文件小，加载速度快，因此在 AOF rewrite 时，可使用 RDB 保存当前数据库状态。如果配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1195&#34;&gt;aof-use-rdb-preamble&lt;/a&gt; 为 &lt;code&gt;yes&lt;/code&gt;，则会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/aof.c#L1432&#34;&gt;rdbSaveRio&lt;/a&gt; 保存数据库状态，此时 AOF rewrite 结束之后的文件组织形式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;+----------+----------+
| RDB file | AOF tail |
+----------+----------+
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;233-rewrite-objects&#34;&gt;2.3.3. Rewrite Objects&lt;/h4&gt;
&lt;p&gt;当不启用 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 时，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/aof.c#L1437&#34;&gt;rewriteAppendOnlyFileRio&lt;/a&gt; 函数将各个数据对象转换为请求的格式存储。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- Database</title>
      <link>https://k-on.me/post/redis-sourcecode-db/</link>
      <pubDate>Tue, 13 Oct 2020 17:11:09 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-db/</guid>
      
        <description>&lt;p&gt;Redis 数据库实现相关源码阅读笔记，源码文件 &lt;code&gt;server.h&lt;/code&gt; &amp;amp; &lt;code&gt;server.c&lt;/code&gt; &amp;amp; &lt;code&gt;db.c&lt;/code&gt; &amp;amp; &lt;code&gt;evict.c&lt;/code&gt; &amp;amp; &lt;code&gt;expire.c&lt;/code&gt; &amp;amp; &lt;code&gt;blocked.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis 数据库对象主要由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;: Database ID，值域为 $0$ 至 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L275&#34;&gt;databases&lt;/a&gt; $- 1$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dict&lt;/code&gt;：数据库具体内容 —— key-value pair
&lt;ul&gt;
&lt;li&gt;key 为 sds strings，不使用 redis object 是为了节省内存&lt;/li&gt;
&lt;li&gt;value 为 redis object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expires&lt;/code&gt;：记录数据对象过期时间的 key-ttl pair
&lt;ul&gt;
&lt;li&gt;key 为 sds strings，会复用 &lt;code&gt;dict&lt;/code&gt; 中的键值以节省内存&lt;/li&gt;
&lt;li&gt;value 为long long 整型，记录了该 key 将于何时 (absolute unix time in milliseconds) 过期&lt;/li&gt;
&lt;li&gt;被动清理过期键：一般地，在查找 key 是否在 &lt;code&gt;dict&lt;/code&gt; 中时，会先判断该 key 是否已过期，若为主库，则会删除已过期键&lt;/li&gt;
&lt;li&gt;主动清理过期键：调用 &lt;code&gt;activeExpireCycle&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avg_ttl&lt;/code&gt;：统计过期时间平均值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expires_cursor&lt;/code&gt;：用于渐进式主动过期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blocking_keys&lt;/code&gt; &amp;amp; &lt;code&gt;ready_keys&lt;/code&gt;：用于实现带阻塞的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;watched_keys&lt;/code&gt;：用于实现事务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defrag_later&lt;/code&gt;：用于内存碎片整理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;键过期以被动的方式进行，只会在访问该 key 的时候触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在客户端访问该 key 时调用 &lt;code&gt;expireIfNeeded&lt;/code&gt; 触发过期删除操作
&lt;blockquote&gt;
&lt;p&gt;当从库处于 read-only 模式时，访问从库的 key 不会触发删除操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Redis 服务器定时调用 &lt;code&gt;activeExpireCycle&lt;/code&gt; 主动扫描键空间以清理过期 key
&lt;blockquote&gt;
&lt;p&gt;可使用配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L938&#34;&gt;active-expire-effort&lt;/a&gt; 修改主动清理操作单次执行时间上限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过期 &lt;code&gt;key&lt;/code&gt; 的删除分为同步和异步两种方式，由配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L985&#34;&gt;lazyfree-lazy-expire&lt;/a&gt; 决定采用何种方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当设置了 &lt;code&gt;maxmemory&lt;/code&gt; 限制时，Redis 会根据所设置的内存策略 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L890&#34;&gt;maxmemory-policy&lt;/a&gt; 决定淘汰 key 的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为性能考虑，应尽量避免调用 &lt;code&gt;gettimeofday&lt;/code&gt; 来获取时间，可使用 Redis 缓存的时间值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-redisdb&#34;&gt;2. redisDb&lt;/h2&gt;
&lt;p&gt;Redis 数据库由多个 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-dict/&#34;&gt;dict&lt;/a&gt; 组成，其结构定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Redis database representation. There are multiple databases identified
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * by integers from 0 (the default database) up to the max configured
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * database. The database number is the &amp;#39;id&amp;#39; field in the structure. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;cm&#34;&gt;/* The keyspace for this DB */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expires&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;              &lt;span class=&#34;cm&#34;&gt;/* Timeout of keys with a timeout set */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blocking_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;cm&#34;&gt;/* Keys with clients waiting for data (BLPOP)*/&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ready_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;cm&#34;&gt;/* Blocked keys that received a PUSH */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;watched_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;cm&#34;&gt;/* WATCHED keys for MULTI/EXEC CAS */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                     &lt;span class=&#34;cm&#34;&gt;/* Database ID */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;avg_ttl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* Average TTL, just for stats */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expires_cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Cursor of the active expire cycle. */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;defrag_later&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;         &lt;span class=&#34;cm&#34;&gt;/* List of key names to attempt to defrag
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                                 * one by one, gradually. */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在之前 Redis dict 结构的介绍中，我们知道 dict 可以有不同的 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-dict/#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#34;&gt;dictType&lt;/a&gt;，不同类型的 dict 的区别在于 kv 类型及其相关操作不同，在 &lt;code&gt;redisDb&lt;/code&gt; 中的各个 dict 其类型如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;field&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;dictType&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;key&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dbDictType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sds strings&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redis objects&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;expires&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;keyptrDictType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sds strings&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;blocking_keys&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;keylistDictType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redis objects&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lists&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;ready_keys&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;objectKeyPointerValueDictType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redis objects&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dummy pointers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;watched_keys&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;keylistDictType&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redis objects&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;lists&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;dbDictType&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 数据库 keysapce 的 &lt;code&gt;dictType&lt;/code&gt; 为 &lt;code&gt;dbDictType&lt;/code&gt;, 其定义如下，键使用 &lt;code&gt;sds&lt;/code&gt; 而不使用 &lt;code&gt;robj&lt;/code&gt;，可以节省内存。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Db-&amp;gt;dict, keys are sds strings, vals are Redis objects. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbDictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictSdsHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                &lt;span class=&#34;cm&#34;&gt;/* hash function */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* key dup */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* val dup */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictSdsKeyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* key compare */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictSdsDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* key destructor */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictObjectDestructor&lt;/span&gt;        &lt;span class=&#34;cm&#34;&gt;/* val destructor */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;keyptrDictType&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;键类型为 &lt;code&gt;sds&lt;/code&gt;，会复用 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt; 中的键值，值类型为 &lt;code&gt;long long&lt;/code&gt;，记录了该对象何时 (absolute unix time in milliseconds) 会过期。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Db-&amp;gt;expires */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyptrDictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictSdsHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                &lt;span class=&#34;cm&#34;&gt;/* hash function */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* key dup */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* val dup */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictSdsKeyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* key compare */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* key destructor */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;                        &lt;span class=&#34;cm&#34;&gt;/* val destructor */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;keylistDictType&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Keylist hash table type has unencoded redis objects as keys and
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * lists as values. It&amp;#39;s used for blocking operations (BLPOP) and to
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * map swapped keys to a list of clients waiting for this keys to be loaded. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keylistDictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictObjHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                &lt;span class=&#34;cm&#34;&gt;/* hash function */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* key dup */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* val dup */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictObjKeyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* key compare */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictObjectDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;       &lt;span class=&#34;cm&#34;&gt;/* key destructor */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictListDestructor&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* val destructor */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;objectKeyPointerValueDictType&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Generic hash table type where keys are Redis Objects,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Values dummy pointers. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;objectKeyPointerValueDictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictEncObjHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;            &lt;span class=&#34;cm&#34;&gt;/* hash function */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                      &lt;span class=&#34;cm&#34;&gt;/* key dup */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;                      &lt;span class=&#34;cm&#34;&gt;/* val dup */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictEncObjKeyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;      &lt;span class=&#34;cm&#34;&gt;/* key compare */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictObjectDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;      &lt;span class=&#34;cm&#34;&gt;/* key destructor */&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;                       &lt;span class=&#34;cm&#34;&gt;/* val destructor */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-redisdb-apis&#34;&gt;3. redisDb APIs&lt;/h2&gt;
&lt;h3 id=&#34;31-查找&#34;&gt;3.1. 查找&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;lookupKey&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Low level key lookup API, not actually called directly from commands
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * implementations that should instead rely on lookupKeyRead(),
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * lookupKeyWrite() and lookupKeyReadWithFlags(). */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;flags&lt;/code&gt; 用于指示是否更新 &lt;code&gt;robj-&amp;gt;lru&lt;/code&gt;，其取值有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOOKUP_NONE&lt;/code&gt;: no special flags are passed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOOKUP_NOTOUCH&lt;/code&gt;: don&amp;rsquo;t alter the last access time of the key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，若此时正有子线程正在进行保存 RDB、重写 AOF 或加载 module 相关操作时，也不会更新该数据对象的 &lt;code&gt;lru&lt;/code&gt; 值，以避免一个数据对象被疯狂复制多次。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt; 存在于 &lt;code&gt;db&lt;/code&gt; 中时，返回其关联的 value 值，否则返回 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lookupKeyReadWithFlags&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Lookup a key for read operations, or return NULL if the key is not found
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * in the specified DB. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyReadWithFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在该函数中，在调用 &lt;code&gt;lookupKey&lt;/code&gt; 判断 &lt;code&gt;key&lt;/code&gt; 是否存在于 &lt;code&gt;db&lt;/code&gt; 中之前，会先调用 &lt;code&gt;expireIfNeeded&lt;/code&gt; 判断该 &lt;code&gt;key&lt;/code&gt; 是否已过期(有关过期的内容将在下文详述)。从库为了和主库保持数据的一致性，并不会主动清理过期键，而是会同步主库在清理过期键时发送的 &lt;code&gt;DEL&lt;/code&gt; 命令，但在该查找操作中，如果 &lt;code&gt;key&lt;/code&gt; 已过期，从库虽未删除该 &lt;code&gt;key&lt;/code&gt;，但仍然会返回 &lt;code&gt;NULL&lt;/code&gt;，表示该 &lt;code&gt;key&lt;/code&gt; 逻辑上不存在，以和主库保持一致的视图。&lt;/p&gt;
&lt;p&gt;调用该函数有以下副作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Redis 主库中，若 &lt;code&gt;key&lt;/code&gt; 达到其过期时间，则会被删除，同步或异步删除则取决于配置的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L985&#34;&gt;lazyfree-lazy-expire&lt;/a&gt; 值 (调用 &lt;code&gt;expireIfNeeded&lt;/code&gt; 引起)&lt;/li&gt;
&lt;li&gt;可能会更新 &lt;code&gt;robj-&amp;gt;lru&lt;/code&gt; (调用 &lt;code&gt;lookupKey&lt;/code&gt; 引起)&lt;/li&gt;
&lt;li&gt;会更新数据库的 &lt;code&gt;hits&lt;/code&gt; 或 &lt;code&gt;misses&lt;/code&gt; 状态信息&lt;/li&gt;
&lt;li&gt;如果启用了键空间通知，则会触发 &lt;code&gt;keymiss&lt;/code&gt; 通知&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;lookupKeyRead&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Like lookupKeyReadWithFlags(), but does not use any flag, which is the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * common case. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookupKeyReadWithFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LOOKUP_NONE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;lookupKeyWriteWithFlags&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Lookup a key for write operations, and as a side effect, if needed, expires
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * the key if its TTL is reached.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns the linked value object if the key exists or NULL if the key
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * does not exist in the specified DB. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyWriteWithFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;expireIfNeeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookupKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;others&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyWrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookupKeyWriteWithFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LOOKUP_NONE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyReadOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookupKeyRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lookupKeyWriteOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookupKeyWrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;32-添加&#34;&gt;3.2. 添加&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;dbAdd&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Add the key to the DB. It&amp;#39;s up to the caller to increment the reference
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * counter of the value if needed.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The program is aborted if the key already exists. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dbAdd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在将 &lt;code&gt;key&lt;/code&gt; 加入 &lt;code&gt;db-&amp;gt;dict&lt;/code&gt; 时，会复制 &lt;code&gt;key&lt;/code&gt; 的字符串值，将 &lt;code&gt;key&lt;/code&gt; 以 &lt;code&gt;sds&lt;/code&gt; 形式加入 &lt;code&gt;db&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果值类型为 list、zset 或 stream，&lt;code&gt;key&lt;/code&gt; 此时在 &lt;code&gt;db-&amp;gt;blocking_keys&lt;/code&gt; 中且不在 &lt;code&gt;db-&amp;gt;ready_keys&lt;/code&gt; 时，会将 &lt;code&gt;key&lt;/code&gt; 加入 &lt;code&gt;db-&amp;gt;ready_keys&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;若 Redis 服务器为 cluster 模式，会将 &lt;code&gt;key&lt;/code&gt; 和对应的 &lt;code&gt;slot&lt;/code&gt; 建立映射，表示 &lt;code&gt;key&lt;/code&gt; 存在于该 &lt;code&gt;slot&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;dbAddRDBLoad&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* This is a special version of dbAdd() that is used only when loading
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * keys from the RDB file: the key is passed as an SDS string that is
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * retained by the function (and not freed by the caller). */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dbAddRDBLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;即使 &lt;code&gt;key&lt;/code&gt; 此时在 &lt;code&gt;db-&amp;gt;dict&lt;/code&gt; 中，也不会触发 aborted，而是会返回 0&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;key&lt;/code&gt; 成功加入 &lt;code&gt;db-&amp;gt;dict&lt;/code&gt; 中，则返回 1&lt;/li&gt;
&lt;li&gt;由于传入的 &lt;code&gt;key&lt;/code&gt; 类型为 &lt;code&gt;sds&lt;/code&gt;，所以和 &lt;code&gt;dbAdd&lt;/code&gt; 相比并无复制字符串操作，因此在成功加入时，调用方不可对 &lt;code&gt;key&lt;/code&gt; 进行释放操作，此时 &lt;code&gt;key&lt;/code&gt; 的所有权交予 &lt;code&gt;db-&amp;gt;dict&lt;/code&gt;；但在返回 0 时，&lt;code&gt;key&lt;/code&gt; 的释放操作需由调用方完成&lt;/li&gt;
&lt;li&gt;若 Redis 服务器为 cluster 模式，会将 &lt;code&gt;key&lt;/code&gt; 和对应的 &lt;code&gt;slot&lt;/code&gt; 建立映射，表示 &lt;code&gt;key&lt;/code&gt; 存在于该 &lt;code&gt;slot&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;dbOverwrite&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Overwrite an existing key with a new value. Incrementing the reference
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * count of the new value is up to the caller.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * This function does not modify the expire time of the existing key.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The program is aborted if the key was not already present. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dbOverwrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;setKey &amp;amp; genericSetKey&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Common case for genericSetKey() where the TTL is not retained. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;genericSetKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* High level Set operation. This function can be used in order to set
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * a key, whatever it was existing or not, to a new object. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;genericSetKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                   &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keepttl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;genericSetKey&lt;/code&gt; 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keepttl&lt;/code&gt; 指示是否保持该 &lt;code&gt;key&lt;/code&gt; 的 ttl 不变，其值由具体的写入命令参数决定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signal&lt;/code&gt; 指示是否需要调用 &lt;code&gt;signalModifiedKey&lt;/code&gt; 通知该 &lt;code&gt;key&lt;/code&gt; 已被修改，除了在 redis module 中，该值一直为 1，而在 redis module 中，该值为 0。使用 Redis module 可以通过调用 &lt;code&gt;RedisModule_SignalModifiedKey&lt;/code&gt; 通知该 &lt;code&gt;key&lt;/code&gt; 已被修改&lt;/li&gt;
&lt;li&gt;在该函数中无论 &lt;code&gt;key&lt;/code&gt; 先前是否存在，都会将 &lt;code&gt;key-val&lt;/code&gt; 对写入 &lt;code&gt;db&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val&lt;/code&gt; 的引用计数会增加&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;keepttl&lt;/code&gt; 不为 1 时，与 &lt;code&gt;key&lt;/code&gt; 关联的过期时间会被移除&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-删除&#34;&gt;3.3. 删除&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;删除某个 key&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Delete a key, value, and associated expiration entry if any, from the DB */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dbSyncDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* This is a wrapper whose behavior depends on the Redis lazy free
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * configuration. Deletes the key synchronously or asynchronously. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dbDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lazyfree_lazy_server_del&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbAsyncDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
                                             &lt;span class=&#34;n&#34;&gt;dbSyncDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;删除指定的 db&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;emptyDb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;emptyDbGeneric&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Remove all keys from all the databases in a Redis server.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If callback is given the function is called from time to time to
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * signal that work is in progress.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The dbnum can be -1 if all the DBs should be flushed, or the specified
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * DB number if we want to flush only a single Redis database number.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Flags are be EMPTYDB_NO_FLAGS if no special flags are specified or
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 1. EMPTYDB_ASYNC if we want the memory to be freed in a different thread.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 2. EMPTYDB_BACKUP if we want to empty the backup dictionaries created by
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    disklessLoadMakeBackups. In that case we only free memory and avoid
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    firing module events.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * and the function to return ASAP.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * On success the fuction returns the number of keys removed from the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * database(s). Otherwise -1 is returned in the specific case the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * DB number is out of range, and errno is set to EINVAL. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;emptyDbGeneric&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dbarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                         &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;34-utils&#34;&gt;3.4. Utils&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;dbRandomKey&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Return a random key, in form of a Redis object.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If there are no keys, NULL is returned.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The function makes sure to return keys not already expired. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dbRandomKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;dbUnshareStringValue&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Prepare the string object stored at &amp;#39;key&amp;#39; to be modified destructively
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * to implement commands like SETBIT or APPEND.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * An object is usually ready to be modified unless one of the two conditions
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * are true:
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 1) The object &amp;#39;o&amp;#39; is shared (refcount &amp;gt; 1), we don&amp;#39;t want to affect
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *    other users.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 2) The object encoding is not &amp;#34;RAW&amp;#34;.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If the object is found in one of the above conditions (or both) by the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * function, an unshared / not-encoded copy of the string object is stored
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * at &amp;#39;key&amp;#39; in the specified &amp;#39;db&amp;#39;. Otherwise the object &amp;#39;o&amp;#39; itself is
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * returned. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dbUnshareStringValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;4-expire&#34;&gt;4. expire&lt;/h2&gt;
&lt;p&gt;设置了过期时间的 &lt;code&gt;key&lt;/code&gt;，会将 &amp;lt;key, absolute-expire-time&amp;gt; 映射加入到 &lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt; 字典中，以支持后续的键过期行为。Redis 的键过期以被动的方式进行，只会在访问到该 &lt;code&gt;key&lt;/code&gt; 的时候触发。访问的方式大致可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在客户端访问到该 &lt;code&gt;key&lt;/code&gt; 时调用 &lt;code&gt;expireIfNeeded&lt;/code&gt; 触发过期删除操作，例如查找、删除、&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L296&#34;&gt;随机返回 key&lt;/a&gt;和 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L867&#34;&gt;Scan&lt;/a&gt;操作时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为防止有些过期 &lt;code&gt;key&lt;/code&gt; 一直未被访问从而无法释放，Redis 主库还会定时调用 &lt;code&gt;activeExpireCycle&lt;/code&gt; 主动去扫描过期键空间清理过期 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L5257&#34;&gt;main&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2943&#34;&gt;initServer&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L1968&#34;&gt;serverCron&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L1698&#34;&gt;databasesCron&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/expire.c#L123&#34;&gt;activeExpireCycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L5257&#34;&gt;main&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2981&#34;&gt;initServer&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2149&#34;&gt;beforeSleep&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/expire.c#L123&#34;&gt;activeExpireCycle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过期 &lt;code&gt;key&lt;/code&gt; 的删除分为同步和异步两种方式，由配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L985&#34;&gt;lazyfree-lazy-expire&lt;/a&gt; 决定采用何种方式。&lt;/p&gt;
&lt;h3 id=&#34;41-expire-apis&#34;&gt;4.1. Expire APIs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;removeExpire&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Remove an expire fo the specified key. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;removeExpire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;只有当 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt; 中时，才会尝试从 &lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt; 删除与 &lt;code&gt;key&lt;/code&gt; 对应的 &lt;code&gt;dictEntry&lt;/code&gt; 并释放其占用的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setExpire&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Set an expire to the specified key. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setExpire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当调用请求来自客户端时，&lt;code&gt;c&lt;/code&gt; 为客户端上下文，否则 &lt;code&gt;c&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;when&lt;/code&gt; 为过期时间，其为 unix time 的绝对值，即 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;when&lt;/code&gt; 这一时刻过期，单位为 &lt;code&gt;ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt; 复用 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt; 的键字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;getExpire&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Return the expire time of the specified key, or -1 if no expire
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * is associated with this key (i.e. the key is non volatile) */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getExpire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;propagateExpire&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Propagate expires into slaves and the AOF file.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * When a key expires in the master, a DEL operation for this key is sent
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * to all the slaves and the AOF file if enabled.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * This way the key expiry is centralized in one place, and since both
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * AOF and the master-&amp;gt;slave link guarantee operation ordering, everything
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * will be consistent even if we allow write operations against expiring
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * keys. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;propagateExpire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lazy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;keyIsExpired&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Check if the key is expired. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;keyIsExpired&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果此时正在 loading data，则不会进行过期操作，因此该函数直接返回 0&lt;/li&gt;
&lt;li&gt;如果正在运行 lua 脚本，则会把 lua 脚本开始运行的时间 &lt;code&gt;server.lua_time_start&lt;/code&gt; 作为当前时间，这是为了防止在 lua 脚本运行期间 key 过期同步至从库，从而导致在从库上 lua 脚本的运行和主库不一致的情况发生，详情可见 &lt;a href=&#34;https://github.com/redis/redis/issues/1525&#34;&gt;issue 1525&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果此时正在某个命令运行期间，会使用缓存的 &lt;code&gt;server.mstime&lt;/code&gt; 作为当前时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;expireIfNeeded&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* The return value of the function is 0 if the key is still valid,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * otherwise the function returns 1 if the key is expired. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;expireIfNeeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;正如之前所述，在客户端访问 &lt;code&gt;key&lt;/code&gt; 时可能需要先调用 &lt;code&gt;expireIfNeeded&lt;/code&gt; 检测该 &lt;code&gt;key&lt;/code&gt; 是否已过期。该函数的运行模式与 Redis 服务器角色有关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Redis 主库中，如果此时 &lt;code&gt;key&lt;/code&gt; 已过期，会触发删除 &lt;code&gt;key&lt;/code&gt; 操作，并将删除操作同步至 salves 和 AOF&lt;/li&gt;
&lt;li&gt;在 Redis 从库中，如果此时 &lt;code&gt;key&lt;/code&gt; 已过期，则只会立马返回 1 表示该 &lt;code&gt;key&lt;/code&gt; 已过期，但不会执行删除操作，这是因为从库为了和主库的数据保持一致，其过期 &lt;code&gt;key&lt;/code&gt; 的清理由同步主库的 del 消息完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-主动清理过期键&#34;&gt;4.2. 主动清理过期键&lt;/h3&gt;
&lt;p&gt;之前我们介绍过 Redis 主库除了在访问 key 时触发过期操作，还会定期调用 &lt;code&gt;activeExpireCycle&lt;/code&gt; 清理过期 key，其接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;activeExpireCycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 参数表示该函数使用何种模式运行，共有两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ACTIVE_EXPIRE_CYCLE_FAST&lt;/code&gt;: 在 &lt;code&gt;beforeSleep&lt;/code&gt; 中调用 &lt;code&gt;activeExpireCycle&lt;/code&gt; 时使用该模式，将单次清理过期 key 的执行时间限制在 &lt;code&gt;config_cycle_fast_duration&lt;/code&gt;(默认为 $1ms$) 之内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ACTIVE_EXPIRE_CYCLE_SLOW&lt;/code&gt;: 在 &lt;code&gt;databaseCron&lt;/code&gt; 中调用 &lt;code&gt;activeExpireCycle&lt;/code&gt; 时使用该模式，将定期清理过期 key 操作使用 CPU 占比控制在 &lt;code&gt;config_cycle_slow_time_perc&lt;/code&gt;(默认为 $25%$) 之内，单次执行时间限制为 &lt;code&gt;config_cycle_slow_time_perc*1000000/server.hz/100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述出现的参数可使用配置项 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L938&#34;&gt;active-expire-effort&lt;/a&gt; 配置，对应关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;active-expire-effort&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;fast_duration(ms)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;slow_time_perc&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;keys_per_loop&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;acceptable_stale&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$a + 1$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$1 + \frac{a}{4}$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$25\% + 2a\%$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$20 + 5a$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$10\% - a\%$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$[1, 10]$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$[1, 3.25]$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$[25\%, 43\%]$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$[20, 65]$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$[10\%, 1\%]$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，keys_per_loop(&lt;code&gt;config_keys_per_loop&lt;/code&gt;) 指的是每次迭代扫描的 key 的数量上限，acceptable_stale(&lt;code&gt;config_cycle_acceptable_stale&lt;/code&gt;) 指的是可容忍的已过期键比例。从上表可以的值，当 &lt;code&gt;active-expire-effort&lt;/code&gt; 值越大时，每次清理过期 key 的调用执行时间上限越长，单个迭代内扫描 key 数量上限越大，对已过期键占比的容忍度越低。&lt;/p&gt;
&lt;p&gt;该函数以“伪增量”(期间写入的过期 key 可能在本次全面遍历中未被访问)形式对过期键空间进行扫描，使用局部静态变量记录上次执行的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current_db&lt;/code&gt; 记录上次调用此函数时的 &lt;code&gt;server.db&lt;/code&gt; 的位置，每个 &lt;code&gt;redisDb&lt;/code&gt; 内部的扫描位置则由 &lt;code&gt;redisDb-&amp;gt;expires_cursor&lt;/code&gt; 记录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timelimit_exit&lt;/code&gt; 记录上次执行是否超时。每次调用该函数扫描的 db 数量上限默认为 &lt;code&gt;CRON_DBS_PER_CALL&lt;/code&gt; 如果该值大于 &lt;code&gt;server.dbnum&lt;/code&gt; 或上次该函数执行超时时，每次调用该函数扫描的 db 数量上限则设置为 &lt;code&gt;server.dbnum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last_fast_cycle&lt;/code&gt; 记录上次以 fast 模式运行该函数的起始时间，以防止上次 fast 模式扫描过程超时且尚未终止时启动新的 fast 模式扫描过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在以下情况下，该函数会立马返回，不启动扫描过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 client paused 期间，Redis 数据库是静态的，其不仅会阻止客户端的写入，也不会执行 evict 和 expire 操作，因此，若 &lt;code&gt;server.clients_paused&lt;/code&gt; 为真时，该函数会直接返回&lt;/li&gt;
&lt;li&gt;在 fast 模式下，上次该函数并未超时退出，且此时已过期键占比近似值 &lt;code&gt;server.stat_expired_stale_perc&lt;/code&gt; 小于可容忍上限 &lt;code&gt;config_cycle_acceptable_stale&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 fast 模式下，上次 fast 模式扫描过程超时且可能尚未终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在扫描过程中，该函数会试图遍历指定的 db 数量，其终止条件有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数运行时间超出时间限制&lt;/li&gt;
&lt;li&gt;每个 db 在单次迭代中已过期键占比低于可容忍值，则切换至下一 db，遍历 db 数量达到指定上限时扫描终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在扫描过程中，该函数还会更新 Redis 运行状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;server.stat_expiredkeys&lt;/code&gt;：已过期键总数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redisDb-&amp;gt;avg_ttl&lt;/code&gt;：ttl 近似平均值，先前值为 0 时，使用本次迭代值作为 ttl 近似平均值；否则以先前值权重 $98\%$，单次迭代值权重 $2\%$ 进行加权平均&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server.stat_expired_time_cap_reached_count&lt;/code&gt;：Expire cycles 超时退出次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server.stat_expire_cycle_time_used&lt;/code&gt;: Expire cycles 使用总时间 (ms)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server.stat_expired_stale_perc&lt;/code&gt;：已过期键占比近似值，以先前值占比 $95\%$，本次调用运行值占比 $5\%$ 进行加权平均&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-处于可写模式下的从库清理过期键&#34;&gt;4.3. 处于可写模式下的从库清理过期键&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;44-expire-commands&#34;&gt;4.4. Expire Commands&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;5-evict&#34;&gt;5. evict&lt;/h2&gt;
&lt;p&gt;在之前关于 redis object 的介绍中，我们知道 redis obejct 有一个 filed 为 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/object.c#L51&#34;&gt;lru&lt;/a&gt;，其在创建时初始化，在&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L63&#34;&gt;每次查找操作时更新&lt;/a&gt;，它的作用就是用于挑选目标 key 进行淘汰。&lt;/p&gt;
&lt;p&gt;Redis 作为内存数据库，通常会设置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L859&#34;&gt;maxmemory&lt;/a&gt; 指定可用的最大内存空间大小。若设置了 &lt;code&gt;maxmemory&lt;/code&gt; 值，则 Redis Server 会在每次执行命令之前调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3612&#34;&gt;freeMemoryIfNeededAndSafe&lt;/a&gt; 以检查目前内存使用量是否已经达到 &lt;code&gt;maxmemory&lt;/code&gt;，若为真，会根据设置的 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L890&#34;&gt;maxmemory-policy&lt;/a&gt; 决定淘汰 key 的方式，可选策略如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile-lru&lt;/code&gt;: Evict using approximated LRU, only keys with an expire set.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allkeys-lru&lt;/code&gt;: Evict any key using approximated LRU.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile-lfu&lt;/code&gt;: Evict using approximated LFU, only keys with an expire set.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allkeys-lfu&lt;/code&gt;: Evict any key using approximated LFU.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile-random&lt;/code&gt;: Remove a random key having an expire set.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allkeys-random&lt;/code&gt;: Remove a random key, any key.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile-ttl&lt;/code&gt;: Remove the key with the nearest expire time (minor TTL)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noeviction&lt;/code&gt;: Don&amp;rsquo;t evict anything, just return an error on write operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们重点介绍在 Redis 中 LRU/LFU 相关策略的实现。&lt;/p&gt;
&lt;h3 id=&#34;51-least-recently-usedlru&#34;&gt;5.1. Least Recently Used(LRU)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获取 lruclock&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Return the LRU clock, based on the clock resolution. This is a time
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * in a reduced-bits format that can be used to set and check the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * object-&amp;gt;lru field of redisObject structures. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLRUClock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mstime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LRU_CLOCK_RESOLUTION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LRU_CLOCK_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* This function is used to obtain the current LRU clock.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If the current resolution is lower than the frequency we refresh the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * LRU clock (as it should be in production servers) we return the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * precomputed value, otherwise we need to resort to a system call. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LRU_CLOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过调用 &lt;code&gt;getLRUClock&lt;/code&gt; 可以获得此时的 lruclock 值，其精度由 &lt;code&gt;LRU_CLOCK_RESOLUTION&lt;/code&gt; 控制，数值最大位数为 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L613&#34;&gt;LRU_BITS&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&#34;https://github.com/redis/redis/issues/2552&#34;&gt;issues 2552&lt;/a&gt; 可知，为性能考虑，应尽量避免调用 &lt;code&gt;gettimeofday&lt;/code&gt; 来获取时间，因此 Redis 还提供了 &lt;code&gt;LRU_CLOCK&lt;/code&gt; 接口在 &lt;code&gt;LRU_CLOCK_RESOLUTION&lt;/code&gt; 精度范围内，返回 Redis Server 此时正缓存的 lruclock 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算 idle time&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Given an object returns the min number of milliseconds the object was never
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * requested, using an approximated LRU algorithm. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;estimateObjectIdleTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;52-least-frequently-usedlfu&#34;&gt;5.2. Least Frequently Used(LFU)&lt;/h3&gt;
&lt;p&gt;从 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.h#L623&#34;&gt;redisObject&lt;/a&gt; 的定义中，我们知道 LFU 和 LRU 复用同一 field &lt;code&gt;lru&lt;/code&gt;，因此在 LFU 中访问频率的大小只可用 &lt;code&gt;LRU_BITS&lt;/code&gt; 位来表示。Redis 使用下图所示的结构表示频率：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;         16 bits      8 bits
    +----------------+--------+
    + Last decr time | LOG_C  |
    +----------------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Last decr time&lt;/code&gt;: 最近一次访问时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOG_C&lt;/code&gt;：对数计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增加计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为位数有限，因此 LFU 使用 8-bit 对数计数器 &lt;code&gt;LOG_C&lt;/code&gt; 表示访问频率，在初始 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/object.c#L51&#34;&gt;createObject&lt;/a&gt; 时，值为 &lt;code&gt;LFU_INIT_VAL&lt;/code&gt;，其大小表示其接下来可能会被访问的“潜能”。&lt;/p&gt;
&lt;p&gt;在每次访问 Redis 数据对象时，会调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L48&#34;&gt;LFULogIncr&lt;/a&gt; 尝试增加对数计数，其代码如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Logarithmically increment a counter. The greater is the current counter value
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * the less likely is that it gets really implemented. Saturate it at 255. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LFULogIncr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RAND_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;baseval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LFU_INIT_VAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;baseval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;baseval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;baseval&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lfu_log_factor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，counter 增加满足以下公式：&lt;/p&gt;
&lt;p&gt;$$
NewC =
\begin{cases}
255, &amp;amp; curC = 255 \cr
curC + 1, &amp;amp; curC \le \text{LFU_INIT_VAL} \cr
curC_{1 - p} \enspace | \enspace (curC + 1)_p, &amp;amp; curC &amp;gt; \text{LFU_INIT_VAL} \cr
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;其中当目前计数值大于 &lt;code&gt;LFU_INIT_VAL&lt;/code&gt; 时，会以概率 $p$ 加 1，从代码中可以看出 $p$ 的大小和当前计数值大小反相关。代码中出现的常量 &lt;code&gt;lfu_log_factor&lt;/code&gt; 可通过 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1768&#34;&gt;redis.conf&lt;/a&gt; 配置，其值越大，计数器加 1 的概率就越小，可参考如下表格(表格中 counter 数值非数学期望值)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;factor&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;100 hits&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;1000 hits&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;100K hits&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;1M hits&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;10M hits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;104&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;18&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;49&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;18&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;142&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;49&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;143&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;减小计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 LFU 策略时，需要并不是历史总访问频率的大小，而是“最近”访问频率的信息，因此需要设计合理降低对数计数器的方法。Redis 使用 16-bit 的 &lt;code&gt;Last decr time&lt;/code&gt; 记录数据对象最近一次被访问的时间(取名为 &lt;code&gt;Last decr time&lt;/code&gt; 可能是因为在每次更新 LFU 时会先调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L47&#34;&gt;LFUDecrAndReturn&lt;/a&gt; 下调当前计数值)。相关源码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Return the current time in minutes, just taking the least significant
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 16 bits. The returned time is suitable to be stored as LDT (last decrement
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * time) for the LFU implementation. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LFUGetTimeInMinutes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unixtime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65535&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Given an object last access time, compute the minimum number of minutes
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * that elapsed since the last access. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LFUTimeElapsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LFUGetTimeInMinutes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65535&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* If the object decrement time is reached decrement the LFU counter but
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * do not update LFU fields of the object, we update the access time
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * and counter in an explicit way when the object is really accessed. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LFUDecrAndReturn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_periods&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lfu_decay_time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;
                                &lt;span class=&#34;n&#34;&gt;LFUTimeElapsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ldt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;lfu_decay_time&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_periods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_periods&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_periods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，在 &lt;code&gt;LFUDecrAndReturn&lt;/code&gt; 中，参数 &lt;code&gt;lfu_decay_time&lt;/code&gt; 类似于元素的半衰期，控制着计数值随时间流逝而衰减的行为，其值同样可通过 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1769&#34;&gt;redis.conf&lt;/a&gt; 配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;lfu_decay_time&lt;/code&gt; 为 0 时，计数器不随时间衰减&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;lfu_decay_time&lt;/code&gt; 大于 0 时，每经过 &lt;code&gt;lfu_decay_time&lt;/code&gt; 分钟，计数器减 1，直至为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以发现在 &lt;code&gt;LFUDecrAndReturn&lt;/code&gt; 中并不会改变 &lt;code&gt;robj-&amp;gt;lru&lt;/code&gt; 的值，只是返回此时经过衰减之后的计数值。其值的更改会在每次&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/db.c#L65&#34;&gt;真正访问该数据对象&lt;/a&gt;时发生。&lt;/p&gt;
&lt;h3 id=&#34;53-eviction-pool&#34;&gt;5.3. Eviction pool&lt;/h3&gt;
&lt;p&gt;Redis 使用淘汰候选数组 &lt;code&gt;EvictionPoolLRU&lt;/code&gt; 保存着可淘汰 key 的信息，其中每个候选 key 的相关信息由 &lt;code&gt;evictionPoolEntry&lt;/code&gt; 表示，其结构定义如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;evictionPoolEntry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;cm&#34;&gt;/* Object idle time (inverse frequency for LFU) */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                    &lt;span class=&#34;cm&#34;&gt;/* Key name. */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cached&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;cm&#34;&gt;/* Cached SDS object for key name. */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                   &lt;span class=&#34;cm&#34;&gt;/* Key DB number. */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;evictionPoolEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EvictionPoolLRU&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt; 字段存储该数据对象的键值，但并不会复用 &lt;code&gt;sds&lt;/code&gt;，而是会复制数据对象的键值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cached&lt;/code&gt; 字段是为了在键长度小于 &lt;code&gt;EVPOOL_CACHED_SDS_SIZE&lt;/code&gt; 时复用之前复制数据对象键值时分配的内存空间，否则会申请新的内存空间来存储数据对象的键值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数组 &lt;code&gt;EvictionPoolLRU&lt;/code&gt; 中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 LRU 相关策略时，entry 按照 idle time 从小到大排序&lt;/li&gt;
&lt;li&gt;使用 LFU 相关策略时，entry 按照访问频率从大到小排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 redis server 初始化时，会&lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L2894&#34;&gt;调用 evictionPoolAlloc&lt;/a&gt; 初始化 &lt;code&gt;EvictionPoolLRU&lt;/code&gt;，此时数组中尚无候选 key 信息，&lt;code&gt;cached&lt;/code&gt; 字段指向长为 &lt;code&gt;EVPOOL_CACHED_SDS_SIZE&lt;/code&gt; 的 &lt;code&gt;sds&lt;/code&gt;。数组会在每次需要淘汰 key 时通过调用 &lt;code&gt;evictionPoolPopulate&lt;/code&gt; 填充。其接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;evictionPoolPopulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dbid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                          &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sampledict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                          &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keydict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                          &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;evictionPoolEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dbid&lt;/code&gt;: database ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sampledict&lt;/code&gt;: 采样的 keysapce，随 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L890&#34;&gt;maxmemory-policy&lt;/a&gt; 而定
&lt;ul&gt;
&lt;li&gt;若只能淘汰过期 key，则采样空间为 &lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若所有 key 均可淘汰，则采样空间为 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keydict&lt;/code&gt;: redisDb 的 keysapce，即 &lt;code&gt;redisDb-&amp;gt;dict&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pool&lt;/code&gt;: 静态变量 &lt;code&gt;EvictionPoolLRU&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该函数的大致处理流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从采样空间 &lt;code&gt;sampledict&lt;/code&gt; 中尝试采样 &lt;code&gt;maxmemory_samples&lt;/code&gt; 个数据对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;maxmemory_samples&lt;/code&gt; 可由 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L901&#34;&gt;redis.conf&lt;/a&gt; 配置&lt;/li&gt;
&lt;li&gt;返回的采样结果中，数据对象可能有重复，其总数也可能小于 &lt;code&gt;maxmemory_samples&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得采样数据对象的 idle 值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果淘汰策略为 LRU 相关， &lt;code&gt;idle = estimateObjectIdleTime(o)&lt;/code&gt;，即为该对象的 idle time&lt;/li&gt;
&lt;li&gt;如果淘汰策略为 LFU 相关，&lt;code&gt;idle = 255 - LFUDecrAndReturn(o)&lt;/code&gt;，此时对数计数器值越大，idle 越小&lt;/li&gt;
&lt;li&gt;如果淘汰策略为 TTL 相关，&lt;code&gt;idle = ULLONG_MAX - expire_unix_time&lt;/code&gt;，越早过期，idle 越大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 idle 值，将该数据对象插入 &lt;code&gt;EvictionPoolLRU&lt;/code&gt; 中相应的位置，维持数组的有序性(idle 从小到大)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;54-free-memory&#34;&gt;5.4. Free memory&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获得目前数据库内存使用情况&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* We don&amp;#39;t want to count AOF buffers and slaves output buffers as
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * used memory: the eviction should use mostly data size. This function
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * returns the sum of AOF and slaves buffer. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeMemoryGetNotCountedMemory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Get the memory status from the point of view of the maxmemory directive:
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * if the memory used is under the maxmemory setting then C_OK is returned.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Otherwise, if we are over the memory limit, the function returns C_ERR. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getMaxmemoryState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;logical&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tofree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Redis 在进行淘汰 key 操作时，会排除 slave 和 AOF 客户端缓冲区占用的内存，该排除部分的值大小可调用 &lt;code&gt;freeMemoryGetNotCountedMemory&lt;/code&gt; 获得。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;getMaxmemoryState&lt;/code&gt; 中，除了返回 &lt;code&gt;C_OK&lt;/code&gt; 或 &lt;code&gt;C_ERR&lt;/code&gt; 表示是否超最大内存限制之外，还会视情况填充传入的非 &lt;code&gt;NULL&lt;/code&gt; 参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;: total amount of bytes used. (Populated both for C_ERR and C_OK)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logical&lt;/code&gt;: the amount of memory used minus the slaves/AOF buffers. (Populated when C_ERR is returned)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tofree&lt;/code&gt;: the amount of memory that should be released in order to return back into the memory limits. (Populated when C_ERR is returned)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;level&lt;/code&gt;: the ratio of memory usage (used_memory/maxmemory). (Populated both for C_ERR and C_OK)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;freeMemoryIfNeeded&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如前文所述，Redis 服务器设置了 &lt;code&gt;maxmemory&lt;/code&gt; 值时，会在每次执行命令之前调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/src/server.c#L3612&#34;&gt;freeMemoryIfNeededAndSafe&lt;/a&gt; 以检查目前内存使用量是否已经达到 &lt;code&gt;maxmemory&lt;/code&gt;，该函数源码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeMemoryIfNeededAndSafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lua_timedout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;loading&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C_OK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;freeMemoryIfNeeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，&lt;code&gt;freeMemoryIfNeededAndSafe&lt;/code&gt; 会在以下两种情况下，不检测当前内存使用状况，直接返回 &lt;code&gt;C_OK&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前有执行超时的 lua 脚本&lt;/li&gt;
&lt;li&gt;当前正在加载数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;code&gt;freeMemoryIfNeeded&lt;/code&gt; 函数中，会根据当前内存使用状况和 &lt;code&gt;maxmemory&lt;/code&gt; 值尝试进行内存释放操作以使内存使用量满足 &lt;code&gt;maxmemory&lt;/code&gt; 的限制。其接口如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeMemoryIfNeeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;一般情况下，当前内存使用量低于 &lt;code&gt;maxmemory&lt;/code&gt; 或在进行释放内存操作后低于 &lt;code&gt;maxmemory&lt;/code&gt; 时，函数返回 &lt;code&gt;C_OK&lt;/code&gt;，否则返回 &lt;code&gt;C_ERR&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;默认情况下从库无 &lt;code&gt;maxmemory&lt;/code&gt; 限制，直接返回 &lt;code&gt;C_OK&lt;/code&gt;
&lt;blockquote&gt;
&lt;p&gt;可通过将 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L922&#34;&gt;replica-ignore-maxmemory&lt;/a&gt; 设置为 no，使得从库也执行驱逐策略，但可能会造成主从数据不一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在 client paused 期间，Redis 数据库是静态的，其不仅会阻止客户端的写入，也不会执行 evict 和 expire 操作，因此，若 &lt;code&gt;server.clients_paused&lt;/code&gt; 为真时，该函数会直接返回 &lt;code&gt;C_OK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当内存管理策略为 &lt;code&gt;noeviction&lt;/code&gt; 时，会检查当前 lazyfree 队列中是否有任务，若为真则等待 &lt;code&gt;lazyfree&lt;/code&gt; 任务完成后调用 &lt;code&gt;getMaxmemoryState&lt;/code&gt; 得到此时的内存使用状态并返回&lt;/li&gt;
&lt;li&gt;根据内存管理策略采样选择最合适的 key 进行淘汰直至内存使用量低于 &lt;code&gt;maxmemory&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当内存管理策略不为 random 相关类型时，每次删除一个 key 之前都会调用 &lt;code&gt;evictionPoolPopulate&lt;/code&gt; 填充 evict pool，随后从后往前遍历得到此时最适合删除的 key&lt;/li&gt;
&lt;li&gt;当内存管略为 volatile 相关类型时，因为采样空间 &lt;code&gt;redisDb-&amp;gt;expires&lt;/code&gt; 可能为空，因此可能无法通过淘汰 key 使得内存使用量低于 &lt;code&gt;maxmemory&lt;/code&gt;，此时只能和 &lt;code&gt;noeviction&lt;/code&gt; 一样，等待 lazyfree 的操作结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- Object</title>
      <link>https://k-on.me/post/redis-sourcecode-object/</link>
      <pubDate>Fri, 09 Oct 2020 10:44:07 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-object/</guid>
      
        <description>&lt;p&gt;Redis Object 相关源码阅读笔记，源码文件 &lt;code&gt;server.h&lt;/code&gt; 和 &lt;code&gt;object.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;redisObject&lt;/code&gt; 主要由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：数据对象的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding&lt;/code&gt;：数据对象的编码格式，同一类型具有多个编码格式的目的是为了节省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lru&lt;/code&gt;：内存策略相关统计值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refcount&lt;/code&gt;：引用计数，共享对象以节省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ptr&lt;/code&gt;：数据对象的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-object-数据结构&#34;&gt;2. Object 数据结构&lt;/h2&gt;
&lt;p&gt;在 Redis 中，各个数据类型，均使用 &lt;code&gt;redisObject&lt;/code&gt; 表示，其定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;redisObject&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LRU_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* LRU time (relative to global lru_clock) or
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                            * LFU data (least significant 8 bits frequency
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                            * and most significant 16 bits access time). */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中，&lt;code&gt;type&lt;/code&gt; 用来区分不同的数据类型，目前共有 7 种数据类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_STRING 0    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* String object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_LIST 1      &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* List object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_SET 2       &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Set object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ZSET 3      &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Sorted set object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_HASH 4      &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Hash object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_MODULE 5    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Module object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_STREAM 6    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Stream object. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;encoding&lt;/code&gt; 则表示数据对象的编码格式，目前共使用 9 中编码格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_RAW 0        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Raw representation */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_INT 1        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as integer */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_HT 2         &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as hash table */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_ZIPMAP 3     &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* No longer used */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_LINKEDLIST 4 &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* No longer used: old list encoding. */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_ZIPLIST 5    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as ziplist */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_INTSET 6     &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as intset */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_SKIPLIST 7   &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as skiplist */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_EMBSTR 8     &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Embedded sds string encoding */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_QUICKLIST 9  &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as linked list of ziplists */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_STREAM 10    &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* Encoded as a radix tree of listpacks */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为节省内存使用，同一 &lt;code&gt;type&lt;/code&gt; 可能会使用多种 &lt;code&gt;encoding&lt;/code&gt;，其对应关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;encoding&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;situation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_STRING&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_RAW&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;默认项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_INT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字符串为整型，且数值大小在 &lt;code&gt;LONG_MIN&lt;/code&gt; 和 &lt;code&gt;LONG_MAX&lt;/code&gt; 之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_EMBSTR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字符串长度小于 &lt;code&gt;OBJ_ENCODING_EMBSTR_SIZE_LIMIT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_QUICKLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_SET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_INTSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Integers in radix 10 in the range of 64 bit signed integers &amp;amp;&amp;amp; number of entries $\le$ &lt;code&gt;set-max-intset-entries&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_HT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Others&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ZSET&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Number of entries $\le$ &lt;code&gt;zset-max-ziplist-entries&lt;/code&gt; &amp;amp;&amp;amp; value size $\le$ &lt;code&gt;zset-max-ziplist-value&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Others&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_HASH&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Number of entries $\le$ &lt;code&gt;hash-max-ziplist-entries&lt;/code&gt; &amp;amp;&amp;amp; value size $\le$ &lt;code&gt;hash-max-ziplist-value&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_HT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Others&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_MODULE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_RAW&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_STREAM&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OBJ_ENCODING_STREAM&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;All&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此外，&lt;code&gt;lru&lt;/code&gt; 字段的含义和 Redis 使用的 key 驱逐策略(LRU,LFU&amp;hellip;)有关，&lt;code&gt;refcount&lt;/code&gt; 为引用计数，&lt;code&gt;ptr&lt;/code&gt; 指向具体数据内容。&lt;/p&gt;
&lt;h2 id=&#34;3-object-apis&#34;&gt;3. Object APIs&lt;/h2&gt;
&lt;h3 id=&#34;31-构造函数&#34;&gt;3.1. 构造函数&lt;/h3&gt;
&lt;h4 id=&#34;311-createobject&#34;&gt;3.1.1. createObject&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;根据传入的参数创建编码格式为 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 的数据对象，此时 &lt;code&gt;robj&lt;/code&gt; 和其内容 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 未确保连续存放。&lt;/p&gt;
&lt;h4 id=&#34;312-string-object&#34;&gt;3.1.2. String Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * string object where o-&amp;gt;ptr points to a proper sds string. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createRawStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * an object where the sds string is actually an unmodifiable string
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * allocated in the same chunk as the object itself. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createEmbeddedStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Create a string object with EMBSTR encoding if it is smaller than
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * used.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The current limit of 44 is chosen so that the biggest string object
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OBJ_ENCODING_EMBSTR_SIZE_LIMIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createEmbeddedStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createRawStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出在 &lt;code&gt;createStringObject&lt;/code&gt; 中，如果字符串长度小于 44，则选用 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt; 编码，否则使用 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 编码时，&lt;code&gt;robj&lt;/code&gt; 和其内容 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 未连续存放，&lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 可以指向任意类型的 &lt;code&gt;sds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt; 编码时，&lt;code&gt;robj&lt;/code&gt; 和其内容 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 连续存放，&lt;code&gt;robj-ptr&lt;/code&gt; 指向 &lt;code&gt;sdshdr8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sdshdr8&lt;/code&gt; 的长度上限为 64，但是此处为了使得整个 &lt;code&gt;robj&lt;/code&gt; fit into the 64 byte arena of jemalloc，因此 &lt;code&gt;OBJ_ENCODING_EMBSTR_SIZE_LIMIT&lt;/code&gt; 为 44
&lt;blockquote&gt;
&lt;p&gt;64 - sizeof(robj) - sizeof(struct sdshdr8) - sizeof(&#39;\0&#39;) = 64 - 16 - 3 - 1 = 44&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a string object from a long long value. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStringObjectFromLongLongWithOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;valueobj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;valueobj == 0&lt;/code&gt; 且数值在区间 $[0, 10000]$ 内，则使用共享对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 key 驱逐策略不为 &lt;code&gt;MAXMEMORY_FLAG_LRU&lt;/code&gt; 或 &lt;code&gt;MAXMEMORY_FLAG_LFU&lt;/code&gt; 时，&lt;code&gt;valueobj&lt;/code&gt; 置为 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果数值大小在 &lt;code&gt;LONG_MIN&lt;/code&gt; 和 &lt;code&gt;LONG_MAX&lt;/code&gt; 之间，使用 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt; 编码，否则使用 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt; 编码时，&lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 中存储的内容为整型值，而不是地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Wrapper for createStringObjectFromLongLongWithOptions() always demanding
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * to create a shared object if possible. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStringObjectFromLongLong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Wrapper for createStringObjectFromLongLongWithOptions() avoiding a shared
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * object when LFU/LRU info are needed, that is, when the object is used
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * as a value in the key space, and Redis is configured to evict based on
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * LFU/LRU. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStringObjectFromLongLongForValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Create a string object from a long double. If humanfriendly is non-zero
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * it does not use exponential format and trims trailing zeroes at the end,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * however this results in loss of precision. Otherwise exp format is used
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * and the output of snprintf() is not modified.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The &amp;#39;humanfriendly&amp;#39; option is used for INCRBYFLOAT and HINCRBYFLOAT. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStringObjectFromLongDouble&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;humanfriendly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Duplicate a string object */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dupStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;该函数保证返回的对象和传入的对象编码方式相同&lt;/li&gt;
&lt;li&gt;当字符串对象表示整型时，即使是在 $[0, 10000]$ 范围内，该函数也不会使用共享对象，会构造新的字符串对象，因此该函数返回的对象中 &lt;code&gt;o-&amp;gt;refcount&lt;/code&gt; 始终为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;313-list-object&#34;&gt;3.1.3. List Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_QUICKLIST */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createQuicklistObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_ZIPLIST */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createZiplistObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;createZiplistObject&lt;/code&gt; 已不再使用，&lt;a href=&#34;https://github.com/redis/redis/pull/2143&#34;&gt;列表编码格式仅为 &lt;code&gt;OBJ_ENCODING_QUICKLIST&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;314-set-object&#34;&gt;3.1.4. Set Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_HT */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createSetObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_INTSET */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createIntsetObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;315-hash-object&#34;&gt;3.1.5. Hash Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_ZIPLIST */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createHashObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;316-zset-object&#34;&gt;3.1.6. Zset Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_SKIPLIST */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createZsetObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_ZIPLIST */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createZsetZiplistObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;317-stream-object&#34;&gt;3.1.7. Stream Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_STREAM */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createStreamObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;318-module-object&#34;&gt;3.1.8. Module Object&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* robj-&amp;gt;encoding is OBJ_ENCODING_RAW */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createModuleObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;moduleType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;32-析构函数&#34;&gt;3.2. 析构函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeStringObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeListObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeSetObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeZsetObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;freeHashObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;只有在对象为字符串类型，且其编码格式为 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt; 或 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt; 时，只需释放 &lt;code&gt;robj&lt;/code&gt; 对象即可。在其他情况下，还需释放 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 所指向的数据内容。&lt;/p&gt;
&lt;h3 id=&#34;33-引用计数相关&#34;&gt;3.3. 引用计数相关&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Set a special refcount in the object to make it &amp;#34;shared&amp;#34;:
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * incrRefCount and decrRefCount() will test for this special refcount
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * and will not touch the object. This way it is free to access shared
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * objects such as small integers from different threads without any mutex. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;makeObjectShared&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;o-&amp;gt;refcount&lt;/code&gt; 值设置为 &lt;code&gt;OBJ_SHARED_REFCOUNT&lt;/code&gt;，以将该对象标记为 shared。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;incrRefCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;o-&amp;gt;refcount == OBJ_SHARED_REFCOUNT&lt;/code&gt; 时，说明该对象为共享对象，无操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o-&amp;gt;refcount == OBJ_STATIC_REFCOUNT&lt;/code&gt; 时，试图增加栈上对象引用计数，会导致 panic&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;decrRefCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* This variant of decrRefCount() gets its argument as void, and is useful
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * as free method in data structures that expect a &amp;#39;void free_object(void*)&amp;#39;
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * prototype for the free method. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;decrRefCountVoid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;o-&amp;gt;refcount == OBJ_SHARED_REFCOUNT&lt;/code&gt; 时，说明该对象为共享对象，无操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o-&amp;gt;refcount == 1&lt;/code&gt; 时，会先根据 &lt;code&gt;robj-&amp;gt;type&lt;/code&gt; 调用指定的析构函数释放 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 所指向的内存，再释放 &lt;code&gt;robj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o-&amp;gt;refcount&lt;/code&gt; 小于 0 时，panic&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* This function set the ref count to zero without freeing the object. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;resetRefCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;34-string-对象相关&#34;&gt;3.4. String 对象相关&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;判断是否可转换为整型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isSdsRepresentableAsLongLong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;判断传入的 &lt;code&gt;sds&lt;/code&gt; 是否可以转换为 &lt;code&gt;long long&lt;/code&gt; 类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若可以，且 &lt;code&gt;llval&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt;，则 &lt;code&gt;llval&lt;/code&gt; 中存储了该整型数值，函数返回 &lt;code&gt;C_OK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若不行，函数返回 &lt;code&gt;C_ERR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;isObjectRepresentableAsLongLong&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llongval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;与 &lt;code&gt;isSdsRepresentableAsLongLong&lt;/code&gt; 类似，判断传入的 &lt;code&gt;robj&lt;/code&gt; 是否可以转换为 &lt;code&gt;long long&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节省内存&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Optimize the SDS string inside the string object to require little space,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * in case there is more than 10% of free space at the end of the SDS
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * string. This happens because SDS strings tend to overallocate to avoid
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * wasting too much time in allocations when appending to the string. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;trimStringObjectIfNeeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Try to encode a string object in order to save space */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;tryObjectEncoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;trimStringObjectIfNeeded&lt;/code&gt; 中，如果 String 对象的编码格式为 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 且 &lt;code&gt;robj-&amp;gt;ptr&lt;/code&gt; 所指向的 &lt;code&gt;sds&lt;/code&gt; 还有超过 $10%$ 的空闲空间，则会对 &lt;code&gt;sds&lt;/code&gt; 进行缩容。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;tryObjectEncoding&lt;/code&gt; 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果字符串对象可以转换为 &lt;code&gt;long&lt;/code&gt; 类型，则会将编码格式转换为 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果字符串对象长度小于 &lt;code&gt;OBJ_ENCODING_EMBSTR_SIZE_LIMIT&lt;/code&gt;，则会将编码方式从 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 转换为 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在不能转换编码方式的情况下，最后会调用 &lt;code&gt;trimStringObjectIfNeeded&lt;/code&gt; 尝试缩容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Compare two string objects via strcmp() or strcoll() depending on flags.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Note that the objects may be integer-encoded. In such a case we
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * use ll2string() to get a string representation of the numbers on the stack
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * and compare the strings, it&amp;#39;s much faster than calling getDecodedObject().
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Important note: when REDIS_COMPARE_BINARY is used a binary-safe comparison
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * is used. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;compareStringObjectsWithFlags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Wrapper for compareStringObjectsWithFlags() using binary comparison. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;compareStringObjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Wrapper for compareStringObjectsWithFlags() using collation. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;collateStringObjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Equal string objects return 1 if the two objects are the same from the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * point of view of a string comparison, otherwise 0 is returned. Note that
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * this function is faster then checking for (compareStringObject(a,b) == 0)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * because it can perform some more optimization. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;equalStringObjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devdocs.io/c/string/byte/strcmp&#34;&gt;strcmp&lt;/a&gt;: Compares two null-terminated byte strings lexicographically.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devdocs.io/c/string/byte/strcoll&#34;&gt;strcoll&lt;/a&gt;: Compares two null-terminated byte strings according to the current locale as defined by the LC_COLLATE category.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Get APIs&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Get a decoded version of an encoded object (returned as a new object).
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If the object is already raw-encoded just increment the ref count. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getDecodedObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果编码格式为 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 或 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt;，调用 &lt;code&gt;incrRefCount&lt;/code&gt; 后直接返回 &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果编码格式为 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt;，则根据 &lt;code&gt;o&lt;/code&gt; 构造编码格式为 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 或 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt; 的 String 对象并返回其指针&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stringObjectLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果编码格式为 &lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt; 或 &lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt;，则返回 &lt;code&gt;sds-&amp;gt;len&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果编码格式为 &lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt;，则返回该整型转换为 10 进制之后的字符串长度&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getDoubleFromObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getDoubleFromObjectOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLongDoubleFromObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLongDoubleFromObjectOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLongLongFromObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLongLongFromObjectOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getLongFromObjectOrReply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;35-utils&#34;&gt;3.5. Utils&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* 检查 robj 的类型是否和传入的 type 相同，相同返回 1，不同则返回 0 */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;checkType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* 返回字符串表示该编码的具体含义 */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;strEncoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;36-todo&#34;&gt;3.6. TODO&lt;/h3&gt;
&lt;p&gt;内存使用量统计 &amp;amp; OBJECT and MEMORY Commands 实现。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- skiplist</title>
      <link>https://k-on.me/post/redis-sourcecode-skiplist/</link>
      <pubDate>Tue, 06 Oct 2020 11:10:35 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-skiplist/</guid>
      
        <description>&lt;p&gt;Redis 跳跃表相关源码阅读笔记，源码文件 &lt;code&gt;server.h&lt;/code&gt; &amp;amp; &lt;code&gt;t_zset.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;p&gt;在 Redis 中实现的跳跃表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大层数为 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/src/server.h#L358&#34;&gt;ZSKIPLIST_MAXLEVEL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;跳跃表中不允许相同的 &lt;code&gt;ele&lt;/code&gt;，允许相同的 &lt;code&gt;score&lt;/code&gt;，按 &lt;code&gt;&amp;lt;score, ele&amp;gt;&lt;/code&gt; pair 进行排序&lt;/li&gt;
&lt;li&gt;增加 &lt;code&gt;backward&lt;/code&gt; 指针，可反向遍历跳跃表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-跳跃表相关数据结构&#34;&gt;2. 跳跃表相关数据结构&lt;/h2&gt;
&lt;p&gt;跳跃表之于普通链表，如同增加快速通道的地铁线路之于单一地铁线路，从&lt;strong&gt;普通&lt;/strong&gt;到&lt;strong&gt;特急&lt;/strong&gt;停靠站越来越少，因此到达目的地所需时间也越短。跳跃表也是利用“快速通道”使得查找、插入和删除等操作更高效，可通过阅读&lt;a href=&#34;https://en.wikipedia.org/wiki/Skip_list&#34;&gt;维基百科&lt;/a&gt;了解详情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.pimg.tw/kevin760515/1458824287-246944453.png&#34; alt=&#34;地铁路线图&#34;&gt;&lt;/p&gt;
&lt;p&gt;Redis 中跳跃表大致基于论文&lt;a href=&#34;https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf&#34;&gt;Skip Lists: A Probabilistic Alternative to Balanced Trees&lt;/a&gt;实现，但有三处改动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许相同的 &lt;code&gt;score&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较不仅仅是基于 &lt;code&gt;score&lt;/code&gt; 的大小&lt;/li&gt;
&lt;li&gt;增加 &lt;code&gt;backward&lt;/code&gt; 指针，用于反向遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://k-on.me/redis/skip_lists.png&#34; alt=&#34;skip_lists&#34;&gt;&lt;/p&gt;
&lt;p&gt;跳跃表 &lt;code&gt;zskiplist&lt;/code&gt; 的结构如下所示:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 分别指向跳跃表的头尾节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;length&lt;/code&gt; 记录该跳跃表中节点个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;level&lt;/code&gt; 记录该跳跃表中除头节点外其他节点的最大层数，其上限为 &lt;code&gt;ZSKIPLIST_MAXLEVEL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在跳跃表中，每个节点 &lt;code&gt;zskiplistNode&lt;/code&gt; 的结构如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistLevel&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ele&lt;/code&gt;: &lt;code&gt;member&lt;/code&gt; 的地址，不允许相同的 &lt;code&gt;member&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backward&lt;/code&gt;: 指向前一节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;level[]&lt;/code&gt;: 每个节点含有复数层的遍历通道，每一层包含在该层下一节点的地址 &lt;code&gt;forward&lt;/code&gt;，以及此时的步长 &lt;code&gt;span&lt;/code&gt;，当 &lt;code&gt;forward&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; 时，&lt;code&gt;span&lt;/code&gt; 等于 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，还有表示 &lt;code&gt;score&lt;/code&gt; 区间的 &lt;code&gt;zrangespec&lt;/code&gt; 和 &lt;code&gt;ele&lt;/code&gt; 区间的 &lt;code&gt;zlexrangespec&lt;/code&gt;，定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Struct to hold a inclusive/exclusive range spec by score comparison. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* are min or max exclusive? */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* May be set to shared.(minstring|maxstring) */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* are min or max exclusive? */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-跳跃表-apis&#34;&gt;3. 跳跃表 APIs&lt;/h2&gt;
&lt;h3 id=&#34;31-构造函数&#34;&gt;3.1. 构造函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create a skiplist node with the specified number of levels.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The SDS string &amp;#39;ele&amp;#39; is referenced by the node after the call. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslCreateNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Create a new skiplist. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslCreate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;初始化时，&lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 等于 1，头节点的 &lt;code&gt;level&lt;/code&gt; 数组长度为 &lt;code&gt;ZSKIPLIST_MAXLEVEL&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-析构函数&#34;&gt;3.2. 析构函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Free the specified skiplist node. The referenced SDS string representation
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * of the element is freed too, unless node-&amp;gt;ele is set to NULL before calling
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * this function. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslFreeNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Free a whole skiplist. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslFree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;33-插入节点&#34;&gt;3.3. 插入节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;zslRandomLevel&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Returns a random level for the new skiplist node we are going to create.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * (both inclusive), with a powerlaw-alike distribution where higher
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * levels are less likely to be returned. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslRandomLevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;返回一个随机的 &lt;code&gt;level&lt;/code&gt;，设 &lt;code&gt;ZSKIPLIST_P&lt;/code&gt; 为 $p$，&lt;code&gt;ZSKIPLIST_MAXLEVEL&lt;/code&gt; 为 $ml$ 则 &lt;code&gt;level&lt;/code&gt; 值 $i$ 与其对应的概率 $P(i)$ 满足下式：&lt;/p&gt;
&lt;p&gt;$$
P(i) =
\begin{cases}
(1-p)p^{i-1},  &amp;amp; i \ne ml \cr
1 - \Sigma_{i=1}^{ml - 1}P(i), &amp;amp; i = ml \cr
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zslInsert&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Insert a new node in the skiplist. Assumes the element does not already
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * exist (up to the caller to enforce that). The skiplist takes ownership
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * of the passed SDS string &amp;#39;ele&amp;#39;. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslInsert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;插入一个新节点至跳跃表，调用方应保证 &lt;code&gt;ele&lt;/code&gt; 此前不存在于跳跃表 &lt;code&gt;zsl&lt;/code&gt; 中。插入操作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;按照 &lt;code&gt;level&lt;/code&gt; 从大到小寻找每一层中最靠近($&amp;lt;$)新节点的目标节点并记录其地址 (该目标节点 score 小于新节点 &lt;code&gt;socre&lt;/code&gt; 或 score 相同时 ele 小于新节点 &lt;code&gt;ele&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;zslRandomLevel&lt;/code&gt; 给新节点生成一个随机的 &lt;code&gt;level&lt;/code&gt; 值，若该 &lt;code&gt;level&lt;/code&gt; 值大于 &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt;，则将为 &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 至 &lt;code&gt;level&lt;/code&gt; 每层最靠近新节点的目标节点初始化为头节点，随后更新 &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 &lt;code&gt;level&lt;/code&gt;、&lt;code&gt;score&lt;/code&gt; 和 &lt;code&gt;ele&lt;/code&gt; 值调用 &lt;code&gt;zslCreateNode&lt;/code&gt; 创建新节点，并将其插入跳跃表中，更新新节点以及每层中最靠近新节点的目标节点的 &lt;code&gt;level&lt;/code&gt; 数组的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新节点 &lt;code&gt;level&lt;/code&gt; 值大于之前 &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 时，每层目标节点的 &lt;code&gt;forward&lt;/code&gt; 和 &lt;code&gt;span&lt;/code&gt; 都需更新&lt;/li&gt;
&lt;li&gt;新节点 &lt;code&gt;level&lt;/code&gt; 值小于之前 &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 时，0 -&amp;gt; &lt;code&gt;level&lt;/code&gt; 层目标节点的 &lt;code&gt;forward&lt;/code&gt; 和 &lt;code&gt;span&lt;/code&gt; 都需更新，而 &lt;code&gt;level&lt;/code&gt; -&amp;gt; &lt;code&gt;zsl-&amp;gt;level&lt;/code&gt; 层目标节点只需更新 &lt;code&gt;span&lt;/code&gt; 值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新新节点和其后一节点(level = 0)的 &lt;code&gt;backward&lt;/code&gt; 指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 &lt;code&gt;zsl-&amp;gt;length&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出，在跳跃表中查找操作和在不考虑换乘时间的情况下最快到达目的车站所采取的策略相同，要点有二:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能搭乘快速列车，也即要在该层找到新节点的左极限&lt;/li&gt;
&lt;li&gt;不要坐过站，也即每次在该层新节点的左极限时跳转至下层，寻找更接近新节点的跳跃表节点，直至最底层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-score-range-apis&#34;&gt;3.4. Score range APIs&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Populate the rangespec according to the objects min and max.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Parse the min-max interval. If one of the values is prefixed
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * by the &amp;#34;(&amp;#34; character, it&amp;#39;s considered &amp;#34;open&amp;#34;. For instance
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * ZRANGEBYSCORE zset (1.5 (2.5 will match min &amp;lt; x &amp;lt; max
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * ZRANGEBYSCORE zset 1.5 2.5 will instead match min &amp;lt;= x &amp;lt;= max */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslParseRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Returns if there is a part of the zset is in range. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslIsInRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Find the first node that is contained in the specified range.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns NULL when no element is contained in the range. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslFirstInRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Find the last node that is contained in the specified range.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns NULL when no element is contained in the range. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslLastInRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;35-lexicographic-range-apis&#34;&gt;3.5. Lexicographic range APIs&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Parse max or min argument of ZRANGEBYLEX.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * (foo means foo (open interval)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * [foo means foo (closed interval)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * - means the min string possible
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * + means the max string possible
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * If the string is valid the *dest pointer is set to the redis object
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * that will be used for the comparison, and ex will be set to 0 or 1
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * respectively if the item is exclusive or inclusive. C_OK will be
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * returned.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * If the string is not a valid range C_ERR is returned, and the value
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  * of *dest and *ex is undefined. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslParseLexRangeItem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Free a lex range structure, must be called only after zelParseLexRange()
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * populated the structure with success (C_OK returned). */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslFreeLexRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Populate the lex rangespec according to the objects min and max.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Return C_OK on success. On error C_ERR is returned.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * When OK is returned the structure must be freed with zslFreeLexRange(),
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * otherwise no release is needed. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslParseLexRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Returns if there is a part of the zset is in the lex range. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslIsInLexRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Find the first node that is contained in the specified lex range.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns NULL when no element is contained in the range. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslFirstInLexRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Find the last node that is contained in the specified range.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns NULL when no element is contained in the range. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslLastInLexRange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于跳跃表是按照 &lt;code&gt;score&lt;/code&gt; 排序的，因此 &lt;code&gt;zslFirstInLexRange&lt;/code&gt; 返回的节点可能比 &lt;code&gt;zslLastInLexRange&lt;/code&gt; 返回的节点位置靠后。&lt;/p&gt;
&lt;h3 id=&#34;36-删除节点&#34;&gt;3.6. 删除节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;zslDeleteNode&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Internal function used by zslDelete, zslDeleteRangeByScore and
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * zslDeleteRangeByRank. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslDeleteNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从跳跃表 &lt;code&gt;zsl&lt;/code&gt; 中删除指定的节点 &lt;code&gt;x&lt;/code&gt;，传入的 &lt;code&gt;update&lt;/code&gt; 数组记录了每层中最靠近(&amp;lt;) &lt;code&gt;x&lt;/code&gt; 的节点地址。值得注意的是，在该函数中无释放操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zslDelete&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Delete an element with matching score/element from the skiplist.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The function returns 1 if the node was found and deleted, otherwise
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 0 is returned.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If &amp;#39;node&amp;#39; is NULL the deleted node is freed by zslFreeNode(), otherwise
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * it is not freed (but just unlinked) and *node is set to the node pointer,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * so that it is possible for the caller to reuse the node (including the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * referenced SDS string at node-&amp;gt;ele). */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从跳跃表 &lt;code&gt;zsl&lt;/code&gt; 中根据 &lt;code&gt;score&lt;/code&gt; 和 &lt;code&gt;ele&lt;/code&gt; 参数删除特定的节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该特定节点存在时，删除成功，返回 1，不存在时，删除失败，返回 0&lt;/li&gt;
&lt;li&gt;传入的 &lt;code&gt;node&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; 时，保存被删除节点的地址，&lt;code&gt;node&lt;/code&gt; 为空时直接释放被删除节点所占内存&lt;/li&gt;
&lt;li&gt;该函数会先寻找距离被删除节点最靠近的目标节点数组，然后调用 &lt;code&gt;zslDeleteNode&lt;/code&gt; 执行删除操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;zslDeleteRangeBy&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Delete all the elements with score between min and max from the skiplist.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Min and max are inclusive, so a score &amp;gt;= min || score &amp;lt;= max is deleted.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Note that this function takes the reference to the hash table view of the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * sorted set, in order to remove the elements from the hash table too. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslDeleteRangeByScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete all the elements with ele between min and max from the skiplist. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslDeleteRangeByLex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zlexrangespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete all the elements with rank between start and end from the skiplist.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Start and end are inclusive. Note that start and end need to be 1-based */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslDeleteRangeByRank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                   &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;37-zslupdatescore&#34;&gt;3.7. zslUpdateScore&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Update the score of an elmenent inside the sorted set skiplist.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Note that the element must exist and must match &amp;#39;score&amp;#39;.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * This function does not update the score in the hash table side, the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * caller should take care of it.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Note that this function attempts to just update the node, in case after
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * the score update, the node would be exactly at the same position.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Otherwise the skiplist is modified by removing and re-adding a new
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * element, which is more costly.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * The function returns the updated element skiplist node pointer. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;zslUpdateScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curscore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newscore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;调用方需确保根据 &lt;code&gt;cursorce&lt;/code&gt; 和 &lt;code&gt;ele&lt;/code&gt; 匹配的节点必须存在在跳跃表中&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;newscore&lt;/code&gt; 不改变节点次序，该函数会就地更新指定节点的 &lt;code&gt;score&lt;/code&gt; 值，否则会先从跳跃表中删除原节点，再根据 &lt;code&gt;ele&lt;/code&gt; 和 &lt;code&gt;newsocre&lt;/code&gt; 重新插入新节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;38-get-apis&#34;&gt;3.8. Get APIs&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Find the rank for an element by both score and key.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Returns 0 when the element cannot be found, rank otherwise.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Note that the rank is 1-based due to the span of zsl-&amp;gt;header to the
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * first element. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslGetRank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Finds an element by its rank. The rank argument needs to be 1-based. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;zslGetElementByRank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zsl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rank&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- intset</title>
      <link>https://k-on.me/post/redis-sourcecode-intset/</link>
      <pubDate>Mon, 28 Sep 2020 21:06:04 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-intset/</guid>
      
        <description>&lt;p&gt;Redis 整型集合相关源码阅读笔记，源码文件 &lt;code&gt;intset.h&lt;/code&gt; &amp;amp; &lt;code&gt;intset.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-intset-相关数据结构&#34;&gt;1. intset 相关数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;encoding&lt;/code&gt;: &lt;code&gt;intset&lt;/code&gt; 的编码方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有三种: &lt;code&gt;INTSET_ENC_INT16&lt;/code&gt;, &lt;code&gt;INTSET_ENC_INT32&lt;/code&gt; 和 &lt;code&gt;INTSET_ENC_INT64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在新插入的值超出当前编码的值范围时，编码会提升，但其提升后无法下降&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;length&lt;/code&gt;: &lt;code&gt;intset&lt;/code&gt; 中的整数个数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;contents&lt;/code&gt; 存储的整数是有序的，因此可存储长度以用于二分查找&lt;/li&gt;
&lt;li&gt;为维护有序性以及采用正确的编码方式，每次插入删除会有内存重分配和内存拷贝过程，因此 &lt;code&gt;intset&lt;/code&gt; 的长度不宜过长，其上限可在 &lt;code&gt;redis.conf&lt;/code&gt; 中通过设置 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.8/redis.conf#L1570&#34;&gt;set-max-intset-entries&lt;/a&gt; 进行配置，当整数集合中的元素个数超过此长度时，集合的底层实现会转为使用 &lt;code&gt;dict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;contents&lt;/code&gt;: &lt;code&gt;contents&lt;/code&gt; 存储的整数是有序的，且不含重复值，其类型取决于 &lt;code&gt;encoding&lt;/code&gt; 值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-intset-apis&#34;&gt;2. intset APIs&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Create an empty intset. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;intsetNew&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Insert an integer in the intset, upgrade encoding if necessary.*/&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;intsetAdd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Delete integer from intset */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;intsetRemove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Determine whether a value belongs to this set */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intsetFind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Return random member */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intsetRandom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Get the value at the given position. When this position is
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * out of range the function returns 0, when in range it returns 1. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intsetGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Return intset length */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intsetLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/* Return intset blob size in bytes. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intsetBlobLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- dict</title>
      <link>https://k-on.me/post/redis-sourcecode-dict/</link>
      <pubDate>Sun, 27 Sep 2020 10:15:20 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-dict/</guid>
      
        <description>&lt;p&gt;Redis dict 实现相关源码阅读笔记，源码文件 &lt;code&gt;dict.h&lt;/code&gt; &amp;amp; &lt;code&gt;dict.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;p&gt;在 Redis 中，&lt;code&gt;dict&lt;/code&gt; 不仅用于实现不同的对象类型，还用于数据库的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可通过自定义哈希、复制、比较和析构函数实现不同的 &lt;code&gt;dictType&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;哈希表使用链地址法处理&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;dict&lt;/code&gt; 中含有两个哈希表 &lt;code&gt;dictht&lt;/code&gt;，以便于实现&lt;strong&gt;渐进式 Rehash&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在每次尝试往字典中新增 key-val pair 时，可能会触发&lt;strong&gt;扩容&lt;/strong&gt; Rehash:
&lt;ul&gt;
&lt;li&gt;一般情况下，载荷因子大于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L994&#34;&gt;$1$&lt;/a&gt; 即触发扩容，但在使用 &lt;code&gt;dict&lt;/code&gt; 实现键空间时还需&lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/server.c#L1350&#34;&gt;考虑 Rehash 带来的内存使用量突增的情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;当 Redis 有子进程在做 RDB saving、AOF rewriting 或 module 相关的任务时，载荷因子需大于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L59&#34;&gt;$5$&lt;/a&gt; 才会触发扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一般情况下，当哈希表的载荷因子小于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/server.c#L1543&#34;&gt;$0.1$&lt;/a&gt; 时会触发&lt;strong&gt;缩容&lt;/strong&gt;操作
&lt;ul&gt;
&lt;li&gt;当 Redis 有子进程在做 RDB saving、AOF rewriting 或 module 相关的任务时，不会进行缩容操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对 $b = 2^n$ 取余&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-数据结构&#34;&gt;2. 数据结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dict&lt;/code&gt; 的数据结构如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rehashidx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* rehashing not in progress if rehashidx == -1 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pauserehash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* If &amp;gt;0 rehashing is paused (&amp;lt;0 indicates coding error) */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;rehashidx&lt;/code&gt; 记录了当前 Rehash 的进度，小于该值的 bucket 均已被迁移至 &lt;code&gt;ht[1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dictType&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中字典类型 &lt;code&gt;dictType&lt;/code&gt; 的结构如下，可以看出，用户可以传入各种自定义的操作函数以实现不同的字典类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义哈希值计算函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashFunction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义键复制函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyDup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义值复制函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;valDup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义键比较函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyCompare&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义键析构函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义值析构函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;valDestructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* 自定义 Rehash 控制函数 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expandAllowed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moreMem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;usedRatio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;dictht&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到在 &lt;code&gt;dict&lt;/code&gt; 中有两个哈希表 &lt;code&gt;dictht&lt;/code&gt;，方便实现渐进式 Rehash，以免在字典中数据量较大时 Rehash 操作带来较大延时。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dictht&lt;/code&gt; 的结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* size of table */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sizemask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* size - 1 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* total dictEntries in table */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Redis 哈希表使用单向链表解决哈希冲突，新加入的节点 &lt;code&gt;dictEntry&lt;/code&gt; 置于 table 中相应 bucket 的头部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;dictht&lt;/code&gt; 中，table 的长度 &lt;code&gt;size&lt;/code&gt; 始终为 2 的整数倍(在 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L1005&#34;&gt;_dictNextPower&lt;/a&gt; 函数中实现)，而 &lt;code&gt;sizemask = size - 1&lt;/code&gt;，从而可以将取余操作转化为位运算&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;dictEntry&lt;/code&gt; 中，使用 &lt;code&gt;union&lt;/code&gt; 来存储不同类型的值 &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Tips&lt;/em&gt;: 对 $b = 2^n$ 取余&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* If safe is set to 1 this is a safe iterator, that means, you can call
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * dictAdd, dictFind, and other functions against the dictionary even while
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * iterating. Otherwise it is a non safe iterator, and only dictNext()
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * should be called while iterating. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;dictIterator&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;safe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;entry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nextEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;cm&#34;&gt;/* unsafe iterator fingerprint for misuse detection. */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fingerprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictIterator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;dict&lt;/code&gt; 结构中的 &lt;code&gt;pauserehash&lt;/code&gt; 表示的是当前正在运行的安全(&lt;code&gt;safe=1&lt;/code&gt;)迭代器个数，其值不为 0 时，意味着此时不能进行 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L207&#34;&gt;move bucket&lt;/a&gt; 操作。&lt;/p&gt;
&lt;h2 id=&#34;3-相关操作&#34;&gt;3. 相关操作&lt;/h2&gt;
&lt;h3 id=&#34;31-扩容&#34;&gt;3.1. 扩容&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dictAddRaw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;existing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L315&#34;&gt;dictAddRaw&lt;/a&gt; 尝试往哈希表中添加元素时，会先根据 &lt;code&gt;key&lt;/code&gt; 及其哈希值调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L1024&#34;&gt;_dictKeyIndex&lt;/a&gt; 获取哈希表的 index。&lt;code&gt;_dictKeyIndex&lt;/code&gt; 在查找 index 之前会先调用 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L982&#34;&gt;_dictExpandIfNeeded&lt;/a&gt; 判断是否需要扩容。扩容需要同时满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dict_can_resize&lt;/code&gt; 为 $1$ 时，载荷因子大于 $1$；&lt;code&gt;dict_can_resize&lt;/code&gt; 为 $0$ 时，载荷因子需大于 $5$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/server.c#L1588&#34;&gt;updateDictResizePolicy&lt;/a&gt; 可知当 Redis 有子进程在做 RDB saving、AOF rewriting 或 module 相关的任务时，&lt;code&gt;dict_can_resize&lt;/code&gt; 为 0&lt;/li&gt;
&lt;li&gt;当前的实现除了键空间以外的哈希表，仅需满足该条件即可扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现键空间相关的哈希表考虑到 Rehash 时的内存使用量突增的情况，还需调用&lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/dict.c#L974&#34;&gt;dictExpandAllowed&lt;/a&gt;判断是否可以扩容&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果正处于 Rehash 状态，&lt;strong&gt;新增&lt;/strong&gt;的 &lt;code&gt;dictEntry&lt;/code&gt; 会添加至 &lt;code&gt;ht[1]&lt;/code&gt;。修改已存在 &lt;code&gt;dictEntry&lt;/code&gt; 的值会就地修改。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS:&lt;/em&gt; 从 &lt;a href=&#34;https://github.com/redis/redis/pull/7954#issuecomment-725544359&#34;&gt;redis/pull/7954&lt;/a&gt; 可以知道在该 PR 之前的 Rehash 操作后，哈希表的大小每次都是翻 $4$ 倍，而不是 $2$ 倍。&lt;/p&gt;
&lt;h3 id=&#34;32-缩容&#34;&gt;3.2. 缩容&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Resize the table to the minimal size that contains all the elements,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * but with the invariant of a USED/BUCKETS ratio near to &amp;lt;= 1 */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dictResize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当 Redis 有子进程在做 RDB saving、AOF rewriting 或 module 相关的任务时，不会进行缩容操作&lt;/li&gt;
&lt;li&gt;缩容后确保哈希表 size 大于等于 &lt;code&gt;DICT_HT_INITIAL_SIZE&lt;/code&gt; (4)&lt;/li&gt;
&lt;li&gt;缩容后确保载荷因子小于等于 $1$&lt;/li&gt;
&lt;li&gt;从 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/server.c#L1543&#34;&gt;htNeedsResize&lt;/a&gt; 可知，当哈希表的载荷因子小于 &lt;a href=&#34;https://github.com/redis/redis/blob/6.2.3/src/server.h#L170&#34;&gt;$0.1$&lt;/a&gt; 时会触发缩容操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在以下几种情况下会调用该函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis Server 在 &lt;code&gt;databasesCron&lt;/code&gt; 中会调用 &lt;code&gt;tryResizeHashTables&lt;/code&gt; 尝试对键空间相关哈希表进行缩容&lt;/li&gt;
&lt;li&gt;哈希数据类型在调用 &lt;code&gt;hashTypeDelete&lt;/code&gt; 删除一个元素后会判断是否需要缩容&lt;/li&gt;
&lt;li&gt;集合数据类型在调用 &lt;code&gt;setTypeRemove&lt;/code&gt; 删除一个元素后会判断是否需要缩容&lt;/li&gt;
&lt;li&gt;有序集合数据类型在调用 &lt;code&gt;zsetDel&lt;/code&gt; or &lt;code&gt;zremrangeGenericCommand&lt;/code&gt; or &lt;code&gt;zdiffAlgorithm2&lt;/code&gt; 删除元素后会判断是否需要缩容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-rehash&#34;&gt;3.3. Rehash&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dictRehash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在每次调用 &lt;code&gt;dictRehash&lt;/code&gt; 时，最多迁移 $n$ 个非空 bucket，最多迁移 $10 \cdot n$ 个空 bucket&lt;/li&gt;
&lt;li&gt;以 bucket 为单位进行迁移，每次迁移完一个 bucket 会相应地增加 &lt;code&gt;d-&amp;gt;rehashidx&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;返回 $1$ 时表示 Rehash 操作还未完成，未处于 Rehash 状态或 Rehash 完成时返回 $0$&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_dictRehashStep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pauserehash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictRehash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在添加(&lt;code&gt;dictAddRaw&lt;/code&gt;)、查找(&lt;code&gt;dictFind&lt;/code&gt;, &lt;code&gt;dictGetRandomKey&lt;/code&gt;, &lt;code&gt;dictGetSomeKeys&lt;/code&gt;)、删除(&lt;code&gt;dictGenericDelete&lt;/code&gt;) 时，会调用该函数执行渐进式 Rehash，表示如果此时无安全迭代器在遍历哈希表，则会调用 &lt;code&gt;dictRehash(d,1)&lt;/code&gt; 迁移 $1$ 个非空 bucket (或 $10$ 个空 bucket)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dictRehashMilliseconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;databasesCron&lt;/code&gt; 中会调用该函数尝试对键空间相关的哈希表执行渐进式 Rehash，每次执行时间 &lt;code&gt;ms&lt;/code&gt; 设置为 $1ms$，但由于在该函数的循环中是每次先调用 &lt;code&gt;dictRehash(d,100)&lt;/code&gt; 再判断当前耗时是否超过 &lt;code&gt;ms&lt;/code&gt;，因此这个执行时间限制只是一个软限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-访问&#34;&gt;3.4. 访问&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* Return a random entry from the hash table. Useful to
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * implement randomized algorithms */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dictGetRandomKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;首先随机选择一个非空的 bucket，然后从该 bucket 中随机选择一个 &lt;code&gt;dictEntry&lt;/code&gt; 作为返回值。可以看出，长度越短的 bucket 中的 &lt;code&gt;dictEntry&lt;/code&gt; 被选中的概率越大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* This function samples the dictionary to return a few keys from random
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * locations. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dictGetSomeKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;des&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;函数返回时，在 &lt;code&gt;des&lt;/code&gt; 中存储采样所得的 &lt;code&gt;dictEntry&lt;/code&gt; 数组结果，不保证元素不会重复，&lt;code&gt;des&lt;/code&gt; 所指的内存空闲需能容纳 &lt;code&gt;count&lt;/code&gt; 个 &lt;code&gt;dictEntry&lt;/code&gt; 指针&lt;/li&gt;
&lt;li&gt;函数返回值为 &lt;code&gt;des&lt;/code&gt; 中包含的 &lt;code&gt;dictEntry&lt;/code&gt; 个数，其可能小于 &lt;code&gt;count&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比调用 &lt;code&gt;count&lt;/code&gt; 次 &lt;code&gt;dictGetRandomKey&lt;/code&gt; 高效&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* This is like dictGetRandomKey() from the POV of the API, but will do more
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * work to ensure a better distribution of the returned element. */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;dictEntry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dictGetFairRandomKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;会先尝试调用 &lt;code&gt;dictGetSomeKeys&lt;/code&gt; 获取 &lt;code&gt;GETFAIR_NUM_ENTRIES&lt;/code&gt; 个 &lt;code&gt;dictEntry&lt;/code&gt;，再随机挑选一个返回&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;dictGetSomeKeys&lt;/code&gt; 返回值为 0 时，直接调用 &lt;code&gt;dictGetRandomKey&lt;/code&gt;，返回其结果&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* dictScan() is used to iterate over the elements of a dictionary. */&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dictScan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                       &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                       &lt;span class=&#34;n&#34;&gt;dictScanFunction&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                       &lt;span class=&#34;n&#34;&gt;dictScanBucketFunction&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucketfn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                       &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scan 开始时，设置 &lt;code&gt;cursor = 0&lt;/code&gt; 调用该函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该函数每次迭代后，返回 &lt;code&gt;cursor&lt;/code&gt; 用于下次调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当返回的 &lt;code&gt;cursor&lt;/code&gt; 等于 0 时，表示 Scan 结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证返回所有 &lt;code&gt;dictEntry&lt;/code&gt;，但不保证不重复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如下所示，&lt;code&gt;cursor&lt;/code&gt; 并不是按序递增，而是按位反转之后递增，利用 &lt;code&gt;dictht-&amp;gt;size&lt;/code&gt; 是 $2$ 的整数倍的条件，这保证了在 Rehash 时不会漏掉 bucket。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 源码阅读 --- quicklist</title>
      <link>https://k-on.me/post/redis-sourcecode-quicklist/</link>
      <pubDate>Thu, 24 Sep 2020 18:35:10 +0800</pubDate>
      
      <guid>https://k-on.me/post/redis-sourcecode-quicklist/</guid>
      
        <description>&lt;p&gt;Redis 快速链表相关源码阅读笔记，源码文件 &lt;code&gt;quicklist.h&lt;/code&gt; &amp;amp; &lt;code&gt;quicklist.c&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-小结&#34;&gt;1. 小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;quicklist&lt;/code&gt; 是由 &lt;code&gt;ziplist&lt;/code&gt; 组成的双向链表，兼顾节省内存空间和提高查询效率的需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 &lt;code&gt;quicklistNode&lt;/code&gt; 中包含一个 &lt;code&gt;ziplist&lt;/code&gt;，此 &lt;code&gt;ziplist&lt;/code&gt; 的长度受到 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L1556&#34;&gt;list-max-ziplist-size&lt;/a&gt; 的限制&lt;/li&gt;
&lt;li&gt;考虑到链表的读写操作通常集中于两端，故 &lt;code&gt;quicklist&lt;/code&gt; 中间部分的 &lt;code&gt;quicklistNode&lt;/code&gt; 中的 &lt;code&gt;ziplist&lt;/code&gt; 可能会使用 LZF 算法进行压缩以进一步节省内存空间，压缩程度由 &lt;a href=&#34;https://github.com/redis/redis/blob/6.0.11/redis.conf#L1572&#34;&gt;list-compress-depth&lt;/a&gt; 控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-quicklist-相关数据结构&#34;&gt;2. quicklist 相关数据结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;quicklist&lt;/code&gt; 结构定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;cm&#34;&gt;/* total count of all entries in all ziplists */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;          &lt;span class=&#34;cm&#34;&gt;/* number of quicklistNodes */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;fill&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QL_FILL_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;              &lt;span class=&#34;cm&#34;&gt;/* fill factor for individual nodes */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;compress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QL_COMP_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* depth of end nodes not to compress;0=off */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;bookmark_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QL_BM_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistBookmark&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bookmarks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* &amp;#39;bookmakrs are an optional feature that
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                                     * is used by realloc this struct, so that
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                                     * they don&amp;#39;t consume memory when not used. */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;quicklistNode&lt;/code&gt;: 快速链表节点，包含一 &lt;code&gt;ziplist&lt;/code&gt;，其结构介绍将在下文详述&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;count&lt;/code&gt;: 该快速链表中所有 &lt;code&gt;ziplist&lt;/code&gt; 的 &lt;code&gt;zlentry&lt;/code&gt; 总数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;len&lt;/code&gt;: 该快速链表中 &lt;code&gt;quicklistNode&lt;/code&gt; 个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;: 其用于限制该快速链表中每个 &lt;code&gt;quicklistNode&lt;/code&gt; 中 &lt;code&gt;ziplist&lt;/code&gt; 的长度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-ziplist/&#34;&gt;ziplist&lt;/a&gt; 那一章节中我们知道 &lt;code&gt;ziplist&lt;/code&gt; 每次更改操作耗时和其长度成正比，因此 &lt;code&gt;ziplist&lt;/code&gt; 不应过长，但是如果其过短的话就无法达到节省内存空间的效果，特别地，当 &lt;code&gt;fill = 1&lt;/code&gt; 时，&lt;code&gt;quicklist&lt;/code&gt; 退化成普通的双向链表&lt;/li&gt;
&lt;li&gt;可在 &lt;code&gt;redis.conf&lt;/code&gt; 中通过设置 &lt;code&gt;list-max-ziplist-size&lt;/code&gt; 进行配置
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其值为正数时，表示的是每个 &lt;code&gt;ziplist&lt;/code&gt; 中 &lt;code&gt;zlentry&lt;/code&gt; 个数(&lt;code&gt;zllen&lt;/code&gt;)上限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其值为负数时，表示的是每个 &lt;code&gt;ziplist&lt;/code&gt; 所用字节总数(&lt;code&gt;zlbytes&lt;/code&gt;)上限&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;64&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Kb&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;recommended&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;normal&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;workloads&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Kb&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;recommended&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Kb&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;probably&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;recommended&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Kb&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;good&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Kb&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;good&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;compress&lt;/code&gt;: 链表的读写通常情况下集中在两端，因此在 &lt;code&gt;quicklist&lt;/code&gt; 中，可能会对中间的 &lt;code&gt;quicklistNode&lt;/code&gt; 节点使用无损数据压缩算法 &lt;a href=&#34;http://oldhome.schmorp.de/marc/liblzf.html&#34;&gt;LZF&lt;/a&gt; 对其包含的 &lt;code&gt;ziplist&lt;/code&gt; 进行压缩以进一步节省内存使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compress&lt;/code&gt; 的大小含义如下：
&lt;ul&gt;
&lt;li&gt;$0$: 表示不进行压缩&lt;/li&gt;
&lt;li&gt;$\mathbb{Z}^+$: 表示首尾 &lt;code&gt;compress&lt;/code&gt; 个 &lt;code&gt;quicklistNode&lt;/code&gt; 不会被压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以看出，&lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 节点永远不会被压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;quicklistBookmark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quicklist&lt;/code&gt; 中最后一个 field 为一个&lt;a href=&#34;https://en.wikipedia.org/wiki/Flexible_array_member&#34;&gt;柔性数组成员&lt;/a&gt; &lt;code&gt;bookmarks&lt;/code&gt;，&lt;code&gt;bookmark_count&lt;/code&gt; 保存该数组的长度。当 &lt;code&gt;quicklist&lt;/code&gt; 长度特别长，需要迭代遍历时，会使用到该数组作为缓存。该数组的长度应保持在较小值，以供高效查找更新，其结构定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistBookmark&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklistBookmark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;quicklistNode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quicklistNode&lt;/code&gt; 包装了单个 &lt;code&gt;ziplist&lt;/code&gt;，其结构定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;cm&#34;&gt;/* ziplist */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;cm&#34;&gt;/* ziplist size in bytes */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/* count of items in ziplist */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;encoding&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;cm&#34;&gt;/* RAW==1 or LZF==2 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;container&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* NONE==1 or ZIPLIST==2 */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;recompress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* true if node is temporarry decompressed for usage. */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;attempted_compress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* node can&amp;#39;t compress; too small
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                                          * used for verifying during testing */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;extra&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* more bits to steal for future usage */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sz&lt;/code&gt;: &lt;code&gt;ziplist&lt;/code&gt; 所占用的字节总数(&lt;code&gt;zlbytes&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;count&lt;/code&gt;: 16-bits(0 to 65535)，表示在 &lt;code&gt;ziplist&lt;/code&gt; 中 &lt;code&gt;zlentry&lt;/code&gt; 个数(&lt;code&gt;zllen&lt;/code&gt;)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们知道 &lt;code&gt;ziplist&lt;/code&gt; 的长度受到 &lt;code&gt;quicklist&lt;/code&gt; 中 &lt;code&gt;fill&lt;/code&gt; 参数的限制，在 32 位机器上 &lt;code&gt;QL_FILL_BITS = 14&lt;/code&gt;，在 64 位机器上 &lt;code&gt;QL_FILL_BITS = 16&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;fill &amp;gt; 0&lt;/code&gt; 时，表示 &lt;code&gt;zllen&lt;/code&gt;，其最大值为 32767，小于 65535&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;fill &amp;lt; 0&lt;/code&gt; 时，表示 &lt;code&gt;zlbytes&lt;/code&gt;，其最大值为 64kb，从 &lt;a href=&#34;https://k-on.me/post/redis-sourcecode-ziplist/&#34;&gt;ziplist&lt;/a&gt; 中我们知道，当所有 &lt;code&gt;zlentry&lt;/code&gt; 存储的是 0 到 12 的整数时，每个 &lt;code&gt;zlentry&lt;/code&gt; 的大小为 $sizeof(prevlen) + sizeof(encoding) = 1 + 1 = 2$ 字节，$64 \times 1024 \div 2 = 32768 &amp;lt; 65535$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;综上可知，16-bit 的 &lt;code&gt;count&lt;/code&gt; 足够使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;encoding&lt;/code&gt;: 表示所包含的 &lt;code&gt;ziplist&lt;/code&gt; 是否被压缩，值为 1 表示未被压缩，值为 2 表示已使用 LZF 压缩算法压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;container&lt;/code&gt;: 表示 &lt;code&gt;quicklistNode&lt;/code&gt; 所包装的数据类型，目前值固定为 2，表示包装的数据类型为 &lt;code&gt;ziplist&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;recompress&lt;/code&gt;: 当我们访问 &lt;code&gt;ziplist&lt;/code&gt; 时，需要解压数据，该参数表示 &lt;code&gt;ziplist&lt;/code&gt; 是否被临时解压&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;attempted_compress&lt;/code&gt;: 测试用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;quicklistLZF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;quicklistNode&lt;/code&gt; 中的 &lt;code&gt;ziplist&lt;/code&gt; 被压缩后，&lt;code&gt;quicklistNode-&amp;gt;zl&lt;/code&gt; 指向 &lt;code&gt;quicklistLZF&lt;/code&gt; 结构，其定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* quicklistLZF is a 4+N byte struct holding &amp;#39;sz&amp;#39; followed by &amp;#39;compressed&amp;#39;. */&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistLZF&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* LZF size in bytes*/&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklistLZF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;值得注意的是，此处 &lt;code&gt;sz&lt;/code&gt; 指的是压缩后得到的 &lt;code&gt;compressed&lt;/code&gt; 字节数组的长度，而 &lt;code&gt;quicklistNode-&amp;gt;sz&lt;/code&gt; 指的是 &lt;code&gt;ziplist&lt;/code&gt; 压缩前的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;quicklistIter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quicklist&lt;/code&gt; 的迭代器，其结构如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistIter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quicklist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* offset in current ziplist */&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklistIter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;quicklist&lt;/code&gt;: 当前迭代的快速链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;: 当前迭代的 &lt;code&gt;quicklistNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zi&lt;/code&gt;: 当前迭代的 &lt;code&gt;zlentry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offset&lt;/code&gt;: 当前访问的 &lt;code&gt;zlentry&lt;/code&gt; 在 &lt;code&gt;current-&amp;gt;zl&lt;/code&gt; 中的偏移量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;direction&lt;/code&gt;: 迭代方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;quicklistEntry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于描述 &lt;code&gt;quicklist&lt;/code&gt; 中的每个 &lt;code&gt;zlentry&lt;/code&gt; 的状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;quicklistEntry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quicklist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;quicklistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;zi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;longval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicklistEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;quicklist&lt;/code&gt;: 指向该 &lt;code&gt;zlentry&lt;/code&gt; 所在的快速链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt;: 指向该 &lt;code&gt;zlentry&lt;/code&gt; 所在的 &lt;code&gt;quicklistNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zi&lt;/code&gt;:  指向该 &lt;code&gt;zlentry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offset&lt;/code&gt;: 该 &lt;code&gt;zlentry&lt;/code&gt; 在 &lt;code&gt;node-&amp;gt;zl&lt;/code&gt; 中的偏移量&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;zlentry&lt;/code&gt; 的数据类型为字符串时，&lt;code&gt;value&lt;/code&gt; 和 &lt;code&gt;sz&lt;/code&gt; 保存了 &lt;code&gt;zlentry&lt;/code&gt; 的值&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;zlentry&lt;/code&gt; 的数据类型为整型时，&lt;code&gt;longval&lt;/code&gt; 保存了 &lt;code&gt;zlentry&lt;/code&gt; 的值&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
  </channel>
</rss>
